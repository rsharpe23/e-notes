АТРИБУТЫ

Есть глобальные атрибуты, которые доступны у всех элементах, а есть специфические,
которые доступны только определенным элементам, например type для <input>.

Список глобальных атрибутов: https://metanit.com/web/html5/1.2.php

Кроме обычных атрибутов, элементы могут содержать еще и логические атрибуты. 
Такие атрибуты не имеют значения, как например "disabled". Значение определяется
присутсвием самого атрибута: <input type="button" disabled>.

Пользовательские атрибуты определяются с помощью префикса "data-".

---------------------------

ЭЛЕМЕНТЫ (ТЕГИ)

Тег <!DOCTYPE html> указывает, что в документе используется стандарт html5.
Он означает - Document Type Declaration.

Тег <base> указывает на путь, относительно которого будут подгружаться различные
страницы. Например <base href="content/"> означает что ссылка 
<a href="page.html">...</a> будет указывать на страницу по адресу: content/page.html.

Тег <meta> определяет метаданные документа. В основном он имеет два атрибута: 
name (имя метаданных) и content (значение метаданных). 
Например: <meta name="keywords" content="ключевые слова для seo">.

Тег <p><p/> хотя и блочный, но в нем нельзя размещать другие блочные теги, а только
строчные.

Тег <details></details> позволяет создавать раскрываемый блок - аккордион. 
Внутри него используется саб-тег <summary></summary>, в котором указывается заголовок.
В раскрытом состоянии к тегу добавляется атрибуты open.

Тег <dl></dl> определяет список терминов и определений к ним. Внутри него используются
саб-теги: <dt></dt> - термин, <dd></dd> - определение к термину.

Тег <figure></figure> применяется для построения различных карточек, фотографий,
диаграмм. Внутри него используется саб-тег <figcaption></figcaption>, в котором
указывается заголовок. Обычно в этот тег помещают картинку.

Тег <iframe></iframe> позволяет встраивать на веб-страницу другую веб-страницу.
Например: <iframe src="http://my-app.com" width="200" height="100"></iframe>.
Не все сайты могут открываться во фреймах, поскольку на стороне сервера загружаемой
страницы, могут действовать ограничения на открытие во фреймах.

---------------------------

ФОРМЫ

Форма - это способ ввода данных и отправки их на сервер. Атрибут "method" устанавливает
метод отправки данных (только get или post). Атрибут "action" устанавливает адрес, на
который передаются данные. Атрибут "enctype" устанавливает кодировку данных, 
например multipart/form-data применяется при отправке файлов.
С помощью атрибута "autocomplete" можно включить/отключить автозаполнение формы. 
Этот атрибут можно также использовать для отдельных полей формы.

Внутри формы помещаются элементы ввода. Обычно это элемент input. 
Но есть и другие элементы: button, select, label, textarea.

Элемент input имеет такие типы: text, password, radio, checkbox, hidden, submit, 
color, date, datetime, datetime-local, email, month, number, range, tel, time, 
week, url, file, image.

Все элементы ввода имеют атрибуты "name" и "value".

Элемент button имеет дополнительные типы:
* submit - для отправки формы;
* reset - для сброса значений формы.

Если у кнопки установлен тип "submit", то ей можно задать ряд дополнительных атрибутов,
например form (определяет форму, за которой закреплена кнопка отправки) и т.п.

Текстовое поле (type="text") имеет ряд полезных атрибутов:
* dir - устанавливает направление текста (слева направо или наоборот);
* list - устанавливает список подсказок для ввода в поле;
* maxlength - максимально допустимое кол-во символов в поле;
* pattern - регулярное выражение, которому должен соотвествовать вводимый текст;
* placeholder - текст, который отображается в поле, когда оно пустое;
* readonly (логический) - поле доступно только для чтения;
* required (логический) - поле должно обязательно иметь значение;
* size - ширина поля в видимых символах;
* value - значение поля по умолчанию.

Атрибут list должен указывать на специальный элемент datalist, который подобен select.

Элемент label определяет метку для поля ввода. Его атрибут for указывает на id поля.
По нажатию на текст метки она переводит фокус на связанное поле.

Для поля ввода можно задать атрибут autofocus. Поле с таким атрибутом автоматически
получает фокус при запуске страницы.

Числовое поле (type="number") имеет специфические атрибуты:
* min - минимально допустимое значение;
* max - максимально допустимое значение;
* step - значение, на которое будет увеличиваться число.

Как и в случае с текстовым полем можно прикрепить список datalist с диапозоном
возможных значений.

Флажок (type="checkbox") представляет элемент, который может находится в двух
состояниях. Атрибут checked позволяет установить его в отмеченное состояние.

Радиокнопки (type="radio") похожи на флажки, но используются группой. 
Они также используют атрибут checked для отмеченного состояние. Атрибут name указывает
не на имя элемента, а на имя группы, к которой принадлежит одна из радиокнопок.

Палитра (type="color") позволяет установить цвет. Значением этого элемента будет
шестнадцатеричный код выбранного цвета. Может рабрать с элементом datalist.

Выбор файлов (type="file") позволяет выберать и отправлять файлы на сервер. 
Для отправки файлов на сервер форма должна обязательно иметь атрибут 
enctype="multipart/form-data".

Некоторые дополнительные атрибуты для выбора файлов:
* accept - устанавливает тип файлов, которые допустимы для выбора;
* miltiple - позволяет выбирать множество файлов;
* required - требует обязательной установки файла.

Элемент select создает список. Внутри списка располагаются элементы option. 
С помощью атрибута selected можно установить выбранный option. Для создания списка 
с множественным выбором нужно добавить атрибут multiple к элементу select.
Элемент optgroup позволяет группировать набор option.

Элемент textarea создает многострочное текстовое поле. С помощью атрибутов cols и rows
можно задать соответсвующее кол-во столбцов и строк.

Чтобы отключить валидацию (например required или pattern) можно задать атрибут
novalidate у элемента формы, либо у кнопки отправки атрибут formnovalidate.

Элементы fieldset и legend нужны чтобы сгруппировать элементы формы. Они создают рамку
и заголовок вокруг вложенных в fieldset элементов. В одной форме может находится
множество элементов fieldset.

У форм, как и у ссылок, есть атрибут target. Он указывает, где отображать ответ после 
отправки формы. Значения атрибута те же, что и для элемента "a":

* _blank - ответ отображается в новом окне или вкладке;
* _self - ответ отображается в том же фрейме (по умолчанию);
* _parent - ответ отображается в родительском фрейме;
* _top - возможно это то же самое, что и top для iframe;
* framename - ответ отображается в заданном фрейме.

---------------------------

СЕМАНТИКА СТРАНИЦЫ

Элемент article представляет целостный блок информации на странице. По сути это
отдельный независимый модуль, например пост блога, комментарий пользователя и т.п.

В нем содержаться такие элементы как: h1-h6, p, div, section, другие article и т.п.

Элемент section объединяет связанные между собой куски информации html-документа,
выполняя их группировку. Например, section может включать набор вкладок на странице
либо блок комментариев.

Элемент section может включать в себя несколько article (чтобы их сгруппировать) 
и наоборот, article может включать в себя несколько section.

Каждый элемент article или section должет быть идентифицирован с помощью включения 
в него заголовка h1-h6.

Элемент nav нужен для создания навигационного меню, будет то межстраничная навигация,
либо навигация внутри одной страницы. Обычно в него помещают тег <ul></ul> со ссылками.
Навигационных меню может быть несколько на одной странице. В футере необязательно
делать ссылки навигационными.

Элемент header нужен для вводного содержимого. Он может содержать такие элементы как
заголовок, логотип, форму поиска, навигационное меню и т.п. 

Элемент footer обычно содержит о том, кто автор контента, копирайт, дата публикации,
ссылки на похожие ресурсы и т.п. Футер может быть не только у всей страницы, но и в
отдельных ее частях, например внутри article.

Элементы header и footer нельзя помещать в address или другие header и footer.

Элемент address предназначен для отображения контактной информации. Обычно его
размещают в футере.

Элемент aside представляет косвенное содержимое веб-страницы. Его можно использовать
для размещения сайдбаров, рекламных блоков, навигационных элементов и т.п.

Элемент main представляет основное содержимое веб-страницы. В нем размещается
уникальный контент, в который не нужно включать повторяющиеся элементы веб-страницы
(сайдбары, навигационные ссылки, логотип, онформацию о копирайте и т.п.).

Элемент main не может находится внутри article, aside, header, footer, nav.
Кроме того, на веб-сранице допустипо наличие только одного main.

IE-11 не поддерживает main, поэтому ради него следует использовать атрибут роли: 
<main role="main"></main>.

---------------------------

РАЗНОЕ

На странице должен быть только один заголовок первого уровня <h1></h1>. 
Он выполняет роль основного заголовка веб-страницы.

Внутри тега <p></p> нельзя использовать блочные теги (хотя он и сам блочный).

Нумерованный список <ol></ol> имеет специфический атрибут start, который задает число 
с которого будет начинаться нумерация.

Решетка внутри ссылки указывает на якорь. С помощью якорей происходит прокрутка
страницы к нужному элементу. Якорь определяется как id элемента с решеткой в начале:
<a href="#footer">Вниз</a> ... <div id="footer"></div>.

Ссылки могут иметь атрибут download. Этот атрибут указывает браузеру делать загрузку
вместо навигации: <a download="file.txt" href="#">Загрузка</a>

Подключить файл стилей можно с помощью тега <link rel="stylesheet" href="file.css">

Для управления мультимедия существуют специальные теги <video></video> и 
<audio></audio>. JS предоставляет специальный Media API, который дает возможность
эффектино работать с ними посредством различных свойств, методов и событий.

С помощью тега <canvas></canvas> можно рисовать на странице различные графические
примитивы, манипулировать изображениями и видео, а также создавать игры.

===========================

СЕЛЕКТОРЫ

Основные селекторы:
* div - селектор элемента;
* .class - селектор класса;
* #id - селектор идентификатора (для уникальных элементов);
* *{} - универсальный селектор (для всех элементов);
* div p - селектор потомков (для вложенных элементов на всех уровнях);
* div > p - селектор дочерних элементов (для вложенных элементов первого уровня);
* div ~ p - селектор элементов одного уровня (для сиблингов);
* div + p - селектор для первого сиблинга.

Селекторы псевдоклассов:
* :root - корневой элемент (т.е. html);
* :link - ссылка в обычном состоянии (по которой не было перехода);
* :visited - ссылка, по которой уже был переход;
* :active - ссылка, в тот момент, когда пользователь нажимает на нее;
* :hover - элемент, на который пользователь навел указатель мыши;
* :focus - элемент, который получает фокус;
* :not(selector) - элементы, к которым не нужно применять стили;
* :lang - стилизация на основании значения атрибута lang;
* :empty - элементы, которые не имеют вложенных элементов, т.е. пустые;
* :target - элемент, id которого совпадает с анкором #...

Псевдоклассы дочерних элементов:
* :first-child - первый дочерний элемент;
* :last-child - последний дочерний элемент;
* :only-child - единственный дочерний элемент (т.е. только один в контейнере);
* :only-of-type - единственный элемент определенного типа (т.е. только один элемент
заданного типа, но при этом могут быть и элементы других типов);
* :nth-child(n) - дочерний элемент под номером n;
* :nth-last-child(n) - дочерний элемент под номером n, с конца;
* :nth-of-type(n) - дочерний элемент определенного типа, под номером n;
* :nth-last-of-type(n) - дочерний элемент определенного типа, под номером n, с конца.

С помощью :nth-child(even/odd) можно выбрать четные и нечетные элементы.
Запись :nth-child(2n+1) означает выбор каждого элемента с шагом 2, начиная с первого.
Т.е. сначала будет так: 2 * 1 + 1, затем так: 2 * 2 + 1 и т.д.

Разница между :nth-child и :nth-of-type в том, что в первом варианте выберется 
тот элемент, который физически находится на указанном месте. Например если задать
div:nth-child(2), то выборка случится только если div находится на втором месте среди
других элементов. А если задать div:nth-of-type(2), тогда будет не важно на каком 
месте находится div. Стили применятся ко второму div, даже если он является десятым 
по счету внутри контейнера.

Псевдоклассы форм:
* :disabled - элемент с атрибутом disabled;
* :enabled - элемент без атрибута disabled;
* :checked - элемент с атрибутом checked (для флажков и радиокнопок);
* :default - элемент по умолчанию (как правило, это кнопка отправки);
* :valid - элемент, значение которого проходит валидацию;
* :invalid - элемент, значение которого не проходит валидацию;
* :in-range - элемент, значение которого находится в определенном диапазоне;
* :out-of-range - элемент, значение которого не находится в определенном диапазоне;
* :required - элемент с атрибутом required;
* :optional - элемент без атрибута required.

Псевдоэлементы:
* ::first-letter - первая буква из текста;
* ::first-line - первая строка из текста; 
* ::before - сообщение, до определенного элемента;
* ::after - сообщение, после определенного элемента;
* ::selection - текст, который выделяется мышкой.

В CSS2 перед псевдоэлементами, как и перед псевдоклассами, ставилось одно двоеточие.
В CSS3 псевдоэлементы обозначаются двумя двоеточиями, но это не обязательно.

Селекторы атрибутов:
* [attr] - атрибут установлен;
* [attr="val"] - атрибут равен val;
* [attr^="val"] - атрибут начинается с val (например value);
* [attr|="val"] - атрибут равен val или начинается с val- ( например val-1);
* [attr*="val"] - атрибут содержит подстроку val (например myvalue);
* [attr~="val"] - атрибут сожержит val как одно из значений через пробел;
* [attr$="val"] - атрибут заканчивается на val (например myval).

Вес селекторов:
- селекторы тегов оцениваются в 1 балл;
- селекторы классов, атрибутов и псевдоклассов оцениваются в 10 баллов;
- селекторы идентификаторов оцениваются в 100 баллов;
- встроенные inline-стили оцениваются в 1000 баллов.

Комбинации селекторов суммируются между собой в общий вес:
* .nav li a - общий вес 12 (2 тега и 1 класс);
* #menu a - ощбий вес 101 (1 идентификатор и 1 тег).

Значение !important полностью отменяет все другие веса и делает помеченный стиль самым
приоритетным.

Псевдоклассы :is() и :where() нужны для сокращения длинных селекторов, например:
* :is(header, main, footer) > p тоже что и header > p, main > p, footer > p;
* div > :is(h2, #content) тоже что и div > h2, div > #content.

Разница между :is() и :where() в том, что :is() определяет вес по наибольшему
селектору, а :where() всегда определяет вес равный 0.

---------------------------

ШРИФТЫ

Обычно, название шрифта записывается без кавычек, но если оно состоит из нескольких
слов, тогда кавычки использовать надо: 
* font-family: Arial; 
* font-family: "Times New Roman";

Шрифты типа serif или sans-serif являются универсальными.

Толщина шрифта может принимать 9 числовых значений: 100, 200, 300, ..., 900. 

Чтобы подключить внешний шрифт (который не установлен на компьютере) нужно использовать
директиву @font-face:

@font-face { 
  font-family: 'Roboto'; 
  src: url(https://); 
  [src: url(https://) format('woff'), url(https://) format('truetype');] 
}

Второе свойство src может отсутствовать, оно добавляется для совместимости и обычно
явно указывает определение шрифта через format(...). Когда браузер будет загружать
страницу, он не станет загружать все шрифты, а подргузить только первый понятный,
например формата woff.

После подключения шрифта, его можно использовать в стилях:
p { font-family: Roboto; }

Для каждой категории шрифта, если он может быть также жирным или курсивным, нужно
добавлять свою директиву @font-face.

Константные размеры шрифта:
* medium - 16 пикселей (базовый размер);
* small - 13 пикселей;
* x-small - 10 пикселей;
* xx-small - 9 пикселей;
* large - 18 пикселей;
* x-large - 24 пикселя;
* xx-large - 32 пикселя.

Проценты задают значение относительно базового или унаследованного шрифта.

Елиница em похожа на проценты, 1em равен 100%. Единица rem означает root em и
отличается от em тем, что задает значение относительно шрифта, который задан 
для элемента html.

---------------------------

СВОЙСТВА

Свойство letter-spacing применяется для межсимвольного интервала, а word-spacing 
для интервала между словами.

Свойство line-height определяет межстрочный интервал. По умолчанию используется
значение 120%.

Свойство text-indent задает отступ первой строки абзаца.

Свойство list-style-type задает тип маркеров для списка (буквы, цифры, кружочки,
квадратики и т.п.), а list-style-position - их позиционирование (значение inside
обеспечивает равномерное распределение маркеров по ширине). 

Свойство list-style-image позволяет задать в качестве маркера изображение.

Свойство border-collapse стилизует границу между ячейками, border-spacing -
пространство между ячейками, caption-side - расположение элемента caption 
(вверху таблицы или внизу), empty-cells - отрисовывать или нет пустые ячейки, 
table-layout - размер содержимого внутри таблицы (или размер таблицы).

Свойство vertical-aligh выравнивает содержимое ячеек таблицы по вертикали.
Также оно выравнивает и элементы с display:inline-block, втнутри их родителя.

Свойство margin схлопывается (т.е. накладывается одно на другое). Оно не является
частью элемента. Его, как и padding, можно задатать четырьмя вариантами:
1. margin: <значение_для_всех_сторон>;
2. margin: <верх_низ> <лево_право>;
3. margin: <верх> <лево_право> <низ>;
4. margin: <верх> <право> <низ> <лево>;

Свойство border-width имеет константные значения:
* thin - 1 пиксель;
* medium - 3 пикселя;
* thick - 5 пикселей.

Свойство box-sizing определяет каким будет итоговый размер элемента. По умолчанию 
стоит значение content-box. Оно задает размер только для контентной части элемента, 
а значения padding и border будут дополнительно расширять весь элемент. Значение 
border-box наоборот задает размер всему элементу в целов, в который будут учиваться 
все border'ы и padding'и.

Свойство box-sizing всегда должно устанавливаться в значение border-box для всех
элементов * { box-sizing: border-box; }. Это необходимо делать для того чтобы элементы
не выпадали из блоков и т.п. Помимо этого нужно обязательно сбрасывать все стили,
которые браузер утснавливает по умолчанию (это может быть файл reset.css и т.п.).

Свойство background является общим и может принимать в себе значения всех фоновых
свойств элемента в любом порядке: background: <background-color> <background-position> 
<background-size> <background-repeat> <background-origin> <background-clip> 
<background-attachment> <background-image>.

В свойстве background значение для background-size должно идти после 
background-position и должно отделяться символом "/".

Свойство box-shadow задает элементу тень. Его значение inset заставляет рисовать тень
внутри блока элемента. Иногда такой прием используется вместо border, когда с помощью
тени рисуется граница, которая не расширяет элемент.

Свойство outline задает контур. Контур не заменяет границу, а рисуется поверх нее.
Контур не занимает места и не меняет размер эл-та, т.к. не участвует в блочной модели.
С помощью outline-offset можно задать отступ контура от внешней границы. 

Контур в основном используют, когда нужно выделять элемент и чтобы при этом ничего 
не прыгало (с border так не получится).

Свойство float задает элементу обтекание. При обтекании должен соблюдаться правильный
порядок размещения тегов. Плавающий элемент (у которого установлен float) должен
размещаться перед элементом который его обтекает. На том элементе, где установлен 
float должен быть также установлен и width и не должно быть установлено никакого
позиционирования (кроме static). Чтобы отменить обтекание, нужно установить свойство
clear:both (на обтекающем элементе).

Свойство overflow задает элементу возможность прокрутки или наоборот, ограничивает 
эту возможность. С помощью overflow-x или overflow-y задается направление прокрутки, 
по горизонтали или по вертикали соответсвенно.

Свойство display задает тип отображения элемента. При значении inline элемент будет
игнорировать свойства: width, height, margin. При значении inline-block элемент будет
обладать признаками блочного и строчного. По отношению к внешним элементам он будет
расцениваться как строчный, а по отношению к вложенным - как блочный.

Свойство position задает элементу позиционирование. По умолчанию используется значение
static. Значение relative делает элемент новой точкой, относительно которой будет
происходить позиционирование его внутренних элементов (те обычно имеют абсолютное
позиционирование). Значение fixed задает позиционирование отностительно окна браузера
(элементы не будут менять положение при прокрутке страницы).

Контейнер для элементов с абсолютным позиционированием не обязательно должен быть с
position:relative. Он также может быть и с position:absolute.

Если элемент имеет position:relative и какие-то сдвиги: top, left и т.д, то он
сместится относительно своего текущего места. При этом нельзя одновременно установить
top и bottom или left и right. Нужно использовать только один сдвиг из каждой пары.

Если элементу задать position:absolute, то он автоматически получит display:block.
Иногда, при установке этого позиционирования, в документ также добавляют пустой элемент
с нужными размерами, либо margin/padding, чтобы заполнить выпадающее пространство.

Свойство display:table может применятся к любым элементам, а не только к таблице.
Например с его помощью можно выравнивать форму с инпутами. Для строк и ячеек
применяются: display:table-row и display:table-cell соответсвенно.

Также, display:table-cell можно устанавливать на родительский div, для вертикального
центрирования его внутреннего элемента/ов. При этом ширина div может быть некорректной.
Чтобы это исправить, нужно добавить еще один контейнер с display:table и width:100%

Вертикальное центрирование можно задать и с пом. связки line-height и vertical-align.
При этом значение line-height не должно быть в процентах. В современных браузерах 
лучше всё таки использовать flex-box для этого.

Свойство font-size задает высоту букв, а line-height - высоту строки. Обычно размер
line-height делают чуть больше, чтобы буквы не вылазили за пределы строк.

Установить font-size и line-height можно одновременно: font: 20px/1.2 Arial,sans-serif;
При этом нужно обязательно указывать семейство шрифтов, иначе ничего не сработает.
Также, можно задать и style, weight: font: italic bold 20px/1.2 sans-serif; 

Отрицательный margin более эффективный способ позиционирования, чем position:relative
т.к. остальные элементы учитывают такие сдвиги, в отличии от position. Последний только
визуально сдвигает элемент, оставляя после себя пустоту. В отличии от margin-top/left,
margin-right/bottom работают по другому. Они укорачивают элемент, а не сдвигают.

Рекомендованый порядок свойств:
1) Сначала положение эл-та относительно других: position, left/right/top/bottom, 
float, clear, z-index.
2) Затем размеры и отступы: width, height, margin, padding...
3) Рамка, частично относится к размерам: border.
4) Общее оформление содержимого: list-style-type, overflow...
5) Цветовое и стилевое оформление: backgroud, color, font...

Логика сортировки свойств такова: "от общего - к локальному и менее важному".
Свойства с префиксами пишутся первыми: сначала -webkit-box-shadow, а затем box-shadow.

---------------------------

ПОДРОБНЕЕ О FLOAT

Если задать свойство float, то элемент автоматически получит display:block.
Но такой блок не растягивается на всю ширину, а только обтекает внутренний контент,
т.е. если div имеет float, а внутри него картинка, то этот div растянется только на
ширину картинки. Кроме того, вертикальные margin'ы плавающих блоков не сливаются 
с отступами своих соседий (в отличии от обычных блоков).

Блочные элементы игнорируют плавающие, а строчные - обтекают их, даже если находятся
внутри блочных (т.е. сам блок игнорирует, а текст внутри него - обтекает). Элемент 
с float сдвигается на заданный край пока не встретит другой такой же элемент.

Чтобы отменить обтекание плавающего элемента, любой нижестоящий элемент может иметь
clear:left|right|both. Это свойство будет сдвигать элемент вниз до тех пор, 
пока не закончатся float'ы справа|слева|с обеих сторон.

В качестве альтернативы можно просто разместить между ними пустой div с clear:both; 
В этом случае также исправятся и баги с вертикальными оступами.

Плавающие элементы не входят в основной поток. Из-за этого родительские элементы не
выделяют под них места. Чтобы это исправить, можно сделать следующее:

* подставить родителю float;
* добавить пустой div с clear в самый конец контейнера;
* добавить родителю универсальный класс clearfix (создается самостоятельно);
* добавить родителю overflow:auto/hidden (но clearfix лучше);

Свойство float можно использовать вместо display:inline-block. В этом случае блочные
элементы будут сдвигаться аналогично inline-block, но с особенностями float.

---------------------------

АНИМАЦИИ

Свойство transform позволяет задать трансформацию элементу. 
При трансформации элемент может накладываться на соседние элементы.

Ф-ции трансформаций:
* rotate(deg) - поворот;
* scale(n), scale(x, y), scaleX(n), scaleY(n) - масштабирование;
* translate(x, y), transalteX(n), transalateY(n) - перемещение;
* skew(x, y) - наклон.

Существуют также варианты для 3D: translate3d() и т.д.

Трансформации можно комбинировать: 
transform: tranlate(50px, 10px) rotate(45deg) scale(2);

По умолчанию точкой опоры трансформаций является центр элемента. Но ее можно 
изменить с помощью свойства transform-origin. Это свойство принимает такие значения 
как left top, left bottom, right top, right bottom. Также оно может принимать значение
в пикселях, процентах и т.п.

Свойство transition позволяет задать анимированный переход от одного стиля к другому.
Чтобы выполнялся переход, элемент должен иметь 2 состояния: первое - это базовые стили,
второе - это стили, которые добавляются элементу через дополнительный селектор. 

Базовые стили также должны включать свойство transition. Его краткая запись:
transition: <transition-property> <transition-duration> <transition-timing-function>
<transition-delay> (например transition: background-color 3s ease-in-out 500ms).

Ф-ции переходов:
* linear - линейная плавность;
* ease - ускорение к середине и замедление к концу;
* ease-in - ускорение только в начале;
* ease-out - ускорение только в конце;
* ease-in-out - ускорение к середине и замедление к концу (наиболее используемая);
* cubic-bezier - для анимации применяется кубическая ф-ция Безье.

Для transition-delay также допустимы отрицательные значения. В этом случае анимация
будет с середины, например если transition-duration: 2s, а transition-delay: -1s, 
то анимация начнется с середины и займет одну секунду.

А transition-timing-function имеет интересную ф-цию "steps", которая разделяет анимацию
на шаги. С пом. неё можно анимировать различные таймеры, счетчики и т.п.

Полноценная анимация создается с помощью ключевого слова @keyframes. Для того чтобы
работала анимация нужно чтобы было как минимум два ключевых кадра. Для определения
промежуточныго кадра применяется процентное значение:

@keyframes название_анимации {
  from { обязательное начальное значение свойст CSS }
  ...
  25% { необязательное значение свойст CSS }
  50% { необязательное значение свойст CSS }
  ...
  to { обязательное конечное значение свойст CSS }
}

После создания анимации ее можно применить на элементе с помощью свойства animation.
Его краткая запись: animation: <animation-name> <animation-duration> 
<animation-timing-function> <animation-iteration-count> <animation-direction>
<animation-delay> <animation-fill-mode>.

Свойство animation-iteration-count определяет, сколько раз будет повторяться анимация.
Этому свойству можно присвоить значение infinite. При повторе анимация начинается с
начального кадра. Но с помощью комбинации animation-direction: alternate; он будет
начинаться с противополножного направления (пинг-понг).

При окончании анимации браузер устанавливает для элемента стиль, который был до
применения анимации. Но комбинация animation-fill-mode: forwards; позволяет в качестве
окончательного значения установить то, что было в последнем кадре.

К анимации можно применять те же ф-ции плавности что и для переходов.

Анимации более тяжелые по сравнению с переходами. Их стоит использовать только для
сложных эффектов. По возможности лучше заменять их переходами. Они работают более
плавно, без всяких подергиваний и притормаживаний страницы.

---------------------------

АДАПТИВНОСТЬ

Видимая область браузера описывается понятием viewport. По умолчанию браузер считает,
что каждая страница предназначена для десктопов. Когда страница открывается на
маленьком девайсе, то она сжимается до размеров его экрана. Например есть девайс с
шириной экрана 320px, а начальная ширина viewport его браузера равна 980px. 
В этом случае страница для девайса будет сжата на коэфициент 320/980.

Многие браузеры по своему определяют стандартные размеры viewport, из-за этого
десктопные страницы могут выглядеть нечетаемо на маленьких экранах. Чтобы избежать
подобной проблемы следует использовать метатег viewport.

Параметры метатега viewport:
* width - ширина области viewport (значение в пикселях или device-width);
* height - высота области viewport (значение в пикселях или device-height);
* initial-scale - коэффициент масштабирования начального размера viewport (значения 
  от 0.1 и выше; 1.0 задает отсутствие масштабирования);
* user-scalable - указывает, может ли пользователь масштабировать страницу с помощью
  жестов (значение yes/no);
* minimum-scale - минимальный масштаб размера viewport (значения от 0.1 и выше; 
  1.0 задает отсутствие масштабирования);
* maximum-scale - максимальный масштаб размера viewport (значения от 0.1 и выше; 
  1.0 задает отсутсвие масштабирования);

Пример использования: 
<meta name="viewport" content="width=device-width, maximum-scale=1.0">.

Media Query определяется ключевым словом @media. Его ф-ции:
* aspect-ration - отношение ширины к высоте области отображения (браузера);
* device-aspect-ration - отношение ширины к высоте экрана устройства;
* max/min-width, max/min-height - максимальная и минимальная ширина и высота
  отображения (браузера);
* max/min-device-width, max/min-device-height - максимальная и минимальная ширина 
  и высота экрана девайса;
* orientation - ориентация (портреная или альбомная).

Пример использования:
@media only screen and (orientation: portrait) { ... }
@media (max-width: 760px) { ... }

Свойство min-width работает от указанной ширины и выше. Свойство max-width работает до
указанной ширины и ниже. При подходе Mobile First для адаптивной верстки используется
свойство min-width. Если, наоборот, сначала верстается декстопная версия, а затем
добавляются мобильные версии, то удобнее использовать max-width.

---------------------------

ПЕРЕМЕННЫЕ

Определяются через префикс --, для любого элемента. Например: div { --my-color: #fff; }.
Получить значение переменной можно с помощью var(): p { color: var(--my-color); }.

Переменные могут использоваться только на тех элементах, для которых объявлены, 
либо на дочерних элементах. Если элемент p, в примере выше, будет находится вне div
тогда переменная работать не будет.

Если необходимо, чтобы переменные использовались глобально для всех элементов, 
тогда их нужно определять для элемента :root. Например: :root { --my-color: #fff; }.

Переменную можно вызывать с резервным значением. Оно будет приминятся если основное
значение не корректно: p { color: var(--my-color, #000); }.

Переменные удобно использовать при создании тем или чтобы хранить различные 
состояния для веб-страниц.

---------------------------

FLEXBOX

Флекс-контейнер задается с помощью комбинации display: flex/inline-flex. Первый вариант
ведет себя как блочный элемент, т.е. растягивается на всю ширину. Второй вариант
растягивается только на ширину внутреннего содержимого.

Направление элементов задается с помощью свойства flex-direction. Его значения:
* row - элементы располагаются строкой, слева на право (по умолчанию);
* row-rewerse - тоже самое только в обратном порядке, справа налево;
* column - элементы располагаются в столбик, сверху вниз;
* column-reverse - тоже самое только в обратном порядке, снизу вверх.

Свойство flex-wrap определяет, будет ли контейнер иметь дополнительные ряды, если
контент внутри не помещается целиком. Его значения:
* nowrap - элементы будут располагаться в одну ряд; те что не поместятся, будут 
  вылазить за его пределы (по умолчанию);
* wrap - элементы будут располагаться в дополнительный ряд, если не поместятся в один;
* wrap-reverse - тоже самое, только расположение будет в обратном порядке.

Свойство flex-flow устанавливает значение одновременно для flex-direction и flex-wrap.
Например flex-flow: row wrap. Второе значение можно опустить, тогда для него будет
использоваться значение по умолчанию - nowrap.

Свойство order устанавливает порядок элемента в контейнере. Порядок задачется числом,
от нуля (по умолчанию, если не задан) и далее.

Свойство justify-content позволяет выравнивать элементы внутри контейнера вдоль
основной линии (обычно по горизонтали). Его значения:
* flex-start - элементы выравниваются по левому краю контейнера (по умолчанию);
* flex-end - элементы выравниваются по правому краю контейнера;
* center - элементы выравниваются по центру контейнера;
* space-between - первый и последний элементы выравниваются по краю; остальные делять 
  оставшееся пространство между собой;
* space-around - все элементы делят пространство между собой.

Свойство align-items позволяет выравнивать элементы внутри контейнера по поперечной 
оси (обычно по вертикали). Его значения:
* stretch - элементы растягиваются по всей высоте контейнера (по умолчанию);
* flex-start - элементы выравниваются по верхнему краю контейнера;
* flex-end - элементы выравниваются по нижнему краю контейнера;
* center - элементы выравниваются по центру контейнера;
* baseline - элементы выравниваются в соответствии со своей базовой линией. 

Свойство aligh-self позволяет переопределить значение свойства align-items для одного
элемента. Принимает те же значения, что и для align-items + auto (по умолчанию).
Для auto берется значение, которое определено в align-items.

Свойство align-content также управляет выравниванием содержимого в контейнере.
Применяется при комбинации flex-wrap: wrap/wrap-reverse. Имеет смысл использовать,
только если в контейнере две и больше строки/столбца. Принимает те же значения, что и
для justify-content + stretch (по умолчанию). 

Свойство flex-basis задает элементу размер. Принимает следующие значения: auto,
content, число. Если значение задано как auto, тогда размер берется из свойства width 
и т.п. Если значение задано числом, тогда width уже не учитывается. Если и flex-basis 
и width имеют auto, тогда это равносильно значению content, т.е. размер определяется 
по содержимому элемента.

Свойство flex-shrink определяет коэфициент усечения элемента, когда в контейнере
недостаточно места для отображения всех элементов. По умолчанию имеет значение 1. 
Чем больше значение, тем сильнее усекается элемент в контейнере относительно других.

Свойство flex-grow определеяет коэфициент расширения элемента, когда в контейнере есть
дополнительно место. По умолчанию имеет значение 0. Чем больше значение, тем сильнее
расширяется элемент в контейнере относительно других.

Если контейнер не имеет свободного места, но его элементы при этом имеют свойства 
flex-grow, то они будут растянуты только по размерам своего содержимого. Когда
контейнер начнет расширятся и появится свободное место, тогда элементы будут
распределять его так, как задано в их flex-grow. 

Тоже самое касается и flex-shrink. Когда контейнер имеет достатчно места для
отображения всех элементов, то они будут иметь размеры своего содержимого. Но когда
контейнер будет слишком мал и все элементы перестанут помещаться, то они будут
уменьшаться на тот коэфициент, что задан в их свойствах flex-shrink.

Свойство flex является общим и объединяет в себя все выше перечисленные. 
Вот его краткая запись: flex: <flex-grow> <flex-shrink> <flex-basis>.
По умолчанию оно имеет такую комбинацию: flex: 0 1 auto.

Существуют псевдонимы различных комбинаций:
* none -> 0 0 auto;
* auto -> 1 1 auto;
* initial -> 0 1 auto.

---------------------------

GRID LAYOUT

Гриды, в отличии от флексов, позиционируют элементы сразу в двух направлениях, 
образуя тем самым таблицу.

Основой является родительский элемент с комбинац. display: grid/inline-grid; 
После этого все его дочерние элементы автоматически становятся грид-элементами.

Чтобы настроить колонки используется свойство grid-template-columns. Оно принимает
значение в виде набора размеров. Сколько размеров задано, столько колонок и будет.

Тоже самое касается и строк. Их можно настроить через свойство grid-template-rows.
Здесь набор значений задает высоту соответсвующих строк.

Если элементов внутри контейнера больше, чем ячеек грида, то образуются дополнительные
строки, причем они могут не соответствовать заданным значениям.

С помощью ф-ции repeat() можно задать повторение одинаковым строкам/столбцам.

.container {
  display: grid;
  grid-template-columns: 8rem 8rem;         -> 2 столбца с шириной по 8rem
  grid-template-rows: 6rem repeat(3, 5rem); -> первая строка 6rem, 3 следующ по 5rem
}

Свойство grid позволяет одновременно задать настройка для строк и столбцов: 
grid: <grid-template-rows> / <grid-template-columns>;

Кроме фиксированных размеров можно также задавать и автоматические. В этом случае
размер ячеек будет вычисляться исходят из размеров сожержимого:
grid-template-rows: 8rem auto auto;

Для гридов существуют специальные пропорциональные размеры - fr. Они похожи на то, 
как во флексах задаются flex-grow и flex-shrink.

Отступы между столбцами и строками можно задать с помощью соответствующих свойств: 
grid-column-gap и grid-row-gap. Если значения этих свойств совпадают, то вместо них
можно использовать одно свойство gap, например: gap: 10px.

Элементы грида можно позиционировать и растягивать на несколько ячеек с помощью
следующих свойств (end здесь исключительно):
* grid-row-start - указывает с какой строки начинается элемент;
* grid-row-end - указывает до какой строки нужно растягивать элемент;
* grid-column-start - указывает с какой колонки начинается элемент;
* grid-column-end - указывает до какой колонки нужно растягивать элемент.

Если поместить элемент не на свое место, то перед ним может образоваться пустота.

Вместо двух свойст можно использовать одно grid-row или grid-column: 
grid-row: <grid-row-start> / <grid-row-end>;
grid-column: <grid-column-start> / <grid-column-end>;

Ключевое слово span указывать на сколько ячеек нужно растягивать, а не до какой:
grid-column: 2 / span 2;

Свойство grid-area позволяет сократить запись, объединением row и column:
grid-area: <row-start> <column-start> <row-end> <column-end>;

Свойство grid-auto-flow задает направление элементов в гриде. Имеет 2 значения:
* row - элементы располагаются в строку; если места не хватает, то 
  переносятся на новую (по умолчанию);
* column - элементы располагаются в столбик; если места не хватает, то переносятся в 
  следующий столбец.

Свойство order задает порядок элементов в гриде. По умолчанию имеет значение 0. 
Чем больше значение, тем ближе к началу будут располагаться элементы.

Ряды и колонки в гриде можно именовать. Это делается с помощью квадратный кобок:
.container {grid-template-columns: [main-s] 1fr [main-e] [sidebar-s] 25% [sidebar-e];}
.main { grid-column: main-s / main-e; }
.sidebar { grid-column: sidebar-s / sidebar-e; }

Области грида создаются с помощью свойства grid-template-areas. Их смысл похож на
именование рядов и колонок. Сначала задается набор рядов и колонок, а затем указыватся
к какой области пренадлежит каждая из ячеек:

.container {
  display: grid;
  grid-template-rows: 100px 1fr 1fr 100px;
  grid-template-columns: 150px 1fr;
  grid-template-areas: "header header"
                       "sidebar content"
                       "sidebar content"
                       "footer footer";
}

.header { grid-area: header }
.sidebar { grid-area: sidebar }
.content { grid-area: content }
.footer { grid-area: footer }

Элементы займут следующие ячейки:
* header - в первой строке две колонки; 
* sidebar - во второй и третьей строке первую колонку;
* content - во второй и третьей строке вторую колонку;
* footer - всю четвертую строку.

Чтобы задать ячейке пустую область, нужно поставить точку с пробелом вместо названия.
Это похоже на "gap" в обычной верстке (последние 3 точки говорят о том, что 3 колоки
будут в пустой области):

.container {
  ...
  grid-template-columns: 150px 10px 1fr;
  grid-template-areas: "sidebar . content"
                       ". . .";
}

---------------------------

ОСОБЕННОСТИ ВЁРСТКИ

Иногда возникает ситуация, когда нужно изменять шрифт при изменении размера экрана.
Хорошим способом для этого является изменение только одного свойства font-size, 
которое задано в <html>; вместо того чтобы прописывать новые значения rem 
у разных элементов, для того или иного @media-запроса.

Бывают случаи, когда внутренний элемент вроде бы соответсвует длине контейнера, но при
этом его border и padding'и почему-то вылазят за рамки, по горизонтали. Так происходит
когда у элемента установлен неправильный box-sizing, со значением content-box.

Иногда под картинкой появляются пробелы. Это из-за того что тег <img> строчный, а для
строчных эл-тов браузер всегда оставляет место под "хвосты" букв. Чтобы это исправить
нужно задать картинке display:block. Для маленьких изображений, вместо этого, можно
просто задать vertical-align:top/bottom и уменьшить line-height.

Процент обычно вычисляется относительно того же свойства родителя, но есть исключения.
Например для margin-left процент берется от ширины родителя, а для line-height - 
от текущего размера шрифта.

Св-во height, указанное в процентах, означает высоту относительно родителя. При этом
height, указанный в процентах, работает только если для родителя также указана высота.

Если у родителя не задан height, а указан min-height, то, чтобы дочерний блок занял
100% высоты, нужно родителю поставить height:1px;

Иногда, вместо svg-спрайтов можно использовать css-спрайты. Их суть заключается в том,
чтобы загрузить на страницу одну большую картинку (обычно с иконками) и затем просто
подставлять небольшую область с помощью background-position, для определен. эл-та.

