Актуальная верcия: 7.x

Варианты CDN: 

 https://pixijs.download/v7.4.2/pixi.js
 https://pixijs.download/v7.4.2/pixi.min.js

 https://pixijs.download/v7.4.2/pixi.mjs
 https://pixijs.download/v7.4.2/pixi.min.mjs

-----------------

Класс Application создает: renderer, stage и ticker.
 let app = new PIXI.Application({ width: 640, height: 360 });

Когда Application создает renderer, он создает canvas в котором тот будет отрисовываться.
Но его сначала нужно добавить на страницу. Канвас доступен по ссылке app.view.

 document.body.appendChild(app.view);

Простейший способ отрисовать изображение - это использовать класс Sprite.
Sprite - это DisplayObject который оборачивает загруженное изображение, чтобы его 
можно было отрисовывать, масштабировать, поворачивать и т.д.

 let sprite = PIXI.Sprite.from('sample.png'); // загрузить картинку асинхронно

После этого нужно добвить спрайт в stage. Stage - это корневой контейнер графа сцены.
Каждый потомок этого контейнера будет орисовываться каждый кадр. Добавив спрайт в stage 
мы скажем Pixi, что хотим отрисовывать его. Контейнер - это тоже DisplayObject.

 app.stage.addChild(sprite);

Ticker - это объект, который запускает заданный колбек в каждом кадре. 
Колбек принимает параметр delta - время, пройденное c момента последнего тика.

 let elapsed = 0.0;
 app.ticker.add(delta => {
   elapsed += delta;
   sprite.x = 100.0 + Math.cos(elapsed / 50.0) * 100.0;
 });

-----------------

Основные компоненты:

 * Renderer (@pixi/core) - это ядро Pixi, которое отображает граф сцены 
   и рисует его на экране (основано на WebGL);

 * Container (@pixi/display) - дерево отрисовываемых объектов, таких как: 
   Sprite, Graphics, Text (наверно имеется ввиду суб-граф для основного графа сцены); 

 * Loader (@pixi/loader) - система, предоставляющая инструменты для асинхронной 
   загрузки ресурсов, например: картинок или аудио;

 * Ticker (@pixi/ticker) - вызывает колбеки для обновления логики один раз в кадр; 
   одновременно можно использовать сразу несколько тикеров;

 * Application (@pixi/app) - это просто обертка для компонентов: Loader, Ticker и Renderer;

 * Interaction (@pixi/interaction) - система ввода, которая дает доступ для 
   touch и mouse-based интерактивности;

 * Accessibility (@pixi/accessibility) - набор инструментов для включения 
   клавиатурной и screen-reader доступности;

-----------------

Цикл отрисовки состоит из 3х шагов:
 1) Рассчет времени от последнего кадра и вызов колбэка ticker'a для обновления данных.
 2) Пересчет обновленных данных (новая позиция, поворот и пр.).
 3) Отрисовка каждого объекта графа сцены (включая те, что за видимыми пределами).

Максимальное FPS зависит от частоты монитора. Монитор с обновлением в 60 герц даст 
максимум 60 fps. Это ограничение вроде как можно снять, но нужно знать, что не полезно 
чтобы обновление было больше чем один раз за кадр.

Получить текущий FPS: app.ticker.FPS;

-----------------

Свойства объектов всегда относительны по отношению к своим предкам. Например, если 
сдвинуть контейнер, то сдвинутся и его дочерние объекты. Если задать контейнеру
полупрозрачность, то полупрозрачным станет все дерево.

Пример построения дерева объектов:

 const container = new PIXI.Container();
 app.stage.addChild(container);

 let parent = container;
 for (let i = 0; i < 3; i++) {
   let sprite = PIXI.Sprite.from('sample.png');
   parent.addChild(sprite);
   parent = sprite;
 }

Совокупная трансформация объекта доступна через свойство worldTransform, 
а прозрачность - через worldAlpha.

Объекты отрисовываются в порядке вставки, но по уровням, начиная от корня app.stage.
Например, в иерархии ниже: B перекроет A, C перекроет B, а D перекроет C. 

 app.stage
   A
     B
     C
   D  

Изменить порядок рендеринга у заданного потомка: setChildIndex().
Добавить потомка на нужную позицию в списке его предков: addChildAt().
Включить автоматическую сортировку потомков на основе их zIndex: sortableChildren().

Создать объект текста: new PIXI.Text('Hello!', { fill: '#ffffff' });
Добавить сразу несколько дочерних объектов: container.addChild(bg, text);

Если объекты находятся за пределами экрана их нужно отбрасывать (cull objects).
Culling - это процесс, который определяет, находится ли объект за пределами экрана. 
И если нет, то для него отключается отрисовка. Если этого не делать, то объекты будут
отрисовываться даже если их пиксели не попадают на экран.

Это можно реализовать через сторонние библиотеки либо самому, выполняя нужные проверки 
в кажом тике. Отключить рендеринг объекта: obj.renderable = false;

Началом координат считает верхний левый угол экрана. По умолчаний, при вызове 
obj.position.set(x, y); позиция задается в локальных координатах.

Чтобы преобразовать локальные координаты в глобальные, используется метод toGlobal():
 const globalPos = obj.toGlobal(new PIXI.Point(0, 0));

Помимо глобальных (мировых) координат, существуют также экранные координаты 
(screen или viewport coordinates). Это координаты относительно DOM-элемента canvas, 
в которых также работают браузерные события мыши и др.

В случае, когда размер канваса равен размеру render view, что задается при создании объекта
PIXI.Apllication (т.е. когда канвас не растягивается дополнительно, например через CSS), 
то экранное пространство будет эквивалентно мировому пространству.

-----------------

Пакет Assets предназначен для загрузки ассетов. Это замена устаревшему PIXI.Loader. 
Чтобы загрузить ассет используется метод load(url), который возвращает промис. 

 const texture = await PIXI.Assets.load('assets/bunny.png');

Все запросы кэшируются. Если передать одинаковый URL повтороно, 
то вернется один и тот же промис.

 const promise1 = PIXI.Assets.load('assets/bunny.png');
 const promise2 = PIXI.Assets.load('assets/bunny.png');
 promise1 === promise2;  -->  true

Из коробки можно загружать следующие типы ассетов:
 * текстуры (avif, webp, png, jpg, gif);
 * spritesheets (json);
 * bitmap-шрифты (xml, fnt, txt);
 * веб-шрифты (ttf, woff, woff2);
 * json и текстовые файлы (json, txt);

Чтобы загрузить бандл, можно воспользоваться методами addBundle() и loadBundle().

 PIXI.Assets.addBundle('animals', {
   bunny: 'bunny.png',
   chicken: 'chicken.png',
   thumper: 'thumper.png',
 });

 const bundle = await PIXI.Assets.loadBundle('animals');

Для работы с бандлами можно также использовать метод init({ manifest }). Он принимает объект
манифеста с заданными ассетами, либо путь к файлу манифеста в формате json.
Этот метод можно вызвать только один раз.

 PIXI.Assets.init({ manifest: 'path/manifest.json' });

 {
   "bundles": [
     {
       "name": "load-screen",
       "assets": [
         { name: "background", "srcs": "sunset.png" },
         { name: "loadbar", "srcs": "loadbar.{png,webp}" }
       ]
     }, 
   ]
 }

Запросы на бандлы также кэшируются, поэтому их можно подгружать повторно, если нужно
использовать один и тот же ассет в разных местах.

Методы backgroundLoad() и backgroundLoadBundle() подгрудают ассеты в фоновом режиме.
(далее написано непонятно, что мол после того как они подгрузят контент, его можно 
отобразить с пом. обычных вызовов load() и loadBundle())

-----------------

Контейнер группирует вместе набор потомков. Почти каждый тип display object'а 
основан на контейнере, даже спрайты.

Контейнеру можно задать маску с помощью свойства mask. В этом случае все содержимое 
не будет отображаться за его пределами. Маска обычно задается каким-нибудь 
спрайтом или объектом PIXI.Graphics.

Контейнеру можно задать фильтр. В этом случае область экрана, охватываемая контейнером, 
будет обрабатываться каким-то пост-эффектом.

Фильтры, доступные из коробки:

 * AlphaFilter (@pixi/filter-alpha) - подобно установке свойсва alpha, но дает эффект 
   сразу для всего контейнера, вместо индивидуального назначения.

 * BlurFilter (@pixi/filter-blur) - применяет эффект размытия.

 * ColorMatrixFilter (@pixi/filter-color-matrix) - цветовая матрица это гибкий способ 
   чтобы применить более сложные оттенки (tints) или цветовые трансформации (например ceпия);

 * DisplacementFilter (@pixi/filter-displacement) - карты смещения создают пиксели 
   с визуальным оффсетом, (например, для создание эффекта волн воды). 

 * FXAAFilter (@pixi/filter-fxaa) - эффект сглаживания Fast Approximate Anti Aliasing;
 * NoiseFilter (@pixi/filter-noise) - эффект рандомного шума (например, зернистость);

-----------------

DisplayObject - это базовый класс для отрисовываемых объектов: спрайтов, текста, 
контейнеров, graphics. Его основные свойства:

 * position - позиция относительно предка; к координатам x и y можно также 
   обратиться напрямую: obj.x, obj.y;

 * rotation - вращение, заданное в радианах; 
 * angle - алиас для rotation, который задан в углах;
 * pivot - точка, вокруг которой вращается объект; также задает origin для потомков;
 * alpha - прозрачность от 0.0 до 1.0;
 * scale - масштаб по x и y;
 * skew - перекос объекта по x и y, заданный в радианах;

 * visible - видимость объекта; если false, то предотвращает обновление 
   и отрисовку объекта и его потомков;

 * renderable - если false, то предотвращает только отрисоку объекта, но при этом 
   он все еще будет обновляться (трансформация и пр.); не влияет на потомков;

-----------------

Graphics - это инструмент для построения фигур и генерации масок. 

 let obj = new PIXI.Graphics();
 obj.beginFill(0xff0000);
 obj.drawRect(0, 0, 200, 100);

Хотя множество методов имеют префикс draw*, на самом деле здесь имеется ввиду построение
геометрии, а не отрисовка. Метод drawRect помещает прямоугольник в список геометрии для
дальнейшего использования. А чтобы отрисовать прямоугольник, нужно добавить его в граф сцены.

 app.stage.addChild(obj); // отрисует красный прямоугольник

Поэтому объекты Graphics могут также использоваться и для системы масок.

 let mask = new PIXI.Graphics();
 mask.beginFill(0xffffff);
 mask.drawRect(0, 0, 100, 100);
 mask.endFill();

 let maskContainer = new PIXI.Container();
 maskContainer.mask = mask;
 maskContainer.addChild(new PIXI.Text('Hello!')); // текст не вылезет за пределы контейнера

Базовые примитивы: Line, Rect, RoundRect, Circle, Ellipse, Arc, Bezier и Quadratic Curve.
Дополнительные примитивы находятся в пакете @pixi/graphics-extras.

Pre-build геометрия объекта Graphics хранится в свойстве geometry. Это свойство можно
применять для переиспользования геометрии, при создании новых форм или масок.

 let template = new PIXI.Graphics();
 template.drawCircle(100, 100, 50);

 for (let i = 0; i < 5; i++) {
   let duplicate = new PIXI.Graphics(template.geometry);
 }

Поскольку объект Graphics может делиться геометрией, то нужно вызывать метод destroy(), 
когда он больше не нужен, чтобы избежать утечек памяти.

Если нужно изменить форму, то не нужно удалять и создавать новый объект. Вместо этого можно
использовать метод clear(), чтобы сбросить содержимое geometry list и затем добавить новые
примитивы. Но это может повлияеть на производительность, если так делать в каждом кадре.

Для лучшей производительности лучше использовать множество graphics-объектов, 
чем один, но с большим количеством форм.

-----------------

Pixi поддерживает интерактивность для событий мыши, касаний и указателя (pointer). 
Указатель вызывается как на мобильных девайсах, так и на десктопах. В большинстве случаев
рекомендуется использовать именно его.

Любой DisplayObject (Sprite, Container и пр.) может стать интерактивным, 
если ему задать свойство eventMode.

let sprite = PIXI.Sprite.from('/some/texture.png');
sprite.on('pointerdown', (event) => {
  alert('clicked!');
});
sprite.eventMode = 'static';

Значения для свойства eventMode:

 * none - игнорирует все события, хорошая оптимизация для неинтерактивных объектов;
 * passive - не эмитет события и игнорирует hit testing на себе, но не на потомках;
 * auto - не эмитет события но имеет hit testing если родитель интерактивный;

 * static - эмитет события и является hit testing; полезно для разных кнопок 
   и других объектов, которые не двигаются;

 * dynamic - эмитет события и является hit testing, но также получает моковые интерактивные
   события, вызванные из тикера чтобы разрешить интерактивность когда мышь не двигается;
   полезно для элементов, которые независимо движутся или анимируются;

Проверить, является ли объект интерактивным можно с пом. свойства isInteractive (или это
метод, непонятно). Оно вернет true, если eventMode установлен как static или dynamic.

Типов событий достаточно много. Их можно посмотреть здесь:
 https://pixijs.com/7.x/guides/components/interaction

Для оптимизации можно задать свойство interactiveChildren = false; для контейнера, 
чьи потомки точно не будут интерактивными. Например для background'а сцены.

Также можно установить зону интерактивности: hitArea = new PIXI.Rectangle(x,y,w,h)
Это позволит не выполнять лишний раз проходы по графу сцены (что-то вроде этого...)
https://pixijs.com/7.x/guides/production/performance-tips#events

-----------------

Каждый спрайт содержит текстуру, которая будет нарисована наряду со всеми преоразованиями.
Его свойства width и height выполняют обычное масштабирование, но не в процентном соотношении
как это делает scale, а в заданных пикселях. Под капотом же происходит обычное измение scale.

Отличие pivot от anchor в том, что первое задается в пикселях, а второе в процентах 
(от 0 до 1). Anchor'ы доступны только для спрайтов. Anchor'ы удобнее тем, что если поменяется
размер текстуры, то не придется пересчитывать новую опорную точку в пикселях. При работе 
со спрайтами рекомендуется использовать именно anchor'ы.

Spritesheet - это медиа формат для более эффективной загрузки и отрисовки спрайтов. 
Для сборки spritesheet использ. сторонние инструменты, например: ShoeBox или TexturePacker.

Основная идея заключается в том, чтобы скомбинировать серию изображений в одно, пометить 
где заканчивается каждое из них и использовать это все как общую BaseTexture.

 // Данные spritesheet
 const atlasData = {
   frames: {
     enemy1: {
       frame: { x: 0, y: 0, w: 32, h: 32 },
       sourceSize: { w: 32, h: 32 },
       spriteSourceSize: { x: 0, y: 0, w: 32, h: 32 },
     },
     enemy2: {
       frame: { x: 32, y: 0, w: 32, h: 32 },
       sourceSize: { w: 32, h: 32 },
       spriteSourceSize: { x: 0, y: 0, w: 32, h: 32 },
     },
   },
   meta: {
     image: 'images/spritesheet.png',
     format: 'RGBA8888',
     size: { w: 128, h: 32 },
     scale: 1,
   },
   animations: {
     enemy: ['enemy1', 'enemy2'],
   },
 };

 // Создание spritesheet на основе общего изображения и данных (те самые пометки) 
 const spritesheet = new PIXI.Spritesheet(
   PIXI.BaseTexture.from(atlasData.meta.image), 
   atlasData
 );

 await spritesheet.parse(); // сгенерировать все текстуры

 // Сами спрайты наверно берутся из глобального кэша, который пополняется после parse()
 const anim = new PIXI.AnimatedSprite(spritesheet.animations.enemy);
 anim.animationSpeed = 0.15;
 anim.play();

 app.stage.addChild(anim);

-----------------

Pixi создает растровое изображение текста, который сначала отрисовывается в offscreen 
буффере с пом. браузерного текстового рендеринга, а затем интрепритируется как спрайт.

Это дает возможность применять для текста CSS-стили, до того, как он будет растеризирован.
Стили можно определить с пом. класса TextStyle.

Для загрузки шрифтов может быть полезен класс FontFaceObserver.

Изменение текста потребует повторной генерации его внутренней отрисовки, что может ухудшить
производительность, если это делать в каждом кадре.

Изменение свойства scale > 1.0 может привести к размытию текста, потому что текст 
не будет перерисовываться в более высокое разрешение. Вместо этого можно инициализировать
текст с более высоким разрешением сразу, а затем уменьшить масштабирование.

Для оптимизации можно использовать bitmap-шрифты. Их символы уже растеризированы 
в изображения и системе не нужно выполнять этот процесс самостоятельно.
Для работы с таким текстом используется класс PIXI.BitmapText.

PIXI.Text лучше использовать: 
 * со статическим текстом;
 * с небольшим кол-вом текстовых объектов;
 * с текстом, требующим высокого точности;
 * с текстом, требующим разметки (линия, межбуквенное пространство и пр.)

PIXI.BitmapText лучше использовать:
 * с динамическим текстом (который часто меняется);
 * с большим кол-вом текстовых объектов;
 * для меньшего потребления памяти;

-----------------

При подгрузке текстуры, загрузчик работает с html-элементом <img>. После подгрузки,
Pixi берет то сырое изображение и загружает его на GPU. Класс BaseTexture конверитрует
изображение в пиксели и использует их в отрисовке (вероятно он и выполняет всю ту работу).

BaseTexture автоматически кэшируются, так что загружая ее повторно (с тем же URL), 
вернется та же BaseTexture. Уничтожение BaseTexture освободит image data связанные с ним.

Для подготовки большого кол-ва текстур можно использовать Prepare. 
Эта техника останавливает рендеринг, пока графика не загрузится на GPU.
https://pixijs.download/v7.4.2/docs/PIXI.Prepare.html

Шпаргалка о том, как загружать паки текстур.
https://pixijs.com/7.x/guides/components/textures

Когда текстура уже не нужна, следет освободить от нее память, вызвав метод destroy(), 
объекта BaseTexture. Это хорошая идея для недолговечных изображений, например для кат-сцен.
Чтобы удалить все текстуры нужно вызвать PIXI.utils.destroyTextureCache().

BaseTexture может работать не только с <img>, но и с <video>, <canvas>, <svg>.
Svg растеризируется при взаимодействии с BaseTexture. При этом работать с этим форматом 
более экономно т.к. сам файл весит обычно меньше, чем растровая картинка.

Текстуру можно создать из RenderTexture, например сначала создать сложную геометрию,
а затем запечь ее в обычную текстуру.
https://pixijs.com/7.x/examples/textures/render-texture-basic

-----------------

Чтобы увеличить производительность можно передать след. параметры для рендера:
useContextAplpa: false, antialias: false.

Всегда, когда только можно, лучше использовать spritesheets, чтобы уменьшить кол-во текстур.
На старых девайсах можно использовать текстуры с низким разрешением. Для этого подойдет
расширение "@0.5x.png", которое уменьшает масштабирование spritesheet на 50%.

Graphics объекты быстрее всего, когда они не изменяются постоянно (не включая transform,
alpha или tint). Маленькие объекты такие же быстрые как и спрайты.

Текстуры автоматически управляются текстурным сборщиком мусора, но можно также 
управлять ими вручную, используя texture.destroy();

Если нужно удалить сразу много текстур, то нужно добавить небольшую задержку 
(add a random delay to their destruction), иначе будут фризы.

Уменьшив resolution для текста, можно добиться уменьшения потребления памяти.

Использование большого кол-ва масок может ухудшить производительность.
Axis-aligned Rectangle маски быстрее всего. На втором месте по производетельности 
Graphics-маски. На третьем - спрайтовые маски.

Использование фильтров - это дорого. Не нужно применять их в большом кол-ве.
После использования, нужно также очищать память: displayObject.filters = null;

Чтобы немного ускорить производительность, нужно заранее устанавливать размер фильтра, 
чтобы это не выполнялось системой: displayObject.filterArea = new PIXI.Rectangle(x,y,w,h).

Различные режимы смешивания (blend modes) приводят к деоптимизациии (ломают батчинг).
SceenSprite / NormalSprite / SceenSprite / NormalSprite дали бы 4 draw calls
SceenSprite / SceenSprite / NormalSprite / NormalSprite дали бы 2 draw calls

Если есть сложный объект, которые имеет много спрайтов или фильтров и не двигается, 
то можно установить: cacheAsBitmap = true; это ускорит рендеринг.
https://pixijs.com/7.x/guides/production/performance-tips#cacheasbitmap

