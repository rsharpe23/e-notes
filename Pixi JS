Актуальная верcия: 7.x

Варианты CDN: 

 https://pixijs.download/v7.4.2/pixi.js
 https://pixijs.download/v7.4.2/pixi.min.js

 https://pixijs.download/v7.4.2/pixi.mjs
 https://pixijs.download/v7.4.2/pixi.min.mjs

-----------------

Класс Application создает: renderer, stage и ticker.
 let app = new PIXI.Application({ width: 640, height: 360 });

Когда Application создает renderer, он создает canvas в котором тот будет отрисовываться.
Но его сначала нужно добавить на страницу. Канвас доступен по ссылке app.view.

 document.body.appendChild(app.view);

Простейший способ отрисовать изображение - это использовать класс Sprite.
Sprite - это DisplayObject который оборачивает загруженное изображение, чтобы его 
можно было отрисовывать, масштабировать, поворачивать и т.д.

 let sprite = PIXI.Sprite.from('sample.png'); // загрузить картинку асинхронно

После этого нужно добвить спрайт в stage. Stage - это корневой контейнер графа сцены.
Каждый потомок этого контейнера будет орисовываться каждый кадр. Добавив спрайт в stage 
мы скажем Pixi, что хотим отрисовывать его. Контейнер - это тоже DisplayObject.

 app.stage.addChild(sprite);

Ticker - это объект, который запускает заданный колбек в каждом кадре. 
Колбек принимает параметр delta - время, пройденное c момента последнего тика.

 let elapsed = 0.0;
 app.ticker.add(delta => {
   elapsed += delta;
   sprite.x = 100.0 + Math.cos(elapsed / 50.0) * 100.0;
 });

-----------------

Основные компоненты:

 * Renderer (@pixi/core) - это ядро Pixi, которое отображает граф сцены 
   и рисует его на экране (основано на WebGL).

 * Container (@pixi/display) - дерево отрисовываемых объектов, таких как: 
   Sprite, Graphics, Text (наверно имеется ввиду суб-граф для основного графа сцены...). 

 * Loader (@pixi/loader) - система, предоставляющая инструменты для асинхронной 
   загрузки ресурсов, например: картинок или аудио.

 * Ticker (@pixi/ticker) - вызывает колбеки для обновления логики один раз в кадр; 
   одновременно можно использовать сразу несколько тикеров.

 * Application (@pixi/app) - это просто обертка для компонентов: Loader, Ticker и Renderer.

 * Interaction (@pixi/interaction) - система ввода, которая дает доступ для 
   touch и mouse-based интерактивности.

 * Accessibility (@pixi/accessibility) - набор инструментов для включения 
   клавиатурной и screen-reader доступности.

-----------------

Цикл отрисовки состоит из 3х шагов:

1) Рассчет времени от последнего кадра и вызов колбэка ticker'a для обновления данных.
2) Пересчет обновленных данных (новая позиция, поворот и пр.).
3) Отрисовка каждого объекта графа сцены (включая те, что за видимыми пределами).

Максимальное FPS зависит от частоты монитора. Монитор с обновлением в 60 герц даст 
максимум 60 fps. Это ограничение вроде как можно снять, но нужно знать, что не полезно 
чтобы обновление было больше чем один раз за кадр.

Получить текущий FPS: app.ticker.FPS;

-----------------

Свойства объектов всегда относительны по отношению к своим предкам. Например, если 
сдвинуть контейнер, то сдвинутся и его дочерние объекты. Если задать контейнеру полупрозрачность, то полупрозрачным станет все дерево.

Пример построения дерева объектов:

 const container = new PIXI.Container();
 app.stage.addChild(container);

 let parent = container;
 for (let i = 0; i < 3; i++) {
   let sprite = PIXI.Sprite.from('sample.png');
   parent.addChild(sprite);
   parent = sprite;
 }

Совокупная трансформация объекта доступна через свойство worldTransform, 
а прозрачность - через worldAlpha.

Объекты отрисовываются в порядке вставки, но по уровням, начиная от корня app.stage.
Например, в иерархии ниже: B перекроет A, C перекроет B, а D перекроет C. 

 app.stage
   A
     B
     C
   D  

Изменить порядок рендеринга у заданного потомка: setChildIndex().
Добавить потомка на нужную позицию в списке его предков: addChildAt().
Включить автоматическую сортировку потомков на основе их zIndex: sortableChildren().

Создать объект текста: new PIXI.Text('Hello!', { fill: '#ffffff' });
Добавить сразу несколько дочерних объектов: container.addChild(bg, text);

Если объекты находятся за пределами экрана их нужно отбрасывать (cull objects).
Culling - это процесс, который определяет, находится ли объект за пределами экрана. 
И если нет, то для него отключается отрисовка. Если этого не делать, то объекты будут отрисовываться даже если их пиксели не попадают на экран.

Это можно реализовать через сторонние библиотеки либо самому, выполняя нужные проверки 
в кажом тике. Отключить рендеринг объекта: obj.renderable = false;

Началом координат считает верхний левый угол экрана. По умолчаний, при вызове 
obj.position.set(x, y); позиция задается в локальных координатах.

Чтобы преобразовать локальные координаты в глобальные, используется метод toGlobal():
 const globalPos = obj.toGlobal(new PIXI.Point(0, 0));

Помимо глобальных (мировых) координат, существуют также экранные координаты 
(screen или viewport coordinates). Это координаты относительно DOM-элемента canvas, 
в которых также работают браузерные события мыши и др.

В случае, когда размер канваса равен размеру render view, заданном при создании объекта PIXI.Apllication, то экранное пространство будет эквивалентно мировому пространству.

-----------------



