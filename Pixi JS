Актуальная верcия: 7.x

Варианты CDN: 

 https://pixijs.download/v7.4.2/pixi.js
 https://pixijs.download/v7.4.2/pixi.min.js

 https://pixijs.download/v7.4.2/pixi.mjs
 https://pixijs.download/v7.4.2/pixi.min.mjs

-----------------

Класс Application создает: renderer, stage и ticker.
 let app = new PIXI.Application({ width: 640, height: 360 });

Когда Application создает renderer, он создает canvas в котором тот будет отрисовываться.
Но его сначала нужно добавить на страницу. Канвас доступен по ссылке app.view.

 document.body.appendChild(app.view);

Простейший способ отрисовать изображение - это использовать класс Sprite.
Sprite - это DisplayObject который оборачивает загруженное изображение, чтобы его 
можно было отрисовывать, масштабировать, поворачивать и т.д.

 let sprite = PIXI.Sprite.from('sample.png'); // загрузить картинку асинхронно

После этого нужно добвить спрайт в stage. Stage - это корневой контейнер графа сцены.
Каждый потомок этого контейнера будет орисовываться каждый кадр. Добавив спрайт в stage 
мы скажем Pixi, что хотим отрисовывать его. Контейнер - это тоже DisplayObject.

 app.stage.addChild(sprite);

Ticker - это объект, который запускает заданный колбек в каждом кадре. 
Колбек принимает параметр delta - время, пройденное c момента последнего тика.

 let elapsed = 0.0;
 app.ticker.add(delta => {
   elapsed += delta;
   sprite.x = 100.0 + Math.cos(elapsed / 50.0) * 100.0;
 });

-----------------

Основные компоненты:

 * Renderer (@pixi/core) - это ядро Pixi, которое отображает граф сцены 
   и рисует его на экране (основано на WebGL);

 * Container (@pixi/display) - дерево отрисовываемых объектов, таких как: 
   Sprite, Graphics, Text (наверно имеется ввиду суб-граф для основного графа сцены); 

 * Loader (@pixi/loader) - система, предоставляющая инструменты для асинхронной 
   загрузки ресурсов, например: картинок или аудио;

 * Ticker (@pixi/ticker) - вызывает колбеки для обновления логики один раз в кадр; 
   одновременно можно использовать сразу несколько тикеров;

 * Application (@pixi/app) - это просто обертка для компонентов: Loader, Ticker и Renderer;

 * Interaction (@pixi/interaction) - система ввода, которая дает доступ для 
   touch и mouse-based интерактивности;

 * Accessibility (@pixi/accessibility) - набор инструментов для включения 
   клавиатурной и screen-reader доступности;

-----------------

Цикл отрисовки состоит из 3х шагов:
 1) Рассчет времени от последнего кадра и вызов колбэка ticker'a для обновления данных.
 2) Пересчет обновленных данных (новая позиция, поворот и пр.).
 3) Отрисовка каждого объекта графа сцены (включая те, что за видимыми пределами).

Максимальное FPS зависит от частоты монитора. Монитор с обновлением в 60 герц даст 
максимум 60 fps. Это ограничение вроде как можно снять, но нужно знать, что не полезно 
чтобы обновление было больше чем один раз за кадр.

Получить текущий FPS: app.ticker.FPS;

-----------------

Свойства объектов всегда относительны по отношению к своим предкам. Например, если 
сдвинуть контейнер, то сдвинутся и его дочерние объекты. Если задать контейнеру
полупрозрачность, то полупрозрачным станет все дерево.

Пример построения дерева объектов:

 const container = new PIXI.Container();
 app.stage.addChild(container);

 let parent = container;
 for (let i = 0; i < 3; i++) {
   let sprite = PIXI.Sprite.from('sample.png');
   parent.addChild(sprite);
   parent = sprite;
 }

Совокупная трансформация объекта доступна через свойство worldTransform, 
а прозрачность - через worldAlpha.

Объекты отрисовываются в порядке вставки, но по уровням, начиная от корня app.stage.
Например, в иерархии ниже: B перекроет A, C перекроет B, а D перекроет C. 

 app.stage
   A
     B
     C
   D  

Изменить порядок рендеринга у заданного потомка: setChildIndex().
Добавить потомка на нужную позицию в списке его предков: addChildAt().
Включить автоматическую сортировку потомков на основе их zIndex: sortableChildren().

Создать объект текста: new PIXI.Text('Hello!', { fill: '#ffffff' });
Добавить сразу несколько дочерних объектов: container.addChild(bg, text);

Если объекты находятся за пределами экрана их нужно отбрасывать (cull objects).
Culling - это процесс, который определяет, находится ли объект за пределами экрана. 
И если нет, то для него отключается отрисовка. Если этого не делать, то объекты будут
отрисовываться даже если их пиксели не попадают на экран.

Это можно реализовать через сторонние библиотеки либо самому, выполняя нужные проверки 
в кажом тике. Отключить рендеринг объекта: obj.renderable = false;

Началом координат считает верхний левый угол экрана. По умолчаний, при вызове 
obj.position.set(x, y); позиция задается в локальных координатах.

Чтобы преобразовать локальные координаты в глобальные, используется метод toGlobal():
 const globalPos = obj.toGlobal(new PIXI.Point(0, 0));

Помимо глобальных (мировых) координат, существуют также экранные координаты 
(screen или viewport coordinates). Это координаты относительно DOM-элемента canvas, 
в которых также работают браузерные события мыши и др.

В случае, когда размер канваса равен размеру render view, что задается при создании объекта
PIXI.Apllication (т.е. когда канвас не растягивается дополнительно, например через CSS), 
то экранное пространство будет эквивалентно мировому пространству.

-----------------

Пакет Assets предназначен для загрузки ассетов. Это замена устаревшему PIXI.Loader. 
Чтобы загрузить ассет используется метод load(url), который возвращает промис. 

 const texture = await PIXI.Assets.load('assets/bunny.png');

Все запросы кэшируются. Если передать одинаковый URL повтороно, 
то вернется один и тот же промис.

 const promise1 = PIXI.Assets.load('assets/bunny.png');
 const promise2 = PIXI.Assets.load('assets/bunny.png');
 promise1 === promise2;  -->  true

Из коробки можно загружать следующие типы ассетов:
 * текстуры (avif, webp, png, jpg, gif);
 * spritesheets (json);
 * bitmap-шрифты (xml, fnt, txt);
 * веб-шрифты (ttf, woff, woff2);
 * json и текстовые файлы (json, txt);

Чтобы загрузить бандл, можно воспользоваться методами addBundle() и loadBundle().

 PIXI.Assets.addBundle('animals', {
   bunny: 'bunny.png',
   chicken: 'chicken.png',
   thumper: 'thumper.png',
 });

 const bundle = await PIXI.Assets.loadBundle('animals');

Для работы с бандлами можно также использовать метод init({ manifest }). Он принимает объект
манифеста с заданными ассетами, либо путь к файлу манифеста в формате json.
Этот метод можно вызвать только один раз.

 PIXI.Assets.init({ manifest: 'path/manifest.json' });

 {
   "bundles": [
     {
       "name": "load-screen",
       "assets": [
         { name: "background", "srcs": "sunset.png" },
         { name: "loadbar", "srcs": "loadbar.{png,webp}" }
       ]
     }, 
   ]
 }

Запросы на бандлы также кэшируются, поэтому их можно подгружать повторно, если нужно
использовать один и тот же ассет в разных местах.

Методы backgroundLoad() и backgroundLoadBundle() подгрудают ассеты в фоновом режиме.
(далее написано непонятно, что мол после того как они подгрузят контент, его можно 
отобразить с пом. обычных вызовов load() и loadBundle())

-----------------

Контейнер группирует вместе набор потомков. Почти каждый тип display object'а 
основан на контейнере, даже спрайты.

Контейнеру можно задать маску с помощью свойства mask. В этом случае все содержимое 
не будет отображаться за его пределами. Маска обычно задается каким-нибудь 
спрайтом или объектом PIXI.Graphics.

Контейнеру можно задать фильтр. В этом случае область экрана, охватываемая контейнером, 
будет обрабатываться каким-то пост-эффектом.

Фильтры, доступные из коробки:

 * AlphaFilter (@pixi/filter-alpha) - подобно установке свойсва alpha, но дает эффект 
   сразу для всего контейнера, вместо индивидуального назначения.

 * BlurFilter (@pixi/filter-blur) - применяет эффект размытия.

 * ColorMatrixFilter (@pixi/filter-color-matrix) - цветовая матрица это гибкий способ 
   чтобы применить более сложные оттенки (tints) или цветовые трансформации (например ceпия);

 * DisplacementFilter (@pixi/filter-displacement) - карты смещения создают пиксели 
   с визуальным оффсетом, (например, для создание эффекта волн воды). 

 * FXAAFilter (@pixi/filter-fxaa) - эффект сглаживания Fast Approximate Anti Aliasing;
 * NoiseFilter (@pixi/filter-noise) - эффект рандомного шума (например, зернистость);

-----------------



