ОБЩИЕ ПОНЯТНИЯ

Java (через компилятор javac) транслируется в специальный байт-код, а затем этот 
байт-код выполняется на виртуальной машине "Java Virtual Machine". Благодаря этому
решается проблема кроссплатформенности. Код пишется один раз, а выполняется везде 
за счет того, что у каждой платформы своя реализация JVM.

Для разработки на Java нужно иметь специальный набор инструментов "Java Development
Kit". JDK содержит компилятор javac и др. А чтобы запускать программы, нужен "Java
Runtime Environment". Основная часть JRE это как раз JVM. JDK уже содержит в себе JRE,
но JRE также поставляется и отдельно для обычных пользователей.

Есть разные варианты JDK - "Oracle JDK" и "Open JDK". У Oracle JDK платная лиценция, 
но она бесплатна для персональных нужд. Она также более производительная и стабильная
чем Open JDK. Последняя же полностью бесплатная (развивается совместно как Oracle, так
и другими компаниями, возможно и Microsoft тоже).

Вирутальная машина - это файл под названием java (или java.exe для Windows). 
Он хранится в папке jre/bin либо в jdk/bin.

Файлы с расширением *.class содержат байт-код.

----------------------------------------

ОСНОВЫ JAVA

Инструкция - это отдельная часть программы (обычно однострочное выражение). 
Каждая инструкция завершается точкой с запятой. Тело метода содержит инструкции.

Ключевое слово var устроено так же, как и в C#. Переменная объявленная через var
обязательно должна быть инициализирована, иначе компилятор не сможет определить ее тип.

Примитивные типы данных:
* byte - целое число от -128 до 127 (1 байт);
* short - целое число от -32768 до 32767 (2 байта);
* int - целое число (4 байта);
* long - целое число (8 байт);
* float - число с плавающей точкой (4 байта);
* double - число с плавающей точкой (8 байта);
* char - одиночный символ UTF-16 в диапазоне от 0 до 65535 (2 байта);
* boolean - логическое значение true/false.

Числовые типы и char по умолчанию имеют значение 0. Для boolean значение по умолчанию
это false. Объекты по умолчанию принимают null (в т.ч. и String).

Все целочисленные значения по умолчанию расцениваются как int. При инициализации
большого числа компилятор выдаст ошибку. В этом случае нужно добавить дополнительно
нужное окончание, например l/L для типа long.
...
long num = 2147483649L;

Числа в других системах счисления записываются также как и в JS: 
int num = 0b1101; int num2 = 0x6FF

Также целые числа поддерживают разделение разрядов с помощью знака подчеркивания:
int num = 123_456;  -->  Тоже что и 123456

Все числа с плавающей точкой по умолчанию расцениваются как double. Чтобы указать, 
что число является float, нужно использовать окончание f.
...
float num = 30.5f;

Переменной символьного значение также можно присвоить число. В этом случае число будет
указывать на номер символа в таблице Unicode (UTF-16). Число можно указывать и в
шеснадцатиричной форме, но оно должно начинаться со знака "\u".
...
char ch = '\u0077';

В Java 15 многострочный текст можно писать с помощью текстовых блоков. 
Текстовый блок определяются с помощью тройных кавычек:
...
String text = """
    Строка текста, в конце которой не нужно 
    указывать символ \n. Другой текст.
""";

Для взаимодействия с консолью используется класс System. За вывод отвечает объект out.
Его методы print и println выводят строку на консоль. Последний метод делает вывод
каждый раз на новой строке. За ввод отвечает объект in.

Отформатированную строку можно вывести с помощью метода printf. 
Он устроен также как и в PHP.
...
int a = 23;
String b = "Привет";
System.out.printf("a:%d b:%s", a, b);

Спецификаторы типов данных, для форматирования строк:
* %d - целове число;
* %f - число с плавающие точкой;
* %x - шеснадцатиричное число;
* %e - число в экспоненциальной форме (1.3e4);
* %c - одиночный символ;
* %s - строка.

При выводе чисел с плавающей точкой можно указать кол-во выводимых знаков:
%.2f  -->  Указывает, что после точки будет два знака.

При делении двух целых чисел результат также будет округляться до целого числа. 
Чтобы получить число с плавающей точкой, один из операторов должен также быть 
с плавающей точкой.

Остаток от деления двух чисел, например 22 % 4, рассчитывается так:
20 / 4 = 5; 22 - 4 * 5 = 2

Разница между операциями | и || (также & и &&) в том, что в первом варианте вычисляется
результат сразу всех операндов и на их основе выводится логическое значение, а во
втором варианте сначала вычисляется результат первого операнда и если он true, 
то все оставшиеся операнды отбрасываются.

Экзотические операции присвоения:
* a %= b - переменной a присваивается остаток от деления a на b;
* a &= b - переменной a присваивается значение a & b (еще операции: |=, ^=);
* a <<= b - переменной a присваивается значение a << b (еще операции: >>=, >>>=);

Преобразования типов при операциях:
- если один из операндов double, то и второй преобразовывается к double;
- если предыдущие условие не соблюдено, тогда идет попытка преобразования к float;
- если и это условие не соблюдено, тогда идет попытка преобразования к long;
- иначе все операнды преобразовываются к int.
...
int a = 1; double b = 2; double c = a + b;       -->  Здесь a преобраз. к double
byte a = 1; short b = 2; byte c = (byte)(a + b)  -->  Здесь a + b преобраз. к int
int a = 'a' + 5;  -->  Здесь символ преобраз. в int и в итоге получаем 102

Массивы могут объявляться как в C++ и как в C#.
int arr[]; int[] arr2;  -->  Оба варианта корректны

Также массивы могут инициализироваться через краткую форму:
int[] arr = { 1, 2, 3, 4, 5 }; 

Многомерный массив по синтаксису напоминает рваный массив из C#. А сам рваный массив 
в Java это как раз и есть многомерный массив, в котором одна из размерностей не
определена.
...
int[][] arr = new int[2][3];  -->  Многомерный массив 2х3
int[][] arr2 = new int[2][];  -->  Рваный массив

Цикл foreach объявляется так: for (int item : arr) { }

Параметры переменной длины - это тоже самое что и остаточные параметры в JS.
Они всегда должны определяться последними в методе.
...
void someMethod(boolean value, String ...rest) {}
someMethod(true, "привет", "мир");

На перегрузку методов влияют только количество и типы параметров.

----------------------------------------

ООП В JAVA

Класс состоит из полей и методов. В каждом файле только один класс может иметь
модификатор public (возможно тот, чье имя совпадает с именем файла).

Ключевое слово this - это ссылка на экземпляр текущего класса для доступа к его полям 
и методам изнутри. А ключевое слово super подобно this, но ссылается на экземпляр
базового класса.

Вызов одного из конструкторов текущего класса:
...
Foo() { this(23, true); }
Foo(int a, boolean b) { this.a = a; this.b = b }

Вызов конструктора базового класса:
Foo() { super(23, true); }  -->  super() должен вызываться в самом начале

Если в базовом классе определен конструктор с параметрами, то производный класс обязан
его явно вызывать. Иначе базовый класс должен также иметь и дефолтный конструктор.

Когда у класса нет ни одного конструктора, то для него создается дефолтный. 
Дефолтные конструкторы производных классов вызывают дефолтные конструкторы базовых. 
Но когда в базовом классе определен только конструктор с параметрами, то производный
класс, пытаясь вызвать его из своего дефолтного, не знает что туда передать.

Помимо конструкторов, существуют еще и инициализаторы. Их код вызывается раньше всех
конструкторов. Объявляется он как обычный блок кода. Инициализатор может быть
статическим. В этом случае он будет похож на статический конструктор в C#.
...
{ /* код инициализатора */ }
Foo() { /* код конструктора */ }

Вместо пространств имен используются пакеты. Чтобы указать что класс пренадлежит
определенному пакету, нужно объявить этот пакет в самом начале файла. Как правило,
названия пакета соответсвует структуре каталога, в котором хранится файл класса.
...
package pac1;        -->  Объявление пакета pac1
public class Foo {}  -->  Теперь класс доступен как pac1.Foo
...
import pac1.Foo;     -->  Импорт класса с пакетом
import java.lang.*;  -->  Импорт всех классов из пакета java.lang
public class Bar {
  Bar() { 
    var scanner = new java.util.Scanner();  -->  Полное название класса
    var foo = new Foo();  -->  После импорта можно не указывать полное название
  }
}

Существует также статический импорт. С помощью него можно импортировать статические
методы и вызывать их напрямую без привязки к классу.
...
import static java.lang.Math.*  -->  Здесь методы импортируются напрямую из класса
public class Foo {
  static void doSomething() {
    double result = sqrt(20)    -->  Вызов статического метода Math.sqrt()
  }
}

Модификатор protected открывает доступ к классу/полю/методу не только для классов
наследников, но и для других классов из одного пакета.

Если модификатор доступа не указан, тогда класс/поле/метод видны всем другим классам 
из одного пакета.

Константа объявляется с помощью ключевого слова final.
...
public static final double PI = 3.14  -->  Глобальная константа
void someMethod(final int arg) {  -->  Иммутабельный параметр
  final int age = 23;  -->  Локальная константа
}

Глобальная константа это поле, помеченное как final static. В C# это const-поле.
Если поле помечено final но без static, то это тоже самое что и readonly в C#.
Если класс или метод помечены final, то это аналог sealed в C# (класс нельзя
унаследовать, а метод нельзя переопределить).

Статические методы обычно используются, когда в классе есть какая-то логика которая 
не связанна с состоянием объекта. В JS такой метод мог бы быть отдельной глобальной 
ф-цией. Но т.к. Java полностью основана на классах, то для таких целей хорошо 
подходят статические методы.

Объект внутреннего класса может быть создан только в том классе, где он определен.
Внутренний класс имеет доступ ко всем членам внешнего класса, в том числе и private.
Аналогично и внешний класс имеет доступ ко всем членам внутреннего класса.

Внутренний класс можно объявить внутри любого контекста, в том числе внутри 
метода и даже цикла. Внутренним может быть также и интерфейс.

Ссылку на this внешнего класса из внутреннего можно получить так: MyOuterClass.this.

В Java статическиим классом может быть только внутренний класс. 
Его правильное название статический вложенный класс.

Наследование классов происходит с помощью ключевого слова extends, а реализация
интерфейсов с помощью implements.

Чтобы переопределить метод в производном классе, нужно добавить к нему аннотацию
@Override. При этом его уровень доступа должен быть не меньшим чем тот, что в базовом.

Проверка приведения типов выполняется также как в JS, с помощью оператора instanceof:
Object obj = new User(); if (obj instanceof User) { }

В Java 16 этот оператор можно использовать сразу с приведением типа:
if (obj instanceof User user) {  }  -->  Если true, то из obj создается user 

Интерфейсы принятно называть прилагательными (но во всех случаях).
В случае, если интерфейс представляет сущность иерархии, его имя может быть
существительным, а класс базовой реализации может называться именем интерфейса 
с окончанием Impl.
...
interface User { }  -->  Интерфейс легко поменять на абстрактный класс
class UserImpl extends Person implements User { }  -->  Класс базовой реализации
class SuperUser extends UserImpl { }

Методы интерфейса по умолчанию имеют модификатор public.

В Java 8 появилась возможность объявления в интерфейсах методов по умолчанию. 
Такие методы не обязательно реализовывать в классах.
...
interface User {
  default void doSomething() {
    System.out.println("Привет мир");
  }
}
new UserImpl().doSomething();

Также в Java 8 появилась возможность объявлять в интерфейсах статические методы:
...
interface Printable {
  static void print() {
    System.out.println("Привет мир");
  }
}
Printable.print();  -->  Это лучше чем статическе методы класса, 
                         т.к. отсутствует возможность создавать экземпляры

В интерфейсам могут быть и приватные методы, но они могут использоваться только внутри
самих интерфейсов. Такие методы похожи на локальные хелперы для интерфейса.

Класс, реализующий интерфейсы с методами по умолчанию, реализует множественное
наследование какого-то примитивного ф-ционала. Это немного напоминает трейты в PHP.

Помимо методов в интерфейсе могут определяться и константы.
...
interface Stateable {
  int OPEN = 1;  -->  В классе это будет public static final int OPEN = 1;
}

Если требуется переопределение класса, и это переопределение будет использоваться 
где-то один раз, то вместо отдельного класса-наследника можно создать анонимный класс.
Выглядит он так: new Класс_Или_Интерфейс() { }.

Анонимный класс - это, можно сказать, пустой класс, унаследованный от того 
(или реализующий тот интерфейс), который указывается после new. 
Его создание происходит в момент инициализации.

Анонимные классы обычно используются как обработчики событий, т.к. их методы имеют
доступ к внешним переменным.
...
obj.doSomething(new Printable() {  -->  Создается анонимный класс, который
                                        реализует интерфейс Printable
  @Override                             
  public void print() { }  -->  Переопределение метода
});

В Java, перечисление это синтаксический сахар над классом с константами. Также это
отдельный типа данных. Как и обычные классы, они могут определять конструкторы, 
поля и методы. Также методы могут определяться и в самих константах.
...
enum Color {
  ONE, TWO, THREE,
  RED("#f00"), GREE("#0f0"), BLUE("#00f"),  -->  Вызовы конструктора Color
  SUM { public int getValue(int x, int y) { return x + y; } },

  private String code;
  Color(String code) { this.code = code; }  -->  Может быть только приватным
  public String getCode() { return code; }
}
Color.RED.getCode();       -->  Вернет "#f00"
Color.SUM.getValue(1, 2);  -->  Вернет 3

Основные методы класса Object:
* toString - выводит строковое представление объекта;
* hashCode - выводит числовой код объекта (типа Id);
* getClass - выводит класс объекта (похож на getType в C#);
* equals - сравнивает объект с другим;
* clone - клонирует объект.

MyClass.class и myObj.getClass() это по сути одно и тоже.

Обобщения (дженерики) похожи на те, что есть в C#. Обобщения не работают с примитивными
типами, но вместо них можно использовать специальные классы-обертки, например вместо
int можно использовать Integer и т.д.

Обобщенные методы и конструкторы синтаксически немного отличаются от тех, что в C#.
...
class Printer {
  <T>Printer(T value) { }  -->  value можно присвоить полю с типом String
  public <T> void print() { }
}
var printer = new Printer("Привет");
printer.<Integer>print();

Тип обобщения может быть ограничен классом или интерфейсом. Границы устанавливаются 
с помощью конструкций extends Тип_Либо_Его_Наследник или super Тип_Либо_Его_Родитель.
Границы используются для безопасности типов. В примере ниже тип T ограничивается
классом Account, либо одним из его наследников.
...
class Transaction<T extends Account> {
  private T acc;

  Transaction(T acc) { 
    this.acc = acc; 
  }

  void doSomething() {
    acc.topUp();  -->  Компилятор распознает ограниченный тип
  }
}

Можно установить сразу несколько ограничений. В примере ниже тип T может быть 
как классом Person (или его наследником), так и классом с интерфейсом Accountable.
...
class Transaction<T extends Person & Accountable> { }

Типы обобщений могут называться как угодно, но есть общепринятые правила:
* T, S, U, V - 1й, 2й, 3й, 4й типы;
* E - элемент коллекции;
* K - ключ в словаре;
* V - значение в словаре.

Вопросительный знак или по-другому подстановочный знак (wildcard), означает неизвестный
тип обобщения. В отличии от T, он позволяет не знать о том, какой тип подставлять в
момент вызова. Запись SomeClass<?> это тоже самое, что SomeClass<Object>.

Много где встречается такое определение: SomeClass<? super T>. Это означает
подстановочный знак с нижней границей (lower-bounded wildcard).
...
List<? super Integer>  -->  List<Integer>, List<Number>, List<Object>

Пустые угловые скобки означают что тип определяется по левой части:
List<Integer> list = new ArrayList<>();

В Java 16 появились рекорды (records). Это сокращенная запись DTO-классов 
(в которых есть только поля, геттеры, конструктор и методы equals/toString/hasCode).
Рекорды также напоминают data-классы из Kotlin.
...
record название (поле1, полеN) { /* тело record */ }

Пепеопределение конструтора выглядит так (если явно не задать инициализацию полей,
тогда логика просто добавится в самое начало, подобно прокси):
...
record Person(String name, int age) {
  Person { }  -->  Канонический конструктор
  Person(String name) { this(name, 23); }  -->  Другой конструктор
}

Переопределять можно и методы equals/toString/hasCode.

Рекорды не могут наследовать классы и от них нельзя наследоваться. Но они могут
реализовывать интерфейсы. В рекордах нельзя явным образом определять нестатические
поля, методы и инициализаторы.

----------------------------------------

ОБРАБОТКА ИСКЛЮЧЕНИЙ

Особенностью исключений в Java является то, что методы, которые выбрасывают исключения
но не обрабатывают их, обязаны в своем определении содержать оператор throws.
...
void doSomething() throws SomeException {
  // Где-то в методе выбрасывается исключение SomeException, но не обрабатывается.
}

Исключения, наследуемые от класса RuntimeException входят в группу непроверяемых
(unchecked exceptions). Для них оператор throws не нужен.

Список основных исключений:
* IllegalArgumentException - мусорный аргумент при вызове метода (выводить какой);
* IllegalStateException - вызов метода не уместен при текущем состоянии объекта;
* ArithmeticException - некорректная арифмитическая операция (деление на ноль и т.д.);
* UnsupportedOperationException - вызван метод, который нельзя вызывать (заглушка).

Исключения не для публичного API: 
* ArrayIndexOutOfBoundsException - при запросе элемента вне границ массива; 
* InterruptedException - выбрасывается при остановке потока;
* NullPointerException - использование пустой ссылки.

Создание своих исключений необходимо, когда нужно указать на определенные смысловые
ситуации, при которых становятся очевидны неправильные шаги в бизнесс-логике. 
Проще говоря они нужны для упрощения отладки бизнесс-логики.

Конструкцию try/catch можно использовать подобно using из C# для автоматического
освобождения ресурсов, которые не контролирует сборщик мусора. Это называется 
try с ресурсами. Такая конструкция работает с объектами, которые реализуют интерфейс
AutoCloseable и автоматически вызывает метод close, в нужный момент.
...
try (var os = new FileOutputStream("")) {  -->  Теперь нет необходимости вызывать 
  /**/                                          явно метод close
} catch (IOException ex) {
  /**/
}

----------------------------------------

КОЛЛЕКЦИИ

Чтобы объект мог перебираться циклом foreach, нужно в его классе реализовать 
базовый интерфейс всех коллекций - Iterable.

Основные классы коллекций:
* ArrayList - простой список элементов;
* HashSet - список уникальных элементов (по хеш-коду);
* HashMap - словарь, где каждый элемент это пара "ключ-значение";

Продвинутые классы коллекций:
* ArrayDeque - очередь и стэк в одном;
* LinkedList - связанный список;
* LinkedHashSet - связанный HashSet;
* TreeSet - HashSet с отсортированными элементами;
* TreeMap - HashMap с отсортированными элементами по ключу;
* PriorityQueue - очередь с отсортированными элементами.

HashSet и HashMap это тоже самое, что Set и Map в JS.
Создание коллекции с указанной емкостью улучшает производительность.

Простой список хорошо подходит, когда нужно получать элементы либо вставлять/удалять 
их с конца (т.к. реализован в виде массива), но плохо подходит когда нужно вставлять
удалять с начала или из середины (т.к. нужно сдвинуть все элементы на новую позицию 
и пересчитать длину).

Связанный список хорошо подходит, когда нужно вставлять/удалять элементы с начала 
или из середины (т.к. реализован в виде набора объектов, где у каждого есть ссылка на
предыдущий и следующий и чтобы вставить/удалить нужно просто поменять у них ссылки), 
но плохо подходит когда нужно получать элементы (т.к. нужно последовательно пройтись 
по всем объектам в наборе).

Для того чтобы коллекция знала как сортировать пользовательские объекты, класс объектов
должен реализовывать интерфейс Comparable. Если же класс не реализовывает этот
интерфейс, то можно воспользоваться медиатором Comparator.

При Comparable на входе имеется только один объект, с которым сравнивается текущий, 
а Comparator получает сразу два объекта и сравнивает их между собой.

----------------------------------------

ПОТОКИ ЧТЕНИЯ И ЗАПИСИ

Потоки бывают бинарными и символьными. Символьные потоки - это те же бинарные, 
но с более высоким уровнем абстракции.

Потоки могут работать с файлами, которые хранятся на физическом носителе, либо
обрабатывать данные из оперативной памяти. 

Потоки могут буферезироваться, это позволяет улучшить производительность, т.к.
уменьшает кол-во обращений к файловой системе.

После завершения работы с потоками, их необходимо закрывать.

Для работы с бинарными потоками используются классы InputStream/OutputStream и их
наследники, а для работы с символьными потоками - Reader/Writer, и также их наследники.

FileOutputStream/FileInputStream - создают бинарный поток для записи байтов в файл,
либо для чтения байтов из файла (т.е. данные записываются в поток, а тот, управляя
файловой системой, записывает их в файл на устройстве).

ByteArrayOutputStream/ByteArrayInputStream - создают бинарный поток для записи байтов 
в массив, либо для чтения байтов из массива. Эти потоки не нужно закрывать, т.к. они
обрабатывают данные из оперативной памяти.

BufferedOutputStream/BufferedInputStream - декораторы бинарных потоков. Создают буфер
и накапливают в нем данные до тех пор, пока он не заполнится. После чего, данные из
буфера передаются основным потокам записи/чтения. Это повышает производительность, 
т.к. уменьшает кол-во обращений к файловой системе.

PrintStream - создает поток вывода данных на консоль (System.out - объект PrintStream).
Вместо консоли, можно выводить данные в файл, или в другой заданный поток. 
Имеет схожий ф-ционал с классом PrintWriter.

DataOutputStream/DataInputStream - декораторы бинарных потоков. Позволяют записывать
данные примитивных типов и строк в бинарный поток, либо читать их оттуда.

ObjectOutputStream/ObjectInputStream - декораторы бинарных потоков. Позволяют
сереализовать объекты для записи в бинарный поток, либо десериализовать их, после того,
как они будут прочтены оттуда.

Сериализация - это преобразование объекта в двоичный формат, а десериализация - это
наоборот, преобразование объекта из двоичного формата.

Чтобы объект можно было сериализовать, его класс должен реализовывать интерфейс
Serializable. Чтобы исключить какое-то поле из сериализации, его нужно объявить вместе
с ключевым словом transient.
...
private transient int age;  -->  Поле не участвует в сериализации.

ZipOutputStream/ZipInputStream - декораторы бинарных потоков. Позволяют архивировать 
и деархивировать данные.

Архивация файлов происходит так. Берем файл и создаем для него объект ZipEntry. 
В нем будет хранится вся информация (название файла в архиве, вес файла и т.д.). 
Затем добавляем этот объект в поток архивации с одновременным добавлением туда и
двоичных данных самого файла. После чего закрываем объект ZipEntry с помощью потока 
и переходим к следующему файлу.

Деархивация происходит похожим образом. Получаем из потока объект ZipEntry.
Затем считываем оттуда двоичные данные самого файла и записываем их в новый файл.
После чего закрываем объект ZipEntry с помощью потока и переходим к следующему файлу.

FilerReader/FilerWriter - предназначены для чтения/записи строк и символов.
Имеют высокий уровень абстракции.

BufferedReader/BufferedWriter - предназначены для чтения/записи строк и символов, 
с предварительной буферизацией. Имеют высокий уровень абстракции.

Для работы с файлами предназначен класс File. Он позволяет создавать/удалять файлы 
и катологи (каталог в линуксе тоже файл), а также получать различную информацию о них.
Потоки, при работе с файловой системой, скорей всего используют именно этот класс.

Для более удобной работы с консолью существует класс Console, подобный тому что есть 
в C#. Объект этого класса доступен только когда программа запускается из терминала.

----------------------------------------

СТРОКИ

Строка - это последовательность символов, за которыми стоит объект класса String.
Соответсвенно значение по умолчанию это null;

Методы строк очень похожи на те, что имеются в JS.

Конкатенация строк происходит также как и в JS, с тем же учетом, что когда прибавляется
нестроковый тип, то он сначала преобразовывается к строке.

Перед преобразованием типа к строке, вызывается метод valueOf, а для преобразования
объектов, valueOf вызывает метод toString.

Строки нельзя сравнивать через знак равенства ==. Вместо него нужно использовать 
метод equals. А чтобы в двух строках сравнить отдельные подстроки, можно
воспользоваться методом regionMatches.

Строки являются неизменяемыми (иммутабельными), т.е. когда изменяются символы,
создается новая строка. Это ухудшает производительность. Чтобы создать изменяемую
строку нужно использовать класс StringBuffer или StringBuilder.

Эти классы практически идентичны и различаются только тем, что StringBuffer применяется
в многопоточных приложениях, а StringBuilder в однопоточных.

Методы класса String, работающие с регулярными выражениями:
* split - разбивает строку на подстроки по заданному шаблону, и возвращает их;
* matches - проверяет строку на соответсвие заданному шаблону и возвращает true/false;
* replaceAll - заменяет найденные совпадения подстрокой и возвращает измененную строку.

Для получения дополнительный возможностей в работе с регулярными выражениями, 
а также для улучшения производительности, применяются классы Pattern и Matcher. 
Первый применяется для компиляции шаблона, а второй - для нахождения соответсвий.

----------------------------------------

ЛЯМБДА-ВЫРАЖЕНИЯ

Лямбда - это сокращенная запись анонимного класса, но с некоторым ограничением. 
Она может определять реализацию только функционального интерфейса. т.е. интерфейса,
который имеет всего один метод (типа execute, handle и т.п.).
...
interface Operation { 
  int doSomething(int x, int y); 
}
Operation op = (x, y) -> x + y;  -->  Тоже, что и анонимный класс, который 
                                      реализует интерфейс Operation

У лямбды можно также типизировать параметры, но это не обязательно. 

Лямбда имеет доступ к полям класса, и может их изменять, но при этом она не может
изменять локальные переменные метода, хотя доступ к ним также имеет. Если лямбда
обращается к локальным переменным, она потребует чтобы они были final.

Кроме того, в объекте функционального интерфейса можно хранить ссылку на метод.
Получить её можно через двоеточия. Это аналогично использованию лямбд. Ссылочный метод
должен сопадать по сигнатуре с методом из функционального интерфейса.
...
Operation op = MyClass::staticMethod;   
Operation op = obj::simpleMethod;  -->  int simpleMethod(int, int)      

Ссылка на нестатический метод любого объекта выглядит так: MyClass::nonStaticMethod.
А функциональный интерфейс для неё должен обязательно принимать объект класса.
...
interface Operation {
  int doSomething(MyClass myClass);  -->  int nonStaticMethod(параметры_любые)
}

Объект функционального интерфейса может хранить ссылку даже на конструктор. В этом
случае единственный метод функционального интерфейса должен быть с такой же сигнатурой,
что и конструктор, а также он должен возвращать объект класса этого конструктора.
...
class User { User(int age) { } }
interface UserFactory { User create(int age) }
UserFactory uFactory = User::new;
User u = uFactory.create(23);

Встроенные функциональные интерфейсы:
* Consumer<T> - принимает T, но ничего не возвращает (Action);
* Predicate<T> - проверяет T на условие и возвращает true/false;
* Function<T, U> - принимает T и возвращает U (Func);
* Supplier<T> - ничего не принимает, но возвращает T (Func);
* UnaryOperator<T> - принимает T и возвращает T (Func);
* BinaryOperator<T> - принимает два T и возвращает T (Func).

----------------------------------------

МНОГОПОТОЧНОСТЬ

При старте программы, метод main запускает главный поток, который также и называется.
Он имеет приоритет 5, а всего их от 1 до 10. От этого потока порождаются все остальные
потоки. Новый поток создается при создании объекта Thread.

Если в процессоре одно ядро, то многопоточность будет реализована так: процессор будет
последовательно обрабатывать каждый поток по чуть-чуть. За счет этого будет достигаться
видимость многопоточности. Это называется виртуальная многопоточность.

Если в процессоре много ядер, то Java постарается распределить потоки по отдельности 
на каждое ядро. Только в этом случае может ускориться робота программы.

Для каждого потока создается свой отдельный стэк в памяти, куда помещаются все
локальные переменные и другие данные, связанные с его выполнением. Чем больше потоков,
тем больше памяти используется. Запуск новых потоков замеляет работы приложения.

Код потока определяется в методе run. Чтобы запустить поток, нужно вызвать метод start.
Чтобы дождаться завершения другого потока, нужно вызвать у него метод join.
...
var st = new SecondThread();  -->  Создаем второй поток
st.start();                   -->  Запускаем второй поток
st.join();                    -->  Указываем, что нужно дождаться его завершения
println("Main thread done");  -->  Вызовется после того, как завершится второй поток.

Другим вариантом создания потока является самостоятельная реализация интерфейса
Runnable (можно через лямбду) и передача runnable-объекта в конструктор Thread.
Получить текущий поток можно с помощью метода Thread.currentThread().

Чтобы завершить поток, можно вызвать метод interrupt(). В этом случае поток по прежнему
продолжит работу, но другой метод isInterrupted() будет возвращать true. Он же в свою
очередь может считаться тригером для завершения какой-то работы (возможно в цикле). 

Следует учитывать, что при перехвате исключения InterruptedException, метод
isInterrupted() снова переключается в false. Это может привести к бесконечному
зацикливанию, если обработка исключения происходит внутри цикла. Чтобы этого избежать,
нужно вызвать break из блока catch, а лучше вообще вынести обработку во внешний код.

Метод Thread.sleep усыпляет поток на заданное время (в миллисекундах). 
После вызова interrupt, это метод будет выбрасывать исключение InterruptedException.

Синхронизация потоков нужна чтобы обеспечить их слаженность, когда они обращаются 
к одному общему ресурсу (чтобы один поток не перезатирал данные, которые уже обратаны
другим потоком и т.п.). Синхронизация потоков напоминает использование метода join.

Синхронизацию можно реализовать с помощью оператора synchronized, в который передается
общий для всех потоков объект и указывается блок кода, для его обработки.
...
void run() {  -->  Вызов должен быть из потока
  synchronized(obj) {  -->  Общий объект для всех потоков (поле класса)
    /* Какая-то работа с этим объектом, например запись в него */
  }
}

Передаваемый объект блокируется одним из потоков, и пока не выполнится блок кода,
другие потоки не смогут получить к нему доступ. После этого, объект снова становится
разблокированным и доступен другим потокам. 

Можно также объявить синхронизируемый метод. Когда он вызывается из потока, его объект
блокируется этим самым потоком и также становится недоступен для других потоков. 
После выполнения метода, с объекта снимается блокировка.
...
class MyClass {
  synchronized void syncMethod() {
    /* Можно работать с обычными полями класса */ 
  }
}
...
void run() {
  lockedObjOfMyClass.syncMethod();
}

Метод wait снимает блокировку своего объекта в текущем потоке и он становится доступным
в других потоках. Проще говоря, он переводит работающий поток в состояние сна. 

Чтобы возобновить работу спящего потока, нужно из другого потока вызвать notify.
Методы wait и notify должны вызываться у одного и того же объекта.

Метод notifyAll возобновляет работу всех спящих потоков, тогда как notify возобновляет
какой-то один случайный (но зато это быстрее, чем возобновлять сразу всех спящих).

Методы wait, notify, notifyAll можно вызывать только из синхронизированного контекста.

Семафоры - это еще один способ синхронизации потоков для доступа к общему ресурсу.
Для работы с ресурсом, поток должен запросить доступ у семафора. При этом семафор имеет
ограниченное кол-во доступов. Когда поток выполнит свою работу, он должен освободить
свой доступ для других потоков. 

Если поток не имеет доступа от семаформа, то он блокируется и ждет до тех пор, 
пока не получит его.

Семафоры хорошо подходят для задач, где одновременно могут работать только ограниченное
кол-во потоков, а не все сразу.

Для обмена данными между потоками, используется класс Exchanger. 
Его метод exchange принимает буфер данных для отправки, а также задержку отправки.
...
message = exch.exchange(message)  -->  Поток получает сообщение из другого потока и в 
                                       тоже время отправляет сообщение сам

Класс Phaser позволяет выполнять потоки фазами. Пока не завершится полностью одна фаза,
потоки не смогут приступить к выполнению другой. Для завершения фазы, нужно чтобы все
ее участники подтвердили это.

Phaser удобно применять, когда нужно парралельно получать какие-то данные и вычислять
на их основе общий результат. Либо когда нужно получать какие-то данные частями и
параллельно что-то с ними делать.

В качестве альтернативы оператору synchronized можно использовать блокировщики. 
Принцип работы с ними прост: cоздаем блокировщик и в нужном месте вызываем метод lock.
После этого код блокируется для текущего потока, а другие потоки, для доступа, должны
дождаться его разблокировки. Чтобы разблокировать код, нужно вызвать метод unlock.

Стандартная реализация определена в классе ReentrantLock, но можно сделать и
собственную реализацию, с помощью интерфейса Lock.
...
void run() {
  reentrantLock.lock();  -->  Блокируем код от других потоков
  try {
    /* Какая-то работа с общими данными */
  } catch (InterruptedException ex) {
    /* При работе с потоками может появиться InterruptedException */
  } finally {
    reentrantLock.unlock();  -->  Снимаем блокировку
  }
}

В заблокированном коде можно вызывать такие методы: await, signal, signalAll. 
Они аналогичны использованию wait, notify и notifyAll соответсвенно. Эти методы
доступны в объекте Condition. Сам же сondition можно получить из блокировщика.
...
Condition condition = reentrantLock.newCondition();
while (условие) { condition.await(); }  -->  Усыпляем поток
condition.signallAll();  -->  Из другого потока возобновляем работу спящих

При работе с многопоточностью иногда можно встретить поля, помеченные как volatile.
Это что-то вроде наблюдаемых полей, т.е. после того, как значение поля изменится в
одном потоке, то его обновление автоматически произойдет и вдругих потоках...

----------------------------------------

STREAM API

Это технология для удобной работы с коллекциями, напоминающая LINQ в C#. 
Методы Stream API похожи на те, что есть у массивов в JS (map, filter, reduce и т.д.).

При работе с потоками данных, результат канала модификаций будет вычисляться в самом
конце при вызове метода, который возвращает конкретный результат, например count и др.
Это называется терминальная операция (т.е. по факту отложенное выполнение).

Потоки, к которым не применяется тирминальная операция называются трансформированными.
Они как раз и образуют тот самый канал для обработки данных (т.е. промежуточную
операцию). На этом этапе задается последовательность будущих модификаций коллекции
(сначала map, затем filter и т.д.). Это опять же напоминает то, как работает LINQ.

Для создания потоков данных испольуются классы:
* Stream<T> - для потока с элементами ссылочного типа;
* IntStream/LongStream/DoubleStream - для потока с элементами примитивного типа;

Чтобы получить поток данных из коллекции, нужно вызвать у коллекции метод stream.
...
var list = new ArrayList<String>();
Collections.addAll(list, "Hello", "my", "world");
list.stream().filter(el -> el.length() > 2).forEach(el -> println(el));

Каждая промежуточная операция возвращает новый поток с дополнительной модификацией:
...
var stream = list.stream();  -->  Создаем поток данных
stream = stream.filter(el -> el.length() > 2);  -->  Дополняем его фильтрацией
stream.forEach(el -> println(el))  -->  Выводим отфильтрованные данные

Если к потоку уже применена терминальная операция, то далее к нему уже нельзя применять
другие терминальные или промежуточные операции:
...
long count = stream.count();  -->  Терминальная операция употребляет поток
stream = stream.filter(el -> el.length() > 3);  -->  Ошибка, поток уже употреблен

Чтобы создать поток данных из массива, можно воспользоваться методом Arrays.stream.
Также для этого можно использовать методы Stream.of, IntStream.of и т.п.

Некоторые методы возвращают урезанные потоки. Например метод takeWhile похож на filter,
но отличается от него тем, что обрабатывает элементы до тех пор, пока не выполнится
переданное условие. После чего он завершает свою работу. Filter же завершает свою
работу после того, как обработает все элементы.

С помощью метода Stream.concat можно объединить несколько потоков в один.

Некоторые терминальные операции возвращают объект Optional<T>. Этот объект является
оберткой над каким-то результирующим значением. Класс Optional помогает дополнительно
обрабатывать данные. Например можно проверить не является ли значение пустым, с помощью
метода isPresent и т.д. Также в нем есть удобный метод orElse, который позволяет задать
альтернативное значение, когда основное отсутсвует и т.д. Чтобы получить значение из
обертки, нужно использовать метод get.

Чтобы преобразовать поток данных в коллекцию, нужно вызвать у него метод collect и 
в нём указать к какой именно коллекции необходимо преобразование (toList, toSet и др).
...
List<Integer> list = stream.filter(el -> el != 0).collect(Collectors.toList());

Потоки данных могут быть параллельными. В этом случае данные будут разбиваться на
небольшие куски и обрабатываться параллельно, после чего снова соединяться в единый
результат. Это может ускорить работу на многоядерных процессорах.

Параллельные потоки можно использовать только тогда, когда не важен порядок обработки
данных. Например в методе reduce данные могут обрабатываться хоть слева направо, хоть
наоборот, справа налево. Результат в обоих случаях будет одинаковый.

Чтобы сделать поток параллельным, нужно вызвать у него метод parallel.
Кроме того, параллельный поток можно получить из коллекции, вызвав parallelStream.
...
var result = stream.parallel().reduce(...);
var result2 = list.parallelStream().filter(...);

Метод forEach в параллельном потоке может выводить данные в произвольном порядке.
Для вывода данных в правильном порядке нужно использовать метод forEachOrdered.

Чтобы улучшить производительность в параллельных потоках можно вообще отключить
сохранение порядка. Это делается с помощью метода unordered.
...
list.parallelStream().sorted().unordered().forEach(...);

У массивов также существуют свои методы для параллельных операций:
* parallelPrefix - параллельный reduce;
* parallelSort - параллельная сортировка;
* parallelSetAll - параллельная инициализация;

----------------------------------------

МОДУЛИ

Модули позволяют группировать пакеты, тем самым они добавляют еще один уровень
инкапсуляции. Каждый проект может иметь только один модуль. Название модуля должно
сопадать с названием проекта.

Чтобы создать модуль, нужно в корневую папку проекта положить файл module-info.java.
Содержимое файла должно быть таким: module Название {}. После этого проект станет
модульным, а его пакеты больше не смогут импортироваться в других проектах.

Для того чтобы пакеты могли импортироваться, нужно предварительно выполнить их экспорт
из модуля: module MyModule { exports com.mypack.MyClass; }.

А чтобы один модульный проект мог импортировать пакеты другого модульного проекта,
нужно сделать между ними модульную зависимость.
...
module MyModule1 {
  requires MyModule2;  -->  Теперь MyModule1 зависит от MyModule2 
}                           и может ипортировать его пакеты 

----------------------------------------

АННОТАЦИИ И РЕФЛЕКСИЯ

Это почти тоже самое, что и атрибуты в C#. Они выполняют роль дескрипторов кода, хранят
какие-то метаданные для обработки классов/полей/методов через рефлексию.

Анотация определяется как интерфейс, с собачкой вначале. А чтобы описать ее назначение,
дополнительной используются системные аннотации @Target и @Retention.
...
@Target(value=ElementType.TYPE)
@Retention(value=RetentionPolicity.RUNTIME)
@interface BakeKind {
  String bakeName();  -->  Так определяются поля аннотации
  String other() default "hello!"  -->  Необязательное поле со значением
}
...
@BakeKind(bakeName="biscuit")
class Cookie { }

@Target указывает что именно можно пометить создаваемой аннотацией:
* TYPE - какой-то тип (обычно это класс);
* FIELD - поле класса;
* METHOD - метод класса;

@Retention указывает жизненный цикл аннотации, будет ли она доступна только во время
компиляции или также еще и во время выполнения программы.

Существуют и другие системные аннотации: 

@Override - не позволит коду скомпилироваться, если имя переопределяемого метода
написано с ошибкой.

@FunctionalInterface - не позволит коду скомпилироваться, если функциональный интерфейс
имеет более чем один метод;


НАПИСАТЬ ПРО РЕФЛЕКСИЮ !!!


----------------------------------------

РАЗНОЕ

Иногда на низком уровне, у объектов встречаются такие методы: write, flush и close.
* write - записывает что-то, в поток или буфер;
* flush - очищает буфер, и передает его содержимое в выходной поток;
* close - закрывает поток и/или освобождает занятые ресурсы. 

Оба метода equals и compareTo сравнивают значения. Разница между ними в том, что 
первый возвращает логический результат и предназначен непосредственно для сравнения, 
а второй возвращает целое число, и необходим для сравнения значений при сортировке.

Для работы с очень большими числами (подобно BigInt из JS) предусмотрены классы: 
* BigInteger - для целых чисел;
* BigDecimal - для чисел с плавающей точкой.

Чтобы правильно скомпилировать и запустить класс с пакетом, нужно выполнять эти
действия не из того каталога, в котором находится непосредственно сам файл, а оттуда,
где находятся начальная папка пакета.

Например есть файл src/com/mypack/MyClass.java, тогда:
1) Переходим в каталог src и компилируем: javac com/mypack/MyClass.java
2) Из этого же каталога вызываем: java com.mypack.MyClass 

Если внутри класса создать объект собственного типа, то из этого объекта можно будет
вызывать даже закрытые члены.
...
class MyClass {
  public MyClass() {
    var obj = new MyClass();
    obj.method();  -->  Так делать можно!
  }

  private void method() { }
}

