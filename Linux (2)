КОМАНДНАЯ СТРОКА

Для работы в командной строке, Linux предоставляет оболочку (shell). 
Оболочка - это командный интерпритатор. Наиболее популярная оболочка - bash.

Команда состоит из 3х частей: сама команда, необязательные опции (флаги) 
и аргументы. Например: ls [-l] [/usr].

Аргументы обычно обозначают объекты, к которым применяется команда. Они указываются
в конце. Например по умолчанию ls применяется к текущему каталог, но если задать
аргумент /usr, то команда применится к этому каталогу.

С пом. символа | можно состовлять цепочки команд: ls -R /usr | less.
Здесь ls -R /usr отправляет свой результат команде less.

С пом. символа > можно перенаправить результат выполнения команды, например с консоли
(по умолчан.) в файл: ls -l > file (если файл не был ранее создан, то создастся).

Для перенаправления ошибок используется символ 2>: ls -l > file 2> error.

Для получения информации о команде используется команда man: man название_команды.
Информация обычно состоит из следующих секций:

 * name - имя команды, и краткое описание;
 * synopsis - как использовать команду; отображает все доступные пар-ры;
 * description - полное описание;
 * options - список всех доступных опций;
 * see alse - список связанных команд.

Альтернативным способом получения информации о команде является её опция --help.

Оболочка bash запоминает историю ввода команд и позволяет повторно использовать
недавние команды. Навигацию по командам можно выполнить с пом. стрелок.

Многие дистрибутивы запоминают только последнии 1000 команд. Эти команды хранятся 
в файле .bash_history, в домашнем каталоге пользователя. 

Чтобы увидеть историю можно ввести в терминале history. Удалить историю можно либо 
с пом. команды history -c, либо просто очистить файл вручную.

Информационные команды:

 * uname - отображает имя хоста системы (т.е. компьютера) и информацию об ОС;

 * lsb_release - информация о LSB (Linux Standart Base), т.е. стандартная 
   базовая версия Linux;

 * hostnamectl - используется для отображения и изменения имени хоста, а также для
   просмотра настроек системы (архитектура, режим загрузки, часовой пояс и пр.);
   не требует входа в систему под root'ом;

 * date - отображает текущую дату.

---------------------

ФАЙЛЫ И КАТАЛОГИ

Корневой каталог имеет путь "/". Перечень стандартных каталогов:

 * /bin - приложения, которые можно запускать через командную строку;
   в основном хранит утилиты, например: bash, cp, cat и др.

 * /etc - конфигурационные файлы системы, например: passwd, hosts, networks и т.д.;
 * /boot - компоненты для загрузки системы, в частности, ядро (файл vmlinuz);
 
 * /sbin - системные приложения для администрирования и восстановления системы,
   например: fdisk, ifconfig, reboot и пр.

 * /usr - пользовательские приложения и данные (аналог Program Files);
 * /usr/bin - большинство пользовательских приложений;
 * /usr/src - исходные файлы open-source приложений (в основном c/cpp);
 * /usr/include - стандартные заголовочные файлы языка C;
 * /usr/lib - библиотеки приложений и устанавливаемые пакеты;
 * /usr/local - локальные приложения;
 * /usr/share - статические разделяемые данные;

 * /var - файлы данных, которые могут изменяться;
 * /var/cache - кэш приложений;
 * /var/include - стандартные заголовочные файлы языка C;
 * /var/lib - данные о состоянии системы;
 * /var/lock - заблокированные данные для отслеживания используемых ресурсов;
 * /var/log - файлы логов;
 * /var/opt - данные установленных пакетов;
 * /var/spool - выполняемые задачи (кроны и пр.);
 * /var/tmp - временные файлы, удаляемые после новой загрузки системы;

 * /dev - файлы устройств; в Linux все оборудование, с которым можно работать,
   соответсвует файлу в системе; если надо обратиться к hardware, то следует 
   обратиться к соответсвующему файлу (с правами root).

 * /home - домашний каталог пользователя;

 * /lib - общие библиотеки приложений, а также драйвера, используемые ядром;
 * /media - каталог для монтирования съемных устройств, например USB;

 * /mmt - тоже самое что и предыдущий, только на старых системах; 
   иногда используется в целях тестирования;

 * /opt - доп. пользовательские приложения; в отличие от /usr обычно помещают более
   крумные файлы, однако единого мнения нет, что помещать в /usr, а что в /opt.

 * /proc - файлы процессов, информация о ядре и компьютере;
 * /root - домашний каталог суперпользователя (системного администратора);

 * /run - используется для конфигурации во время выполнения; файлы удаляются 
   автоматически, когда становятся не нужны;

 * /srv - файлы некоторых важных сервисов, например здесь может хранится файловая
   структура своего веб-сервера и ftp-сервера.

 * /sys - похож на /proc, но хранит свою информацию на жестком диске, поэтому она
   доступна после перезагрузки; здесь информация больше связана с оборудованием,
   тогда как в /proc - с ядром.

 * /tmp - временные файлы, автоматически удаляемые при перезагрузке;

Команды для работы с каталогами:
 
 * pwd - выводит полный путь к текущему каталогу;

 * cd - позволяет перемещаться по каталогам; абсолютные путь задается через косую 
   черту перед именем каталога, иначе команда попытается найти относительный каталог;
   для переходу к домашнему каталогу применяется символ ~ (алиас для /home/username);
   для перехода на один/два уровня вверх применятеся путь .., ../../ (и т.д.);

 * mkdir - создает каталог; опция -p позволяет создать папку вместе с родительской
   (если та отсутствует): mkdir folder, mkdir -p ~/folder1/folder2

 * rmdir - удаляет пустой каталог: rmdir folder; если в каталоге есть файлы или
   подкаталоги, то применяется команда rm -r или -rf: rm -r folder

Команда ls отображает список файлов и папок в заданном каталоге.
Команда ls * выводит также содержимое подкаталогов.

Основные опции ls:
 -R - рекурсивно выводит содержимое подкаталогов (указывается вместо *);
 -d - выводит только каталоги. 
 -s - выводит файлы с их размером;
 -S - файлы, отсортированные по размеру;
 -t - файлы, отсортированные по времени доступа;

 -l - файлы и каталоги с их свойствами (права, владелец, размер и пр.); права файла
 имеет след. структуру drwxrwxr-x; самый первый символ указ. на тип файла, d обознач.
 каталог, l - символьную ссылку, а дефис - файл; далее идут 9 знаков разрешений;

 -a - выводит скрытые файлы.

При выводе списка файлов, вместо каталога можно задать шаблон с рег. выр-ем, 
который определит конкертные файлы для вывода, например:

 ls /project/*.min.js  -->  выберет все файлы c окончанием .min.js
 ls /project/[abc]*    -->  все файлы и папки, кот. начинаются на a, b или c

Команды для работы с файлами:

 * touch - создаёт файл: touch hello.txt
 * rm - удаляет файл: rm hello.txt; опция -r удаляет также и каталог;

 * cp - копирует файл: cp /etc/hello.txt /usr/hello.txt, cp hello.txt /folder

   (во втором примере важно чтобы folder уже существовал, иначе будет создан 
   текстовый файл folder с содержимым hello.txt); 

   опция -r позволяет копировать каталог: cp -r folder1 folder2 
   (folder2 создается автоматически);

   символ * копирует все файлы из текущего каталога: cp * /usr, cp .* /usr 
   (во втором примере копируются все скрытые файлы);

   другие опции:
    -a - копирует также свойства файлов;
    -b - создает резервные копии перед копированием;
    -f - принудительное копирование (когда файл запрещено копир. в место назначения);
    -i - запрашивает перезапись, если файл уже существует;
    -u - копируется только если целевой файл старше исходного файла, 
    или если целевой файл не существует;

 * mv - перемещает файл/каталог, а также переименовывает его: 
   mv hello.txt /folder (folder должен существовать), mv hello.txt world.txt;

 * wc - выводит кол-во строк, слов и символов в файле.

Команда ln -s создает символьную ссылку файла (ярлык): ln -s hello.txt /usr/hello
(в каталоге usr создается ссылка hello на файл hello.txt)

Команда find применяется для поиска файлов и каталогов: find /usr -name "*.txt"
(сначала указывается папка, затем опция критерия, и шаблон поиска)

Основные опции find:

 -amin N - находит все файлы, к которым последний раз обращались менее 
  N-минут назад, например: find -amin 5;

 -executable - находит все исполняемые файлы;
 -group NAME - все файлы, владельцем которых является пользователь с логином NAME;
 -mmin N - все файлы, которые последний раз были изменены менее N-минут назад;
 -newer FILE - все файлы новее, чем файл FILE;
 -nogroup/nouser - все файлы, у которых нет группы или владельца;
 -perm MODE - все файлы, у которых установлен режим разрешений mode;

 -size N - находит все файлы размера n (либо больше/меньше); к N также применяются
 символы K, M и G для обозначения килобайтов, мегабайтов и гигабайтов соответсвенно,
 например: find /usr -size +2G (все файлы более 2 гиг);

 -type T - находит файлы по типу; тип d - это каталог, а f - файл.

Команда whereis применяется для поиска местоположений бинарный файлов, исходных файлов,
а также файлов команд, например: whereis gcc найдет местоположение команды gcc.

Команда mount применяется для ручного монтирования устройства в файловую систему. 
(в Linux, монтируемые устройства называются файлововыми системами).

Эта команда принимает два аргумента: монтируемое устройство и место монтирования. 
В качестве монтируемого устройства выступает его название (например, название диска).
В качестве места, куда оно монтируется, выступает каталог /media.

 mount /dev/phone /media/username/folder  -->  теперь можно перейти в folder
                                               и посмотреть содержимое устройства
Основные опции mount:
 -t - тип файловой системы (ext4, vfat, ntfs);
 -r - монтирует устройство только для чтения (по умолчанию -rw);

При запуске компьютера некоторые файловые системы монтируются автоматически. 
Для этого используется файл /etc/fstab. Он содержит список всех автоматических
подключений. Некоторым файловым системам можно убрать автомонтирование.

В Linux, перед отсоединением устройства от компьютера нужно сначала отключить его.
Отключение устройства гарантирует, что все данные, которые находятся в кэше или еще 
не были записаны, запишутся в файловую систему. 

Для отключения устройства используется команда: unmount /dev/sda1.

Но иногда она может выдать сообщение, что устройство занято открытым файлом, 
а отключение может привести к потере данных. В этом случае для завершения процессов,
связанных с устройством, можно использовать команду: fuser -kv /dev/sda1.

Команда mount без аргументов выводит информацию обо всех смонтированных устройствах.
Команда df -h показывает более читабельную информацию об устройствах, чем mount.
Команда lsblk отображает устройства, доступные в текущий момент на компьютере.

Устройства, которые называются как /dev/sd[x] представляют жесткие SATA-диски 
и USB-девайсы. Основными элементами жетского диска являются разделы (участки диска).

Управлять дисками и разделами можно с пом. таких утилит, как fdisk и gdisk.

--------------------

ТЕКСТОВЫЕ КОМАНДЫ

Команды для вывода содержимого файлов:

 * cat - выводит содержимое файла: cat file.txt;
 * tac - тоже, что и cat, но отображает содержимое в обратном порядке;
 * head - отображает первые строки файла;
 * tail - отображает последние строки файла;
 * less - открывает файл в спец. окружении, напоминающем редактор vi;
 * more - тоже, что и less, только с меньшими возможностями.

Эти команды можно комбинировать между собой для вывода более конкретный результата:

 head -n 2 file.txt | tail -n 1  -->  сначала, с пом. head, будут выбраны первые 
                                      две строки, после этого они передадуться в tail 
                                      и из них выберется одна последняя

Результат других команд на консоли - это тоже текст и его также можно 
обрабатывать с помощью текстовых команд: 

 ls -l | tail -n 2  -->  последние 2 строки из списка файлов и каталогов

Команда tr преобразовывает или удаляет символы из файла, например: 
cat file.txt | tr a-z A-Z  -->  переведет символы из дипазона a-z в верхний регистр
cat file.txt | tr a-z A-Z > file2.txt  -->  тоже самое, но результат запишет в файл

Команда sort используется для сортировки: cat file.txt | sort 
Для сортировки чисел нужно добавить флаг: cat nums.txt | sort -n
Отсортировать результат команды: ls | sort

Команда cut позволяет получить из (структурированного!) файла кусок информации.

Основные опции cut:
 -d - разделитель в строке (структурированного текста);
 -f N - номера полей для вывода (которые разделены через -d);

Вывод имен пользователей из файла, содержащего следующий текст:
 Tom:39:Microsoft        
 Bob:43:Google           cut -d : -f 1 file.txt  -->  Tom Bob Sam Alice Kate
 Sam:28:Jetbrains        (опция -d указывает что разделитель - двоеточие,
 Alice:34:Oracle          а -f, что надо получить первое поле)
 Kate:25:Google           

Вывод первого и третьего полей: cut -d : -f 1,3 file.txt  -->  Tom:Microsoft
Вывод с первого по второе поле: cut -d : -f 1-2 file.txt  -->  Tom:39

Вывод первых 3х имен, отсортированных по алфавиту:
 cat file.txt | cut -d : -f 1 | sort | head -3  -->  Alice Bob Kate

Команда grep выполняет поиск в файле с использованием регулярного выражения.
Она имеет следующий формат: grep [опции] шаблон file.

 grep "127.0." /etc/hosts  -->  найдет строки, содержащие данный префикс
 grep "T[ou]m" file.txt    -->  найдет строки, которые содержат Tom или Tum
 ls /home/username | grep "Do"  -->  Documents Downloads
 
Команда awk выполняет заданное действие на основе регулярного выражения.
Она имеет следующий формат: awk '/pattern/{action}' file.

Действие заключается в фигурные скобки. А сам шаблон лучше помещать в одинарные
кавычки, чтобы оболочка не могла интерпритировать рег. выр-е.

 awk -F : '/Tom/{print $3}' file.txt  -->  выведет 3 поле (с пом. встроенной в awk
                                    команды print) для всех строк, где упоминается Tom

 awk -F : '$2 > 30 {print $1}' file.txt  -->  выведет пользователей у которых возраст
                                          больше 30 (awk доступны операторы сравнения)
---------------------

РАБОТА С АРХИВАМИ

Команда gzip (gnu zip) используются для сжатия и распаковки файлов.
Она имеет следующий формат: gzip [опции] file1 file2 fileN.
Помимо файлов команде можно передать и каталог.

По умолчанию, при архивации, оригинальный файл (или несколько файлов) удаляется, 
а вместо него создаёт новый файл с доп. расширением .gz. При распаковке 
удаляется файл архива.

Чтобы файл не удалялся, используется опция -k: gzip -k book.pdf  -->  book.pdf.gz

Другие опции gzip:
 -d - распаковывает архив;
 -l - выводит список заархивированных файлов;
 -r - рекурсивно архивирует содержимое каталогов;
 -1 - применяет быстрое архивирование (в ущерб размеру);
 -9 - применяет лучшее архивирование (в ущерб скорость);

Файл можно распаковать и с помощью команды gunzip (тоже использует опцию -k).

Команда xz также применяется для архивации данных. Она использует алгоритм с высокой
степенью сжатия и низким использованием памяти. Используется для сжатия больших файлов
(в основном в системе Linux для сжатия ядра) а также для сжатия и распаковки на лету.

 xy -v book.pdf (опция -v выводит подробную сводку операции) 
 xy -d -v book.pdf.xz

При архивации сразу нескольких файлов, для каждого из них будут созданы отдельные
архивы, что неудобно. Команда tar позволяет объединить несколько файлов в один архив.
Она имеет следующий формат: tar [опции] имя_архива file1 file2 fileN

Основные опции tar:
 -c - создает архив;
 -d - сравнивает архивы;
 -r - добавляет файлы в конец архива;
 -t - выводит содержимое архива;
 -u - обновляет только те файлы, кот. новее одноименных файлов в архиве;
 -x - извлекает файлы из архива;
 -f NAME - устанавливает имя для архива;
 -v - выводит подробную сводку операции;
 --delete - удаляет содержимое архива;
 --overwrite - перезаписывает файлы при извлечении;
 --overwrite-dir - перезаписывает каталоги при извлечении;
 --remove-files - удаляет файлы при добавлении в архив.

Примеры архивации и распаковки: 
 tar -cvf archive.tar hello.txt image.png book.pdf
 tar -cvf home.tar /home
 tar -xvf archive.tar (распаковка)

Создание архива объединенияет нескольких файлов в один пакет, но не сжимает их. 
Для сжатия, команде tar нужно передать опцию -z (gzip) или -j (bzip2).

 tar -czvf archive.tar.gz hello.txt image.png book.pdf

Архивные файлы сохраняют свои пути при распаковке. Например, если при архивации указать
путь /home/username/Documents/file.txt, то при распаковке, файл туда же и выгрузится.

Опция -С (большая), при архивации, позволяет включить в архив только относительные 
пути файлов и каталогов: tar -cvf archive.tar -C ~/Documents/test .

Точка указывает, что при распаковке все файлы архива поместятся в текущую папку. 
Вместо точки можно указать произвольный путь. Это будут подпапки в текущем каталоге.

При распаковке тоже можно указать опцию -C. В этом случае файлы будут распакованы в
указанный каталог, а не текущую папку: tar -xvf archive.tar -C test(copy).

Для архивации, сжатия и распаковки zip-файлов используются команды zip и unzip.
Опция -r рекурсивно архивирует содержимое папок.

 zip myfiles.zip book.pdf image.png
 unzip myfiles.zip

------------------

ПОЛЬЗОВАТЕЛИ И ГРУППЫ

Учетная запись пользователя - это объект, который создается в системе Linux для
предоставления разрешений, позволяющих выполнять определенные задачи.

Учетные записи создаются как для людей, которым необходим доступ к системе, так и для
служб, которым нужен доступ к определенным файлам или ресурсам (демоны).

Пользователи Linux обладают рядом свойств. Эти св-ва хранятся в файлах /etc/passwd 
и /etc/shadow. В частности, это:

 * Username - имя/логин пользователя; по умолчанию в системе есть пользователи, кот.
   предназначены для системных задач и служб; их не следует изменять или удалять;

 * Password - пароль пользователя; хранится в /etc/shadow (в зашифрованном виде);

 * UID - идентификатор пользователя; числа до 1000 обычно принадлежат службам, 
   а после - людям; идентификатор 0 зарезервирован для пользователя root;

 * GID - идетификатор группы пользователя; в Linux все пользователи должны быть членами
   хотя бы одной группы (основной); помимо основной группы, пользователи могут быть
   членами и вторичных групп; параметры основной группы хранятся в /etc/passwd, 
   а вторичных - в /etc/group.

 * GECOS - комментарий, содержащий описание учетной записи (необязателен);

 * Домашний каталог - каталог пользователя, в котором храняется его файлы и конфиги
   (которые применяются конкретно к нему);

 * Оболочка по умолчанию - то, через что пользователь входит в систему 
   (нужна не всем пользователям).

Для выполнения действий в системе, связанных с администрированием, нужно чтобы их
команды запускались через sudo, например sudo apt update (перед выполнением система
потребует ввести пароль). 

Права пользователей и групп записаны в файле /etc/sudoers.
Подробное описание этого файла здесь https://metanit.com/os/linux/5.1.php

Команда useradd применяетя для создания учетной записи нового пользователя:
 sudo useradd [опции] username

Оснонвые опции useradd:
 -b BASE_DIR - устанавливает BASE_DIR для домашнего каталога новой учетки;
 -d HOME_DIR - устанавливает HOME_DIR в качестве домашнего каталога;
 -p ЗАШИФРОВАННЫЙ_ПАРОЛЬ - пароль новой учетки; 
 -g - имя или идентификатор основной группы новой учетки;
 -m - создает учетку вместе с домашним каталогом;
 -r - создает системную учетную запись;
 -s SHELL - задает оболочку shell для логина новой учетки;
 -u UID - идентификатор пользоваля новой учетки;
 -U - создает группу с тем же имененм, что и у пользователя;
 -G ГРУППЫ - задает список доп. групп для новой учетки.

Также пользователя можно создать, отредактировав базу данных пользователей напрямую. 
Она хранится в двух файлах: /etc/passwd и /etc/shadow (поля разделены двоеточием)

Эти файлы лучше изменять с пом. команды vipw т.к. она проверяет их согласованность 
после изменения, а также записывает изменения во временный файл, что предотвращает 
блокировки, вызваннные одновременным доступом к файлу разными пользователями.

Команда usermod изменяет уже созданную учетную запись: usermod [опции] username.
Также она позволяет добавлять пользователей в группу или удалять их оттуда.

Оснонвые опции usermod:
 -m - перемещает содержимое домашнего каталога (используется только с -d);
 -a - добаляет пользователя в доп. группы, указанные в -G, не удаляя из других групп;
 -G ГРУППЫ - устанавливает список дополнительных групп;
 -L - блокировка пользователя;
 -U - разблокировка пользователя.

Команда userdel удаляет пользователя: userdel [опции] username.

Оснонвые опции userdel: 
 -f - принудительное выполение, которое в ином случае не выполнилось бы
  (например удалить пользователя вошедшего в систему);

 -r - удаляет пользователя вместе с домашним каталогом.

Некоторые примеры этих команд:

 sudo useradd -m superuser1

 sudo usermod -aG users superuser1  -->  доб. пользователя superuser1 в группу users
 sudo usermod -d /home/newdir superuser1  -->  изменение домашнего каталога
 sudo usermod -L superuser1

 sudo userdel -r superuser1

Команда id позволяет получить информацию о пользователе. Ей передается логин и пароль.
Если логин не переда, то выведется информация о текущем пользователе.

 id root  -->  данные о пользователе root

Команда users выводит список всех залогиненых пользователях. Также это можно сделать 
с пом. команды loginctl, которая отбрасывает некоторую дублируемую информацию.

Чтобы получить более детальную информацию о пользователях, используется команда who.
Чтобы посмотреть, что сейчас делают пользователи, используется команда w.

Команда passwd применяется для установки пароля: passwd [опции] username.
Если не указ. username, то пароль будет устанавливаться для текущего пользователя.

С пом. этой команды пользователи могут изменять собственные пароли, а администраторы - 
пароли других пользователей. Также с пом. неё можно задавать срок действия пароля.

Основные опции passwd:
 -d - удаляет пароль для указанной учетной записи;
 -k - меняет пароль только если его срок действия истек;
 -l - блокирует пароль указанной учетки;
 -u - разблориует пароль указанной учетки;
 -S - показывает статус пароля для указанной учетки;
 -n MIN_DAYS - минимальное кол-во дней до смены пароля;
 -x - устанавливает максимально кол-во дней до смены пароля;

 -e - принудительно делает пароль истекшим 
  (при след. логине пользователь обязан поменять пароль);

 -i INACTIVE - автоматич. прекращает срок действия учетки, если она 
  не использовалась в течении заданного периода.

Пример удаления пароля: sudo passwd -d superuser1.

Для настройки политики качества паролей применяется файл /etc/security/pwquality.conf.
Этот файл определяет правила и настройки, которые контролируют надежность паролей
(с пом. него команда passwd выводит доп. инфу о надежности пароля и пр.).

Команда change применяется для изменения политики устаревания и срока действия 
пароля пользователя: change [опции] username.

Основные опции change:
 -d LAST_DAY - изменить дату последней смены пароля;
 -E EXPIRE_DATE - назначить дату истечения срока действия учетки;
 -l - показывает информацию об устаревании учетки;
 -m MIN_DAYS - минимальное кол-во дней до смены пароля;
 -M - максимальное кол-во дней до смены пароля; 

 -i INACTIVE - автоматич. прекращает срок действия учетки, если она 
  не использовалась в течении заданного периода.

Примеры использования change:
 sudo change -l superuser1
 sudo change -d 2024-12-1 superuser1
 sudo change -E 2024-12-31 superuser1

Команда pwck проверяет согласованность /etc/passwd, /etc/shadow и /etc/group.
Например проверим файл /etc/passwd: sudo pwck /etc/passwd.

Цель команды - убедиться, что учетки пользователей и группы, перечисленные в этих 
файлах действительны, а также обнаружить любые несоответствия между ними. Это помогает 
выявить и исправить ошибки, которые могут возникнуть из-за ручного редактирования.

Пользователь может быть членом разных групп. У пользователя есь как минимум одна - 
основная группа. Если у пользователя нет основной группы, он не сможет войти в систему.
При создании пользователя ему в качестве основной назначается одноименная группа.

Отличие между основной и дополнительной группой заключается в том, что основная 
автоматически становится группой-владельцем любого нового файла, созд. пользователем.

Идентификатор основной группы (GID) хранится в четвертом поле файла /etc/passwd
 superuser1:x:1001:1001::/home/superuser1:/bin/sh

Команда groups позволяет получить все группы указанного пользователя.
Команда groupadd добавляет новую группу в систему: groupadd [опции] groupname.

Основные опции groupadd:
 -g GID - устанавливает идентификатор для новой группы;
 -p ПАРОЛЬ - применяет пароль для новой группы;
 -U ПОЛЬЗОВАТЕЛИ - задает список членов этой группы;

Всесозданные группы хранятся в файле /etc/group. Каждая строка в файле описывает 
определенную группу и состоит из четырех полей, разделенных двоеточием:

 * первое поле - имя группы;
 * второе - пароль группы (знак ! означает, что для этой группы пароль не разрешен)
 * третье - уникальный идентификатор группы - GID;
 * четвертое - имена членов группы.

Команда groupmod изменяет группу: groupmod [опции] groupname.

Основные опции groupmod:
 -g GID - изменить идентификатор группы;
 -n ГРУППА - изменяет имя группы;
 -p ПАРОЛЬ - изменяет пароль группы;

 -a - добавляет пользователей, упомянутых опцией -U, в группу, 
  не удаляя уже имеющихся участников;

 -U ПОЛЬЗОВАТЕЛИ - список членов этой группы;

Команда groupdel удаляет группу: groupdel [опции] groupname. Опция -f позволяет 
принудительно удалить группу, даже если это основная группа пользователя.

Команда grpck, подобно pwck, проверяет целостность групп: sudo grpck -r /etc/passwd.  

В Linux для каждого файла и каталога устанавливаются разрешения (права), которые 
используются для разграничения доступа. Разрешения указывают, кто может производить 
чтение или запись файлов, а также выполнять исполняемые программы.

Разрешение состоит из 3х битов: [read][write][execute].

Первый бит указывает можно ли окрыть файл, либо можно ли получить содержимое каталога.
Второй бит указывает можно ли изменить содержимое файла, либо можно ли создавать 
и удалять файлы в каталоге. Третий бит указывает можно ли выполнить файл, 
либо можно ли перейти к каталогу (например с пом. команды cd).

Разрешение указывается тремя частями:
 * разрешение для пользователя-владельца;
 * разрешение для группы-владельца;
 * разрешение для остальных пользователей.

Сначала система проверяет, является ли пользователь владельцем файла. Если да, то он 
получает разрешения для пользователя-владельца. Если нет, то система проверяет, 
является ли пользователь членом группы-владельца (группа файла). Если да, то он 
получает разрешения для группы владельца. Иначе пользователь получает 
разрешения для остальных пользователей.

Пример разрешения: 100 100 100 (файл доступен только для чтения: 
пользователю, группе и всем остальных).

При установке разрешений применяются десятичный цифры, т.е. предыдущий 
вариант можно задать как 444.

Вместо битов часто применяются символьные маркеры. Если бит установлен то записываются 
r, w, x, в нужных позициях. Если бит остутствует то применяется дефис. 
Например разрешение 100 отображается как r--, а 111 как rwx.

Т.о. разрешение 100 100 100 принимает вид r--r--r--, а 111 111 111 - rwxrwxrwx.

Команда chmod используется для установки разрешений файлу или каталогу:
 chmod [опции] разрешения файл/каталог

Например: chmod 700 ~/Documents/test  -->  каталог доступен только 
                                           для пользователя-владельца.

Если каталог имеет содержимое, то по умолчанию оно не получит указанные разрешения.
Чтобы рекурсивно изменить права доступа ко всем вложенным файлам и каталогам, 
применяется флаг -R.

Также для установки разрешений можно применять относительный режим:

 chmod u=rwx,g=rwx,o=- ~/Documents/test  -->  u - это пользователь-владелец,
                                              g - группа-владелец, o - все остальные

При изменении разрешений в относительном режиме можно добавить или удалить 
резрешение сразу всем частям: chmod +x myfile.

Также доступны и более сложные команды:
 chmod g+w,o-r myfile  -->  группе-владельцу добавится право на запись, 
                            а у всех остальных удалится право на чтение 

Команда chown изменяет владельца и группу файла или каталога:
 sudo chown username:groupname ~/Documents/test

Команда chgrp позволяет сменить группу для каталога, не затрагивая владельца.
Как и в случае с chmod, эти команды можно применять рекурсивно с помощью флага -R.

Пользователь, создавший файл, автоматически становится пользователем-владельцем, 
а его основная группа становится группой-владельцем.

Некоторые разрешения в конце содержат символ t. Это т.н. sticky bit: drwxrwxrwt.
Он используется для защиты файлов от случайного удаления, в среде, где файлы могут 
создавать несколько пользователей (в одном каталоге). Обычно он применяется
в как разрешение по умолчанию для каталога /tmp.

------------------

ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ

Когда пользователь входит в систему, используется конфигурация, заданная в /etc/profile.
Этот файл определяет настройки оболочки для всех пользователей при входе в систему.
Он также может включать команды, которые необходимо выполнить при вервом входе.

Кроме /etc/profile, в системе также имеется файл .profile, который создается
в домашнем каталоге пользователя и который определяет настройки только для текущего
пользователя. Этот файл выполняется последним, поэтому в случае конфликта настроек
последнее действие всегда за ним.

Кроме того, когда пользователь открывает окно терминала, применяется еще один файл 
конфигурации - /etc/bashrc, а также его версия для конкретного пользователя - ~/.bashrc. 

Во многих дистрибутивах /etc/profile включает в себя исходный код /etc/bashrc.
Поэтому если необходимо, чтобы при входе в систему и при запуске терминала применялись 
какие-то натройки, то их можно определить именно в bashrc-файлах.

После внесения изменений в эти файлы их новые настройки надо активировать.
Для этого используется команда source или ".": source ~/.bashrc либо . ~/.bashrch

Переменная окружения - это некоторое значение, используемое оболочкой.
Системные и пользовательские переменные доступны с момента загрузки системы.

Команда env используется для получения всех переменных окружения.

Источником новых переменных для всех пользователей явялется файл /etc/profile.
Соответсвенно если переменная нужна только для текущего пользователя, 
то она записывается в .profile.

Некоторые дистрибутивы хранят все переменные (и настройки оболочки) только в bashrc.
Для установки новой переменной, необходимо записать её в конце файла.

Команда echo используется для вывода значения переменной. 
Имя переменной должно предваряться символом "$": echo $MY_CUSTOM_VAR.

С помощью echo можно и установить переменную: echo HELLO=Hello_World >> ~/.bashrc

------------------

УПРАВЛЕНИЕ ПРОЦЕССАМИ

При запуске Linux сначала запускается ядро. Ядро запускает первый процесс - systemd.
Этот процесс отвечает за все остальные процессы. Каждый процесс запускает свои дочерние 
процессы и так образуется дерево, которое можно просмотреть с пом. команды pstree.

Команда ps используется для мониторинга процессов. 
Обычно она вызывается в комбинации с опциями "aux" либо с флагом -ef.

Опция "a" обеспечивает отображение всех процессов, "u" предоставляет расширенную 
информацию об использовании, а "x" показывает с какого TTY и каким 
пользователем запускается процесс.

Выводимые столбцы "aux":

 * USER - имя пользователя, запустившего процесс;
 * PID - идентификатор процесса;
 * %CPU - процент процессорного времени, использ. процессом с момента запуска;
 * %MEM - процент памяти, используемый процессом в данный момент;
 * VSZ - общий объем памяти, затребованный процессом;
 * RSS - общий объем памяти, используемой процессом в данный момент;

 * TTY - терминал, с которого был запущен процесс (знак вопроса указывает 
   на процесс демона, который не связан ни с каким TTY);

 * STAT - текущее состояние процесса;
 * START - время запуска процесса;
 * TIME - общее кол-во системного времени, использ. процессом с момента запуска;

 * COMMAND - команда, которая использовалась для запуска процесса (если имя заключено 
   в квадратные скобки, процесс запускается не в терминале, а является потоком ядра). 

Выводимые столбцы -ef:
 UID - имя пользователя, запустившего процесс;
 PID - идентификатор процесса;
 PPID - идентификатор родительского процесса;
 C - аналогично %CPU;
 STIME - аналогично START;
 
Эту команду можно сочетать с командами обработки текста:
 ps aux | grep chrome  -->  все процессы, связанные с Google Chrome

Команда top предоставляет сводку по наиболее активным процессам.
Она автоматически обновляет сводку каждые 5 минут.

Верхние 5 строчек показывают, что делает система:

1) текущее время; время работы системы; кол-во пользователей, подключен. к системе; 
числа показывающие, насколько загружен компьютер относительно кол-ва процессов/ядер 
компьютера, за минуту, последние 5 минут и последние 15 минут соответственно;

2) общее кол-во задач; задачи, кот. активно обслуживались во время последнего цикла опроса; 
задачи, кот. не были активны в последнем цикле опроса; задачи, для кот. родительский процесс 
больше недоступен и, следовательно, их нельзя остановить или управлять ими (зомби);

3) Эта строка показывает информацию об использовании процессора. 
Её информация может дать представление о том, что именно делает компьютер: 

 * us - объем нагрузки пользовательских процессов (без root и не без прямого доступа к ядру);
 * sy - объем нагрузки системных процессов (запущенные с правами root);
 * ni - процессы, приоритет кот. был настроен с пом. команды nice;
 * id - активность цикла ожиданий (процент бездействия в системе);

 * wa - кол-во времени, в течен. которого система ожидала выполнения операций IO; 
   если значение высокое, то на компьютере много задач, связанных с вводом-выводом и что 
   хранилище не может эффективно справиться с ними (среднее значение выше 30% может указывать 
   на то, что канал IO не работает должным образом);

 * hi - кол-во времени, которое компьютер потратил на обработку аппаратных прерываний 
  (должно быть низким, иначе это указ. на то, что использ. плохо функционирующие драйверы);

 * si - кол-во времени, которое система потратила на обработку программных прерываний;
 * st - кол-во времени, которое было украдено у процессора виртуальными машинами.

4) Показатели использования памяти:
 * total - общий объем памяти в мегабайтах (в виде установленной оперативной памяти);
 * free - объем памяти, который в данный момент ни для чего не используется;
 * used - объем памяти, использ. в текущий момент программами и службами;
 * buff/cache - объем памяти, использ. для кеширования запросов на чтение и запись.

5) Аналогичные показатели, толька для swap'а.

В нижней части приведена информация о процессах (некоторые столбцы описаны выше):

 * PR - приоритет процесса; процессы с более высоким приоритетом обслуживаются раньше 
  (выражаются меньшим числом); некоторые процессы имеют приоритет RT (реального времени), 
   что означает, что они могут получать доступ к системным ресурсам в любое время;

 * NI - указывает, какой из процесов с одинаковыми приоритетами имеет больший приоритет;

 * VIRT - зарезервированная память процесса (все процессы могут резервировать вирутальную 
   память из общего адресного пространства в 32 ТБ);

 * RES - резидентная память (та, которая выделена процессу и которая 
   в настоящее время активно используется);

 * SHARE - библиотеки, используемые процессом;
 * S - тоже, что и STAT;

Если надо отобразить доп. столбцы, то нужно нажать F.
С пом. клавиш Влево-Вправо и Enter можно переключить включение столбца в сводку.
Для выхода из сводки процессов нужно нажать Q.

Основные опции top:
 -d SECS - устанавливает интервал обновления;
 -o FIELD - сортирует по полю;
 -p PIDLIST - мониторинг только указанных процессов;
 -U USER - фильтрует процессы по пользователю.

Команда top не выводит информацию о том, какие из процессов нагружают жесткий диск. 
Для этого есть другая команда - iotop (устанавливается отдельно).

Команда pgrep позволяет найти идентификатор процесса и некоторую доп. информацию 
по определенному шаблону: pgrep [опции] шаблон.

Процесс должен соответствовать шаблону, а опции указывают, как интерпритир. этот шаблон.

Основные опции pgrep:
 -l - выводит список идентификаторов и имя команды;
 -a - список идентификаторов и полное имя команды;
 -v - ищет все процессы, которые не соответствуют шаблону;
 -c - кол-во процессов, которые соответствуют шаблону;
 -f - использует полное имя процесса;
 -i - не учитывает регистр шаблона;
 -n - выбирает наиболее новые процессы;
 -o - выбирает наиболее старые процессы;
 -O SECONDS - выбирает процессы, которые запушены как минимум SECONDS секунда назад;
 -P PPID - выбирает только дочерние процессы, процесса с идентификатором PPID;
 -u ID - выбирает процессы по определенному пользователю;
 -x - устанавливает точное соответствие имени команды;

Примеры использования pgrep:

 pgrep chrome  -->  идентификаторы всех процессов, кот. запускаются командой chrome
                    (т.е. все процессы браузера Google Chrome)

 pgrep *gnome*  -->  идентификаторы всех процессов, у котор. команда содежит "gnome"
                     (звездочка - это произвольное кол-во любых символов)

 pgrep -a *gnome*  -->  тоже самое, только с полным именен команды
 pgrep -l -u username  -->  выбор процессов по пользователю
 
Идентификаторы процессов по имени команды можно получить и с помощью pidof.

Для завершения процесса можно использовать след. команды: kill, pkill и killall.
При использовании одной из этих команд можно также отправить процессу определенный сигнал.
Всего доступно 32 сигнала, 4 из которых являются общими.

Список общих сигналов (в скобках указаны их номера):

 * SIGHUP (1) - используется при изменении файла конфигурации; 
   позволяет процессу применить новые настройки конфигурации;

 * SIGKILL (9) - принудительно завершает процесс; используется только если процесс 
   не останавливается после отправки ему сигнала 15 (т.к. есть риск потери 
   несохраненных данных из открытых файлов);

 * SIGTERM (15) - запрашивает завершение процесса; процесс может это игнорировать;
 * SIGUSR1 (30) - посылает определенным пользователям сигнал.

Команда kill самая простая. Записывается она так: kill [-s signame | -n signum] PID

 kill 10848  -->  убить процесс под заданным PID
 kill 10848 3822  -->  убить сразу несколько процессов

Команда killall позволяет более точно указывать процессы, кот. надо завершить:
 killall -r chrome_  -->  завершить процессы, имена кот. имеют "chrome_"

Основные опции killall:
 -I - игнорирует регистр имени процессов;
 -r - позволяет указать рег. выр-е, которому должны соотв. процессы;
 -u - позволяет указать пользователя, процессы которого будут завершены.

Команда pkill завершает процесс на основании его имени или атрибутов.
 pkill chrome  -->  завершить все процессы браузера

Основные опции pkill похожи на те, что имеются у pgrep.

Процессы могут запускаться самостоятельно, через определенные интервалы времени.
Для этого используются cron'ы. Ядром этого инструмента является процесс cron crond,
который автоматически запускается на Linux и каждую минут проверяет свою конфигурацию.

По умолчанию cron считывает свой главный файл конфигурации - /etc/crontab.
Этот файл управляет всеми заданиями, которые должны быть запланированы через cron
(его лучше не изменять, поскольку он может перезаписаться при обновлении).

Каждая крона состоит из 3х элементов (примеры в /etc/crontab):

1) Указание времени, когда команда должна быть запущена.
Для этого используются 5 компонентов: минуты, часы, день_месяца, месяц, день_недели.

2) Указание имени пользователя, с разрешениями которого должна выполняться крона.
3) Указание команды, которую необходимо выполнить.

Пример кроны, которая запускает команду test -x /usr/sbin/anacron, от имени root, 
каждое 1 число, любого месяца в 6:52: 

 52 6    1 * *    root    test -x /usr/sbin/anacron

Помимо системного crontab, отдельные пользователи могут иметь свой crontab.
Обычно это стандартный способ планирования заданий.

Для работы с пользовательским crontab использ. команда: crontab -e. Она отображает все 
запланированные задачи пользователя, и тут же предлагает создать новую. Для этого сначала 
нужно выбрать редактор (нажать 1, 2, или 3), а затем записать в нем саму крону.

Альтернативой внесению изменений в /etc/crontab, является создание файлов с кронами в 
каталоге /etc/cron.d. Эти файлы будут включены при запуске процесса cron. Преимущество этого 
способа в том, что кроны не потеряются при обновлении ПО.

Также сron использ. четыре отдельных каталога для планировки заданий через равные 
промежутки времени: /etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly и /etc/cron.monthly.
Сожержимое этих каталогов - это bash-скрипты.

----------------

УПРАВЛЕНИЕ ПАКЕТАМИ

В Linux все ПО, как правило, распрастраняется в виде пакетов.
Самые распрастраненные форматы пакетов это rpm и deb.

RPM (Red Hat Package Manager) использ. в дистрибутивах на базе Red Hat (Fedora, Suse).
DEB используется в Debian и производных от него дистрибутивах (Ubuntu).

Для поиска и управления пакетами используются менеджеры пакетов, которые 
берут необходимые данные из специальных репозиториев.

В Ubuntu список всех репозиториев пакетов хранится в файле /etc/apt/source.list.
Наиболее важные репозитории добавляются автоматически, но для специфичного 
ПО можно добавить репозиторий вручную.

Категории пакетов Ubuntu:

 * main - ПО, которое официально поддерживается Canonical 
  (обычно это наиболее стабильное и поддерживаемое ПО);

 * restricted - поддерживаемое ПО, которое имеет ограничения в лицензии 
  (например, некоторые драйверы);

 * universe - бесплатное ПО, которое официально не поддерживается;
 * multiverse - неподдерживаемое ПО с лицензионными ограничен.;
 * backports - новейшее ПО, которое может быть нестабильным.

Все строки файла source.list состоят из следующих полей:

Первое поле определяет формат пакета. Формат deb используется для бинарных пакетов 
(программные файлы), а deb-src для пакетов с исходным кодом.

Второе поле - это URL-адрес репозитория.
Третье - название дистрибутива (обычно это текущия версия дистрибутива).
Четвертое - категория пакета.

Например: deb http://archive.ubuntu.com/ubuntu mantic main

Для управления пакетами из репозитория использ. утилита apt (Advanced Packaging Tolos).
Утилита apt использует базу данных для учета пакетов, которая хранится в /var/lib/apt.
Каждый раз при установке пакета, в БД добавляется список всех установленных файлов.

Утилита apt в качестве аргумента принимает следующие команды:

 * list - отображает пакеты на основе имени пакета;
 * search - ищет пакет по регулярному выражению;
 * show - показывает информацию о пакете;

 * update - обновляет список пакетов, доступных для установки 
  (используется перед установкой, чтобы установить самую последунюю версию);

 * upgrade - обновляет пакеты до последней версии;

 * install - устанавливает пакет/пакеты (если устанавливаются несколько 
   пакетов, то они должны разделяться пробелом);

 * remove - удаляет пакет/пакеты.

Примеры использования apt:
 sudo apt search python3  -->  найдет все пакеты которые связаны с python3
 sudo apt show python3.12  -->  отобразит информацию о python3.12
 sudo apt install python3.12  -->  установит python3.12
 sudo apt remove python3.12  -->  удалит python3.12

Дополнительные команды, связанные с apt:
 sudo apt purge progname  -->  удалить программу полностью
 sudo apt remove progname  -->  удалить программу, но оставит конфиги
 sudo apt autoremove  -->  удалить неиспользуемые зависимости
 sudo apt autoclean  -->  очистить локальное хранилище, вместе с кэш-файлами

Если в ходе установки программ происходят ошибки:
 sudo apt check  -->  найдет битые зависимости, а также конфликтующие пакеты
 sudo apt -f install  -->  исправит битые зависимости

Для ручного управления пакетами (установка из архива) использ. утилита dpkg.
Инсталлировать deb-файл: sudo dpkg -i packagename.deb.
Деинсталлировать deb-файл: sudo dpkg -r package.

Команда dpkg -l применяется для просмотра установленных пакетов 
(в том числе и через apt).

----------------

УПРАВЛЕНИЕ СЕТЕВЫМИ ПОДКЛЮЧЕНИЯМИ

На аппаратном уровне за взаимодействие с сетью отвечает сетевая карта. Каждая сетевая 
карта имеет уникальный адрес (во всем мире) - MAC-адрес (Media Access Control).
Это касается не только сетевых карт компьютера, но и мобильных телефонов.

Однако для реального взаимодействия по сети, применяются IP-адреса.
IP-адрес - это адрес копмьютера в сети интернет. По нему можно напрямую обраться 
к каждому компьютеру.

Веб-серверы обычно назначают своим IP-адресам специальные имена - домены.
При обращении в браузере к этим именам, они преобразуются обратно в IP, DNS-сервером.
Таким образом компьютер должен также знать, где найти эти DNS-серверы.

Подобную информацию можно установить вручную, но во многих случаях она 
устанавливается автоматически с помощью DHCP-сервера.

Команда ip применяется для управления IP-адресами. Её можно использовать для 
настройки IP, управления маршрутизацией и т.д.: ip [опции] object { command | help }

Аргумент object может принимать след. значения:

 * link - используется для управления или отображения свойств сетевого устройства, 
   а также для мониторинга состояния сетевого интерфейса;

 * addr/address - используется для управления или отображения адресов IPv4/IPv6;
 * route - для управления или отображения записей в таблице маршрутизации;
 * rule - для управления или отображения правил в БД политики маршрутизации;

 * neight - для управления или отображения записей в кэше ARP (ARP предоставляет 
   информацию о том, какой IP-адрес каким MAC-адресом используется; используя 
   эту опцию можно изменить данную информацию);

 * netns - для управления пространствами имен IP-сетей (обычно используется в 
   облачной среде и позволяет управлять изолированными сетевыми средами, 
   используя один и тот же сетевой интерфейс);

 * tunnel - для управления или отображения IP-туннелей 
  (обычно используется при настройке VPN);

 * madr - для управления или отображения адресов многоадресной рассылки для интерфейсов 
  (групповые адреса, которые можно добавить на сетевую карту; использование многоадресной 
   рассылки позволяет пользователю или приложению одновременно обращаться ко всем узлам, 
   которые предоставляют одну и туже ф-циональность);

 * mroute - для управления или отображения записей кжша многоадресной маршрутизации;
 * monitor - для наблюдения за тем, что происходит на данном устройстве.

Каждый из объектов может иметь свой набор опций. Чтобы узнать о них подробнее, 
нужно после него указать ключевое слово help: ip monitor help.

Просмотреть текущую конфигурацию сети: ip addr show.
Каждое сетевое устройство на компьютере предваряется номером. 

Устройство под номером 1 - lo (loopback device) представляет сетевой интерфейс, 
используемый для внутренних целей на компьютере.

Для каждого устройства в угловых скобках заданы атрибуты. 

Атрибут BROADCAST указывает, что устройство способно отправлять широковещательные 
сообщения на другие узлы сети.

Атрибут MULTICAST указывает, что устройство также может отправлять многоадресные пакеты.
Атрибут UP указывает, что устройство работает.

После угловых скобок идет ряд атрубутов IP-протокола. Так, mtu представляет 
максимальную единицу передачи данных, используемую на интерфейсе.

Строки, которые начинаются с inet, показывают назначенные сетевой карте адреса 
с соответсвующими масками подсети.

Просмотреть текущее состояние сетевого интерфейса: ip link show.
Просмотреть таблицу маршрутов: ip route show.

Команда ping применяется для проверки сетевого подключения. 
Она начинает непрерывный вывод сообщений, который можно остановить через Ctrl + Z.
Ей передается имя или адрес хоста, подключение к которому надо проверить.

 ping www.ubuntu.com  -->  проверить подключение к сайту ubuntu
 ping -c 3 185.125.190.20  -->  отправить на указанный хост 3 пакета

Основные опции ping:

 -c COUNT - устанавливает кол-во отправляемых пакетов (команда автоматически 
  завершится после достижения этого числа);
 
 -l DEVICE - устанавливает имя сетевого устройства, которое следует использовать 
 (полезно на компьютере с несколькими сетевыми устройствами; если указать без DEVICE, 
  то команда отправит пакеты не дожидаясь ответа);

 -i SECONDS - кол-во секунд ожидания между отдельными пакетами ping (по умолчанию 1);
 -f - отправлять пакеты как можно быстрее, но только после получения ответа;

 -t TTL - устанавливает время жизни (time to live) для отправляемых пакетов; 
  аргумент TTL указывает на максмальное кол-во маршрутизаторов, через кот. может пройти 
  пакет на пути к месту назначения. TTL уменьшается на единицу для каждого маршрутизатора, 
  через который он проходит, пока не станет равным 0, что означает, 
  что пакет больше не будет маршрутизироваться;

 -b - отправляет пакеты на широковещательный адрес сети и запрашивает ответ от каждого 
  подключенного хоста, которому разрешено отвечать на ping-пакеты.

Эту команду также можно использовать для проверки задержки между текущим компьютером 
и определенным хостом. Чтобы узнать задержку, нужно взглянуть на поле time. 

Команда трассировки tracepath позволяет определить путь отправки пакетов.
Эта команда может определить на каком этапе возникает проблема, когда невозможно 
подключиться к удаленному хосту: tracepath www.ubuntu.com

С пом. этой команды можно увидить каждый пройденный маршрутизатор, для кот. отображается 
его имя, IP-адрес, а затем время прохождения 3х пакетов, отправленных на него:

Команда ss используется для получения информации о текущих сетевых взаимодействиях.
Она является альтернативой команде netstat, которая использовалась раньше, 
но в современных дистрибутивах уже не включается по умолчанию.

Основные опции ss (можно комбинировать: ss -ptr):
-a - выводит все сокеты;
-r - преобразовывать ip-адреса в имена хостов (домены);
-l - выводит сокеты, прослушивающие подключения;
-e - подробную информацию о сокетах;
-m - информацию об использовании памяти сокетами;
-p - выводит просесс, который использует сокеты;
-T - выводит поток, который использует сокеты;
-i - внутрюнню информацию TCP;
-s - сводку об использовании сокетов;
-E - постоянно отображает сокеты по мере их уничтожения;
-4 - только сокеты IP версии 4;
-6 - только сокеты IP версии 6;
-t - только TCP-сокеты;
-u - только UDP-сокеты;

Выводимая таблица отображает следующую информацию:

 * Netid - тип сокетов; nl - означает netlink; он применяется для обмена информацией 
   между ядром Linux и пользовательскими процессами. Другие типы: tcp, udp, us_str;

 * State - состояние сокетов; наиболее распрастраненные значения: ESTAB (established 
   - установлено), UNCONN (unconnected - не подключено), LISTEN (listening 
   - прослушивает подключения);

 * Recv-Q - кол-во пакетов, ожидающий в очереди для приема;
 * Send-Q - кол-во пакетов, ожидающий в очереди для отправки;
 * Local Address:Port - адрес локальной машины и порт;
 * Peer Address:Port - адрес удаленной машины, на который отправляются данные.

Информацию можно фильтровать:
 * dst - фильтрация по адресу назначения;
 * src - фильтрация по исходящему адресу;
 * state - фильтрация по состоянию.

Все подключения, которые обращаются к адресу 64.233.165.113:
 ss dst 64.233.165.113 (это google.com)

Все подключения, у которых исходящий адрес на локальной машине 192.168.0.108:55854
 ss src 192.168.0.108:55854 (можно и без порта) 
 ss src :55854 (фильтрация только по порту) 
 ss -r src 192.168.0.108 (вместо IP будут домены) 

Все подключения, где локальная машина использует порт 55854, либо где удаленный хост 
использует https: ss -a src:55854 or dst :https

Все подключения, которые идут к доменам "1e100.net"  
 ss -r | grep "1e100.net" (простая фильтрация через grep).

Фильтрация TCP-сокетов по состоянию listening: ss -t state listening.

----------------

РАБОТА С SSH

При работе с несколькими компьютерами, подключенными к одной сети, нередко требуется 
установить между ними безопасное соединение. Для этих целей используется SSH 
(Secure Shell). Он состоит из 3х компонентов: ssh, scp, sftp. 

Соединение по SSH подразумевает наличие клиента и сервера (хоста).
Клиент обращается к серверу и может через ssh управлять им.

Клиент обычно присутствует во всех дистрибутивах по умолчанию. Сервер в дистрибутивах 
на базе Fedora также присутсвует, но в Ubuntu его нужно устанавл. самостоятельно.
Обычно это пакет openssh-server.

При первом контакте клиент и сервер обмениваются открытыми и закрытыми ключами 
через которые происходит взаимосвязь (см. безопасное соединение на основе шифрования).

Когда клиент впервые подключается к хосту, то он записывает его у себя в файле 
.ssh/known_hosts в домашнем каталоге. При последующих подключениях хост проверяется 
через этот файл. Проверка основана на отпечатке открытого ключа сервера.

После успешного подключения между клиентом и сервером устанавливается защищенный канал 
с помощью ключа сессии (общий ключ для клиента и сервера, который шифрует данные, 
передаваемые между компьютерами).

Проверить статут ssh-сервиса: systemctl status ssh (возможно имеется ввиду хоста).
Запустить ssh-сервис: sudo system start ssh (хост будет готов принимать подключения).

Подключиться к хосту с клиента: ssh 192.168.0.116 (IP-адрес хоста).
Здесь предполагается что на сервере точно такой же пользователь, как и на клиенте.

Если на сервере другой пользователь, то при подключении нужно указывать его имя:
 ssh superuser1@192.168.0.116 (подключение к учетке superuser1).

После этого клиент может удаленно управлять копьютером хоста.
Для отключения от хоста нужно выполнить компанду exit.

Если данные о подключениях к хостам больше не нужны, то их можно 
удалить в файле .ssh/known_hosts.

Конфигурация клиента находится в файле /etc/ssh/ssh_config для всех пользователей
и в .ssh_config, в папке .ssh домашнего каталога, для конкретного пользователя.
Наиболее используемые настройки клиента:

 * Host - хосты, к котором может подключаться пользователь 
  (ограничивает те хосты, которые вводятся через терминал при подключении);

 * CheckHostIP - если "yes", то SSH проверяет IP хоста в файле known_hosts
  (применяется для защиты от подмены DNS или IP-адреса); 

 * Ciphers - используется для указания порядка, в котором следует использовать 
   различные алгоритмы шифрования в сеансе SSHv2;

 * Compression - следует ли использовать сжатие в сеансе SSH;

 * ForwardX11 - определяет, будут ли пересылаться соединения X11; если "yes", 
   то графические экраны из сеанса SSH можно пересылать через защищенный туннель;

 * PasswordAuthentication - указывает, надо ли использовать аутенификацию по паролю;
   в безопасной среде, где для аутентификации использ. ssh-ключи, можно установить "no"

Конфигурация сервера находится в файле /etc/ssh/sshd_config.
Некоторые настройки повторяют настройки клиента, но есть и специфичные:

 * AllowTcpForwarding - разрешить ли клиентам выполнять переадресацию TCP-портов;
 * Port - порт, который прослушивает процесс SSH (по умолчанию 22 порт);
 * PermitRootLogin - разрешить ли вход в систему с правами root;
 * PermitEmptyPasswords - разрешить ли вход в систему с пустым паролем;
 * X11Forwarding - разрешить ли клиентам использовать перенаправление X11.

При работе с SSH доступна такая ф-циональность, как X11Forwarding, которая позволяет 
клиенту запускать приложения, установленные на хосте.

Для работы X11Forwarding необходимы 2 условия:
1) На хосте, в файле /etc/ssh/sshd_config, настройка X11Forwarding должна быть "yes".
2) При подключении к хосту надо использовать опцию -X (ssh -X 192.168.0.116).

Команда scp применяется для безопасного копирования файлов. Она похожа на cp, 
но отличается тем, что требует полный путь, включая название хоста, а также имя 
пользователя хоста (если он не такой как на клиенте).

Перед применением scp вызывать команду ssh не нужно. Опция -r позволяет 
копировать полную структуру подкаталогов:

 scp clientfile host:/hostfile  -->  копирует с компьютера-клиента clientfile 
   на компьютер-хост с адресом "host" по пути hostfile

 scp host:/hostfile clientfile  -->  обратное копирование с хоста на клиент

На практике выглядти так (username@ можно опустить если пользователи одинаковые): 
 scp ~/Documents/hello.txt username@192.168.0.116:/home/username/Documents/world.txt

Команда sftp также применяется для копирования файлов, но с установкой защищенного 
FTP-сеанса между компьютерами. Она предполагает, что между компьютерами уже установлено 
ssh-соединение. В качестве аргумента принимает одно из следующих действий:

 * put - копирует файл с текущего компьютера на другой;
 * mput - копирует несколько файлов с текущего компьютера на другой;
 * get - копирует файл с другого компьютера на текущий;
 * mget - копирует несколькл файлов с другого компьютера на текущий.

Перед установкой сеанса, нужно заранее перейти в каталог, в который или из которого 
надо копировать файлы. А после установки, перейти в нужный каталог уже на хосте.

Установить сеанс: sftp username@host.
Передать файл на хост: put hostfolder/hello.txt
Загрузить файл с хоста: get hostfolder/world.txt

Для отключения от SFTP-сеанса применяется команда quit или exit.

----------------

ЛОГГИРОВАНИЕ

За логирование отвечает процесс rsyslog. Он наблюдает за тем, что происходит 
на компьютере и записывает все действия в файлы из папки /var/log 
(веб-сервер apache также записывает сюда свои сообщения).

Основные события в системе записываются в файл syslog.

Основной файл конфигурации rsyslog - это /etc/rsyslog.conf, а также файлы из каталога 
/etc/rsyslog.d (их содержимое добавляется к конфигурации rsyslog.conf)

Структура этого файла состоит в основном из 2х компонентов - модулей и директив. 
В конце указывается директива $IncludeConfig /etc/rsyslog.d/*.conf 
которая и подключает файлы из каталога /etc/rsyslog.d.

Файл 50-default.conf определяет базовые правила логирования для rsyslog.
Правила дают понять, куда объекту производить логгирование. 
Их можно установить для следующих объектов:

 * auth - обрабатывает события, связанные с аутинтификацией;
 * authpriv - по сути аналогичен с auth;
 * cron - логгирует сообщения, созданные подсистемой cron;
 * daemon - логгирует сообщения, созданные сервисом;

 * kern - логирует сообщения, которые относятся к ядру, а также сообщения, 
   генерируемые брандмауэром ядра iptables;

 * lpr - логгирует сообщения, которые относятся к устаревшей системе печати lpr;
 * mail - логгирует сообщения, связанные с почтой;

 * news - логгирует сообщения, связанные с протоголом NNTP 
  (протокол передачи сетевых новостей);

 * user - логгирует сообщения, которые относятся к пользователю.

При логгировании объекты создают сообщения с заданным приоритетом. Если указан приоритет, 
то все сообщения с этим и более высоким приоритетом записываются в указанный файл.
В rsyslog применяются следующие приоритеты:

 * debug - отладочная информация, дающая подбробные данные обо всем, что делает объект; 
   например сообщает, какие системные и библиотечные вызовы он выполняет;

 * info - стандартная информация о том, что делает делает процесс; например информация 
   об открытых файлах (не дает подробной информации о системных и библиотечных вызовах);

 * notice - информация о некретических ошибках; например о файле, который должен 
   существовать, но поскольку его не было, то он был создан автоматически;

 * warn - информация о предупреждениях, возникших при выполнении процесса 
  (когда нормальная функциональность нарушена, но объект продолжает работать);

 * err - информация об ошибках;

 * crit - информация о критических ситуациях, которые ставят под угрозу 
   нормальную работу компьютера;

 * alert - информация о ситуациях, которые могут привести к остановке компьютера;
 * emerg (panic) - указывает на прекращение нормальной работы компьютера.

Примеры сочетания объектов с приоритетами: 

 kern.info (логгирование информационных сообщений с конкретным и более высокими 
   приоритетами, которые генерируются ядром)

 kern,cron.info (можно указывать несколько объектов через запятую)
 *.crit         (звездочка ссылается на все объекты)
 mail.=info     (знак = логгирует только конкретный приоритет, но не более высокие)
 mail.!info     (знак ! исключает конкретный приоритет и более высокие за ним)

 *.*;auth,authpriv.none (знак ; используется в качестве разделителя; 
   данная запись указывает на все объекы и все приоритеты, но исключает 
   логгирования для объектов auth, authpriv)

Далее указывается файл логгов. Черточка означает, что сообщения будут 
буферизоваться, а не записываться сразу:

 kern.*   -/var/log/kern.log (сообщения всех приоритетов, которые относятся к ядру, 
   логгируются в файл /var/log/kern.log с предварительной буферизацией) 

Команда logger позволяет отправять сообщения в rsyslog (позвоялет использовать 
логгирование в различных скриптах, где нет сдандартного output):

 logger hello world! (в файле /var/log/syslog появится строка 
   "2024-03-21:01:15.79400+03:00 User user: hello world!") 

Также можно использовать опцию -t. В этом случае сообщение пометится доп. тегом 
(теги облегчают распознавание особых сообщений):

 logger -t myteg hello!  -->  "2024-03-21:01:15.79400+03:00 User mytag: hello!"

В дополнение к rsyslog существует также сервис journald, который используется для 
предоставления информации о службах и их текущем состоянии. Он дает информацию 
в режиме реального времени, которая очищается при перезапуске компьютера.

Команда journalctl позволяет прочитать сообщения журнала.
Чтобы перейти к самым последним строкам, используется опция -G.

Опции journalctl для фильтрации:
 --system - отображает системный журнал;
 --user - отображает логи текущего пользователя;
 -D PATH - логи из определенного каталога;
 --file PATH - лог по определенному пути;
 -S DATE - показывает сообщения начиная с определенной даты;
 -U DATE - сообщения до определенной даты;
 -t STRING - сообщения с определенным тегом;
 -p RANGE - сообщения с определенным приоритетом;
 -g PATTERN - использует рег. выр-е для поиска сообщений;
 -k - сообщения лога ядра для текущей загрузки.

Примеры использования journalctl:
 journalctl --system -n 10 (последние 10 записей из системного лога)
 journalctl -p err (все сообщения, принадлежащие приоритету err)
 journalctl -S "2024-03-20 16:30:20" (время можно опустить)
 journalctl -S yesterday (yesterday, today, tomorrow)
 journalctl -S yesterday -p err (опции можно кобминировать)

----------------

ЯДРО И МОДУЛИ

Ядро Linux является сердцем операционной системы. Это единственная часть ОС, 
которая напрямую взаимодействует с оборудованием. Все остальные программы 
должны пройти через ядро.

Для доступа к аппаратной части, ядро использует драйверы. 
Роль драйвера - сообщить ядру, как оно должно обращаться к оборудованию.

Каждый драйвер представлен модулем ядра. Самые необходимые драйверы компилируются 
в самом ядре. Остальные - подргужаются динамически.

Команда lsmod применяется для получения списка загруженных модулей.

Выводимая информация состоит из 3х столбцов: имя модуля; объем используемой памяти; 
кол-во и имена зависимых модулей, используемых в данный момент.

Команда modinfo применяется для получения информации о загруженном 
модуле: modinfo [опции] modulename.

Основыне опции modinfo:
 -a - выводит только автора модуля;
 -d - выводит только описание;
 -l - только лицензию;
 -p - только параметры;
 -n - только имя файла;
 -F FIELD - только указанное поле FIELD;
 -V - только версию.

Обычно модули загружаются автоматически, но иногда может потребоваться сделать это 
вручную, например загрузить с новыми опциями (перед этим, ядро нужно выгрузить).

Для загрузки модуля применяется команда modprobe modulename, а для выгрузки, 
тоже самое, но с добавлением опции -r:

  modprobe -r bluetooth (сначала выгружаем ядро)
  modprobe bluetooth (затем заново загружаем)

Модули, которые имеют зависимости (другие модули ядра) выгрузить не получится.
Для этого сначала нужно выгрузить все зависимости (см. третий столбец команды lsmod).

В некоторых случаях модуль ядра может остутствовать для некоторого оборудования.
Для решения этой проблемы следует поискать проприетарный драйвер у поставщика 
этого оборудования. Команда lspci -K поможет это определить.

Ядро можно настраивать. Для этого нужно записать новые параметры в определенные 
конфигурационные файлы в каталоге /proc/sys (с помощью команды echo). 
При этом нужно понимать, что выполняется, иначе система может выйти из строя.

Внутри /proc/sys вся ф-циональность сгруппирована по папкам:
 * debug - содержит параметры, относящиеся к отладке ядра;
 * dev - содержит параметры, относящиеся к устройствам и их работе;
 * fs - параметры файловой системы;
 * kernel - параметры, связанные с ядром;
 * net - параметры, связанные с сетью;
 * user - параметры, связанные с пользователем;
 * vm - параметры, которые относятся к управлению памятью.

Например файл конфигурации /proc/sys/net/ipv4/ip_forward указывает, может ли компьютер 
маршрутизировать пакеты между двумя сетевыми картами (может потребоваться, если 
нужно использовать компьютер в качестве точки беспроводного доступа).

По умолчанию стоит значение "0", что означает, что маршрутизация отключена.
Чтобы включить этот параметр, нужно прописать: echo 1 > ip_forward.

Однако изменения не сохранаются после перезагрузки компьютера. Чтобы обойти 
это ограничение можно использовать пакет sysctl. При загрузке системы он использует 
свой файл конфигурации /etc/sysctl.conf, который содержит список всех 
параметров, необходимых для применения к /proc.

В /etc/sysctl.conf все файлы конфигурации из /proc/sys упоминаются с использованием 
относительных путей, а вместо слэшей применяется точка: #net.ipv4.ip_forward=1
Символ решетки означает, что строка закомментирована.

Некоторые распрастраненные настройки ядра:

 * /proc/sys/dev/scsi/logging_level - определяет уровень ведения журнала, который должны 
   использовать устройства SCSI; чем выше уровень, тем более интенсивно ведется журнал; 
   нужно использовать только значения степени двойки; применяется, если надо больше 
   или меньше логгировать события SCSI.

 * /proc/sys/fs/file-max - определяет максимальное кол-во файлов, 
   которые можно открыть одновременно;

 * /proc/sys/kernel/hostname - содержит имя компьютера, известное ядру;

 * /proc/sys/kernel/osrelease - содержит текущую версию ядра 
   (этот файл считывается командой uname -r);

 * /proc/sys/net/core/rmem_max - устанавливает максимальный объем памяти, который ядро 
   должно зарезервировать для беферизации входящих сетевых пакетов;

 * /proc/sys/vm/laptop_mode - сообщает ядру, должно ли оно работать в режиме ноутбука 
   (значение "1" будет означать что нужно использовать более энергоэффективные настройки);

 * /proc/sys/vm/swappiness - сообщает ядру, как быстро оно должно начать swap'ить
   (сохранять данные из оперативной памяти на жесткий диск, при её нехватки); 
   более высокие значения указывают на более высокую готовность.

----------------

РАЗНЫЕ КОМАНДЫ

poweroff - выключить компьютер
reboot - перезагрузка
systemctl suspend - сон

