КОМАНДНАЯ СТРОКА

Для работы в командной строке, Linux предоставляет оболочку (shell). 
Оболочка - это командный интерпритатор. Наиболее популярная оболочка - bash.

Команда состоит из 3х частей: сама команда, необязательные опции (флаги) 
и аргументы. Например: ls [-l] [/usr].

Аргументы обычно предоставляют объекты, к которым применяется команда. Они указываются
в конце. Например по умолчанию ls применяется к текущему каталог, но если задать
аргумент /usr, то команда применится к этому каталогу.

С пом. символа | можно состовлять цепочки команд: ls -R /usr | less.
Здесь ls -R /usr отправляет свой результат команде less.

С пом. символа > можно перенаправить результат выполнения команды, например с консоли
(по умолчан.) в файл: ls -l > file (если файл не был ранее создан, то создастся).

Для перенаправления ошибок используется символ 2>: ls -l > file 2> error.

Для получения информации о команде используется команда man: man название_команды.
Информация обычно состоит из следующих секций:

 * name - имя команды, и краткое описание;
 * synopsis - как использовать команду; отображает все доступные пар-ры;
 * description - полное описание;
 * options - список всех доступных опций;
 * see alse - список связанных команд.

Альтернативным способом получения информации о команде является её опция --help.

Оболочка bash запоминает историю ввода команд и позволяет повторно использовать
недавние команды. Навигацию по командам можно выполнить с пом. стрелок.

Многие дистрибутивы запоминают только последнии 1000 команд. Эти команды хранятся 
в файле .bash_history, в домашнем каталоге пользователя. 

Чтобы увидеть историю можно ввести в терминале history. Удалить историю можно либо 
с пом. команды history -c, либо просто очистить файл вручную.

Информационные команды:

 * uname - отображает имя хоста системы (т.е. компьютера) и информацию об ОС;

 * lsb_release - информация о LSB (Linux Standart Base), т.е. стандартная 
   базовая версия Linux;

 * hostnamectl - используется для отображения и изменения имени хоста, а также для
   просмотра настроек системы (архитектура, режим загрузки, часовой пояс и пр.);
   не требует входа в систему под root'ом;

 * date - отображает текущую дату.

---------------------

ФАЙЛЫ И КАТАЛОГИ

Корневой каталог имеет путь "/". Перечень стандартных каталогов:

 * /bin - приложения, которые можно запускать через командную строку;
   в основном хранит утилиты, например: bash, cp, cat и др.

 * /etc - конфигурационные файлы системы, например: passwd, hosts, networks и т.д.;
 * /boot - компоненты для загрузки системы, в частности, ядро (файл vmlinuz);
 
 * /sbin - системные приложения для администрирования и восстановления системы,
   например: fdisk, ifconfig, reboot и пр.

 * /usr - пользовательские приложения и данные (аналог Program Files);
 * /usr/bin - большинство пользовательских приложений;
 * /usr/src - исходные файлы open-source приложений (в основном c/cpp);
 * /usr/include - стандартные заголовочные файлы языка C;
 * /usr/lib - библиотеки приложений и устанавливаемые пакеты;
 * /usr/local - локальные приложения;
 * /usr/share - статические разделяемые данные;

 * /var - файлы данных, которые могут изменяться;
 * /var/cache - кэш приложений;
 * /var/include - стандартные заголовочные файлы языка C;
 * /var/lib - данные о состоянии системы;
 * /var/lock - заблокированные данные для отслеживания используемых ресурсов;
 * /var/log - файлы логов;
 * /var/opt - данные установленных пакетов;
 * /var/spool - выполняемые задачи (кроны и пр.);
 * /var/tmp - временные файлы, удаляемые после новой загрузки системы;

 * /dev - файлы устройств; в Linux все оборудование, с которым можно работать,
   соответсвует файлу в системе; если надо обратиться к hardware, то следует 
   обратиться к соответсвующему файлу (с правами root).

 * /home - домашний каталог пользователя;

 * /lib - общие библиотеки приложений, а также драйвера, используемые ядром;
 * /media - каталог для монтирования съемных устройств, например USB;

 * /mmt - тоже самое что и предыдущий, только на старых системах; 
   иногда используется в целях тестирования;

 * /opt - доп. пользовательские приложения; в отличие от /usr обычно помещают более
   крумные файлы, однако единого мнения нет, что помещать в /usr, а что в /opt.

 * /proc - файлы процессов, информация о ядре и компьютере;
 * /root - домашний каталог суперпользователя (системного администратора);

 * /run - используется для конфигурации во время выполнения; файлы удаляются 
   автоматически, когда становятся не нужны;

 * /srv - файлы некоторых важных сервисов, например здесь может хранится файловая
   структура своего веб-сервера и ftp-сервера.

 * /sys - похож на /proc, но хранит свою информацию на жестком диске, поэтому она
   доступна после перезагрузки; здесь информация больше связана с оборудованием,
   тогда как в /proc - с ядром.

 * /tmp - временные файлы, автоматически удаляемые при перезагрузке;

Команды для работы с каталогами:
 
 * pwd - выводит полный путь к текущему каталогу;

 * cd - позволяет перемещаться по каталогам; абсолютные путь задается через косую 
   черту перед именем каталога, иначе команда попытается найти относительный каталог;
   для переходу к домашнему каталогу применяется символ ~ (алиас для /home/username);
   для перехода на один/два уровня вверх применятеся путь .., ../../ (и т.д.);

 * mkdir - создает каталог; опция -p позволяет создать папку вместе с родительской
   (если та отсутствует): mkdir folder, mkdir -p ~/folder1/folder2

 * rmdir - удаляет пустой каталог: rmdir folder; если в каталоге есть файлы или
   подкаталоги, то применяется команда rm -r или -rf: rm -r folder

Команда ls отображает список файлов и папок в заданном каталоге.
Команда ls * выводит также содержимое подкаталогов.

Основные опции ls:
 -R - рекурсивно выводит содержимое подкаталогов (указывается вместо *);
 -d - выводит только каталоги. 
 -s - выводит файлы с их размером;
 -S - файлы, отсортированные по размеру;
 -t - файлы, отсортированные по времени доступа;

 -l - файлы и каталоги с их свойствами (права, владелец, размер и пр.); права файла
 имеет след. структуру drwxrwxr-x; самый первый символ указ. на тип файла, d обознач.
 каталог, l - символьную ссылку, а дефис - файл; далее идут 9 знаков разрешений;

 -a - выводит скрытые файлы.

При выводе списка файлов, вместо каталога можно задать шаблон с рег. выр-ем, 
который определит конкертные файлы для вывода, например:

 ls /project/*.min.js  -->  выберет все файлы c окончанием .min.js
 ls /project/[abc]*    -->  все файлы и папки, кот. начинаются на a, b или c

Команды для работы с файлами:

 * touch - создаёт файл: touch hello.txt
 * rm - удаляет файл: rm hello.txt; опция -r удаляет также и каталог;

 * cp - копирует файл: cp /etc/hello.txt /usr/hello.txt, cp hello.txt /folder

   (во втором примере важно чтобы folder уже существовал, иначе будет создан 
   текстовый файл folder с содержимым hello.txt); 

   опция -r позволяет копировать каталог: cp -r folder1 folder2 
   (folder2 создается автоматически);

   символ * копирует все файлы из текущего каталога: cp * /usr, cp .* /usr 
   (во втором примере копируются все скрытые файлы);

   другие опции:
    -a - копирует также свойства файлов;
    -b - создает резервные копии перед копированием;
    -f - принудительное копирование (когда файл запрещено копир. в место назначения);
    -i - запрашивает перезапись, если файл уже существует;
    -u - копируется только если целевой файл старше исходного файла, 
    или если целевой файл не существует;

 * mv - перемещает файл/каталог, а также переименовывает его: 
   mv hello.txt /folder (folder должен существовать), mv hello.txt world.txt;

 * wc - выводит кол-во строк, слов и символов в файле.

Команда ln -s создает символьную ссылку файла (ярлык): ln -s hello.txt /usr/hello
(в каталоге usr создается ссылка hello на файл hello.txt)

Команда find применяется для поиска файлов и каталогов: find /usr -name "*.txt"
(сначала указывается папка, затем опция критерия, и шаблон поиска)

Основные опции find:

 -amin N - находит все файлы, к которым последний раз обращались менее 
  N-минут назад, например: find -amin 5;

 -executable - находит все исполняемые файлы;
 -group NAME - все файлы, владельцем которых является пользователь с логином NAME;
 -mmin N - все файлы, которые последний раз были изменены менее N-минут назад;
 -newer FILE - все файлы новее, чем файл FILE;
 -nogroup/nouser - все файлы, у которых нет группы или владельца;
 -perm MODE - все файлы, у которых установлен режим разрешений mode;

 -size N - находит все файлы размера n (либо больше/меньше); к N также применяются
 символы K, M и G для обозначения килобайтов, мегабайтов и гигабайтов соответсвенно,
 например: find /usr -size +2G (все файлы более 2 гиг);

 -type T - находит файлы по типу; тип d - это каталог, а f - файл.

Команда whereis применяется для поиска местоположений бинарный файлов, исходных файлов,
а также файлов команд, например: whereis gcc найдет местоположение команды gcc.

Команда mount применяется для ручного монтирования устройства в файловую систему. 
(в Linux, монтируемые устройства называются файлововыми системами).

Эта команда принимает два аргумента: монтируемое устройство и место монтирования. 
В качестве монтируемого устройства выступает его название (например, название диска).
В качестве места, куда оно монтируется, выступает каталог /media.

 mount /dev/phone /media/username/folder  -->  теперь можно перейти в folder
                                               и посмотреть содержимое устройства
Основные опции mount:
 -t - тип файловой системы (ext4, vfat, ntfs);
 -r - монтирует устройство только для чтения (по умолчанию -rw);

При запуске компьютера некоторые файловые системы монтируются автоматически. 
Для этого используется файл /etc/fstab. Он содержит список всех автоматических
подключений. Некоторым файловым системам можно убрать автомонтирование.

В Linux, перед отсоединением устройства от компьютера нужно сначала отключить его.
Отключение устройства гарантирует, что все данные, которые находятся в кэше или еще 
не были записаны, запишутся в файловую систему. 

Для отключения устройства используется команда: unmount /dev/sda1.

Но иногда она может выдать сообщение, что устройство занято открытым файлом, 
а отключение может привести к потере данных. В этом случае для завершения процессов,
связанных с устройством, можно использовать команду: fuser -kv /dev/sda1.

Команда mount без аргументов выводит информацию обо всех смонтированных устройствах.
Команда df -h показывает более читабельную информацию об устройствах, чем mount.
Команда lsblk отображает устройства, доступные в текущий момент на компьютере.

Устройства, которые называются как /dev/sd[x] представляют жесткие SATA-диски 
и USB-девайсы. Основными элементами жетского диска являются разделы (участки диска).

Управлять дисками и разделами можно с пом. таких утилит, как fdisk и gdisk.

---------------------

ТЕКСТОВЫЕ КОМАНДЫ

Команды для вывода содержимого файлов:

 * cat - выводит содержимое файла: cat file.txt;
 * tac - тоже, что и cat, но отображает содержимое в обратном порядке;
 * head - отображает первые строки файла;
 * tail - отображает последние строки файла;
 * less - открывает файл в спец. окружении, напоминающем редактор vi;
 * more - тоже, что и less, только с меньшими возможностями.

Эти команды можно комбинировать между собой для вывода более конкретный результата:

 head -n 2 file.txt | tail -n 1  -->  сначала, с пом. head, будут выбраны первые 
                                      две строки, после этого они передадуться в tail 
                                      и из них выберется одна последняя

Результат других команд на консоли - это тоже текст и его также можно 
обрабатывать с помощью текстовых команд: 

 ls -l | tail -n 2  -->  последние 2 строки из списка файлов и каталогов

Команда tr преобразовывает или удаляет символы из файла, например: 
cat file.txt | tr a-z A-Z  -->  переведет символы из дипазона a-z в верхний регистр
cat file.txt | tr a-z A-Z > file2.txt  -->  тоже самое, но результат запишет в файл

Команда sort используется для сортировки: cat file.txt | sort 
Для сортировки чисел нужно добавить флаг: cat nums.txt | sort -n
Отсортировать результат команды: ls | sort

Команда cut позволяет получить из (структурированного!) файла кусок информации.

Основные опции cut:
 -d - разделитель в строке (структурированного текста);
 -f N - номера полей для вывода (которые разделены через -d);

Вывод имен пользователей из файла, содержащего следующий текст:
 Tom:39:Microsoft        
 Bob:43:Google           cut -d : -f 1 file.txt  -->  Tom Bob Sam Alice Kate
 Sam:28:Jetbrains        (опция -d указывает что разделитель - двоеточие,
 Alice:34:Oracle          а -f, что надо получить первое поле)
 Kate:25:Google           

Вывод первого и третьего полей: cut -d : -f 1,3 file.txt  -->  Tom:Microsoft
Вывод с первого по второе поле: cut -d : -f 1-2 file.txt  -->  Tom:39

Вывод первых 3х имен, отсортированных по алфавиту:
 cat file.txt | cut -d : -f 1 | sort | head -3  -->  Alice Bob Kate

Команда grep выполняет поиск в файле с использованием регулярного выражения.
Она имеет следующий формат: grep [опции] шаблон file.

 grep "127.0." /etc/hosts  -->  найдет строки, содержащие данный префикс
 grep "T[ou]m" file.txt    -->  найдет строки, которые содержат Tom или Tum
 ls /home/username | grep "Do"  -->  Documents Downloads
 
Команда awk выполняет заданное действие на основе регулярного выражения.
Она имеет следующий формат: awk '/pattern/{action}' file.

Действие заключается в фигурные скобки. А сам шаблон лучше помещать в одинарные
кавычки, чтобы оболочка не могла интерпритировать рег. выр-е.

 awk -F : '/Tom/{print $3}' file.txt  -->  выведет 3 поле (с пом. встроенной в awk
                                    команды print) для всех строк, где упоминается Tom

 awk -F : '$2 > 30 {print $1}' file.txt  -->  выведет пользователей у которых возраст
                                          больше 30 (awk доступны операторы сравнения)
---------------------

РАБОТА С АРХИВАМИ

Команда gzip (gnu zip) используются для сжатия и распаковки файлов.
Она имеет следующий формат: gzip [опции] file1 file2 fileN.
Помимо файлов команде можно передать и каталог.

По умолчанию, при архивации, оригинальный файл (или несколько файлов) удаляется, 
а вместо него создаёт новый файл с доп. расширением .gz. При распаковке 
удаляется файл архива.

Чтобы файл не удалялся, используется опция -k: gzip -k book.pdf  -->  book.pdf.gz

Другие опции gzip:
 -d - распаковывает архив;
 -l - выводит список заархивированных файлов;
 -r - рекурсивно архивирует содержимое каталогов;
 -1 - применяет быстрое архивирование (в ущерб размеру);
 -9 - применяет лучшее архивирование (в ущерб скорость);

Файл можно распаковать и с помощью команды gunzip (тоже использует опцию -k).

Команда xz также применяется для архивации данных. Она использует алгоритм с высокой
степенью сжатия и низким использованием памяти. Используется для сжатия больших файлов
(в основном в системе Linux для сжатия ядра) а также для сжатия и распаковки на лету.

 xy -v book.pdf (опция -v выводит подробную сводку операции) 
 xy -d -v book.pdf.xz

При архивации сразу нескольких файлов, для каждого из них будут созданы отдельные
архивы, что неудобно. Команда tar позволяет объединить несколько файлов в один архив.
Она имеет следующий формат: tar [опции] имя_архива file1 file2 fileN

Основные опции tar:
 -c - создает архив;
 -d - сравнивает архивы;
 -r - добавляет файлы в конец архива;
 -t - выводит содержимое архива;
 -u - обновляет только те файлы, кот. новее одноименных файлов в архиве;
 -x - извлекает файлы из архива;
 -f NAME - устанавливает имя для архива;
 -v - выводит подробную сводку операции;
 --delete - удаляет содержимое архива;
 --overwrite - перезаписывает файлы при извлечении;
 --overwrite-dir - перезаписывает каталоги при извлечении;
 --remove-files - удаляет файлы при добавлении в архив.

Примеры архивации и распаковки: 
 tar -cvf archive.tar hello.txt image.png book.pdf
 tar -cvf home.tar /home
 tar -xvf archive.tar (распаковка)

Создание архива объединенияет нескольких файлов в один пакет, но не сжимает их. 
Для сжатия, команде tar нужно передать опцию -z (gzip) или -j (bzip2).

 tar -czvf archive.tar.gz hello.txt image.png book.pdf

Архивные файлы сохраняют свои пути при распаковке. Например, если при архивации указать
путь /home/username/Documents/file.txt, то при распаковке, файл туда же и выгрузится.

Опция -С (большая), при архивации, позволяет включить в архив только относительные 
пути файлов и каталогов: tar -cvf archive.tar -C ~/Documents/test .

Точка указывает, что при распаковке все файлы архива поместятся в текущую папку. 
Вместо точки можно указать произвольный путь. Это будут подпапки в текущем каталоге.

При распаковке тоже можно указать опцию -C. В этом случае файлы будут распакованы в
указанный каталог, а не текущую папку: tar -xvf archive.tar -C test(copy).

Для архивации, сжатия и распаковки zip-файлов используются команды zip и unzip.
Опция -r рекурсивно архивирует содержимое папок.

 zip myfiles.zip book.pdf image.png
 unzip myfiles.zip

------------------

ПОЛЬЗОВАТЕЛИ И ГРУППЫ

Учетная запись пользователя - это объект, который создается в системе Linux для
предоставления разрешений, позволяющих выполнять определенные задачи.

Учетные записи создаются как для людей, которым необходим доступ к системе, так и для
служб, которым нужен доступ к определенным файлам или ресурсам (демоны).

Пользователи Linux обладают рядом свойств. Эти св-ва хранятся в файлах /etc/passwd 
и /etc/shadow. В частности, это:

 * Username - имя/логин пользователя; по умолчанию в системе есть пользователи, кот.
   предназначены для системных задач и служб; их не следует изменять или удалять;

 * Password - пароль пользователя; хранится в /etc/shadow (в зашифрованном виде);

 * UID - идентификатор пользователя; числа до 1000 обычно принадлежат службам, 
   а после - людям; идентификатор 0 зарезервирован для пользователя root;

 * GID - идетификатор группы пользователя; в Linux все пользователи должны быть членами
   хотя бы одной группы (основной); помимо основной группы, пользователи могут быть
   членами и вторичных групп; параметры основной группы хранятся в /etc/passwd, 
   а вторичных - в /etc/group.

 * GECOS - комментарий, содержащий описание учетной записи (необязателен);

 * Домашний каталог - каталог пользователя, в котором храняется его файлы и конфиги
   (которые применяются конкретно к нему);

 * Оболочка по умолчанию - то, через что пользователь входит в систему 
   (нужна не всем пользователям).

Для выполнения действий в системе, связанных с администрированием, нужно чтобы их
команды запускались через sudo, например sudo apt update (перед выполнением система
потребует ввести пароль). 

Права пользователей и групп записаны в файле /etc/sudoers.
Подробное описание этого файла здесь https://metanit.com/os/linux/5.1.php

Команда useradd применяетя для создания учетной записи нового пользователя:
 sudo useradd [опции] username

Оснонвые опции useradd:
 -b BASE_DIR - устанавливает BASE_DIR для домашнего каталога новой учетки;
 -d HOME_DIR - устанавливает HOME_DIR в качестве домашнего каталога;
 -p ЗАШИФРОВАННЫЙ_ПАРОЛЬ - пароль новой учетки; 
 -g - имя или идентификатор основной группы новой учетки;
 -m - создает учетку вместе с домашним каталогом;
 -r - создает системную учетную запись;
 -s SHELL - задает оболочку shell для логина новой учетки;
 -u UID - идентификатор пользоваля новой учетки;
 -U - создает группу с тем же имененм, что и у пользователя;
 -G ГРУППЫ - задает список доп. групп для новой учетки.

Также пользователя можно создать, отредактировав базу данных пользователей напрямую. 
Она хранится в двух файлах: /etc/passwd и /etc/shadow (поля разделены двоеточием)

Эти файлы лучше изменять с пом. команды vipw т.к. она проверяет их согласованность 
после изменения, а также записывает изменения во временный файл, что предотвращает 
блокировки, вызваннные одновременным доступом к файлу разными пользователями.

Команда usermod изменяет уже созданную учетную запись: usermod [опции] username.
Также она позволяет добавлять пользователей в группу или удалять их оттуда.

Оснонвые опции usermod:
 -m - перемещает содержимое домашнего каталога (используется только с -d);
 -a - добаляет пользователя в доп. группы, указанные в -G, не удаляя из других групп;
 -G ГРУППЫ - устанавливает список дополнительных групп;
 -L - блокировка пользователя;
 -U - разблокировка пользователя.

Команда userdel удаляет пользователя: userdel [опции] username.

Оснонвые опции userdel: 
 -f - принудительное выполение, которое в ином случае не выполнилось бы
  (например удалить пользователя вошедшего в систему);

 -r - удаляет пользователя вместе с домашним каталогом.

Некоторые примеры этих команд:

 sudo useradd -m superuser1

 sudo usermod -aG users superuser1  -->  доб. пользователя superuser1 в группу users
 sudo usermod -d /home/newdir superuser1  -->  изменение домашнего каталога
 sudo usermod -L superuser1

 sudo userdel -r superuser1

Команда id позволяет получить информацию о пользователе. Ей передается логин и пароль.
Если логин не переда, то выведется информация о текущем пользователе.

 id root  -->  данные о пользователе root

Команда users выводит список всех залогиненых пользователях. Также это можно сделать 
с пом. команды loginctl, которая отбрасывает некоторую дублируемую информацию.

Чтобы получить более детальную информацию о пользователях, используется команда who.
Чтобы посмотреть, что сейчас делают пользователи, используется команда w.

Команда passwd применяется для установки пароля: passwd [опции] username.
Если не указ. username, то пароль будет устанавливаться для текущего пользователя.

С пом. этой команды пользователи могут изменять собственные пароли, а администраторы - 
пароли других пользователей. Также с пом. неё можно задавать срок действия пароля.

Основные опции passwd:
 -d - удаляет пароль для указанной учетной записи;
 -k - меняет пароль только если его срок действия истек;
 -l - блокирует пароль указанной учетки;
 -u - разблориует пароль указанной учетки;
 -S - показывает статус пароля для указанной учетки;
 -n MIN_DAYS - минимальное кол-во дней до смены пароля;
 -x - устанавливает максимально кол-во дней до смены пароля;

 -e - принудительно делает пароль истекшим 
  (при след. логине пользователь обязан поменять пароль);

 -i INACTIVE - автоматич. прекращает срок действия учетки, если она 
  не использовалась в течении заданного периода.

Пример удаления пароля: sudo passwd -d superuser1.

Для настройки политики качества паролей применяется файл /etc/security/pwquality.conf.
Этот файл определяет правила и настройки, которые контролируют надежность паролей
(с пом. него команда passwd выводит доп. инфу о надежности пароля и пр.).

Команда change применяется для изменения политики устаревания и срока действия 
пароля пользователя: change [опции] username.

Основные опции change:
 -d LAST_DAY - изменить дату последней смены пароля;
 -E EXPIRE_DATE - назначить дату истечения срока действия учетки;
 -l - показывает информацию об устаревании учетки;
 -m MIN_DAYS - минимальное кол-во дней до смены пароля;
 -M - максимальное кол-во дней до смены пароля; 

 -i INACTIVE - автоматич. прекращает срок действия учетки, если она 
  не использовалась в течении заданного периода.

Примеры использования change:
 sudo change -l superuser1
 sudo change -d 2024-12-1 superuser1
 sudo change -E 2024-12-31 superuser1

Команда pwck проверяет согласованность /etc/passwd, /etc/shadow и /etc/group.
Например проверим файл /etc/passwd: sudo pwck /etc/passwd.

Цель команды - убедиться, что учетки пользователей и группы, перечисленные в этих 
файлах действительны, а также обнаружить любые несоответствия между ними. Это помогает 
выявить и исправить ошибки, которые могут возникнуть из-за ручного редактирования.

Пользователь может быть членом разных групп. У пользователя есь как минимум одна - 
основная группа. Если у пользователя нет основной группы, он не сможет войти в систему.
При создании пользователя ему в качестве основной назначается одноименная группа.

Отличие между основной и дополнительной группой заключается в том, что основная 
автоматически становится группой-владельцем любого нового файла, созд. пользователем.

Идентификатор основной группы (GID) хранится в четвертом поле файла /etc/passwd
 superuser1:x:1001:1001::/home/superuser1:/bin/sh

Команда groups позволяет получить все группы указанного пользователя.
Команда groupadd добавляет новую группу в систему: groupadd [опции] groupname.

Основные опции groupadd:
 -g GID - устанавливает идентификатор для новой группы;
 -p ПАРОЛЬ - применяет пароль для новой группы;
 -U ПОЛЬЗОВАТЕЛИ - задает список членов этой группы;

Всесозданные группы хранятся в файле /etc/group. Каждая строка в файле описывает 
определенную группу и состоит из четырех полей, разделенных двоеточием:

 * первое поле - имя группы;
 * второе - пароль группы (знак ! означает, что для этой группы пароль не разрешен)
 * третье - уникальный идентификатор группы - GID;
 * четвертое - имена членов группы.

Команда groupmod изменяет группу: groupmod [опции] groupname.

Основные опции groupmod:
 -g GID - изменить идентификатор группы;
 -n ГРУППА - изменяет имя группы;
 -p ПАРОЛЬ - изменяет пароль группы;

 -a - добавляет пользователей, упомянутых опцией -U, в группу, 
  не удаляя уже имеющихся участников;

 -U ПОЛЬЗОВАТЕЛИ - список членов этой группы;

Команда groupdel удаляет группу: groupdel [опции] groupname. Опция -f позволяет 
принудительно удалить группу, даже если это основная группа пользователя.

Команда grpck, подобно pwck, проверяет целостность групп: sudo grpck -r /etc/passwd.  

В Linux для каждого файла и каталога устанавливаются разрешения (права), которые 
используются для разграничения доступа. Разрешения указывают, кто может производить 
чтение или запись файлов, а также выполнять исполняемые программы.

Разрешение состоит из 3х битов: [read][write][execute].

Первый бит указывает можно ли окрыть файл, либо можно ли получить содержимое каталога.
Второй бит указывает можно ли изменить содержимое файла, либо можно ли создавать 
и удалять файлы в каталоге. Третий бит указывает можно ли выполнить файл, 
либо можно ли перейти к каталогу (например с пом. команды cd).

Разрешение указывается тремя частями:
 * разрешение для пользователя-владельца;
 * разрешение для группы-владельца;
 * разрешение для остальных пользователей.

Сначала система проверяет, является ли пользователь владельцем файла. Если да, то он 
получает разрешения для пользователя-владельца. Если нет, то система проверяет, 
является ли пользователь членом группы-владельца (группа файла). Если да, то он 
получает разрешения для группы владельца. Иначе пользователь получает 
разрешения для остальных пользователей.

Пример разрешения: 100 100 100 (файл доступен только для чтения: 
пользователю, группе и всем остальных).

При установке разрешений применяются десятичный цифры, т.е. предыдущий 
вариант можно задать как 444.

Вместо битов часто применяются символьные маркеры. Если бит установлен то записываются 
r, w, x, в нужных позициях. Если бит остутствует то применяется дефис. 
Например разрешение 100 отображается как r--, а 111 как rwx.

Т.о. разрешение 100 100 100 принимает вид r--r--r--, а 111 111 111 - rwxrwxrwx.

Команда chmod используется для установки разрешений файлу или каталогу:
 chmod [опции] разрешения файл/каталог

Например: chmod 700 ~/Documents/test  -->  каталог доступен только 
                                           для пользователя-владельца.

Если каталог имеет содержимое, то по умолчанию оно не получит указанные разрешения.
Чтобы рекурсивно изменить права доступа ко всем вложенным файлам и каталогам, 
применяется флаг -R.

Также для установки разрешений можно применять относительный режим:

 chmod u=rwx,g=rwx,o=- ~/Documents/test  -->  u - это пользователь-владелец,
                                              g - группа-владелец, o - все остальные

При изменении разрешений в относительном режиме можно добавить или удалить 
резрешение сразу всем частям: chmod +x myfile.

Также доступны и более сложные команды:
 chmod g+w,o-r myfile  -->  группе-владельцу добавится право на запись, 
                            а у всех остальных удалится право на чтение 

Команда chown изменяет владельца и группу файла или каталога:
 sudo chown username:groupname ~/Documents/test

Команда chgrp позволяет сменить группу для каталога, не затрагивая владельца.
Как и в случае с chmod, эти команды можно применять рекурсивно с помощью флага -R.

Пользователь, создавший файл, автоматически становится пользователем-владельцем, 
а его основная группа становится группой-владельцем.

Некоторые разрешения в конце содержат символ t. Это т.н. sticky bit: drwxrwxrwt.
Он используется для защиты файлов от случайного удаления, в среде, где файлы могут 
создавать несколько пользователей (в одном каталоге). Обычно он применяется
в как разрешение по умолчанию для каталога /tmp.

------------------

ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ

Когда пользователь входит в систему, используется конфигурация, заданная в /etc/profile.
Этот файл определяет настройки оболочки для всех пользователей при входе в систему.
Он также может включать команды, которые необходимо выполнить при вервом входе.

Кроме /etc/profile, в системе также имеется файл .profile, который создается
в домашнем каталоге пользователя и который определяет настройки только для текущего
пользователя. Этот файл выполняется последним, поэтому в случае конфликта настроек
последнее действие всегда за ним.

Кроме того, когда пользователь открывает окно терминала, применяется еще один файл 
конфигурации - /etc/bashrc, а также его версия для конкретного пользователя - ~/.bashrc. 

Во многих дистрибутивах /etc/profile включает в себя исходный код /etc/bashrc.
Поэтому если необходимо, чтобы при входе в систему и при запуске терминала применялись 
какие-то натройки, то их можно определить именно в bashrc-файлах.

После внесения изменений в эти файлы их новые настройки надо активировать.
Для этого используется команда source или ".": source ~/.bashrc либо . ~/.bashrch

Переменная окружения - это некоторое значение, используемое оболочкой.
Системные и пользовательские переменные доступны с момента загрузки системы.

Команда env используется для получения всех переменных окружения.

Источником новых переменных для всех пользователей явялется файл /etc/profile.
Соответсвенно если переменная нужна только для текущего пользователя, 
то она записывается в .profile.

Некоторые дистрибутивы хранят все переменные (и настройки оболочки) только в bashrc.
Для установки новой переменной, необходимо записать её в конце файла.

Команда echo используется для вывода значения переменной. 
Имя переменной должно предваряться символом "$": echo $MY_CUSTOM_VAR.

С помощью echo можно и установить переменную: echo HELLO=Hello_World >> ~/.bashrc

------------------

УПРАВЛЕНИЕ ПРОЦЕССАМИ

При запуске Linux сначала запускается ядро. Ядро запускает первый процесс - systemd.
Этот процесс отвечает за все остальные процессы. Каждый процесс запускает свои дочерние 
процессы и так образуется дерево, которое можно просмотреть с пом. команды pstree.

Команда ps используется для мониторинга процессов. 
Обычно она вызывается в комбинации с опциями "aux" либо с флагом -ef.

Опция "a" обеспечивает отображение всех процессов, "u" предоставляет расширенную 
информацию об использовании, а "x" показывает с какого TTY и каким 
пользователем запускается процесс.

Выводимые столбцы "aux":

 * USER - имя пользователя, запустившего процесс;
 * PID - идентификатор процесса;
 * %CPU - процент процессорного времени, использ. процессом с момента запуска;
 * %MEM - процент памяти, используемый процессом в данный момент;
 * VSZ - общий объем памяти, затребованный процессом;
 * RSS - общий объем памяти, используемой процессом в данный момент;

 * TTY - терминал, с которого был запущен процесс (знак вопроса указывает 
   на процесс демона, который не связан ни с каким TTY);

 * STAT - текущее состояние процесса;
 * START - время запуска процесса;
 * TIME - общее кол-во системного времени, использ. процессом с момента запуска;

 * COMMAND - команда, которая использовалась для запуска процесса (если имя заключено 
   в квадратные скобки, процесс запускается не в терминале, а является потоком ядра). 

Выводимые столбцы -ef:
 UID - имя пользователя, запустившего процесс;
 PID - идентификатор процесса;
 PPID - идентификатор родительского процесса;
 C - аналогично %CPU;
 STIME - аналогично START;
 
Эту команду можно сочетать с командами обработки текста:
 ps aux | grep chrome  -->  все процессы, связанные с Google Chrome

Команда top предоставляет сводку по наиболее активным процессам.
Она автоматически обновляет сводку каждые 5 минут.

Верхние 5 строчек показывают, что делает система:

1) текущее время; время работы системы; кол-во пользователей, подключен. к системе; 
числа показывающие, насколько загружен компьютер относительно кол-ва процессов/ядер 
компьютера, за минуту, последние 5 минут и последние 15 минут соответственно;

2) общее кол-во задач; задачи, кот. активно обслуживались во время последнего цикла опроса; 
задачи, кот. не были активны в последнем цикле опроса; задачи, для кот. родительский процесс 
больше недоступен и, следовательно, их нельзя остановить или управлять ими (зомби);

3) Эта строка показывает информацию об использовании процессора. 
Её информация может дать представление о том, что именно делает компьютер: 

 * us - объем нагрузки пользовательских процессов (без root и не без прямого доступа к ядру);
 * sy - объем нагрузки системных процессов (запущенные с правами root);
 * ni - процессы, приоритет кот. был настроен с пом. команды nice;
 * id - активность цикла ожиданий (процент бездействия в системе);

 * wa - кол-во времени, в течен. которого система ожидала выполнения операций IO; 
   если значение высокое, то на компьютере много задач, связанных с вводом-выводом и что 
   хранилище не может эффективно справиться с ними (среднее значение выше 30% может указывать 
   на то, что канал IO не работает должным образом);

 * hi - кол-во времени, которое компьютер потратил на обработку аппаратных прерываний 
  (должно быть низким, иначе это указ. на то, что использ. плохо функционирующие драйверы);

 * si - кол-во времени, которое система потратила на обработку программных прерываний;
 * st - кол-во времени, которое было украдено у процессора виртуальными машинами.

4) Показатели использования памяти:
 * total - общий объем памяти в мегабайтах (в виде установленной оперативной памяти);
 * free - объем памяти, который в данный момент ни для чего не используется;
 * used - объем памяти, использ. в текущий момент программами и службами;
 * buff/cache - объем памяти, использ. для кеширования запросов на чтение и запись.

5) Аналогичные показатели, толька для swap'а.

В нижней части приведена информация о процессах (некоторые столбцы описаны выше):

 * PR - приоритет процесса; процессы с более высоким приоритетом обслуживаются раньше 
  (выражаются меньшим числом); некоторые процессы имеют приоритет RT (реального времени), 
   что означает, что они могут получать доступ к системным ресурсам в любое время;

 * NI - указывает, какой из процесов с одинаковыми приоритетами имеет больший приоритет;

 * VIRT - зарезервированная память процесса (все процессы могут резервировать вирутальную 
   память из общего адресного пространства в 32 ТБ);

 * RES - резидентная память (та, которая выделена процессу и которая 
   в настоящее время активно используется);

 * SHARE - библиотеки, используемые процессом;
 * S - тоже, что и STAT;

Если надо отобразить доп. столбцы, то нужно нажать F.
С пом. клавиш Влево-Вправо и Enter можно переключить включение столбца в сводку.
Для выхода из сводки процессов нужно нажать Q.

Основные опции top:
 -d SECS - устанавливает интервал обновления;
 -o FIELD - сортирует по полю;
 -p PIDLIST - мониторинг только указанных процессов;
 -U USER - фильтрует процессы по пользователю.

Команда top не выводит информацию о том, какие из процессов нагружают жесткий диск. 
Для этого есть другая команда - iotop (устанавливается отдельно).

Команда pgrep позволяет найти идентификатор процесса и некоторую доп. информацию 
по определенному шаблону: pgrep [опции] шаблон.

Процесс должен соответствовать шаблону, а опции указывают, как интерпритир. этот шаблон.

Основные опции pgrep:
 -l - выводит список идентификаторов и имя команды;
 -a - список идентификаторов и полное имя команды;
 -v - ищет все процессы, которые не соответствуют шаблону;
 -c - кол-во процессов, которые соответствуют шаблону;
 -f - использует полное имя процесса;
 -i - не учитывает регистр шаблона;
 -n - выбирает наиболее новые процессы;
 -o - выбирает наиболее старые процессы;
 -O SECONDS - выбирает процессы, которые запушены как минимум SECONDS секунда назад;
 -P PPID - выбирает только дочерние процессы, процесса с идентификатором PPID;
 -u ID - выбирает процессы по определенному пользователю;
 -x - устанавливает точное соответствие имени команды;

Примеры использования pgrep:

 pgrep chrome  -->  идентификаторы всех процессов, кот. запускаются командой chrome
                    (т.е. все процессы браузера Google Chrome)

 pgrep *gnome*  -->  идентификаторы всех процессов, у котор. команда содежит "gnome"
                     (звездочка - это произвольное кол-во любых символов)

 pgrep -a *gnome*  -->  тоже самое, только с полным именен команды
 pgrep -l -u username  -->  выбор процессов по пользователю
 
Идентификаторы процессов по имени команды можно получить и с помощью pidof.

Для завершения процесса можно использовать след. команды: kill, pkill и killall.
При использовании одной из этих команд можно также отправить процессу определенный сигнал.
Всего доступно 32 сигнала, 4 из которых являются общими.

Список общих сигналов (в скобках указаны их номера):

 * SIGHUP (1) - используется при изменении файла конфигурации; 
   позволяет процессу применить новые настройки конфигурации;

 * SIGKILL (9) - принудительно завершает процесс; используется только если процесс 
   не останавливается после отправки ему сигнала 15 (т.к. есть риск потери 
   несохраненных данных из открытых файлов);

 * SIGTERM (15) - запрашивает завершение процесса; процесс может это игнорировать;
 * SIGUSR1 (30) - посылает определенным пользователям сигнал.

Команда kill самая простая. Записывается она так: kill [-s signame | -n signum] PID

 kill 10848  -->  убить процесс под заданным PID
 kill 10848 3822  -->  убить сразу несколько процессов

Команда killall позволяет более точно указывать процессы, кот. надо завершить:
 killall -r chrome_  -->  завершить процессы, имена кот. имеют "chrome_"

Основные опции killall:
 -I - игнорирует регистр имени процессов;
 -r - позволяет указать рег. выр-е, которому должны соотв. процессы;
 -u - позволяет указать пользователя, процессы которого будут завершены.

Команда pkill завершает процесс на основании его имени или атрибутов.
 pkill chrome  -->  завершить все процессы браузера

Основные опции pkill похожи на те, что имеются у pgrep.

Процессы могут запускаться самостоятельно, через определенные интервалы времени.
Для этого используются cron'ы. Ядром этого инструмента является процесс cron crond,
который автоматически запускается на Linux и каждую минут проверяет свою конфигурацию.

По умолчанию cron считывает свой главный файл конфигурации - /etc/crontab.
Этот файл управляет всеми заданиями, которые должны быть запланированы через cron
(его лучше не изменять, поскольку он может перезаписаться при обновлении).

Каждая крона состоит из 3х элементов (примеры в /etc/crontab):

1) Указание времени, когда команда должна быть запущена.
Для этого используются 5 компонентов: минуты, часы, день_месяца, месяц, день_недели.

2) Указание имени пользователя, с разрешениями которого должна выполняться крона.
3) Указание команды, которую необходимо выполнить.

Пример кроны, которая запускает команду test -x /usr/sbin/anacron, от имени root, 
каждое 1 число, любого месяца в 6:52: 

 52 6    1 * *    root    test -x /usr/sbin/anacron

Помимо системного crontab, отдельные пользователи могут иметь свой crontab.
Обычно это стандартный способ планирования заданий.

Для работы с пользовательским crontab использ. команда: crontab -e. Она отображает все 
запланированные задачи пользователя, и тут же предлагает создать новую. Для этого сначала 
нужно выбрать редактор (нажать 1, 2, или 3), а затем записать в нем саму крону.

Альтернативой внесению изменений в /etc/crontab, является создание файлов с кронами в 
каталоге /etc/cron.d. Эти файлы будут включены при запуске процесса cron. Преимущество этого 
способа в том, что кроны не потеряются при обновлении ПО.

Также сron использ. четыре отдельных каталога для планировки заданий через равные промежутки 
времени: /etc/cron.hourly, /etc/cron.daily, /etc/cron.weekly и /etc/cron.monthly.
Сожержимое этих каталогов - это bash-скрипты.

------------------

УПРАВЛЕНИЕ СЕТЕВЫМИ ПОДКЛЮЧЕНИЯМИ



