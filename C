ВВЕДЕНИЕ

Программа на Си состоит из набора директив препроцессора, определений ф-ций 
и глобальных данных.

Каждая инструкция выполняет определенное действие. В конце инструкции ставится точка 
с запятой. Набор инструкций задается блоком кода, который определяется фигурными скобками.

Стартовой точкой выполнения кода является ф-ция main(). Эта ф-ция может возвращать либо
число, либо void. Если main() возвращает число, то ноль означает успешное выполнения
программы, а другие числа - какую-то ошибку.

 int main(void) {} 
 void main(void) {}

Компиляция программы с помощью командной строки: gcc myfile.c

После компиляции будет создан исполняемый файл a.out
Переопределить имя исполняемого файла можно с помощью флага -o: 

 gcc myfile.c -o myprog.out

По умолчанию при компиляции не отобрадается никаких предупреждений. Для компиляции 
с предупреждениями нужно ипользовать флаг -Wall:

 gcc -Wall myfile.c

С помощью флага -std= можно задать стандарт языка, например c99, c11, c17. 
А чтобы гарантировать, что программа будет строго соответстовать определенному стандарту,
можно задать флаг -pedantic.

 gcc -std=c11 myfile.c
 gcc -std=c17 -Wall -pedantic myfile.c & ./a.out  -->  скомпилировать и запустить

Флаг -S позволяет сгенерировать файл с ассемблерным кодом (ассемблер GAS).
 gcc myfile.c -S  -->  создаст файл myfile.s

Если вместо кириллицы отображаются непонятные знаки, то в код нужно добавить вызов
setlocale(LC_ALL, ""); Эта ф-ция станет доступна после подключения locale.h

----------------------

ОСОБЕННОСТИ ЯЗЫКА

Базовые типы данных и их размеры:

 * char - символ 1 байт (signed char);
 * unsigned char - беззнаковый символ 1 байт;

 * short - число 2 байта (short int, signed short, sifned short int);
 * unsigned short - беззнаковое число 2 байта (unsigned short int);

 * int - число, 2 байта для x32 и 4 байта для x64 архитектур (signed, signed int);
 * unsigned int - беззнаковое число 2/4 байта (unsigned, unsigned int);

 * long - число, 4 байта для Windows_x64 и 8 байт для Linux_x64/MacOS_x64;
   (long int, signed long int, signed long)

 * unsigned long - беззнаковое число 4/8 байт (unsigned long int);

 * long long - число 8 байт (long long int, signed long long int, signed long long);
 * unsigned long long - беззнаковое число 8 байт (unsigned long long int);

 * float - вещественное число 4 байта;
 * double - вещественное число 8 байт;
 * long double - вещественное число 10 байт;

 * void - тип без значения;

Любое десятичное число, в зависисоти от размера, рассматривается как: 
int, long int или long long int. И при присвоении в переменную другого типа неявно
преобразуется. Чтобы избежать ненужного преобразования, к числу добавляется суффикс:

 * u/U - unsigned int, unsigned long int и unsigned long long int;
 * ul/UL - unsigned long int и unsigned long long int;
 * ll/LL - long long int;
 * ull/ULL - unsigned long long int;

 unsigned int a = 1;  -->  выполнится неявное преобразование из int в unsigned int
 unsigned int b = 2u;  -->  здесь неявное преобразование пропустится

Вещественные числа по умолчанию представлены как double. Чтобы указать, что число 
имеет тип float или long double нужно добавить суффикс f или l соответсвенно:

 double a = 3.14;
 float b = 3.14f;
 long double c = 3.14l;

Числа в двоичной системе начинаются с префикса 0b, восьмеричные числа начинаются с 0, 
а шестнадцатиричные с 0x. После префикса указывается число в заданной системе.

 int a = 0b1011;  -->  11 в двоичной системе
 int b = 013;     -->  11 в восьмиричной системе
 int c = 0xB;     -->  11 в шестнадцатиричной системе

Char-переменная в качестве значения принимает символьный литерал в одинарный кавычках.
Однако в реальности такая переменная хранит число - код символа из таблицы ASCII.
Т.е. символьные литералы в одинарных кавычках - это данные типа int.

 char a = 'A';  -->  65
 char b = 65;   -->  тоже самое

Оператор typedef позволяет задать псевдоним для типа: typedef тип псевдоним
 
 typedef unsigned char BYTE;
 BYTE num = 22;

Стандарт указывает лишь минимальные размеры для базовых типов. Однако предельные размеры 
могут отличаться, в зависимости от компиляторов. Чтобы точно знать размер типа используется
оператор sizeof, который возвращает кол-во памяти в байтах. 

 size_t size1 = sizeof(int);
 size_t size2 = sizeof(unsigned long);

Возвращаемое значение оператора sizeof представлено типом size_t, который является просто
псевдонимом другого числового типа. В одних системах size_t может быть unsigned long, 
в других чем-то еще. Поэтому при работе с sizeof нужно использовать именно size_t.

Оператор sizeof может также вычислять размер переменной или даже целого выражения 
(переменную или выражение можно указывать как в скобках, так и без).
 
 int num = 2;
 size_t numSize = sizeof(num);  -->  4 (размер типа переменной)

 // Вычислит размер возвращаемого типа, т.е. 4, потому что printf() 
 // возвращает int. При этом сама ф-ция не выполнится.

 size_t expSize = sizeof printf("hello!");                 

Для вывода на консоль используется ф-ция printf().
Она становится доступной после подключения заголовочного файла stdio.h

 printf("hello world!");

Выводимая строка может также содержать спец. символы, например \n, \r, \t и др.
Для вывода других типов данных используются спецификаторы:

 %c - для вывода букв;
 %s - для вывода строк;
 %d - для вывода целых чисел;
 %u - для вывода целых беззнаковых числе;
 %i - для вывода чисел типа int;
 %f - для вывода вещественных чисел (float, double);
 %o - для вывода восьмеричных чисел;
 %x - для вывода шестнадцатиричных чисел;
 %X - для вывода шестнадцатиричных чисел в верхнем регистре;
 %% - для вывода знака процента;

 printf("char: %c \n", 'a');
 printf("string: %s \n", "hello!");
 printf("number: %u \n", 23);
 printf("name: %s age: %d weight: %f", "Tom", 23, 63.5);

Для вывода вещественных чисел можно использовать ширину поля и точность. 
 printf("x: %4.2f", 71.8925)  -->  71.90 

В спецификаторе %4.2f, 4 означает до скольки знаков выводить перед точкой, 
а 2 - до скольки знаков выводить после точки.

Чтобы конкретизировать выводимое значение, можно задать модификатор:
 * h - для значений short int;
 * l - для значений long int и unsigned long int;
 * ll - для значений long long int и unsigned long long int;
 * L - для значений long double;

 printf("x: %hd", 7100);

Можно также задать доп. флаги чтобы более точно настроить вывод. Например, знак "-" сделает
выравнивание текста по левому краю, а число 9 (перед s) - это скорей всего доп. пробелы.

 printf("%-9s %d", "Tom", 38);  -->  "Tom       38"

Для определения константы используется ключевое слово const: 
 const int num = 23;

При делении целых чисел, результат округляется до целого, даже если он присвоен float.
Чтобы получить вещественное число, один из операндов должен также быть вещественным числом.

 float a = 10 / 4;    -->  2.0
 float b = 10.0 / 4;  -->  2.5
  
Логические операции не возвращают последний доступный операнд, как в JS, 
а только 1, если выр-е истино или 0, если выр-е ложно.

Логическое отрицание возвращает 1 если операнд равен 0.
Логическое умножение (конъюнкция) возвращает 1, если оба операнда не равны 0.
Логическое сложение (дизъюнкция) возвращает 1, если хотя бы один операнд не равен 0.

      !2  -->  0        !0  -->  1
 -2 && 5  -->  1    0 && 7  -->  0
 -2 || 5  -->  1    0 || 7  -->  1

Операции сравнения (>, >=, <, <=, ==, !=) имеют больший приоритет, чем логические. 
Они также возвращают либо 0, либо 1.

Операции сдвига (<<, >>) сдвигают битовое представление числа вправо или влево 
на заданное кол-во разрядов:

  2 << 2  -->  8 (00010 -> 01000)  
 16 >> 3  -->  2 (10000 -> 00010) 

Поразрядные операции сравнивают биты операндов между собой (делают побитовое сравнение).
Условия поразрядных конъюнкции и дизъюнкции такие же как и у логических. Поразрядное
исключающее ИЛИ (^) возвращает 1 если только один из сравниваемых битов равен 1.
Поразрядное отрицание (~) инвертирует все биты операнда. 

 6 & 2  -->  2 (0110 & 0010 -> 0010)
 5 | 2  -->  7 (0101 | 0010 -> 0111)
 5 ^ 6  -->  3 (0101 ^ 0110 -> 0011)
 ~10  -->  -11 (01010 -> 10101)

В примере выше, при выполнении ~10, получается код отрицательного числа, т.к. старший бит
равен 1. Система воспринимает его как дополнительный код, поскольку для записи отрицательных
чисел используются именно дополнительные коды. Отсюда и такой результат -11.

Дополнительный код отрицательного числа - это его обратный код + 1. Обратный код находится
путем инверсии всех битов, кроме последнего (старшего), т.к. тот отвечает за знак.

 -11 = 11011 (прямой код) -> 10100 (обратный код) -> 10101 (дополнительный код)

Стоит отметить также, что операция ~10 выдает обратный код числа -10. А обратный код числа
всегда соответвуюет дополнительному коду следующего числа, т.е. -11.

Если в арифметических операциях участвуют значения разных типов, то компилятор неявно
приведет их к одному типу. Обычно к самому большему. 

 int a = 10;
 double b = 4;
 double c = a + b;  -->  14.00000 ("a приводится к double")

Приведение типов может сопровождаться потерей информации, например когда переменная 
большего типа приводится к переменной меньшего типа. Посему приводить нужно 
только от меньшего типа к большему.

 int a = 300;
 char b = a;  -->  44 (в других языках потребовалось бы явное приведение, через скобки)
 long c = a;  -->  300

В примере выше, при присвоении b = a, происходит срез байтов 
и остается только первый младший байт.

 00000000000000000000000100101100  -->  00101100

Операторы if и switch, а также тернарный оператор принимают только выражения, которые
возвращают какое-то число. Ненулевое згачение означает истину, а ноль - ложь.

Циклов всего 3: for, while и do...while.

Чтобы инициализировать массив, используется набор значений в фигурных скобках.
Если присвоить пустые фигурные скобки, то элементы получать значения по умолчания.

При объявлении массива с инициализацией можно явно не указывать его длину.
Не обязательно инициализировать все элементы, можно только несколько первых.
Также можно частично инициализировать некоторые элементы (не по порядку).

 int a[4];                      
 int b[3] = {};                  -->  0, 0, 0
 int c[] = { 1, 2, 3 };          -->  1, 2, 3
 int d[5] = { 10, 12 };          -->  10, 12, 0, 0, 0
 int e[5] = { [1]=11, [3]=13 };  -->  0, 11, 0, 13, 0

Оператор sizeof также вычисляет размер массива в байтах и возвращает size_t, 
который можно вывести на консоль, с пом. спецификатора %zu.

 int arr[] = { 5, 6, 7 };
 size_t arrSize = sizeof(arr);  
 printf("%zu", arrSize);  -->  12 (3 элемента по 4 байта)

При переборе массива в цикле, для i рекомендуется задавать тип size_t, 
т.к. он гарантирует что i не выйдет за пределы типа.

При динамической установке размера массива его нельзя инициализировать 
через фигурные скобки.

 int size = 2;

 // Так нельзя
 int a[size] = { 1, 2 };

 // Так можно
 int b[size];
 b[0] = 1;
 b[1] = 2;

Чтобы запретить изменение элементов массива, нужно сделать массив константным:

 const int arr[3] = { 11, 12, 13 };  
 arr[1] = 22;  // ошибка

Многомерный массив определяется следующим способом:

 int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };

 // Тоже самое, поскольку все массивы - это непрерывный блок данных в памяти
 int b[3][2] = { 1, 2, 3, 4, 5, 6 };  

 printf("%d", a[2][0]);  -->  5

В Си строки - это массивы символов, где последний элементом является '\0' - нулевой байт.
Нулевой байт служит признаком окончания строки (первый символ из таблицы ASCII).

 char msg1[] = "Hello";
 char msg2[] = { 'H', 'e', 'l', 'l', 'o', '\0' };  // тоже, что и "Hello"

 sizeof(msg1) / sizeof(char);  -->  6
 
Для ввода с консоли используется ф-ция scanf(). Она определена в заголовочном файле stdio.h
Эта ф-ция принимает шаблонную строку и аргументы в виде набора переменных, куда будут
считываться данные. Переменные передаются по ссылке. 

Шаблонная строка содержит спецификаторы, которые определяют вводимые данные. Например, 
с ее помощью можно задать ввод сразу нескольких значений, либо задать ограничение на кол-во
вводимых символов. В качестве разделителя ввода можно испльзовать пробелы.

 int count;
 double price;
 long code;

 scanf("%d", &count);
 scanf("%lf %ld", &price, &code);
 
Пример считывания строки:

 char name[10];

 // Имя массива - это адрес его первого элемента
 // Ширина поля 10 означает, что считываться будут только 10 символов, 
 // а затем считывание прекратится.

 scanf("%10s", name); 

Если нужно вводить также пробелы, тогда спецификатор нужно изменить на "%10[^\n]".
Запись [^\n] означает, что надо считывать ввод до тех пор, пока не встретиться символ
перевода строки '\n', т.е. пока пользователь не нажмет на Enter.
 
----------------------

УКАЗАТЕЛИ

Указатель хранит адрес переменной в памяти. Адрес переменной представляет собой 
целочисленное значение, выраженное в шестнадцатиричном формате.

Указатель всегда указывает на начало переменной. Например, переменная типа int занимает в
памяти 4 ячейки (поскольку каждая ячейка хранит по одному байту). Указатель на такую
переменную будет хранить адрес только первой ячейки из 4 выделенных.

При этом размер указателя равен 8 байт (4 байта на x32 архитектуре), 
независимо от того, на какой тип он указывает.

Чтобы получить переменную указателя, к нему применяется операция * (разыменовывание),
Чтобы получить адрес переменной - к переменной применяется операция &. 

Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить
ему условное нулевое значение с помощью константы NULL, которая хранится в stdio.h

 int* p = NULL;

Используя указатель, можно менять значение переменной, адрес которой он хранит.

 int a = 10;
 int* p = &a;
 *p = 45;  -->  a = 45

Для вывода указателя используется спецификатор %p. При выводе адреса, ф-ция printf() 
ожидает, что указатель будет типа void* (иначе могут быть предупреждения).

 printf("%p", (void*)p);

Указатель типа void* указывает на данные любого типа. Однако к такому указателю нельзя
применить операцию разыменовывания и тем самым получить значение по адресу.
Чтобы получить значение, нужно привести void* к конкретному типу.

 int b = 23;
 void* p2 = &b;

К указателям одного типа могут применятся операциии сравнения (>, >=, <, <=, ==, !=).
Для сравнения используются номера адресов.

К указателям можно также применять арифмитеческие операции (кроме void*): 
 * инкремент/декремент - изменение адреса на размер типа;
 * добавление/удаление числа - изменение адрес на размер типа * число;
 * вычитание указателя - расстояние между адресами;

Расстояние между адресами - это кол-во значений, которые могут там поместится. 
Оно представлено типом ptrdif_t. Этот тип является псевдонимом long long.

Операции всегда выполняются справа на лево. Следует всегда следить за этим:

 // Сначала выполнится сдвиг адреса p++, 
 // а затем по новому адресу будет выполнено разыменование
 int b = *p++;    -->  6356629

 // Нужно добавить доп. скобки
 int c = (*p)++;  -->  46

 // Здесь все правильно, т.к. порядок операций идет справо на лево
 int d = ++*p;    -->  47

С помощью указателей можно изменять значения любых переменных, даже констант констант.
Несмотря на то, что константы вроде как представляют неизменяемые сущности.
 
 const int a = 10;
 int* p = &a;
 *p = 20;  // допустимо (a = 20)
  p = &b;  // допустимо

Чтобы запретить измение переменной указателя, нужно создать указатель на константу.
Но такому указателю можно присвоить новый адрес.

 const int* p = &a;
 *p = 20;  // ошибка
  p = &b;  // допустимо

Чтобы запретить измение адреса указателя, нужно создать константный указатель.
Но измение переменной указателя будет доступно.

 int* const p = &a;
 *p = 20;  // допустимо
  p = &b;  // ошибка

Чтобы запретить измение и переменной, и адреса указателя нужно создать 
константный указатель на константу.

 const int* const p = &a;
 *p = 20;  // ошибка
  p = &b;  // ошибка

Имя массива является адресом его первого элемента, а точнее адресом первого байта, 
первого элемента. Прибавляя определенное число к имени массива можно получить
указатель на соответсвующий элемент.

 int arr[] = { 1, 3, 2, 4 };
 int first = *arr;  -->  1

 // Сместив адрес массива на 4 байта, получаем адрес 2 эл-та
 int second = *(arr + 1);  -->  3 

Когда идет обращение к элементу массива через квадратные скобки, компилятор рассматривает
такую запись как прибавление числа к имени массива.

 arr[2]; arr + 2; // одно и то же.

К элементу можно обратиться даже так: 3[arr]  -->  3 + arr  -->  4 

В Си для представления строки можно использовать указатель на char.
Но в таком случае изменять элементы не получится.

 char* str = "hello world!";
 str[1] = 'a';  // ошибка
 *str = 'B';    // ошибка

Чтобы была возможность изменять элементы строки, нужно использовать массив char.

 char str[] = "hello world!";
 str[1] = 'a';  // допустимо
 *str = 'B';    // допустимо

Указателям на char можно присваивать значение NULL. Однако этот случай нужно отличать 
от пустой строки. Пустая строка имеет один символ - нулевой байт.

 char* str = NULL;   // строка без инициализации
 char* str2 = "\0";  // пустая строка 

Массив указателей определяется следующим способом:

 int* p[3] = { &a, &b, &c };
 const a = *p[0];  // обычный способ получить значение эл-та

 // Сначала происходит сдвиг на 4 байта (p + 1)
 // Затем разыменовываем p и получаем адрес сдвига (т.е. b)
 // После этого разыменовываем сам адрес b

 const b = **(p + 1);

Для работы с многомерными массивами используются указатели на массивы. 
Такие указатели по сути указывают на подмассивы:

 int arr[3][2] = { {1, 2}, {3, 4}, {5, 6} };

 // Здесь размерность массива это часть определения указателя. 
 // Такому указателю нельзя задать адрес массива с большей размерностью

 int (*p)[2] = arr + 1;
 int (*p2)[] = arr + 2;  // размерность вычислится автоматически
 int (*p3)[2] = &arr;    // ошибка, arr содержит больше 2х элементов

 printf("%d", (*p)[0]);  -->  3

Если указатель на char можно представить в виде строки, то массив char-указателей
представляет собой массив строк:

 char* arr[] = { "hello", "world" };
 char* str = arr[1];

Указатель на указатель хранит адрес указателя на переменную. 
Это называется многоуровневая адресация.

 int a = 20;
 int* p = &a;
 int** pp = &p;

 // Разыменовав указатель мы получаем значение переменной, на которую он указывает. 
 // Следовательно, разыменовав "pp" мы получаем значение "p", т.е. адрес "a".

 printf("%p", *pp); -->  адрес a  
 printf("%d", **pp); --> значение a

Они часто используются при выделении динамической памяти для многомерных массивов.

----------------------

ФУНКЦИИ

Компилятор должен знать о ф-ции до ее вызова, поэтому сначала идет определение ф-ции, 
а только потом вызов. Вместо определения ф-ции можно сначала указать прототип. 
В этом случае вызов ф-ции станет доступен перед определением.

Если ф-ция принимает параметры, то в ее прототипе должны указываться только их типы, 
без названий. Если ф-ция не принимает параметров, то в ее прототипе нужно указать void.

(обычно void в параметрах указывают не только в прототипе но и в определении, 
чтобы компилятор не выдавал лишних предупреждений в процессе работы)

 int add(int, int);
 void log(void);

 int main() {
     log(); 
     return 0;  
 }

 void log() {
     int res = add(1, 2);
     printf("Result: %d", res);
 }

 int add(int x, int y) {
     return x + y;
 }
 
Если в ф-цию передать значение другого типа, то компилятор попытается выполнить 
приведение типов.

 add(1, 2.5);  // ф-ция получит числа 1 и 2    

При компиляции ф-ции, для ее параметров выделяются отдельные участки памяти. 
При этом для параметров типа float формируются участки с типом double, 
а для char и short - участки с типом int.

При вызове ф-ции вычисляются значения передаваемых аргументов, а затем эти значения 
заносятся в участки памяти, отведенные для параметров. Значения типа float станут double, 
а char и short станут int.

После завершения работы ф-ции, память, выделенная для параметров, освобождается.

Иногда бывают ситуации, когда нужно гарантировать, что параметр сохранит свое значение 
на протяжении всей работы ф-ции. В этом случае параметр должен быть константным.

Это особенно актуально при работе с указателями, т.к. через них можно  
изменить исходное значение переменной.

 int myFunc(const int* num) {}
 
Если ф-ция возвращает тип void, и явно не вызывает оператор return, 
то компилятор сам добавит его в конце.

 void myFunc() {
     printf("hello world");
     return;  // добавится автоматически   
 }

При определении рекурсии, все рекурсивные вызовы должны обращаться к подфункциям, 
которые в конце концов сведутся к базовому варианту. Это так называемый рекурсивный спуск.

Вместо рекурсий можно использовать циклы. Они работают быстрее и эффективнее.
Но рекурсии дают более элегатные решения. Например, при обходе деревьев.

Если локальная переменная определена без инициализации, то она получит мусорное значение.
Если глобальная переменная определена без инициализации, то она получит значение 0.

Область видимости локальных переменных - это блок кода. Как только блок кода начинает
выполняться, то для его переменных выделяется память. После завершения работы блока кода,
выделенная память освобождается и переменные удаляются.

Локальные переменные могут быть статическими. Их особенность в том, что они инициализируются
только один раз, а при последующих обращениях используют старое значение из памяти и не
уничтожаются; даже после завершения работы блока кода/ф-ции.

Локальные переменные еще называют автоматическими, потому что они определяются 
в автоматической памяти (стэк?).

Чтобы получить доступ к глобальной переменной из другого файла, нужно объявить ее 
с помощью ключевого слова extern (без инициализации). А чтобы получить доступ к ф-ции 
из другого файла, нужно просто указать ее прототип.

Файл other.c
 
 char msg[] = "hello world!";
 int add(int x, int y) {
     return x + y;
 }

Файл main.c

 #include <stdio.h>

 extern char msg[];
 int add(int, int);

 void main() {
     printf("%s %d", msg, add(1, 2));  -->  "hello world!" 3
 }

При компиляции нужно передать имена всех файлов: gcc main.c other.c

Глобальные переменные и ф-ции также могут быть статическими. 
В этом случае они будут недоступны для использования в других файлах.

Файл other.c

 static char msg[] = "hello world!";
 static int add(int x, int y) {
     return x + y;
 }

Файл main.c

 extern char msg[];  // переменная недоступна
 int add(int, int);  // ф-ция недоступна

Если ф-ция принимает в параметрах массив, то фактически это будет только указатель 
на его первый элемент, а не полноценная коллекция.

 void myFunc(int arr[]) {
     // Так сделать не получится
     size_t length = sizeof(arr) / sizeof(arr[0]);
 } 

Массиву в параметрах можно установить минимальную длину с пом. оператора static:
 void myFunc(int arr[static 4]) {}  // ожидаем массив минимум с 4 эл-тами

Массив можно также передавать как константный. В этом случае значения его 
эл-тов нельзя будет изменить.

Имя ф-ции является адресом первого байта, по которому располагается ее код.
Указателю на ф-цию можно присвоить ту ф-цию, сигнатура которой соответвует его типу.
Его синтаксис напоминает то, как объявляется указатель на массив (тоже в скобках).

 // Указатель на ф-цию, которая не принимает никаких параметров 
 // и ничего не возвращает. Здесь также нужно указывать void в круглых скобках.
 void (*p)(void);  

 // Указатель на ф-цию с двумя целочисленными параметрами, 
 // которая возвращает также число
 int (*p2)(int, int);

 p = log;
 p();

 p2 = add;
 int res = p2(10, 20);

Пример объявления массива указателей на ф-ции, которые принимают по два 
параметра типа int и возвращают double:

 double (*p[3])(int, int) = { add, sub, mul };
 double res = p[0](10, 5);

С помощью оператора typedef можно задать псевдоним (тип) ф-ции. Такие псевдонимы упрощают
применение указателей на ф-ции: typedef возвращаемый_тип (псевдоним)(тип_параметра)

 // Здесь message - это псевдоним ф-ции, которая ничего не принимает и не возвращает
 typedef void (message)(void);

 // Здесь msg - это указатель на ф-цию типа message. 
 // Возможно здесь избыточный код, т.к. log это уже сам по себе указатель...
 message* msg = &log; 
 msg();

Псевдоним ф-ции можно определить сразу как указатель на ф-цию.

 typedef double (*operation)(int, int);
 operation ops[] = { add, sub, mul };
 double res = ops[0](10, 5);
 
Ф-ция в своих параметрах может принимать указатель на другую ф-цию. Вместо указателя 
на ф-цию можно также передавать псевдоним (тип) ф-ции.

 void myFunc(int (*p)(int, int), message msg) {
    int res = p(10, 20);
    msg();
 }

 myFunc(add, log);

Ф-ция может возвращать указатель на другую ф-цию. Пример объявления таких ф-ций:

 // Ф-ция myFunc, которая принимает один параметр типа int 
 // и возвращает указатель int (*p)(int, int)

 int (*myFunc(int arg))(int, int) {
     return arg > 0 ? add : sub;
 }

 int (*p)(int, int) = myFunc(1);
 int res = p(10, 20);

 // Ф-ция myFunc, которая ничего не принимает 
 // и возвращает указатель void (*p)(void)

 void (*myFunc())(void) {
     return log;
 }

 void (*p)(void) = myFunc();
 p();

Всесто указателя на ф-цию можно также возвращать псевдоним ф-ции:
 message* myFunc() { return &log; } 

Для определения ф-ции с переменным кол-вом параметром используется многоточие. 
Но при этом ф-ция должна иметь как минимум один обязательный параметр.

 void myFunc(int n, ...) {}

Типы таких параметров могут также быть неопределенными и становится известными только 
во время вызова ф-ции. Для упрощения работы с переменным кол-вом параметров неопределенных
типов, в заголовочном файле stdarg.h имеются специальные макросы:

 // Этот макрос с помощью requeredParam связывает va_list с первым необязательным 
 // параметром, т.е. requeredParam как бы сообщает, где искать первый параметр 
 // и отталкиваясь от него, двигаться по остальным. 
 void va_start(va_list param, requeredParam); 

 // Этот макрос позволяет получить значение текущего параметра 
 // и перемещает указатель va_list на следующий параметр.
 type va_arg(va_list param, type);  

 // Этот макрос завершает обработку параметров
 void va_end(va_list param);

Эти маросы используют тип данных va_list, который позволяет обрабатывать
нефиксированный набор параметров.

 int sum(int count, ...) {
     int res = 0;

     va_list factor;
     va_start(factor, count);  
     for (int i = 0; i < count; i++) {
         res += va_arg(factor, int);
     }   
     va_end(factor);

     return res;
 }

 int res = sum(5, 1, 2, 3, 4, 5);

Ф-ции printf() и scanf() используют этот механиз для работы с переменным кол-вом параметров.
А для идентификации типов параметров используют спецификаторы (%d, %s, %c и др.)
 
Ф-ция main() может получать параметры командной строки, которые передаются программе 
при запуске. Для этого используется следующая сигнатура: int main(int argc, char* argv[]);

Параметр argc - это кол-во передаваемых аргументов, а argv - названия этих аргументов.
По умолчанию, если программе не передается никаких параметров, то argc будет иметь 
значение 1, а argv содержать название программы.

 ./a.out              -->  argc = 1, argv = { "a" }
 ./a.out hello world  -->  argc = 3, argv = { "a", "hello", "world" }

----------------------

ПРЕПРОЦЕССОР

Процесс компиляции программы на Си разделяется на 3 этапа:
1. Препроцессор.
2. Компиляция.
3. Линковка.

Препроцессор, с помощью директив, обрабатывает исходный код программы. Это может быть 
вставка каких-то кусков текста или использование определенного текста в зависимсоти 
от условий и т.п. Результатом работы препроцессора является полноценный код
программы, который передается на компиляцию.

Компилятор компилирует обработанный препроцессором исходный код в объектные файлы.
Линковщик объединяет (линкует) объектные файлы в один исполняемый файл или в библиотеку.

В Си доступны следующие директивы:
 #include - включает текста из файла;
 #define - определяет макрос или препроцессорный идентификатор;
 #undef - отменяет определение макроса или идентификатора;
 #ifdef, #ifndef - проверяет, определен/неопределен ли идентификатор;
 #if, #else, #endif, #elif - директивы условной компиляции;
 #line - меняет номер следующей ниже строки;
 #error - формирует текста сообщения об ошибке трансляции;
 #pragma - определяет действия, которые зависят от конкретной реализации компилятора;

Директива #include имеет 2 формы применения: с угловыми скобками или с кавычками.
Обычно, она вставляет текст из какого-то заголовочного файла. Заголовочные файлы содержат
прототипы ф-ций, объявления переменных и констант, и имеют расширение .h

 #include <stdio.h> 
 #include "stdio.h"

Угловые скобки используются при подключении встроенных заголовочных файлов. 
Поиск таких файлов производится в стандартных системных каталогах.

Список встроенные заголовочных файлов можно посмотреть здесь:
https://metanit.com/c/tutorial/3.1.php

Кавычки используются при подключении пользовательских заголовочных файлов. 
При подключении таких файлов важно соблюдать правильный путь.

Заголовочные файлы должны содержать только объявления (без инициализаций), 
а за определения должны отвечать файлы .c 

Директива #define определяет идентификатор и последовательность символов, 
которые будут подставляться вместо него в коде.

 #define N 23
 #define REAL long double
 #define BEGIN {
 #define END }

 void main() BEGIN             //  void main() {
     REAL x = N;               //      long double x = 23;  
     printf("%Ld", x);         //      printf("%Ld", x);
 END                           //  }

Директива #undef отменяет определение препроцессорного идентификатора.
Это необходимо делать если один и тот же идентификатор определяется повторно
(иначе будут предупреждения при компиляции).

 #define MESSAGE "hello world!"

 printf(MESSAGE);
 
 #undef MESSAGE
 #define MESSAGE "world hello"

 printf(MESSAGE);

Препроцессорный идентификатор можно определить и через командную строку (аналогично тому, 
как это делается с помощью директивы #define). Для этого используется флаг -D

 Файл main.c

 void main() {
     int x = NUMBER;
     printf("%d", x);  -->  23
 }

 gcc -D NUBMER=25 main.c

С помощью #define можно определять и более сложные идентификаторы - макросы.
Они позволяют определять замену не только отдельных символов, но и для целых выражений.

Макрос с параметрами определяется так: #define макрос(параметр1, параметрN) символы
Для обращения к макросу приеняется конструкция: макрос(аргумент1, аргументN)

 #define print(num) printf("Num is: %d \n", num)
 print(1000);  -->  "Num is 1000"  

 ---------- 

 // При работе с многострочным кодом нужно использовать фигурные скобки.
 // Макрос swap является обобщенным. Здесь неважно, какой тип у переменных "x" и "y"

 #define t int
 #define swap(t, x, y) {t temp = x; x = y; y = temp;}
 
 t x = 4;
 t y = 10;
 swap(t, x, y);  // вместо swap будет выр-е в фигурных скобках

 ---------- 

 // При работе с однострочным выражением его нужно заключать в круглые скобки.
 #define min(a, b) (a < b ? a : b)

 int x = 23;
 int y = 14;
 int z = min(x, y);    //  int z = (x < y ? x : y)  

При обработке исходного кода, препроцессор может выполнить две операции: # и ##.
Операция # позволяет заключить название параметра в кавычки.
Операция ## позволяет объединить лексемы.

 #define print(num) printf(#num" = %d", num)
 
 int x = 23;
 int number = 124;

 print(x);       -->  "x = 23"
 print(number);  -->  "number = 124"  
 
 ---------- 

 #define print(a, b, c) printf("%d", "a##b##c")
 print(2, 81, 34);  -->  "28134"

Директивы условной компиляции позволяют, в зависимости от условий, 
добавлять в исходный код определенный текст.
 
 #define N 23 

 void main() {
 #if N == 23
     printf("N = 23");
 #elif N == 24
     printf("N = 24");
 #else
     printf("N is undefined");
 #endif
 }

Директива #ifdef проверяет, определен ли идентификатор, и если так, то позволяет 
добавлять в исходный код определенный текст. Директива #ifndef, наоборот, 
проверят идентификатор на неопределенность.

 #define DEBUG

 void main() {
 #ifdef DEBUG
     printf("debug mode");
 #else
     printf("production mode");
 #endif
 }

Если требуется одновременно проверить значения нескольких идентификаторов, 
то можно использовать специальный оператор defined

 #define BETA
 #define DEBUG

 void main() {
 #if defined DEBUG && !defined BETA
     printf("debug mode, final version");
 #elif defined DEBUG && defined BETA
     printf("debug mode, beta version");
 #else
     printf("undefined mode");
 #endif
 }

Различные архитектуры, операционные системы и компиляторы могут предопределять ряд 
встроенных макросов, которые можно использовать, например, для определения особенности
окружения. Такие макросы обычно начинаются и заканчиваются нижним подчеркиванием.

 void main() {
 #ifdef __GNUC__
     puts("GCC compiler")
 #endif

 #ifdef __x86_64__
     puts("Intel x86 64bit");
 #elif __i386__
     puts("Intel x86 32bit");
 #endif

 #ifdef __WINDOWS__
     puts("Windows");
 #elif __linux__
     puts("Linux");
 #else
     puts("Undefined OS");
 #endif
 }

----------------------

СТРУКТУРЫ

При определении структуры, закрывающая фигурная скобка должна быть с точкой с запятой. 
При объявлении переменной структуры нужно также указывать ключевое слово struct.
Инициализация структуры аналогична инициализации массивов.

 struct person {
     char* name;
     int age;
 };

 // Значения для полей передаются в том порядке, в кот. они заданы при определении.
 struct person tom = { "Tom", 23 };

 // Значения для полей структуры передаются по имени, независимо от порядка
 struct person tom = { .age = 23, .name = "Tom" };

 // Поля можно инициализировать по отдельности
 struct person tom;
 tom.name = "Tom";
 tom.age = 23;

Для обращения к полям структуры используется точка, но если переменная структуры 
является указателем, то вместо точки используется стрелка.

 struct person* tom;
 tom->age = 23;

При определении структуры можно сразу задать ее переменные. В этом случае имя структуры
указывать не обязательно.

 struct person { char* name; int age; } tom, bob;
 struct { char* name; int age; } tom = { "Tom", 360 };

Чтобы не использовать каждый раз ключевое слово struct при объявлении переменной структуры,
можно определить структуру через псевдоним, с помощью typedef:

 typedef struct { char* name; int age; } person;
 person tom = { "Tom", 23 };

Кроме этого, структуру можно определить с помощью директивы #define:

 #define PERSON struct { char* name; int age }
 PERSON tom = { "Tom", 23 };

Структуру можно определять внутри ф-ции или блока кода. В этом случае она будет видна
только в пределах фигурных скобок.

Одну структуру можно присваивать другой структуре того же типа. 
В этом случае поля структуры получают копии значений.

 struct person tom = { "Tom", 34 };
 struct person bob = tom;

Структура может иметь вложенную структуру:

 struct product { char* name; int price; };
 struct order { char* name; struct product prod; };

 // Вложенную стрктуру можно инициализировать либо так, 
 // либо через каждое поле по отдельности

 struct order ord = { "Phone", { "Motorola", 810 } };

Структура, как и ф-ция, должна быть определена перед использованием. Но если нужно обратиться
к структуре до ее определения, то можно сначала определить структуру неполного типа, 
а уже после задать полноценное определение.

 struct product;  // Структура неполного типа

 struct order {
     char* name;
     struct product* prod;
 };

 struct product {
     char* name;
     int price;
     struct order* ord; 
 };

Структура неполного типа должна объявляться только как указатель, иначе к ее полям 
не получится обращаться и ее размер будет неизвестен (размер же указателя всегда известен 
и занимает 8 байт на 64-разрядной архитектуре).

Чтобы запретить иземение полей структуры, можно создать указатель на константную структуру.
Но при этом изменение адреса такого указателя по прежнему будет доступно. Чтобы запретить
изменение и адреса, указатель на константную структуру сам должен быть константным.

 const struct number { int value; };
 
 struct number num = { 1 };
 struct number num2 = { 2 };

 struct number* p = &num;
 p->value = 8;  // Так нельзя
 p = &num2;     // Но можно так

 const struct number* p2 = &num;
 p2 = &num2;    // Теперь и так нельзя
  
Пример создания массива структур: 
 struct person people[] = { { "Tom", 23 }, { "Bob", 58 } };

Если ф-ция принимает структуру в параметрах, то значения всех ее полей будут скопированы, 
а их изменение не приведет к изменению исходной структуры. Чтобы иметь возможность 
изменять исходную структуру, нужно передавать указатель на нее.

Адрес структуры - это адрес ее первого поля. Поля структуры размещаются в памяти в том
порядке, в котором они заданы при определении, но с учетом выравнивания.

Выравнивание поля с примитивным типом позволяет ему размещаться только по тем адресам,
которые кратны размеру типа. Например поля с типом long или указатели смогут размещаться
только по адресам, которые делятся на 8 без остатка.

Выравнивание полей структуры происходит по самому большому полю. Отсюда следует, 
что ее размер всегда будет кратен размеру наибольшего поля. Пространства между полями 
могут заполняться отступами (padding), если поля задаются в неправильном порядке. 

Например размер структуры: struct { int a, char* b, int c }; будет не 16 байт, а 24, 
т.к. порядок определения полей в ней неоптимизирован. Поля "a" и "c" будут подвержены
выравниванию по наибольшему полю "b" и после них появятся доп. оступы в 4 байта.

Отступы добавляются из-за того, что "b" не может располагаться сразу после "a", 
на 4 ячейке, т.к. она не кратна 8.

Чтобы избежать лишних отступов, поля всегда нужно определять в порядке от наибольшего к
наименьшему: struct { char* b, int a, int c }; В оптимизированной структуре поля "a" и "с"
занимают ячейки 8 и 12 соответсвенно, т.к. они кратны 4 и соответсвенно их не нужно
выравнивать. В итоге размер структуры будет ожидаемые 16 байт.

При работе со структурами, вместо определения переменной структуры, можно использовать
составной литерал. Его можно передавать в качестве аргумента либо использовать 
как возвращаемое значение.

 typedef struct { int x; int y; } point;

 void print(point p) {}
 point getPoint() { return (point){ 1, 2 }; }
 
 // 2 способа определения составного литерала
 print( (point){ .x = 1, .y = 2 } );  
 print( (point){ 3, 4 } );
 
Перечисления определяются с помощью ключевого слова enum. В фигурных скобках задаются
числовые константы. По умолчанию они неявно получают значения от 0 и далее, 
но их можно переопредить вручную.

Чтобы объявить переменную перечисления, нужно также использовать enum. 
Но как и в случае со структурами, такое объявление можно сократить через typedef.

В отличие от других языков, в Си константы доступны не через переменную, а сразу.

 enum operation { ADD, SUB = 5, MUL };
 // Переменной перечисления можно задать одну из ее констант
 enum operation op = MULL;  -->  6

Объединения позволяют хранить данные разных типов в одном участке памяти, 
как бы накладывая их друг на друга. Определяются с помощью ключевого слова union.
Переменная определяется также с помощью union.

 // Размер объединения вычисляется по наибольшему полю

 union ascii {       // | letter |
     int digit;      // | 1 байт | 1 байт | 1 байт | 1 байт |
     char letter;    // |              digit                |
 };

 union ascii code; 
 code.digit = 120;  // letter также станет 120 
 code.letter = 87;  // digit станет 87

Объединения в основном используют, когда нужно хранить значения разных типов:

 typedef enum { STRING, INT } type;
 typedef union { int intValue; char* strValue; } value;

 void print(value v, type t) {
     if (t == STRING) printf("%s", v.strValue);
     if (t == INT) printf("%d", v.intValue);
 }

 value v = { 235324 }; // инициализировать можно только первое поле объединения
 print(v, INT);

 value v2;
 v2.strValue = "Hello";
 print(v2, STRING);

Структуры и объединения могут иметь битовые поля. Такие поля обычно не кратны байту.
Это позволяет экономить память, размещая данные более плотно.

Типом битового поля может быть только int и его модификаторы signed, unsigned.
Битовое поле задается следующим способом: тип имя:ширина;

Ширина битового поля - это число, которое обозначает сколько бит будет иметь поле.
Ширина не должна превышать длину машинного слова. Машинное слово измеряется в битах 
и равно разрядности регистров процессора, т.е. для x64 архитерктуры оно равно 64 бита. 

 struct point {
     int x:5;  // поле x может хранить до 5 бит информации.
     int y:3;
 };

 // Переменная структуры будет занимать 8 бит, 
 // без выравнивания полей (10100010)

 struct point center = { 2, 5 };

----------------------

ДИНАМИЧЕСКАЯ ПАМЯТЬ

Структура памяти основана на сегментах. Сначала идет сегмент стека. За ним идет сегмент
динамической памяти (куча). После, идет сегмент констант и глобальных переменных. 
И в конце - сегмент кода, содержащий скомпилированные машинные инстукции 
для всех ф-ций программы.

Об организации памяти: https://metanit.com/c/tutorial/5.18.php

Сегмент динамической памяти позволяет программам запрашивать память во время выполнения.
Для этого используются ф-ции из заголовочного файла stdlib.h

 * malloc(s) - выделяет память длиной s-байт и возвращает указатель 
   на ее начало. В случае неудачи возвращает NULL;

 * calloc(n, m) - выделяет память для n эл-тов по m байт и возвращает указатель 
   на ее начало. В случае неудачи возвращает NULL. В отличие от malloc() 
   инициализирует все выделенные байты нулями.

 * realloc(*bl, ns) - изменяет размер выделенной памяти до ns байт, на начало которой
   указывает bl. Если указатель bl равен NULL, то работает как malloc();

 * free(*bl) - освобождает выделенную память, на начало которой указывает bl;

Примеры работы с динамической памятью:

 // Поскольку malloc() может вернуть NULL, 
 // указатель нужно проверять перед использованием 

 int* p = malloc(sizeof(int));
 if (p) *p = 24;   
            
 // После завершения работы, освобождаем память. Но указатель на нее 
 // по прежнему будет доступен. Поэтому его тоже нужно затирать.
             
 free(p);   
 p = NULL; 

Пример выделения памяти для массива:

 // Размер выделенной памяти можно также получить через
 // разыменовывание указателя

 int* p = malloc(3 * sizeof *p);
 if (p != NULL) {
     p[0] = 1;
     p[1] = 2;
     p[2] = 3;
 }
 
Пример выделения памяти для структуры:

 struct person { char* name; int age; };

 struct person* p = malloc(sizeof(struct person));
 if (p != NULL) {
     p->name = "Tom";
     p->age = 38;
 }

Пример использования ф-ции calloc():

 int* p = calloc(1, sizeof(int));   // Выделение памяти для 1 int
 if (p) printf("%d", *p);   // Переменная указателя уже имеет начальное значение

 int* p2 = calloc(3, sizeof(int));  
 if (p != NULL) {
     p[2] = 23;
     for (int i = 0; i < 3; i++) {
         printf("%d", p[i]);
     } 
 }

Пример использования ф-ции realloc():

 int* p = malloc(sizeof(int));
 p = realloc(p, 4 * sizeof(int))  // Расширяем память до 4х int

Пример выделение памяти для двухмерного зубчатого массива:

 int rowCount = 10;
 int** table = calloc(rowCount, sizeof(int*));

 for (int i = 0; i < rowCount; i++) {
     int colCount = rand();
     table[i] = calloc(colCount, sizeof(int));
     if (int j = 0; j < colCount; j++) {
         table[i][j] = rand();
     }
 } 
 
 for (int i = 0; i < rowCount; i++) {
     int colCount = sizeof(table[i]) / sizeof(int);
     for (int j = 0; j < colCount; j++) {
         printf("%d", table[i][j]);
     }
     // Когда память станет не нужна, нужно будет освободить 
     // не только table но и каждый выделяемый row
     free(table[i]);
 }

 free(table);

Пример кэширование с помощью локальной статической переменной:

 int* createPointer() {
     static int* p = NULL;
     if (p == NULL) {
         p = malloc(sizeof(int));
         *p = 23;
     }
     return p;
 }

 int* p = createPointer();
 int* p2 = createPointer();
 int* p3 = createPointer();

 free(p);
 p = NULL;
 p2 = NULL;
 p3 = NULL;

Если ф-ция возвращает локальный указатель, то это означает что он привязан 
к динамической памяти (иначе код не скомпилируется). Посему, освобождение памяти 
в таком случае всегда передается внешнему коду.

----------------------

РАБОТА С ФАЙЛАМИ

Файл в языке Си рассматривается как неструктурированная последовательность байтов.
В связи с этим, файлом может считаться как собственно файл на жестком диске, 
принтер, дисплей и другие подключаемые устройства ввода-вывода.

Взаимодействие между приложением и файлами производится через обмен блоков байт 
фиксированной длины (обычно длина равна степени двойки - 256 или 512 байт).

При чтении из файла, данные помещаются в буфер ОС, а затем побайтно передаются приложению.
При записи в файл, данные накапливаются в буфере и когда он заполнится, записываются 
на диск в виде единого блока байт.

Буферы - это участки памяти, поэтому передача данных между приложением и буфером происходит
быстро, в отличие от взаимодействия с физическим устройством типа принтера.

Файл вместе со средствами буферизации представляет поток.

Чтобы работать с потоком, его необходимо открыть. Для этого используется ф-ция fopen().
Она (и другие ф-ции для работы с потоками) доступна после подключения stdio.h

Эта ф-ция принимает 2 параметра: имя файла и режим открытия, и возвращает либо указатель 
на структуру FILE, либо NULL в случае ошибки. Указатель на FILE идентифицирует поток 
в программе и через него можно обращаться к открытому файлу.

Режимы открытия позволяют разграничить доступ к файлам, а также разделить их на
текстовые и бинарные. Они представлены набором символов:

 * w - текстовый файл открывается для перезаписи;
 * r - текстовый файл открывается для чтения;
 * a - текстовый файл открывается для дозаписи;

 * w+ - текстовый файл открывается для чтения и перезаписи;
 * r+ - текстовый файл открывается для чтения и редактирования 
 * a+ - текстовый файл открывается для чтения и дозаписи;

 * wb - бинарный файл открывается для перезаписи;
 * rb - бинарный файл открывается для чтения;
 * ab - бинарный файл открывается для дозаписи;

 * w+b - бинарный файл открывается для чтения и перезаписи;
 * r+b - бинарный файл открывается для чтения и редактирования;
 * a+b - бинартный файл открывается для чтения и дозаписи;

При использовании любого из режимов для записи (w, a, w+, a+, wb, ab, w+b, a+b) 
если файл не существует, то он будет создан.

Режим для редактирования означает, что запись в конец файл недопустима.
 
После завершения работы с потоком его нужно закрыть. Для этого используется ф-ция fclose().
Она принимает указатель на структуру FILE, связанный с открытым файлом. Возвращает 0 
при успешном выполнении или встроенное значение EOF, в случае ошибки.
 
 #inclide <stdio.h>

 int main() {
     FILE* f = fopen("myfile.txt", "r");
     if (f == NULL) {
         perror("Error occurred while opening myfile.txt");
         return 1;
     }

     fclose(f);
     return 0;
 }

Для вывод ошибок на консоль используется ф-ция perror().

Работа с бинарными файлами производится через чтение/запись символов, 
т.к. один символ соответствует одному байту.

Для записи символа в файл используется ф-ция putc(). Она принимает 2 параметра: указатель 
на файловый поток и символ, который надо записать. Возвращает записанный символ.

 char* msg = "hello!";
 int size = sizeof(msg) / sizeof(msg[0]);

 FILE* f = fopen("data.txt", "w");
 if (f != NULL) {
     for (int i = 0; i < size; i++) {
         putc(msg[i], f);
     }
     fclose(f);
 }

Для чтения символа из файла используется ф-ция getc(). Она принимает указатель на 
файловый поток и возвращает считанный символ (точнее его числовой код). 
Когда будет достигнут конец файла, эта ф-ция вернет EOF.

 FILE* f = fopen("data.txt", "r");
 if (f != NULL) {
     char c;
     while ( (c = getc(f)) != EOF ) {
         printf("%c", c);
     }
     fclose(f);
 }

Пример чтения и записи структуры в бинарный файл:

 struct person { char name[16]; int age; };

 struct person tom = { "Tom Smith", 21 };
 int size = sizeof(struct person);

 FILE* f = fopen("person.data", "wb");
 if (f != NULL) {
     char* c = (char*)tom;
     for (int i = 0; i < size; i++) {
         putc(*c++, f);
     }
     fclose(f);
 }

 --------

 struct person* p = malloc(size);
 
 FILE* f = fopen("person.data", "rb");
 if (f != NULL) {
     int i;                                
     char* c = (char*)p;                
     while ( (i = getc(f)) != EOF ) {   // Здесь сравнение идет не по символу,
       *c = i;                          // а по числовому коду, т.к. если структура будет
       c++;                             // иметь поле с отрицательным числом, это приведет
     }                                  // к преждевременному выходу из цикла
     fclose(f);
 }

 printf("%s %d", p->name, p->aget);
 free(p);

Ф-ция fwrite() предназначена для записи данных из массива. 
Она принимает параметры, описанные ниже и возвращает кол-во записанных эл-тов:

 * buffer - указатель на первый элемент массива;
 * size - размер каждого эл-та;
 * count - кол-во эл-тов, которые надо записать;
 * stream - указатель на файловый поток для записи;

Ф-ция fread() предназначена для считывания данных из файла в массив. 
Она принимает похожие параметры и возвращает кол-во считанных объектов:

 char str[] = "Hello!";
 FILE* f = fopen("data.txt", "w");
 if (f != NULL) {
     size_t count = fwrite(str, 1, sizeof(str), f);
     fclose(f);
 }

 char str2[10];
 FILE* f = fopen("data.txt", "r");
 if (f != NULL) {
     size_t count = fread(str2, 1, 10, f);
     printf(str);
     fclose(f);
 }

С помощью этих ф-ций можно обрабатывать не только массивы, но и структуры, поскольку 
в качестве указателя может выступать адрес любого объекта.

Для отслеживания работы с файлами используются ф-ции feof() и ferror(). Первая отслеживает
конец файла, а вторая сообщает, произошла ли ошибка при работе с файлом. Обе ф-ции принимают
указатель на файл. Ф-ция feof() возвращает 0, если достигнут конец файла.

 if (fread(str, 1, 10, f)) {
     ...
 } else {
     if (feof(f)) {   // Если конец файла
         ...
     } else if (ferror(f)) {   // Если ошибка
         ...
     }
 }

Ф-ция fputs() записывает в файл строку. Она принимает такие же параметры, как и putc() 
и возвращает либо неотрицательное число, либо EOF, при ошибках записи.

Ф-ция fgets() считывает из файла одну строку. Принимает 3 параметра, описанные ниже 
и возвращает либо указатель s, либо NULL, при ошибке или достижении конца файла.

 * s - строка, в которую производится считывание;
 * n - число, указывающее сколько символов нужно считать;
 * f - файловый поток для чтения;
 
Эта ф-ция прекращает чтение, когда прочтет n-1 символов или встретит 
символ переноса строки \n

Пример копирования текстового файла:

 char buffer[256];
 FILE* f = fopen("data.txt", "r");
 FILE* f2 = fopen("data2.txt", "w");

 if (f && f2) {
     // Считывает по 256 байт из файла f, пока не дойдет 
     // до конца, и записывает их в файл f2

     while ( fgets(buffer, 256, f) != NULL ) {
         fputs(buffer, f2);
     } 
 }

 fclose(f); 
 fclose(f2);

Ф-ции fscanf() и fprintf() подобно консольному вводу/выводу позволяют считывать 
и записывать в файл форматированные данные:

 struct person people[] = { { "Tom", 23 }, { "Bob", 58 } };
 int n = sizeof(people) / sizeof(people[0]);

 FILE* f = fopen("users.dat", "w");
 if (f != NULL) {
     for (int i = 0; i < n; i++) {
         struct person usr = people[i];
         fprintf(f, "%s %d \n", usr.name, usr.age);
     } 
     fclose(f);
 }

 --------
 
 char* name[20];
 int age;

 FILE* f = fopen("users.dat", "r");
 if (f != NULL) {
     // Считывает данные не с консоли, а из файла, 
     // в переменные name и age, пока не дойдет до конца 

     while ( fscanf(f, "%20s %d \n", name, &age) != EOF ) {
         printf("%s %d \n", name, age); 
     }
 }

Операции чтения/записи всегда производятся с текущей позиции в потоке. При открытии потока 
в режимах "r" и "w", текущая позиция устанавливается на начальный байт. Режим "a"
устанавливается позицию в конец файла (за конечным байтом).

При выполнении операций чтения/записи позиция перемещается в соответсвии с 
числом прочитанных или записанных символов.

Чтобы читать/записывать данные с какой-то определенной позиции, используются ф-ция fseek().
Она принимает 3 параметра: уазатель на поток, спещение позиции и начальную позицию.

Начальная позиция задается с пом. констант: SEEK_SET (начало файла), SEEK_CUR 
(текущая позация в потоке) и SEEK_END (конец файла).

Также есть еще две вспомогательные ф-ции ftell() и rewind(). Первая позволяет получить
текущую позицию потока, а вторая - установить позицию на начало потока.

 FILE* f = fopen("test.txt", "r");
 if (f != NULL) {
     // Вручную устанавливаем позицию в конец файла
     fseek(f, 0, SEEK_END);

     // Получаем размер файла, т.к. конечная позиция файла
     // равна кол-ву всех его байтов.

     long fileSize = ftell(f);
     printf("%ld", fileSize);

     fclose(f);
 }

С пом. этих ф-ций можно считывать конкретные данные на конкретных позациях, а также
перезаписывать их. Например, можно изменить определенную структуру из массива записанных
структур и пр. (см. https://metanit.com/c/tutorial/7.6.php)

При запуске программы, открывается ряд потоков, основными из которых являются:
 * stdin - стандартный поток ввода;
 * stdout - стандартный поток вывода;
 * stderr - стандаратный поток вывода сообщений о ошибках;

Поток stdin по умолчанию соответсвует клавиатуре, а stdout и stderr - дисплею.
Этими потоками на более низком уровне можно также управлять с помощью putc(), getc(),
fgets(), fputs() и пр. (см https://metanit.com/c/tutorial/7.7.php)  

 #include <stdio.h>

 int main(void) {
     int c;
     // Консольный ввод/вывод на более низком уровне
     while ( (c = getc(stdin)) != EOF ) {
         putc(c, stdout);
     }
     return 0;
 }

Консольные ф-ции printf(), scanf() - это по сути абстракции более высокого уровня 
для getc(), putc(). Но помимо консоли они имеют аналоги для ввода/вывода данных в строку.

Ф-ция sscanf() считывает данные из строки в переменные. Первый параметр - это строка 
из которой считываются данные. Второй параметр - это формат считывания. Все последующие
параметры - это переменные, куда идет считывание.

 char buffer[50] = "F 69 123.45";
 char a; int b; double c;

 // Формат считывания определяет, как данные из buffer будут сопоставяться 
 // с переменными. Поскольку значения в buffer разделены пробелами, 
 // то и спецификаторы разделяются пробелами

 sscanf(beffer, "%c %d %lf", &a, &b, &c);

 // Строки таже могут наклыдываться друг на друга

 char* buffer = "Name is Tom and age is 38";
 char name[10]; int age;
 sscanf(buffer, "Name is %s and age is %d", name, &age);
 
Ф-ция sprintf() наоборот, записывает данные в строку. 
Результатом является кол-во записанных символом + нулевой символ.

 char* str[50];

 char* name = "Tom";
 int age = 38;

 int charNum = sprintf(str, "Name: %s  Age: %d", name, age);
 printf("%s, %d", str, charNum);  -->  "Name: Tom  Age: 38, 19"
 
----------------------

СТАНДАРТНАЯ БИБЛИОТЕКА

Поставляется вместе с компилятором. Состоит из ряда ф-ций и макросов.
Заголовочные файлы стандартной библиотеки: https://metanit.com/c/tutorial/8.1.php

Ф-ции для работы со строками и памятью (string.h)

 * strlen() - возвращает кол-во символом строки (число с типом size_t, 
   которое использует спецификатор %zu для вывода на консоль);

 * strcmp() - принимает две строки и посимвольно сравнивает их; если строки равны, 
   то возвращает 0; если одна строка меньше другой - то число, меньше 0, 
   а если больше - то число, больше 0;

 * strcat() - объединяет две строки в одну; 
   после объединения первая строка расширяется второй;

 * strcpy() - копирует символы из одной строки в другую (результирующая строка 
   должна иметь достаточную длину, чтобы вместить копируемую);

 * strstr() - ищет в строке подстроку; возвращает адрес первого символа подстроки 
   (чтобы получить индекс, нужно от этого адреса вычесть адрес всей строки);
 
 * memset() - инициализирует блок динамической памяти начальными значениями 
   (значениями инициализируется не заданный тип, а каждый байт выделенной памяти);

 * memcpy() - копирует определенное кол-во байт из одного блока памяти в другой
   (копируемые данные могут быть любых типом: int, char, стркуктура и пр.)

 * memcmp() - сравнивает определенное кол-во байт двух блоков памяти, заданное в 
   третьем параметре; возвращает теже числа, как и при работе с strcmp();

Ф-ции для работы с датой и временем (time.h)

 * time() - возвращает текущую дату и время, либо инициализирует текущей датой и временем
   передаваемый параметр; возвращаемое значение и параметр представлены типом time_t;
   чтобы получить структуру времени tm, нужно передать time_t в ф-цию localtime();
   (чтобы получить текущий год, нужно к tm_year прибавить нулевой год - 1900)

 * strftime() - преобразовывает дату и время в отформатированную строку; 
   формат задается через спецификаторы (https://metanit.com/c/tutorial/8.4.php)

Ф-ции для преобразования числа в строку и наоборот:

 * strtol() - преобразует строку в число, например: "24 flowers" -> 24 (stdlib.h) 
 * snprintf() - преобразует числа в отформатированную строку (stdio.h)

----------------------

РАЗНОЕ

Обобщения не поддерживаются нативно, однако их можно реализовать с пом. макросов.
Кроме того, стандарт С11 предоставляет спец. макрос _Generic, для упрощенной реализации.

Реализация обобщенной ф-ции с помощью обычных макросов:

 #define DEFINE_SUM(T) T sum_##T(T a, T b) { \
     return a + b; \
 }

 DEFINE_SUM(int)
 DEFINE_SUM(float)

 #define sum(T) sum_##T

 sum(int)(3, 2);
 sum(float)(3.0, 2.0);

Первый макрос определяет код обобщенной ф-ции. Оператор ## присоединяет название типа 
к названию ф-ции. Слэш позволяет переносить код макроса на следующие строки.

Его вызов задает определение ф-ции с конкретным типом, т.е. DEFINE_SUM(int) 
разворачивается в int sum_int(int a, int b) { return a + b; }

Второй макрос позволяет вызвать ф-цию с конкретным типом, т.е. sum(int) станет sum_int.
Комбинация этих макросов позволяет вызывать ф-ции следующим образом:

 sum(int)(3, 2);        // sum_int(3, 2);
 sum(float)(3.2, 2.0);  // sum_float(3.2, 2.0);

Подобным образом можно создавать и обобщенные структуры:

 #define DEFINE_PERSON(T, U) struct person_##U { \
     T id; \
     char name[20]; \
 };

 DEFINE_PERSON(int, int);
 DEFINE_PERSON(char*, char);

 #define person(T) struct person_##T

 person(int) tom = { .id = "cajks234s", .name = "Tom" };
 person(char) bob = { .id = 1234, .name = "Bob" };

Реализация обобщенной ф-ции с помощью макроса _Generic:

 #define sum(a, b) _Generic((a), \
     int: sum_int, \
     float: sum_float, \
     default: sum_dobule \
 )(a, b)

 void sum_int(int a, int b) { }
 void sum_float(float a, float b) { }
 void sum_double(double a, double b) { }

 sum(1, 2);
 sum(5.2f, 6.1f);
 sum(1.0, 2.0);

Первый параметр _Generic - это значение, тип которого будет сопоставляться с ключами из второго параметра. Второй параметр это коллекция ключ/значение, где ключи - это типы, 
а значения - ф-ции, которые им соответствуют.

Поддержка Unicode и кодировки UTF-8, UTF-16 и UTF-32...

