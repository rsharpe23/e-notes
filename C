ВВЕДЕНИЕ

Программа на Си состоит из набора директив препроцессора, определений ф-ций 
и глобальных данных (переменных).

Каждая инструкция выполняет определенное действие. В конце инстуркции ставится точка 
с запятой. Набор инструкций задается блоком кода, который определяется фигурными скобками.

При компиляции исходного кода вначале срабатывает препроцессор, который сканирует исходный
код на наличие строк, начинающихся с символа решетки. Эти строки расцениваются препроцессором
как директивы и на их месте происходит какое-то преобразование текста. Например, на месте
директивы #include <stdio.h> вставляется код из файл stdio.h

Стартовой точкой выполнения кода является ф-ция main(). Эта ф-ция может возвращать либо
число, либо void. Если main() возвращает число, то ноль означает успешное выполнения
программы, а другие числа - какую-то ошибку. Ключевое слово void в круглых скобках 
означает, что ф-ция не принимает параметров: 

 int main(void) { ... }

-------
Чтобы сделать доступным консольный ввод/вывод, нужно подключить заголовочный файл stdio.h
Вывод строки выполняется с помощью ф-ции printf(); Чтобы вывести число можно использовать
шаблонную строку со знаком %d (спецификатором).

 printf("Hello World! \n");
 printf("Number is %d \n", 23);
---------

Компиляция программы с помощью командной строки: gcc myfile.c

После компиляции будет создан исполняемый файл a.out
Переопределить имя исполняемого файла можно с помощью флага -o: 

 gcc myfile.c -o myprog.out

По умолчанию при компиляции не отобрадается никаких предупреждений. Для компиляции 
с предупреждениями нужно ипользовать флаг -Wall:

 gcc -Wall myfile.c

С помощью флага -std= можно задать стандарт языка, например c99, c11, c17. 
А чтобы гарантировать, что программа будет строго соответстовать определенному стандарту,
можно задать флаг -pedantic.

 gcc -std=c11 myfile.c
 gcc -std=c17 -Wall -pedantic myfile.c & ./a.out  -->  скомпилировать и запустить

Флаг -S позволяет сгенерировать файл с ассемблерным кодом (ассемблер GAS).
 gcc myfile.c -S  -->  создаст файл myfile.s

Если вместо кириллицы отображаются непонятные знаки, то в код нужно добавить вызов
setlocale(LC_ALL, ""); Эта ф-ция станет доступна после подключения locale.h

----------------------

ОСНОВЫ ЯЗЫКА

Базовые типы данных и их размеры:

 * char - символ 1 байт (signed char);
 * unsigned char - беззнаковый символ 1 байт;

 * short - число 2 байта (short int, signed short, sifned short int);
 * unsigned short - беззнаковое число 2 байта (unsigned short int);

 * int - число, 2 байта для x32 и 4 байта для x64 архитектур (signed, signed int);
 * unsigned int - беззнаковое число 2/4 байта (unsigned, unsigned int);

 * long - число, 4 байта для Windows_x64 и 8 байт для Linux_x64/MacOS_x64;
   (long int, signed long int, signed long)

 * unsigned long - беззнаковое число 4/8 байт (unsigned long int);

 * long long - число 8 байт (long long int, signed long long int, signed long long);
 * unsigned long long - беззнаковое число 8 байт (unsigned long long int);

 * float - вещественное число 4 байта;
 * double - вещественное число 8 байт;
 * long double - вещественное число 10 байт;

 * void - тип без значения;

Любое десятичное число, в зависисоти от размера, рассматривается как: 
int, long int или long long int. И при присвоении в переменную другого типа неявно
преобразуется. Чтобы избежать ненужного преобразования, к числу добавляется суффикс:

 * u/U - unsigned int, unsigned long int и unsigned long long int;
 * ul/UL - unsigned long int и unsigned long long int;
 * ll/LL - long long int;
 * ull/ULL - unsigned long long int;

 unsigned int num = 1;  -->  выполнится неявное преобразование из int в unsigned int
 unsigned int num2 = 2u;  -->  здесь неявное преобразование пропустится

Вещественные числа по умолчанию представлены как double. Чтобы указать, что число 
имеет тип float или long double нужно добавить суффикс f или l соответсвенно:

 double num = 3.14;
 float num2 = 3.14f;
 long double num3 = 3.14l;

---------------
Спецификаторы:
 %c - char;
 %d - int;
 %u - unsigned int;
 %hu - unsigned short;
 %ld - long;
 %lu - unsigned long, size_t;
 %lld - long long;
 %llu - unsigned long long;
 %f - float, double;
 %Lf - long double (может работает некорректно);
-----------------

Числа в двоичной системе начинаются с префикса 0b, восьмеричные числа начинаются с 0, 
а шестнадцатиричные с 0x. После префикса указывается число в заданной системе.

 int num = 0b1011;  -->  11 в двоичной системе
 int num2 = 013;  -->  11 в восьмиричной системе
 int num3 = 0xB;  -->  11 в шестнадцатиричной системе

Char-переменная в качестве значения принимает символьный литерал в одинарный кавычках.
Однако в реальности такая переменная хранит число - код символа из таблицы ASCII.
Т.е. символьные литералы в одинарных кавычках - это данные типа int.

 char letter = 'A';  -->  65
 char letter2 = 65;  -->  тоже самое

При определении переменных, в одной строке можно задать сразу несколько:
 int num1 = 1, num2 = 2, num3 = 3;

Оператор typedef позволяет задать псевдоним для типа (typedef тип псевдоним):
 
 typedef unsigned char BYTE;
 BYTE num = 22;

Стандарт указывает лишь минимальные размеры для базовых типов. Однако предельные размеры 
могут отличаться, в зависимости от компиляторов. Чтобы точно знать размер типа используется оператор sizeof, который возвращает кол-во памяти в байтах. 

 size_t size = sizeof(int);
 size_t size2 = sizeof(unsigned long);

Возвращаемое значение оператора sizeof представлено типом size_t, который является просто псевдонимом другого числового типа. В одних системах size_t может быть unsigned long, 
в других чем-то еще. Поэтому при работе с sizeof нужно использовать именно size_t.

Оператор sizeof может также вычислят размер переменной или даже целого выражения 
(переменную или выражение можно указывать как в скобках, так и без).
 
 int num = 2;
 size_t numSize = sizeof(num);

 // Вычислит размер возвращаемого типа, т.е. 4, потому что printf() 
 // возвращает int. При этом сама ф-ция не выполнится.

 size_t expSize = sizeof printf("hello!");                 

Консольный вывод. Функция printf...



