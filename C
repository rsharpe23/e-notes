ВВЕДЕНИЕ

Программа на Си состоит из набора директив препроцессора, определений ф-ций 
и глобальных данных (переменных).

Каждая инструкция выполняет определенное действие. В конце инстуркции ставится точка 
с запятой. Набор инструкций задается блоком кода, который определяется фигурными скобками.

При компиляции исходного кода вначале срабатывает препроцессор, который сканирует исходный
код на наличие строк, начинающихся с символа решетки. Эти строки расцениваются препроцессором
как директивы и на их месте происходит какое-то преобразование текста. Например, на месте
директивы #include <stdio.h> вставляется код из файл stdio.h

Стартовой точкой выполнения кода является ф-ция main(). Эта ф-ция может возвращать либо
число, либо void. Если main() возвращает число, то ноль означает успешное выполнения
программы, а другие числа - какую-то ошибку. Ключевое слово void в круглых скобках 
означает, что ф-ция не принимает параметров: 

 int main(void) { ... }

Компиляция программы с помощью командной строки: gcc myfile.c

После компиляции будет создан исполняемый файл a.out
Переопределить имя исполняемого файла можно с помощью флага -o: 

 gcc myfile.c -o myprog.out

По умолчанию при компиляции не отобрадается никаких предупреждений. Для компиляции 
с предупреждениями нужно ипользовать флаг -Wall:

 gcc -Wall myfile.c

С помощью флага -std= можно задать стандарт языка, например c99, c11, c17. 
А чтобы гарантировать, что программа будет строго соответстовать определенному стандарту,
можно задать флаг -pedantic.

 gcc -std=c11 myfile.c
 gcc -std=c17 -Wall -pedantic myfile.c & ./a.out  -->  скомпилировать и запустить

Флаг -S позволяет сгенерировать файл с ассемблерным кодом (ассемблер GAS).
 gcc myfile.c -S  -->  создаст файл myfile.s

Если вместо кириллицы отображаются непонятные знаки, то в код нужно добавить вызов
setlocale(LC_ALL, ""); Эта ф-ция станет доступна после подключения locale.h

----------------------

ОСНОВЫ ЯЗЫКА

Базовые типы данных и их размеры:

 * char - символ 1 байт (signed char);
 * unsigned char - беззнаковый символ 1 байт;

 * short - число 2 байта (short int, signed short, sifned short int);
 * unsigned short - беззнаковое число 2 байта (unsigned short int);

 * int - число, 2 байта для x32 и 4 байта для x64 архитектур (signed, signed int);
 * unsigned int - беззнаковое число 2/4 байта (unsigned, unsigned int);

 * long - число, 4 байта для Windows_x64 и 8 байт для Linux_x64/MacOS_x64;
   (long int, signed long int, signed long)

 * unsigned long - беззнаковое число 4/8 байт (unsigned long int);

 * long long - число 8 байт (long long int, signed long long int, signed long long);
 * unsigned long long - беззнаковое число 8 байт (unsigned long long int);

 * float - вещественное число 4 байта;
 * double - вещественное число 8 байт;
 * long double - вещественное число 10 байт;

 * void - тип без значения;

Любое десятичное число, в зависисоти от размера, рассматривается как: 
int, long int или long long int. И при присвоении в переменную другого типа неявно
преобразуется. Чтобы избежать ненужного преобразования, к числу добавляется суффикс:

 * u/U - unsigned int, unsigned long int и unsigned long long int;
 * ul/UL - unsigned long int и unsigned long long int;
 * ll/LL - long long int;
 * ull/ULL - unsigned long long int;

 unsigned int num = 1;  -->  выполнится неявное преобразование из int в unsigned int
 unsigned int num2 = 2u;  -->  здесь неявное преобразование пропустится

Вещественные числа по умолчанию представлены как double. Чтобы указать, что число 
имеет тип float или long double нужно добавить суффикс f или l соответсвенно:

 double num = 3.14;
 float num2 = 3.14f;
 long double num3 = 3.14l;

Числа в двоичной системе начинаются с префикса 0b, восьмеричные числа начинаются с 0, 
а шестнадцатиричные с 0x. После префикса указывается число в заданной системе.

 int num = 0b1011;  -->  11 в двоичной системе
 int num2 = 013;    -->  11 в восьмиричной системе
 int num3 = 0xB;    -->  11 в шестнадцатиричной системе

Char-переменная в качестве значения принимает символьный литерал в одинарный кавычках.
Однако в реальности такая переменная хранит число - код символа из таблицы ASCII.
Т.е. символьные литералы в одинарных кавычках - это данные типа int.

 char letter = 'A';  -->  65
 char letter2 = 65;  -->  тоже самое

При определении переменных, в одной строке можно задать сразу несколько:
 int num1 = 1, num2 = 2, num3 = 3;

Оператор typedef позволяет задать псевдоним для типа (typedef тип псевдоним):
 
 typedef unsigned char BYTE;
 BYTE num = 22;

Стандарт указывает лишь минимальные размеры для базовых типов. Однако предельные размеры 
могут отличаться, в зависимости от компиляторов. Чтобы точно знать размер типа используется оператор sizeof, который возвращает кол-во памяти в байтах. 

 size_t size = sizeof(int);
 size_t size2 = sizeof(unsigned long);

Возвращаемое значение оператора sizeof представлено типом size_t, который является просто псевдонимом другого числового типа. В одних системах size_t может быть unsigned long, 
в других чем-то еще. Поэтому при работе с sizeof нужно использовать именно size_t.

Оператор sizeof может также вычислят размер переменной или даже целого выражения 
(переменную или выражение можно указывать как в скобках, так и без).
 
 int num = 2;
 size_t numSize = sizeof(num);

 // Вычислит размер возвращаемого типа, т.е. 4, потому что printf() 
 // возвращает int. При этом сама ф-ция не выполнится.
 size_t expSize = sizeof printf("hello!");                 

Для вывода на консоль используется ф-ция printf().
Она становится доступной после подключения заголовочного файла stdio.h

 printf("hello world!");

Выводимая строка может также содержать спец. символы, например \n, \r, \t и др.
Для вывода других типов данных используются спецификаторы:

 %c - для вывода букв;
 %s - для вывода строк;
 %d - для вывода целых чисел;
 %u - для вывода целых беззнаковых числе;
 %i - для вывода чисел типа int;
 %f - для вывода вещественных чисел (float, double);
 %F - для вывода вещественных чисел в верхнем регистре;
 %o - для вывода восьмеричных чисел;
 %x - для вывода шестнадцатиричных чисел;
 %X - для вывода шестнадцатиричных чисел в верхнем регистре;
 %% - для вывода знака процента;

 printf("char: %c \n", 'p');
 printf("string: %s \n", "hello!");
 printf("number: %u \n", 23);
 printf("name: %s age: %d weight: %f", "Tom", 23, 63.5);

Для вывода вещественных чисел можно использовать ширину поля и точность. 
 printf("x: %4.2f", 71.8925)  -->  71.90 

В спецификаторе %4.2f, 4 означает до скольки знаков выводить перед точкой, 
а 2 - до скольки знаков выводить после точки.

Чтобы конкретизировать выводимое значение, можно задать модификатор:
 * h - для значений short int;
 * l - для значений long int и unsigned long int;
 * ll - для значений long long int и unsigned long long int;
 * L - для значений long double;

 printf("x: %hd", 7100);

Можно также задать доп. флаги чтобы более точно настроить вывод. Например, знак "-" сделает
выравнивание текста по левому краю, а число 9 (перед s) - это скорей всего доп. пробелы.

 printf("%-9s %d", "Tom", 38);  -->  "Tom       38"

Для определения константы используется ключевое слово const: 
 const int num = 23;

При делении целых чисел, результат округляется до целого, даже если он присвоен flot.
Чтобы получить вещественное число, один из операндов должен также быть вещественным числом.

 float a = 10 / 4;    -->  2.0
 float b = 10.0 / 4;  -->  2.5
  
Логические операции не возвращают последний доступный операнд, как в JS, 
а только 1, если выр-е истино или 0, если выр-е ложно.

Логическое отрицание возвращает 1 если операнд равен 0:
 !2  -->  0    !0  -->  1

Логическое умножение (конъюнкция) возвращает 1, если оба операнда не равны 0:
 -2 && 5  -->  1    0 && 7  -->  0

Логическое сложение (дизъюнкция) возвращает 1, если хотя бы один операнд не равен 0:
 -2 || 5  -->  1    0 || 7  -->  1

Операции сравнения (>, >=, <, <=, ==, !=) имеют больший приоритет, 
чем логические операции.

Операции сдвига (<<, >>) сдвигают битовое представление числа вправо или влево 
на заданное кол-во разрядов:

  2 << 2  -->  8 (00010 -> 01000)  
 16 >> 3  -->  2 (10000 -> 00010) 

Поразрядные операции сравнивают биты операндов между собой (делают побитовое сравнение).
Условия поразрядных конъюнкции и дизъюнкции такие же как и у логических. Поразрядное исключающее ИЛИ (^) возвращает 1 если только один из сравниваемых битов равен 1.
Поразрядное отрицание (~) инвертирует все биты операнда. 

 6 & 2  -->  2 (0110 & 0010 -> 0010)
 5 | 2  -->  7 (0101 | 0010 -> 0111)
 5 ^ 6  -->  3 (0101 ^ 0110 -> 0011)
 ~10  -->  -11 (01010 -> 10101)

В примере выше, при выполнении ~10, получается код отрицательного числа, т.к. старший бит равен 1. Система воспринимает его как дополнительный код, поскольку для записи отрицательных чисел используются именно дополнительные коды. Отсюда и такой результат -11.

Дополнительный код отрицательного числа - это его обратный код + 1. Обратный код находится путем инверсии всех битов, кроме последнего (старшего), т.к. тот отвечает за знак.

 -11 = 11011 (прямой код) -> 10100 (обратный код) -> 10101 (дополнительный код)

Примеры установки, удаление и проверки бита на заданной позиции приведены здесь
 https://metanit.com/c/tutorial/2.8.php

Операции присваивания...

