ВВЕДЕНИЕ

Программа на Си состоит из набора директив препроцессора, определений ф-ций 
и глобальных данных (переменных).

Каждая инструкция выполняет определенное действие. В конце инстуркции ставится точка 
с запятой. Набор инструкций задается блоком кода, который определяется фигурными скобками.

При компиляции исходного кода вначале срабатывает препроцессор, который сканирует исходный
код на наличие строк, начинающихся с символа решетки. Эти строки расцениваются препроцессором
как директивы и на их месте происходит какое-то преобразование текста. Например, на месте
директивы #include <stdio.h> вставляется код из файл stdio.h

Стартовой точкой выполнения кода является ф-ция main(). Эта ф-ция может возвращать либо
число, либо void. Если main() возвращает число, то ноль означает успешное выполнения
программы, а другие числа - какую-то ошибку.

 int main() {} 
 void main() {}

Компиляция программы с помощью командной строки: gcc myfile.c

После компиляции будет создан исполняемый файл a.out
Переопределить имя исполняемого файла можно с помощью флага -o: 

 gcc myfile.c -o myprog.out

По умолчанию при компиляции не отобрадается никаких предупреждений. Для компиляции 
с предупреждениями нужно ипользовать флаг -Wall:

 gcc -Wall myfile.c

С помощью флага -std= можно задать стандарт языка, например c99, c11, c17. 
А чтобы гарантировать, что программа будет строго соответстовать определенному стандарту,
можно задать флаг -pedantic.

 gcc -std=c11 myfile.c
 gcc -std=c17 -Wall -pedantic myfile.c & ./a.out  -->  скомпилировать и запустить

Флаг -S позволяет сгенерировать файл с ассемблерным кодом (ассемблер GAS).
 gcc myfile.c -S  -->  создаст файл myfile.s

Если вместо кириллицы отображаются непонятные знаки, то в код нужно добавить вызов
setlocale(LC_ALL, ""); Эта ф-ция станет доступна после подключения locale.h

----------------------

ОСОБЕННОСТИ ЯЗЫКА

Базовые типы данных и их размеры:

 * char - символ 1 байт (signed char);
 * unsigned char - беззнаковый символ 1 байт;

 * short - число 2 байта (short int, signed short, sifned short int);
 * unsigned short - беззнаковое число 2 байта (unsigned short int);

 * int - число, 2 байта для x32 и 4 байта для x64 архитектур (signed, signed int);
 * unsigned int - беззнаковое число 2/4 байта (unsigned, unsigned int);

 * long - число, 4 байта для Windows_x64 и 8 байт для Linux_x64/MacOS_x64;
   (long int, signed long int, signed long)

 * unsigned long - беззнаковое число 4/8 байт (unsigned long int);

 * long long - число 8 байт (long long int, signed long long int, signed long long);
 * unsigned long long - беззнаковое число 8 байт (unsigned long long int);

 * float - вещественное число 4 байта;
 * double - вещественное число 8 байт;
 * long double - вещественное число 10 байт;

 * void - тип без значения;

Любое десятичное число, в зависисоти от размера, рассматривается как: 
int, long int или long long int. И при присвоении в переменную другого типа неявно
преобразуется. Чтобы избежать ненужного преобразования, к числу добавляется суффикс:

 * u/U - unsigned int, unsigned long int и unsigned long long int;
 * ul/UL - unsigned long int и unsigned long long int;
 * ll/LL - long long int;
 * ull/ULL - unsigned long long int;

 unsigned int a = 1;  -->  выполнится неявное преобразование из int в unsigned int
 unsigned int b = 2u;  -->  здесь неявное преобразование пропустится

Вещественные числа по умолчанию представлены как double. Чтобы указать, что число 
имеет тип float или long double нужно добавить суффикс f или l соответсвенно:

 double a = 3.14;
 float b = 3.14f;
 long double c = 3.14l;

Числа в двоичной системе начинаются с префикса 0b, восьмеричные числа начинаются с 0, 
а шестнадцатиричные с 0x. После префикса указывается число в заданной системе.

 int a = 0b1011;  -->  11 в двоичной системе
 int b = 013;     -->  11 в восьмиричной системе
 int c = 0xB;     -->  11 в шестнадцатиричной системе

Char-переменная в качестве значения принимает символьный литерал в одинарный кавычках.
Однако в реальности такая переменная хранит число - код символа из таблицы ASCII.
Т.е. символьные литералы в одинарных кавычках - это данные типа int.

 char a = 'A';  -->  65
 char b = 65;   -->  тоже самое

Оператор typedef позволяет задать псевдоним для типа: typedef тип псевдоним
 
 typedef unsigned char BYTE;
 BYTE num = 22;

Стандарт указывает лишь минимальные размеры для базовых типов. Однако предельные размеры 
могут отличаться, в зависимости от компиляторов. Чтобы точно знать размер типа используется
оператор sizeof, который возвращает кол-во памяти в байтах. 

 size_t size1 = sizeof(int);
 size_t size2 = sizeof(unsigned long);

Возвращаемое значение оператора sizeof представлено типом size_t, который является просто
псевдонимом другого числового типа. В одних системах size_t может быть unsigned long, 
в других чем-то еще. Поэтому при работе с sizeof нужно использовать именно size_t.

Оператор sizeof может также вычислять размер переменной или даже целого выражения 
(переменную или выражение можно указывать как в скобках, так и без).
 
 int num = 2;
 size_t numSize = sizeof(num);  -->  4 (размер типа переменной)

 // Вычислит размер возвращаемого типа, т.е. 4, потому что printf() 
 // возвращает int. При этом сама ф-ция не выполнится.

 size_t expSize = sizeof printf("hello!");                 

Для вывода на консоль используется ф-ция printf().
Она становится доступной после подключения заголовочного файла stdio.h

 printf("hello world!");

Выводимая строка может также содержать спец. символы, например \n, \r, \t и др.
Для вывода других типов данных используются спецификаторы:

 %c - для вывода букв;
 %s - для вывода строк;
 %d - для вывода целых чисел;
 %u - для вывода целых беззнаковых числе;
 %i - для вывода чисел типа int;
 %f - для вывода вещественных чисел (float, double);
 %o - для вывода восьмеричных чисел;
 %x - для вывода шестнадцатиричных чисел;
 %X - для вывода шестнадцатиричных чисел в верхнем регистре;
 %% - для вывода знака процента;

 printf("char: %c \n", 'a');
 printf("string: %s \n", "hello!");
 printf("number: %u \n", 23);
 printf("name: %s age: %d weight: %f", "Tom", 23, 63.5);

Для вывода вещественных чисел можно использовать ширину поля и точность. 
 printf("x: %4.2f", 71.8925)  -->  71.90 

В спецификаторе %4.2f, 4 означает до скольки знаков выводить перед точкой, 
а 2 - до скольки знаков выводить после точки.

Чтобы конкретизировать выводимое значение, можно задать модификатор:
 * h - для значений short int;
 * l - для значений long int и unsigned long int;
 * ll - для значений long long int и unsigned long long int;
 * L - для значений long double;

 printf("x: %hd", 7100);

Можно также задать доп. флаги чтобы более точно настроить вывод. Например, знак "-" сделает
выравнивание текста по левому краю, а число 9 (перед s) - это скорей всего доп. пробелы.

 printf("%-9s %d", "Tom", 38);  -->  "Tom       38"

Для определения константы используется ключевое слово const: 
 const int num = 23;

При делении целых чисел, результат округляется до целого, даже если он присвоен float.
Чтобы получить вещественное число, один из операндов должен также быть вещественным числом.

 float a = 10 / 4;    -->  2.0
 float b = 10.0 / 4;  -->  2.5
  
Логические операции не возвращают последний доступный операнд, как в JS, 
а только 1, если выр-е истино или 0, если выр-е ложно.

Логическое отрицание возвращает 1 если операнд равен 0.
Логическое умножение (конъюнкция) возвращает 1, если оба операнда не равны 0.
Логическое сложение (дизъюнкция) возвращает 1, если хотя бы один операнд не равен 0.

      !2  -->  0        !0  -->  1
 -2 && 5  -->  1    0 && 7  -->  0
 -2 || 5  -->  1    0 || 7  -->  1

Операции сравнения (>, >=, <, <=, ==, !=) имеют больший приоритет, чем логические. 
Они также возвращают либо 0, либо 1.

Операции сдвига (<<, >>) сдвигают битовое представление числа вправо или влево 
на заданное кол-во разрядов:

  2 << 2  -->  8 (00010 -> 01000)  
 16 >> 3  -->  2 (10000 -> 00010) 

Поразрядные операции сравнивают биты операндов между собой (делают побитовое сравнение).
Условия поразрядных конъюнкции и дизъюнкции такие же как и у логических. Поразрядное
исключающее ИЛИ (^) возвращает 1 если только один из сравниваемых битов равен 1.
Поразрядное отрицание (~) инвертирует все биты операнда. 

 6 & 2  -->  2 (0110 & 0010 -> 0010)
 5 | 2  -->  7 (0101 | 0010 -> 0111)
 5 ^ 6  -->  3 (0101 ^ 0110 -> 0011)
 ~10  -->  -11 (01010 -> 10101)

В примере выше, при выполнении ~10, получается код отрицательного числа, т.к. старший бит
равен 1. Система воспринимает его как дополнительный код, поскольку для записи отрицательных
чисел используются именно дополнительные коды. Отсюда и такой результат -11.

Дополнительный код отрицательного числа - это его обратный код + 1. Обратный код находится
путем инверсии всех битов, кроме последнего (старшего), т.к. тот отвечает за знак.

 -11 = 11011 (прямой код) -> 10100 (обратный код) -> 10101 (дополнительный код)

Стоит отметить также, что операция ~10 выдает обратный код числа -10. А обратный код числа
всегда соответвуюет дополнительному коду следующего числа, т.е. -11.

Если в арифметических операциях участвуют значения разных типов, то компилятор неявно
приведет их к одному типу. Обычно к самому большему. 

 int a = 10;
 double b = 4;
 double c = a + b;  -->  14.00000 ("a приводится к double")

Приведение типов может сопровождаться потерей информации, например когда переменная 
большего типа приводится к переменной меньшего типа. Посему приводить нужно 
только от меньшего типа к большему.

 int a = 300;
 char b = a;  -->  44 (в других языках потребовалось бы явное приведение, через скобки)
 long c = a;  -->  300

В примере выше, при присвоении b = a, происходит срез байтов 
и остается только первый младший байт.

 00000000000000000000000100101100  -->  00101100

Операторы if и switch, а также тернарный оператор принимают только выражения, которые
возвращают какое-то число. Ненулевое згачение означает истину, а ноль - ложь.

Циклов всего 3: for, while и do...while.

Чтобы инициализировать массив, используется набор значений в фигурных скобках.
Если присвоить пустые фигурные скобки, то элементы получать значения по умолчания.

При объявлении массива с инициализацией можно явно не указывать его длину.
Не обязательно инициализировать все элементы, можно только несколько первых.
Также можно частично инициализировать некоторые элементы (не по порядку).

 int a[4];                      
 int b[3] = {};                  -->  0, 0, 0
 int c[] = { 1, 2, 3 };          -->  1, 2, 3
 int d[5] = { 10, 12 };          -->  10, 12, 0, 0, 0
 int e[5] = { [1]=11, [3]=13 };  -->  0, 11, 0, 13, 0

Оператор sizeof также вычисляет размер массива в байтах и возвращает size_t, 
который можно вывести на консоль, с пом. спецификатора %zu.

 int arr[] = { 5, 6, 7 };
 size_t arrSize = sizeof(arr);  
 printf("%zu", arrSize);  -->  12 (3 элемента по 4 байта)

При переборе массива в цикле, для i рекомендуется задавать тип size_t, 
т.к. он гарантирует что i не выйдет за пределы типа.

При динамической установке размера массива его нельзя инициализировать 
через фигурные скобки.

 int size = 2;

 // Так нельзя
 int a[size] = { 1, 2 };

 // Так можно
 int b[size];
 b[0] = 1;
 b[1] = 2;

Чтобы запретить изменение элементов массива, нужно сделать массив константным:

 const int arr[3] = { 11, 12, 13 };  
 arr[1] = 22;  // ошибка

Многомерный массив определяется следующим способом:

 int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };

 // Тоже самое, поскольку все массивы - это непрерывный блок данных в памяти
 int b[3][2] = { 1, 2, 3, 4, 5, 6 };  

 printf("%d", a[2][0]);  -->  5

В Си строки - это массивы символов, где последний элементом является '\0' - нулевой байт.
Нулевой байт служит признаком окончания строки (первый символ из таблицы ASCII).

 char msg1[] = "Hello";
 char msg2[] = { 'H', 'e', 'l', 'l', 'o', '\0' };  // тоже, что и "Hello"

 sizeof(msg1) / sizeof(char);  -->  6
 
Для ввода с консоли используется ф-ция scanf(). Она определена в заголовочном файле stdio.h.
Эта ф-ция принимает шаблонную строку и аргументы в виде набора переменных, в которые
будут считываться данные. Переменные передаются по ссылке. 

Шаблонная строка содержит спецификаторы, которые определяют вводимые данные. Например, 
с ее помощью можно задать ввод сразу нескольких значений, либо задать ограничение на кол-во
вводимых символов. В качестве разделителя ввода можно испльзовать пробелы.

 int count;
 double price;
 long code;

 scanf("%d", &count);
 scanf("%lf %ld", &price, &code);
 
Пример считывания строки:

 char name[10];

 // Имя массива - это адрес его первого элемента
 // Ширина поля 10 означает, что считываться будут только 10 символов, 
 // а затем считывание прекратится.

 scanf("%10s", name); 

Если нужно вводить также пробелы, тогда спецификатор нужно изменить на "%10[^\n]".
Запись [^\n] означает, что надо считывать ввод до тех пор, пока не встретиться символ
перевода строки '\n', т.е. пока пользователь не нажмет на Enter.
 
----------------------

УКАЗАТЕЛИ

Указатель хранит адрес переменной в памяти. Адрес переменной представляет собой 
целочисленное значение, выраженное в шестнадцатиричном формате.

Указатель всегда указывает на начало переменной. Например, переменная типа int занимает в
памяти 4 ячейки (поскольку каждая ячейка хранит по одному байту). Указатель на такую
переменную будет хранить адрес только первой ячейки из 4 выделенных.

Чтобы получить переменную указателя, к нему применяется операция * (разыменовывание),
Чтобы получить адрес переменной - к переменной применяется операция &. 

Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить
ему условное нулевое значение с помощью константы NULL, которая хранится в stdio.h

 int* p = NULL;

Используя указатель, можно менять значение переменной, адрес которой он хранит.

 int a = 10;
 int* p = &a;
 *p = 45;  -->  a = 45

Для вывода указателя используется спецификатор %p. При выводе адреса, ф-ция printf() 
ожидает, что указатель будет типа void* (иначе могут быть предупреждения).

 printf("%p", (void*)p);

Указатель типа void* указывает на данные любого типа. Однако к такому указателю нельзя
применить операцию разыменовывания и тем самым получить значение по адресу.
Чтобы получить значение, нужно привести void* к конкретному типу.

 int b = 23;
 void* p2 = &b;

К указателям одного типа могут применятся операциии сравнения (>, >=, <, <=, ==, !=).
Для сравнения используются номера адресов.

К указателям можно также применять арифмитеческие операции (кроме void*): 
 * инкремент/декремент - изменение адреса на размер типа;
 * добавление/удаление числа - изменение адрес на размер типа * число;
 * вычитание указателя - расстояние между адресами;

Расстояние между адресами - это кол-во значений, которые могут там поместится. 
Оно представлено типом ptrdif_t. Этот тип является псевдонимом long long.

Операции всегда выполняются справа на лево. Следует всегда следить за этим:

 // Сначала выполнится сдвиг адреса p++, 
 // а затем по новому адресу будет выполнено разыменование
 int b = *p++;    -->  6356629

 // Нужно добавить доп. скобки
 int c = (*p)++;  -->  46

 // Здесь все правильно, т.к. порядок операций идет справо на лево
 int d = ++*p;    -->  47

С помощью указателей можно изменять значения любых переменных, даже констант констант.
Несмотря на то, что константы вроде как представляют неизменяемые сущности.
 
 const int a = 10;
 int* p = &a;
 *p = 20;  // допустимо (a = 20)
  p = &b;  // допустимо

Чтобы запретить измение переменной указателя, нужно создать указатель на константу.
Но такому указателю можно присвоить новый адрес.

 const int* p = &a;
 *p = 20;  // ошибка
  p = &b;  // допустимо

Чтобы запретить измение адреса указателя, нужно создать константный указатель.
Но измение переменной указателя будет доступно.

 int* const p = &a;
 *p = 20;  // допустимо
  p = &b;  // ошибка

Чтобы запретить измение и переменной, и адреса указателя нужно создать 
константный указатель на константу.

 const int* const p = &a;
 *p = 20;  // ошибка
  p = &b;  // ошибка

Имя массива является адресом его первого элемента, а точнее адресом первого байта, 
первого элемента. Прибавляя определенное число к имени массива можно получить
указатель на соответсвующий элемент.

 int arr[] = { 1, 3, 2, 4 };
 int first = *arr;  -->  1

 // Сместив адрес массива на 4 байта, получаем адрес 2 эл-та
 int second = *(arr + 1);  -->  3 

Когда идет обращение к элементу массива через квадратные скобки, компилятор рассматривает
такую запись как прибавление числа к имени массива.

 arr[2]; arr + 2; // одно и то же.

К элементу можно обратиться даже так: 3[arr]  -->  3 + arr  -->  4 

В Си для представления строки можно использовать указатель на char.
Но в таком случае изменять элементы не получится.

 char* str = "hello world!";
 str[1] = 'a';  // ошибка
 *str = 'B';    // ошибка

Чтобы была возможность изменять элементы строки, нужно использовать массив char.

 char str[] = "hello world!";
 str[1] = 'a';  // допустимо
 *str = 'B';    // допустимо

Указателям на char можно присваивать значение NULL. Однако этот случай нужно отличать 
от пустой строки. Пустая строка имеет один символ - нулевой байт.

 char* str = NULL;   // строка без инициализации
 char* str2 = "\0";  // пустая строка 

Массив указателей определяется следующим способом:

 int* p[3] = { &a, &b, &c };
 const a = *p[0];  // обычный способ получить значение эл-та

 // Сначала происходит сдвиг на 4 байта (p + 1)
 // Затем разыменовываем p и получаем адрес сдвига (т.е. b)
 // После этого разыменовываем сам адрес b

 const b = **(p + 1);

Для работы с многомерными массивами используются указатели на массивы. 
Такие указатели по сути указывают на подмассивы:

 int arr[3][2] = { {1, 2}, {3, 4}, {5, 6} };

 // Здесь размерность массива это часть определения указателя. 
 // Такому указателю нельзя задать адрес массива с большей размерностью

 int (*p)[2] = arr + 1;
 int (*p2)[] = arr + 2;  // размерность вычислится автоматически
 int (*p3)[2] = &arr;    // ошибка, arr содержит больше 2х элементов

 printf("%d", (*p)[0]);  -->  3

Если указатель на char можно представить в виде строки, то массив char-указателей
представляет собой массив строк:

 char* arr[] = { "hello", "world" };
 char* str = arr[1];

Указатель на указатель хранит адрес указателя на переменную. 
Это называется многоуровневая адресация.

 int a = 20;
 int* p = &a;
 int** pp = &p;

 // Разыменовав указатель мы получаем значение переменной, на которую он указывает. 
 // Следовательно, разыменовав "pp" мы получаем значение "p", т.е. адрес "a".

 printf("%p", *pp); -->  адрес a  
 printf("%d", **pp); --> значение a

----------------------

ФУНКЦИИ

Компилятор должен знать о ф-ции до ее вызова, поэтому сначала идет определение ф-ции, 
а только потом вызов. Вместо определения ф-ции, можно сначала указать прототип. 
В этом случае вызов ф-ции станет доступен перед определением.

Если ф-ция принимает параметры, то в ее прототипе они также должны быть указаны, 
но без названий. Если ф-ция не принимает параметров, то в прототипе нужно указать void.

 int add(int, int);
 void log(void);

 int main() {
     log(); 
     return 0;  
 }

 void log() {
     int res = add(1, 2);
     printf("Result: %d", res);
 }

 int add(int x, int y) {
     return x + y;
 }
 
Если в ф-цию передать значение другого типа, то компилятор попытается выполнить 
приведение типов.

 add(1, 2.5);  // ф-ция получит числа 1 и 2    

При компиляции ф-ции, для ее параметров выделяются отдельные участки памяти. 
При этом для параметров типа float формируются участки с типом double, 
а для char и short - участки с типом int.

При вызове ф-ции вычисляются значения передаваемых аргументов, а затем эти значения 
заносятся в участки памяти, отведенные для параметров. Значения типа float станут double, 
а char и short станут int.

После завершения работы ф-ции, память, выделенная для параметров, освобождается.

Иногда бывают ситуации, когда нужно гарантировать, что параметр сохранит свое значение 
на протяжении всей работы ф-ции. В этом случае параметр должен быть константным.

Это особенно актуально при работе с указателями, т.к. через них можно  
изменить исходное значение переменной.

 int myFunc(const int* num) {}
 
Если ф-ция возвращает тип void, и явно не вызывает оператор return, 
то компилятор сам добавит его в конце.

 void myFunc() {
     printf("hello world");
     return;  // добавится автоматически   
 }

При определении рекурсии, все рекурсивные вызовы должны обращаться к подфункциям, 
которые в конце концов сведутся к базовому варианту. Это так называемый рекурсивный спуск.

Вместо рекурсий можно использовать циклы. Они работают быстрее и эффективнее.
Но рекурсии дают более элегатные решения. Например, при обходе деревьев.

Если локальная переменная определена без инициализации, то она получит мусорное значение.
Если глобальная переменная определена без инициализации, то она получит значение 0.

Область видимости локальных переменных - это блок кода. Как только блок кода начинает
выполняться, то для его переменных выделяется память. После завершения работы блока кода,
выделенная память освобождается и переменные удаляются.

Локальные переменные могут быть статическими. Их особенность в том, что они инициализируются
только один раз, а при последующих обращениях используют старое значение из памяти и не
уничтожаются; даже после завершения работы блока кода/ф-ции.

Чтобы получить доступ к глобальной переменной из другого файла, нужно объявить ее 
с помощью ключевого слова extern (без инициализации). А чтобы получить доступ к ф-ции 
из другого файла, нужно просто указать ее прототип.

Файл other.c
 
 char msg[] = "hello world!";
 int add(int x, int y) {
     return x + y;
 }

Файл main.c

 #include <stdio.h>

 extern char msg[];
 int add(int, int);

 void main() {
     printf("%s %d", msg, add(1, 2));  -->  "hello world!" 3
 }

При компиляции нужно передать имена всех файлов: gcc main.c other.c

Глобальные переменные и ф-ции также могут быть статическими. 
В этом случае они будут недоступны для использования в других файлах.

Файл other.c

 static char msg[] = "hello world!";
 static int add(int x, int y) {
     return x + y;
 }

Файл main.c

 extern char msg[];  // переменная недоступна
 int add(int, int);  // ф-ция недоступна

Если ф-ция принимает в параметрах массив, то фактически это будет только указатель 
на его первый элемент, а не полноценная коллекция.

 void myFunc(int arr[]) {
     // Так сделать не получится
     size_t length = sizeof(arr) / sizeof(arr[0]);
 } 

Массиву в параметрах можно установить минимальную длину с пом. оператора static:
 void myFunc(int arr[static 4]) {}  // ожидаем массив минимум с 4 эл-тами

Массив можно также передавать как константный. В этом случае значения его 
эл-тов нельзя будет изменить.

Имя ф-ции является адресом первого байта, по которому располагается ее код.
Указателю на ф-цию можно присвоить ту ф-цию, сигнатура которой соответвует его типу.
Его синтаксис напоминает то, как объявляется указатель на массив (тоже в скобках).

 // Указатель на ф-цию, которая не принимает никаких параметров 
 // и ничего не возвращает. Здесь также нужно указывать void в круглых скобках.
 void (*p)(void);  

 // Указатель на ф-цию с двумя целочисленными параметрами, 
 // которая возвращает также число
 int (*p2)(int, int);

 p = log;
 p();

 p2 = add;
 int res = p2(10, 20);

Пример объявления массива указателей на ф-ции, которые принимают по два 
параметра типа int и возвращают double:

 double (*p[3])(int, int) = { add, sub, mul };
 double res = p[0](10, 5);

С помощью оператора typedef можно задать псевдоним (тип) ф-ции. Такие псевдонимы упрощают
применение указателей на ф-ции: typedef возвращаемый_тип (псевдоним)(тип_параметра)

 // Здесь message - это псевдоним ф-ции, которая ничего не принимает и не возвращает
 typedef void (message)(void);

 // Здесь msg - это указатель на ф-цию типа message. 
 // Возможно здесь избыточный код, т.к. log это уже сам по себе указатель...
 message* msg = &log; 
 msg();

Псевдоним ф-ции можно определить сразу как указатель на ф-цию.

 typedef double (*operation)(int, int);
 operation ops[] = { add, sub, mul };
 double res = ops[0](10, 5);
 
Ф-ция в своих параметрах может принимать указатель на другую ф-цию. Вместо указателя 
на ф-цию можно также передавать псевдоним (тип) ф-ции.

 void myFunc(int (*p)(int, int), message msg) {
    int res = p(10, 20);
    msg();
 }

 myFunc(add, log);

Ф-ция может возвращать указатель на другую ф-цию. Пример объявления таких ф-ций:

 // Ф-ция myFunc, которая принимает один параметр типа int 
 // и возвращает указатель int (*p)(int, int)

 int (*myFunc(int arg))(int, int) {
     return arg > 0 ? add : sub;
 }

 int (*p)(int, int) = myFunc(1);
 int res = p(10, 20);

 // Ф-ция myFunc, которая ничего не принимает 
 // и возвращает указатель void (*p)(void)

 void (*myFunc())(void) {
     return log;
 }

 void (*p)(void) = myFunc();
 p();

Всесто указателя на ф-цию можно также возвращать псевдоним ф-ции:
 message* myFunc() { return &log; } 

Для определения ф-ции с переменным кол-вом параметром используется многоточие. 
Но при этом ф-ция должна иметь как минимум один обязательный параметр.

 void myFunc(int n, ...) {}

Типы таких параметров могут также быть неопределенными и становится известными 
только во время вызова ф-ции. Для упрощения работы с переменным кол-вом параметров
неопределенных типов в заголовочном файле stdarg.h есть специальные макросы:

 // Этот макрос с помощью requeredParam связывает va_list с первым необязательным 
 // параметром, т.е. requeredParam как бы сообщает, где искать первый параметр 
 // и отталкиваясь от него, двигаться по остальным. 
 void va_start(va_list param, requeredParam); 

 // Этот макрос позволяет получить значение текущего параметра 
 // и перемещает указатель va_list на следующий параметр.
 type va_arg(va_list param, type);  

 // Этот макрос завершает обработку параметров
 void va_end(va_list param);

Эти маросы используют тип данных va_list, который позволяет обрабатывать
нефиксированный набор параметров.

 int sum(int count, ...) {
     int res = 0;

     va_list factor;
     va_start(factor, count);  
     for (int i = 0; i < count; i++) {
         res += va_arg(factor, int);
     }   
     va_end(factor);

     return res;
 }

 int res = sum(5, 1, 2, 3, 4, 5);

Ф-ции printf() и scanf() используют этот механиз для работы с переменным кол-вом параметров.
А для идентификации типов параметров используют спецификаторы (%d, %s, %c и др.)
 
Ф-ция main() может получать параметры командной строки, которые передаются программе 
при запуске. Для этого используется следующая сигнатура: int main(int argc, char* argv[]);

Параметр argc - это кол-во передаваемых аргументов, а argv - названия этих аргументов.
По умолчанию, если программе не передается никаких параметров, то argc будет иметь 
значение 1, а argv содержать название программы.

 ./a.out              -->  argc = 1, argv = { "a" }
 ./a.out hello world  -->  argc = 3, argv = { "a", "hello", "world" }

----------------------

ПРЕПРОЦЕССОР


