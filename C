ВВЕДЕНИЕ

Программа на Си состоит из набора директив препроцессора, определений ф-ций 
и глобальных данных (переменных).

Каждая инструкция выполняет определенное действие. В конце инстуркции ставится точка 
с запятой. Набор инструкций задается блоком кода, который определяется фигурными скобками.

При компиляции исходного кода вначале срабатывает препроцессор, который сканирует исходный
код на наличие строк, начинающихся с символа решетки. Эти строки расцениваются препроцессором
как директивы и на их месте происходит какое-то преобразование текста. Например, на месте
директивы #include <stdio.h> вставляется код из файл stdio.h

Стартовой точкой выполнения кода является ф-ция main(). Эта ф-ция может возвращать либо
число, либо void. Если main() возвращает число, то ноль означает успешное выполнения
программы, а другие числа - какую-то ошибку. Ключевое слово void в круглых скобках 
означает, что ф-ция не принимает параметров: 

 int main(void) { ... }

Компиляция программы с помощью командной строки: gcc myfile.c

После компиляции будет создан исполняемый файл a.out
Переопределить имя исполняемого файла можно с помощью флага -o: 

 gcc myfile.c -o myprog.out

По умолчанию при компиляции не отобрадается никаких предупреждений. Для компиляции 
с предупреждениями нужно ипользовать флаг -Wall:

 gcc -Wall myfile.c

С помощью флага -std= можно задать стандарт языка, например c99, c11, c17. 
А чтобы гарантировать, что программа будет строго соответстовать определенному стандарту,
можно задать флаг -pedantic.

 gcc -std=c11 myfile.c
 gcc -std=c17 -Wall -pedantic myfile.c & ./a.out  -->  скомпилировать и запустить

Флаг -S позволяет сгенерировать файл с ассемблерным кодом (ассемблер GAS).
 gcc myfile.c -S  -->  создаст файл myfile.s

Если вместо кириллицы отображаются непонятные знаки, то в код нужно добавить вызов
setlocale(LC_ALL, ""); Эта ф-ция станет доступна после подключения locale.h

----------------------

ОСОБЕННОСТИ ЯЗЫКА

Базовые типы данных и их размеры:

 * char - символ 1 байт (signed char);
 * unsigned char - беззнаковый символ 1 байт;

 * short - число 2 байта (short int, signed short, sifned short int);
 * unsigned short - беззнаковое число 2 байта (unsigned short int);

 * int - число, 2 байта для x32 и 4 байта для x64 архитектур (signed, signed int);
 * unsigned int - беззнаковое число 2/4 байта (unsigned, unsigned int);

 * long - число, 4 байта для Windows_x64 и 8 байт для Linux_x64/MacOS_x64;
   (long int, signed long int, signed long)

 * unsigned long - беззнаковое число 4/8 байт (unsigned long int);

 * long long - число 8 байт (long long int, signed long long int, signed long long);
 * unsigned long long - беззнаковое число 8 байт (unsigned long long int);

 * float - вещественное число 4 байта;
 * double - вещественное число 8 байт;
 * long double - вещественное число 10 байт;

 * void - тип без значения;

Любое десятичное число, в зависисоти от размера, рассматривается как: 
int, long int или long long int. И при присвоении в переменную другого типа неявно
преобразуется. Чтобы избежать ненужного преобразования, к числу добавляется суффикс:

 * u/U - unsigned int, unsigned long int и unsigned long long int;
 * ul/UL - unsigned long int и unsigned long long int;
 * ll/LL - long long int;
 * ull/ULL - unsigned long long int;

 unsigned int a = 1;  -->  выполнится неявное преобразование из int в unsigned int
 unsigned int b = 2u;  -->  здесь неявное преобразование пропустится

Вещественные числа по умолчанию представлены как double. Чтобы указать, что число 
имеет тип float или long double нужно добавить суффикс f или l соответсвенно:

 double a = 3.14;
 float b = 3.14f;
 long double c = 3.14l;

Числа в двоичной системе начинаются с префикса 0b, восьмеричные числа начинаются с 0, 
а шестнадцатиричные с 0x. После префикса указывается число в заданной системе.

 int a = 0b1011;  -->  11 в двоичной системе
 int b = 013;     -->  11 в восьмиричной системе
 int c = 0xB;     -->  11 в шестнадцатиричной системе

Char-переменная в качестве значения принимает символьный литерал в одинарный кавычках.
Однако в реальности такая переменная хранит число - код символа из таблицы ASCII.
Т.е. символьные литералы в одинарных кавычках - это данные типа int.

 char a = 'A';  -->  65
 char b = 65;   -->  тоже самое

При определении переменных, в одной строке можно задать сразу несколько:
 int a = 1, b = 2, c = 3;

Оператор typedef позволяет задать псевдоним для типа (typedef тип псевдоним):
 
 typedef unsigned char BYTE;
 BYTE num = 22;

Стандарт указывает лишь минимальные размеры для базовых типов. Однако предельные размеры 
могут отличаться, в зависимости от компиляторов. Чтобы точно знать размер типа используется
оператор sizeof, который возвращает кол-во памяти в байтах. 

 size_t size1 = sizeof(int);
 size_t size2 = sizeof(unsigned long);

Возвращаемое значение оператора sizeof представлено типом size_t, который является просто
псевдонимом другого числового типа. В одних системах size_t может быть unsigned long, 
в других чем-то еще. Поэтому при работе с sizeof нужно использовать именно size_t.

Оператор sizeof может также вычислять размер переменной или даже целого выражения 
(переменную или выражение можно указывать как в скобках, так и без).
 
 int num = 2;
 size_t numSize = sizeof(num);  -->  4 (размер типа переменной)

 // Вычислит размер возвращаемого типа, т.е. 4, потому что printf() 
 // возвращает int. При этом сама ф-ция не выполнится.
 size_t expSize = sizeof printf("hello!");                 

Для вывода на консоль используется ф-ция printf().
Она становится доступной после подключения заголовочного файла stdio.h

 printf("hello world!");

Выводимая строка может также содержать спец. символы, например \n, \r, \t и др.
Для вывода других типов данных используются спецификаторы:

 %c - для вывода букв;
 %s - для вывода строк;
 %d - для вывода целых чисел;
 %u - для вывода целых беззнаковых числе;
 %i - для вывода чисел типа int;
 %f - для вывода вещественных чисел (float, double);
 %o - для вывода восьмеричных чисел;
 %x - для вывода шестнадцатиричных чисел;
 %X - для вывода шестнадцатиричных чисел в верхнем регистре;
 %% - для вывода знака процента;

 printf("char: %c \n", 'a');
 printf("string: %s \n", "hello!");
 printf("number: %u \n", 23);
 printf("name: %s age: %d weight: %f", "Tom", 23, 63.5);

Для вывода вещественных чисел можно использовать ширину поля и точность. 
 printf("x: %4.2f", 71.8925)  -->  71.90 

В спецификаторе %4.2f, 4 означает до скольки знаков выводить перед точкой, 
а 2 - до скольки знаков выводить после точки.

Чтобы конкретизировать выводимое значение, можно задать модификатор:
 * h - для значений short int;
 * l - для значений long int и unsigned long int;
 * ll - для значений long long int и unsigned long long int;
 * L - для значений long double;

 printf("x: %hd", 7100);

Можно также задать доп. флаги чтобы более точно настроить вывод. Например, знак "-" сделает
выравнивание текста по левому краю, а число 9 (перед s) - это скорей всего доп. пробелы.

 printf("%-9s %d", "Tom", 38);  -->  "Tom       38"

Для определения константы используется ключевое слово const: 
 const int num = 23;

При делении целых чисел, результат округляется до целого, даже если он присвоен float.
Чтобы получить вещественное число, один из операндов должен также быть вещественным числом.

 float a = 10 / 4;    -->  2.0
 float b = 10.0 / 4;  -->  2.5
  
Логические операции не возвращают последний доступный операнд, как в JS, 
а только 1, если выр-е истино или 0, если выр-е ложно.

Логическое отрицание возвращает 1 если операнд равен 0:
 !2  -->  0    !0  -->  1

Логическое умножение (конъюнкция) возвращает 1, если оба операнда не равны 0:
 -2 && 5  -->  1    0 && 7  -->  0

Логическое сложение (дизъюнкция) возвращает 1, если хотя бы один операнд не равен 0:
 -2 || 5  -->  1    0 || 7  -->  1

Операции сравнения (>, >=, <, <=, ==, !=) имеют больший приоритет, чем логические. 
Они также возвращают либо 0, либо 1.

Операции сдвига (<<, >>) сдвигают битовое представление числа вправо или влево 
на заданное кол-во разрядов:

  2 << 2  -->  8 (00010 -> 01000)  
 16 >> 3  -->  2 (10000 -> 00010) 

Поразрядные операции сравнивают биты операндов между собой (делают побитовое сравнение).
Условия поразрядных конъюнкции и дизъюнкции такие же как и у логических. Поразрядное
исключающее ИЛИ (^) возвращает 1 если только один из сравниваемых битов равен 1.
Поразрядное отрицание (~) инвертирует все биты операнда. 

 6 & 2  -->  2 (0110 & 0010 -> 0010)
 5 | 2  -->  7 (0101 | 0010 -> 0111)
 5 ^ 6  -->  3 (0101 ^ 0110 -> 0011)
 ~10  -->  -11 (01010 -> 10101)

В примере выше, при выполнении ~10, получается код отрицательного числа, т.к. старший бит
равен 1. Система воспринимает его как дополнительный код, поскольку для записи отрицательных
чисел используются именно дополнительные коды. Отсюда и такой результат -11.

Дополнительный код отрицательного числа - это его обратный код + 1. Обратный код находится
путем инверсии всех битов, кроме последнего (старшего), т.к. тот отвечает за знак.

 -11 = 11011 (прямой код) -> 10100 (обратный код) -> 10101 (дополнительный код)

Стоит отметить также, что операция ~10 выдает обратный код числа -10. А обратный код числа
всегда соответвуюет дополнительному коду следующего числа, т.е. -11.

Если в арифметических операциях участвуют значения разных типов, то компилятор неявно
приведет их к одному типу. Обычно к самому большему. 

 int a = 10;
 double b = 4;
 double c = a + b;  -->  14.00000 ("a приводится к double")

Приведение типов может сопровождаться потерей информации, например когда переменная 
большего типа приводится к переменной меньшего типа. Посему приводить нужно 
только от меньшего типа к большему.

 int a = 300;
 char b = a;  -->  44 (в других языках потребовалось бы явное приведение, через скобки)
 long c = a;  -->  300

В примере выше, при присвоении b = a, происходит срез байтов 
и остается только первый младший байт.

 00000000000000000000000100101100  -->  00101100

Операторы if и switch, а также тернарный оператор принимают только выражения, которые
возвращают какое-то число. Ненулевое число означает истину, а 0 - ложь.

Циклов всего 3: for, while и do...while.

Массив определяется так: тип название[длина];

Чтобы инициализировать массив, используется набор значений в фигурных скобках.
Если присвоить пустые фигурные скобки, то элементы получать значения по умолчания.

При объявлении массива с инициализацией можно явно не указывать его длину.
Не обязательно инициализировать все элементы, можно только несколько первых.
Также можно частично инициализировать некоторые элементы (не по порядку).

 int a[4];                      
 int b[2] = {};                  -->  0, 0
 int c[] = { 1, 2, 3 };          -->  1, 2, 3
 int d[5] = { 10, 12 };          -->  10, 12, 0, 0, 0
 int e[5] = { [1]=11, [3]=13 };  -->  0, 11, 0, 13, 0

Оператор sizeof также вычисляет размер массива в байтах и возвращает size_t, 
который можно вывести на консоль, с пом. спецификатора %zu.

 int arr[] = { 5, 6, 7 };
 size_t arrSize = sizeof(arr);  
 printf("%zu", arrSize);  -->  12 (3 элемента по 4 байта)

При переборе массива в цикле, для i рекомендуется задавать тип size_t, 
т.к. он гарантирует что i не выйдет за пределы типа.

При динамической установке размера массива его нельзя инициализировать 
через фигурные скобки.

 int size = 2;

 // Ошибка!
 int a[size] = { 1, 2 };

 // Так нормально
 int b[size];
 b[0] = 1;
 b[1] = 2;

Чтобы запретить изменение элементов массива, нужно сделать массив константным:

 const int arr[3] = { 11, 12, 13 };  
 arr[1] = 22;  // Ошибка!

Пример определения и инициализации многомерных массивов:

 int a[3][2] = { {1, 2}, {3, 4}, {5, 6} };

 // Тоже самое, поскольку все массивы - это непрерывный блок данных в памяти
 int b[3][2] = { 1, 2, 3, 4, 5, 6 };  

 printf("%d", a[2][0]);  -->  5

В Си строки - это массивы символов, где последний элементом является '\0' - нулевой байт.
Нулевой байт служит признаком окончания строки (первый символ из таблицы ASCII).

 char msg1[] = "Hello";
 char msg2[] = { 'H', 'e', 'l', 'l', 'o', '\0' };  -->  тоже, что и "Hello"

 sizeof(msg1) / sizeof(char);  -->  6
 
Для ввода с консоли используется ф-ция scanf(). Она определена в заголовочном файле stdio.h.
Эта ф-ция принимает шаблонную строку и аргументы в виде набора переменных, в которые
будут считываться данные. Переменные передаются по ссылке. 

Шаблонная строка содержит спецификаторы, которые определяют вводимые данные. Например, 
с ее помощью можно задать ввод сразу нескольких значений, либо задать ограничение на кол-во
вводимых символов. В качестве разделителя ввода можно испльзовать пробелы.

 int count;
 double price;
 long code;

 scanf("%d", &count);
 scanf("%lf %ld", &price, &code);
 
Пример считывания строки:

 char name[10];
 // Название массива - это адрес его первого элемента
 // Ширина поля 10 означает, что считываться будут только 10 символов, 
 // а затем считывание прекратится.
 scanf("%10s", name); 

Если нужно вводить также пробелы, тогда спецификатор нужно изменить на "%10[^\n]".
Запись [^\n] означает, что надо считывать ввод до тех пор, пока не встретиться символ
перевода строки '\n', т.е. пока пользователь не нажмет на Enter.
 
----------------------

УКАЗАТЕЛИ



 


    


