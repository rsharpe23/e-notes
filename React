ОСНОВЫ

Версия 19.1

Компонент - это элемент пользовательского интерфейса, у которого есть своя логика 
и представление. Компонент в React представляет из себя ф-цию, возвращающую JSX разметку.
Название ф-ции должно начинаться с заглавной буквы, иначе компонент не будет работать 

В одном файле может определяться сразу несколько компонентов. Компонент, чье название
соответсвует названию файла, обычно экспортируется через экспорт по умолчанию, а все
вспомогательные компоненты - через именованный экспорт.

Компонент должен всегда возвращать только один корневой элемент. Если корневых элементов
несколько, то их нужно обернуть (обычно во фрагмент, но можно просто в <div>).

Фрагмент определяется как тег без названия (краткий синтаксис): <> ... </>

JSX - это синтаксическое расширение для JS, позволяющее писать HTML-подобную разметку 
в JS-файле. React активно использует JSX, но сам по себе JSX не являет его core-особенностью.

Если JSX разметка находится на той же строке, где и return, то ее можно указывать без скобок,
иначе со скобками, т.к. все что идет после return будет проигнорировано.

JSX требует чтобы одиночные теги всегда закрывались (т.е. так <br />). Названия атрибутов
почти такие же, как и в HTML, но записываются в camelCase (кроме aria-* и data-*). 
Вместо атрибута class используется className, поскольку слово class зарезервировано JS.

Чтобы передать в JSX значение переменной или JS-выражение, нужно использовать 
фигурные скобки. Атрибут style нужно задавать через объект.

 <h1>To Do List for {formatDate(today)}</h1>
 <img className="My avatar" src={avatar} alt={description} />
 <img style={{ width: mySize, height: mySize }} />

Чтобы получить доступ к пропсам компонента, нужно обратиться к первому (и единственному)
параметру ф-ции. Пропсы представлены объектом, который обычно деструктуризируют. 

Если при деструктуризации пропсу указать значение по умолчанию, то его можно не устанавливать
из вне. Но если ему передать null или 0, то значение по умолчанию работать не будет.

Если компонент имеет какое-то содержимое между своими тегами, то это содержимое можно
получить с пом. специального пропса - children.

 const Card = ({ children }) => {
   return <div className="card">{children}</div>
 };

Пропсы должны быть иммутабельными внутри своего компонента. Изменять пропсы могут только
родительские компоненты, путем передачи дочерним компонентам новых значений.

Условный рендеринг выполняется с пом. обычного JS-выражения. Для этого используется либо
оператор if/else, либо тернарный оператор, либо оператор &&. Оператор && следует использовать
с осторожностью, т.к. если значение левого операнда будет 0, то вместо того, чтобы ничего не
рендерить, React просто покажет 0 (т.е. левый операнд нужно всегда явно приводить к bool).

Если из компонента (например при условном рендеринге) вернуть null, undefined 
или false, то он ничего не отрендерит.

Чтобы отобразить список компонентов, используется, обычно, ф-ция map(), которая принимает
какие-то данные и возвращает JSX (цикл не подойдет, т.к. компонент должен всегда что-то
возвращать). Несколько удобных способов создания массива для работы с map():

 Array(9).fill(null)        // массив из 9 эл-тов, раных null  
 Array.from({ length: 9 })  // массив из 9 пустых эл-тов

При отображении списка элементов, каждому эл-ту нужно задавать ключ. Ключ - это своего рода
идентификатор (строка или число), который отделяет один элемент от другого. React использ.
ключи при добавлении, удалении или изменении элементов в списке, чтобы отображать их 
в правильном порядке.

 // Элементы, созданные через map(), всегда должны иметь ключи.
 // Ключи нужно включать в данные, а не генерировать на лету.

 const people = [{ id: 1, name: 'Креола' }, { id: 2, name: 'Марио' }];
 const items = people.map(person => <li key={person.id}>{person.name}</li>)

Cледует учитывать, что краткий синтаксис фрагмента не позволяет передать key, поэтому 
если требуется чтобы элемент состоял из нескольких DOM-узлов, то их можно обернуть 
либо в тег (например <div>), либо более явный <Fragment>.

Следует избегать использования индексов в качестве ключей, т.к. может произойти их
переупорядочевание, если какие-то эл-ты будут удалены, или добавлены новые.

Ф-ции компонентов должны быть чистыми. Это означает, что они всегда должны возвращать
предсказуемый JSX, который зависит только от пропсов и локальных переменных. 

 // Изменяя глобальную переменную, ф-ция выполняет сайд эффект, 
 // в результате которого каждый новый вызов приводит 
 // к непредсказуемому результату

 let guest = 0;
 const Cup = () => {
   guest = guest + 1;                          // Чистые ф-ции никогда не мутируют 
   return <h2>Tea cup for getst: {guest}</h2>  // переменные из внешней области видимости!
 };

В примере выше, сайд эффект выполняется при рендеринге. Это неправильно! 
Сайд эффекты могут выполняться только после рендеринга (например при обработке события 
или при использовании хука useEffect).

Приложение на React представляет собой дерево рендеринга, где каждый узел это какой-то
компонент. Правильно составленное дерево рендеринга увеличивает производительность.
Так, например, компоненты верхнего уровня должны содержать наибольшую сложность, а конечные
компоненты, наоборот, должны быть простыми, т.к. часто рендерятся повторно.

Кроме дерева рендеринга, приложение также имеет дерево зависимостей, где каждый узел это
импортируемый js-модуль. Оно необходимо сборщикам для объединения используемого кода 
(чтобы на выходе иметь оптимизированный бандл), а также для определения наиболее 
тяжелых модулей, которые задерживают отрисовку UI и др.

Жизненный цикл компонента:
 * монтирование - когда компонент добавляется на экран;
 * обновление - когда компонент получает новые пропсы или изменяется состояние;
 * размонтирование - когда компонент удаляется с экрана;

-------------

ИНТЕРАКТИВНОСТЬ

Обработчики событий принято называть либо с префиксом on*, либо с handle*

Все события в JSX всплывают наверх, за исключением события скрола.
Остановить дальнейшее всплытие можно с пом. метода e.stopPropagation().

 // При клике по кнопке, сначала выведется "Клик по кнопке", 
 // а затем "Клик по тулбару"

 <div className="Toolbar" 
   onClick={() => alert('Клик по тулбару')}>
   <button onClick={() => alert('Клик по кнопке')}>Play</button>
 </div>

Обработчики событий часто передают через пропсы, от родителей к детям. 
Это хорошая практика, вместо использования всплытия событий.

 const Button = ({ onClick, children }) => {
   const _onClick = (e) => {
     e.stopPropagation();
     // Какое-то доп. действие
     onClick();
   };
   return <button onClick={_onClick}>{children}</button>
 };

 <div className="Toolbar">
   <Button onClick={() => alert('Клик по тулбару')}>Play</Button>
 </div>

Хук - это ф-ция, содержащая логику компонента (обычно завязанную на состояниях) для
переиспользования ее в разных местах. Хуки могут вызываться только в начале компонента 
Их нельзя вызывать в цикле или в условии. Названия хуков начинаются с префикса use*

Для определения состояния используется хук useState(). Обновление состояния приводит к новому
рендеру. Состояние изменяется только после отрисовки компонента (но не во время отрисовки).

 const Counter = () => {
   // Хотя состояние и определяется как локальная переменная, 
   // но на самом деле оно хранится в памяти отдельно от компонента.

   const [value, setValue] = useState(0);

   return (
     <button onClick={() => {
       setValue(value + 1);    // несмотря на то, что состояние обновляется 3 раза -
       setValue(value + 1);    // value изменится только один раз (выполнится
       setValue(value + 1);    // только самый последний setValue)

       // На каждый рендер - свой фиксированный snapshot состояния, 
       // (даже если к состоянию обратиться через время)

       setTimeout(() => alert(value), 3000);  -->  0

     }}>Inc</button>           
   );
 };

Обновление состояния начинается только после того, как выполнится весь код в обработчике
события. Это называется batching. Батчинг позволяет избежить лишних переотрисовок. 

Однако, если все же требуется обновить состояние несколько раз за одну отрисовку, 
то нужно использовать сеттер с колбеком.

 setValue(value + 5);
 setValue((value) => value + 1); 

 alert(value)  -->  6

Если состояние является объектом, то для изменения его свойст нужно задавать 
новый объект, с обновленными свойствами. 

 setPerson({ 
   ...person, 
   artwork: { 
     ...person.artwork,
     city: 'Краков'
   } 
 });

Тоже самое касается и массивов. При работе с массивами нужно избегать мутирующих методов,
например: splice(), sort(), push() и т.п. Для изменения эл-тов хорошо подходит 
метод map(), а для удаления эл-тов - метод filter().

 setArtists([
   ...artists.slice(0, idx),
   { id: someId, name: someValue },   // правильная вставка между эл-тами
   ...artists.slice(idx)
 ]);

Для удобного обновления объектов и массивов можно использовать библиотеку Immer. 
Она предоставляет мутирующий синтаксис, но не мутирует сам стейт:

 updatePerson((draft) => {
   draft.artwork.city = 'Лагос';
 });

Не рекомендуется создавать состояния с глубоковложенными объектами (и массивами), 
поскольку за ними тяжело следить и любая случайная мутация может привести к багам. 
Вместо этого, нужно попытаться реструктуризировать такие объекты в плоские 
(как это сделано в GLTF) или использовать Immer.

-------------

УПРАВЛЕНИЕ СОСТОЯНИЕМ

Если на месте одного компонента отрендерить другой, то первый будет уничтожен и его текущий
стейт будет сброшен. Но если другой компонент, является таким же, как и первый (по типу), 
то стейт не будет сброшен (даже если передаются другие пропсы).

 const Scoreboard = () => {
   const [isPlayerA, setPlayerA] = useState(true);
   return (
     {isPlayerA ? (
       <Counter person="Taylor" />   // здесь два компонента одного типа находятся  
     ) : (                           // на одной и той же позиции в дереве рендеринга, 
       <Counter person="Sarah" />    // поэтому их стейт будет общим
     )}
   );
 };

Но если все же необходимо, чтобы стейт сбрасывался и у таких компонентов, то их нужно либо
рендерить на разных позициях (например первый на первом месте, а второй - на втором, но
каждый из них отображается по своему условию), либо задавать им разный key.

 {isPlayerA ? (
   <Counter key="Taylor" person="Taylor" />   // теперь, при переключении компонентов
 ) : (                                        // их стейты будут сбрасываться
   <Counter key="Sarah" person="Sarah" />
 )}

Подход со сбросом стейтов через key удобен при работе с формами.
См. подробнее https://ru.react.dev/learn/preserving-and-resetting-state

Состояние не хранится в JSX тегах. Оно всего лишь ассоциируется с той позицией 
в дереве рендеринга, где хранится JSX тег.

Когда в компоненте появляется много действий для одного стейта, например добавление
редактирование, удаление элементов списка. То такую связанную логику можно вынести
в отдельный редюсер. Редюсер напоминает Redux.

 // Редюсер - это pure function, как компонент.
 // Тип действия редюсера определяется св-вом type.
 // Название действия должно быть в прошедшем времени.

 const myReducer = (items, action) => {
   switch (action.type) {
     case: 'added':
       return [...items, { id: action.id, text: action.text, done: false }];

     case: 'changed':
       return items.map((item) => item.id === action.item.id ? action.item : item);

     case: 'deleted':
       return items.filter((item) => item.id !== action.id);
   }
 };

 const MyComponent = () => {
   // Вместо useReduces можно использовать useImmerReducer
   // Он принимает редюсер в мутирующем стиле (более читабельный).

   const [items, dispatch] = useReduces(myReducer, initialItems);

   // Вместо того, чтобы в обработчиках событий использовать
   // сеттер от useState, используется dispatch редюсера

   const handleAddItem = (text) => {
     dispatch({ type: 'added', id: nextId++, text: someText });
   };

   const handleChangeItem = (changedItem) => {
     dispatch({ type: 'change', item: changedItem });
   };

   const handleDeleteItem = (itemId) => {
     dispatch({ type: 'deleted', id: itemId });
   };

   return (
     <AddItem onAddItem={handleAddItem} />

     <ItemList 
       value={items} 
       onChangeItem={handleChangeItem} 
       onDeleteItem={handleDeleteItem}
     /> 
   );
 };

Чтобы передать данные от родителя к глубоковложенным потомкам, следует использовать контекст.
Контекст - это компонент, который передает вглубь какое-то значение. Чтобы создать контекст
используется ф-ция createContext(). Получить контекст можно с пом. хука useContext.

 const MyContext = createContext(1);  // контекст с начальным значением

 const ParentComponent = () => {
   return (
     <MyContext value={23}>      // если не обернуть в MyContext, то ChildComponent 
       <section>                 // получит значение 1, при вызове useContext
         <div>
           <ChildComponent />
         </div>
       </section>
     </MyContext>
   );
 };

 const ChildComponent = () => {
   const someNum = useContext(MyContext);
   return <h2>{someNum}</h2>  -->  23
 };

Если использовать сразу несколько контекстов разных типов, то они не будут конфликтовать 
друг с другом. Нижестоящие контексты перекрывают вышестоящие (если они одного типа).

Констекст часто используют в паре с редюсером. Это удобно, когда требуется 
реализовать глобальные сигналы и т.п.

 // Создаем отдельные контексты, т.к. одни компоненты могут 
 // только считывать таски, а другие - только диспатчить

 const TaskContext = createContext(null);
 const TaskDispatchContext = createContext(null);

 const useTasks = () => useContext(TaskContext);
 const useTaskDispatch = () => useContext(TaskDispatchContext);

 const TaskProvider = ({ children }) => {
   const [tasks, dispatch] = useReducer(taskReducer, initialTasks);
   return (

     // Контекст имеет два вложенных компонента - Provider и Consumer. 
     // Первый используется для предоставления данных, а второй - для получения. 
     // Вместо Consumer можно использовать useContext(). А Provider используется 
     // по умолчанию, когда указывается компонент контекста.

     <TaskContext.Provider value={tasks}>
       <TaskDispatchContext.Provider value={dispatch}
         {children}
       <TaskDispatchContext.Provider>
     </TaskContext.Provider>
   );
 };

 const TaskApp = () => {
   return (
     <TaskProvider>      // не нужно ничего передавать через пропсы
       <AddTask />       // это намного удобнее...
       <TaskList />
     </TaskProvider>
   );
 };

 const AddTask = () => {
   const dispatch = useTaskDispatch();
   return (
     ...
     <button onClick={() => {
       dispatch({ type: 'added', id: nextId++, text: someText });
     }}>Add</button>
   );
 };

 const TaskList = () => {
   const tasks = useTasks();
   return (
     <ul>
       {tasks.map((task) => (
         <li key={task.id}><Task task={task} /></li>
       ))}
     </ul>
   );
 };

 const Task = ({ task }) => {
   const dispatch = useTaskDispatch();
   return (
     <input value={task.text} onChange={(e) => {
       dispatch({ type: 'changed', task: { ...task, text: e.target.value } })
     }} />
   ); 
 };

-------------

ПРОДВИНУТЫЕ ВОЗМОЖНОСТИ

Если требуется иметь состояние, изменение которого не вызывает перерисовку компонента,
то нужно использовать реф. Реф - это объект со свойством current, которое хранит 
его значение. В отличие от обычного стейта, значение рефа изменяется сразу. 
Создается реф с пом. хука useRef().

Рефы обычно хранят те данные, которые не должны отображаться (например id таймера). 
Часто они хранят DOM-элементы, для манипуляции с ними через нативный DOM API. 
Если елемент удаляется из DOM, то значение ref становится null.

 const Form = () => {
   const inputRef = useRef(null);
   const handleClick = () => inputRef.current.focus();
   return (
     <>
       <input ref={inputRef} />  // inputRef получит элемент только после отрисовки
       <button onClick={handleClick}>Focus</button>
     </>
   );
 };

Атрибуту ref (DOM-элемента) можно присвоить не только сам реф, но и колбек.
Этот подход удобен, когда требуется установить рефы для списка элементов, через цикл.

 const Friends = () => {
   ...
   return (
     <ul>
        {cats.map((cat) => (
          <li key={cat} ref={(node) => {

            const map = catsRef.current;
            map.set(cat, node);

            // Замыкание, вероятно, вызывается во время очистки 
            // (когда ref получает null)

            return () => map.delete(cat);
          }}
          </li>
        ))}
     </ul>
   );
 }; 

Если реф установить компоненту, то он передастся просто как пропс. В этом случае реф,
переданный от родителя может получить доступ к DOM-элементу потомка и родитель будет
манипулировать тем эл-том как угодно. Чтобы ограничить это, потомок может использовать
специальный хук useImperativeHandle() который задает рефу не настоящий DOM-элемент, 
а псевдоэлемент с набором допустимого API.

 const Form = () => {
   const inputRef = useRef(null);
   const handleClick = () => inputRef.current.focus();
   return (
     <>
       <MyInput ref={inputRef} />
       <button onClick={handleClick}>Focus</button>
     </>
   );
 };

 const MyInput = ({ ref }) => {
   const _ref = useRef(null);
   useImperativeHandle(ref, () => {
     return {
       // Родителский inputRef получит не DOM-элемент, 
       // а этот объект, с одним лишь методом focus()
       focus() {
         _ref.current.focus(); 
       }
     };
   });
   return <input ref={_ref} />
 };

Чтобы выполнить сайд эффект от рендеринга компонента, используется хук useEffect().
По умолчанию эффекты выполняется после каждого рендеринга (а точнее, после фазы фиксации,
поэтому код внутри useEffect() запускается с небольшим опозданием).

 const VideoPlayer = ({ src, isPlaying }) => {
   const ref = useRef(null);

   useEffect(() => {
     if (isPlaying) {
       ref.current.play();
     } else {
       ref.current.pause();
     }
   });

   return <video ref={ref} src={src} />
 };

Если внутри useEffect() устанавливать состояние, то это приведет к зацикливанию, 
т.к. установка состояния запускает новый рендеринг. Эффекты обычно должны синхронизировать
компоненты с внешней системой, например делать запросы на сервер.

Эффекту можно передавать зависимости, (через массив, во втором параметре). В этом случае 
он будет вызываться только если изменились сами зависимости. Зависимостями могут быть 
только реактивные переменные, т.е.: пропсы, состояния и локальные переменные, 
зависящие от них (вычисляемые свойства).

 useEffect(() => {
   // Это выполняется после каждого рендеринга
 });

 useEffect(() => {
   // Это выполняется только при монтировании 
 }, []);

 useEffect(() => {
  // Это выполняется при монтировании и также, если a или b 
  // изменились с последнего рендеринга
 }, [a, b]);

Хук useEffect() может возвращать ф-цию очистки. Она вызывается при размонтировании компонента,
а также перед следующим выполнением эффекта и используется для: очистки занятых ресурсов,
отписки от событий, сбрасывания анимаций в первоначальное состояние и т.п.

Ф-ция очистки должна также отменять и сетевой запрос (если таковой выполняется из эффекта),
либо делать его игнорируемым. В режиме разработки это будет приводить к дублированию запросов
(см. ниже). Хорошей практикой в этом случае является использование такого решения, которое
устраняет дублирование запросов или кэширует ответы (например React Query, useSWR или 
React Router 6.4+, вместо простого fetch). 

Использование fetch() внутри эффекта может привести к состоянию гонки, когда к примеру
отправляются сразу несколько запросов, но ответы приходят в неправильном порядке. 
Исправить это поможет игнорирование устаревших ответов.

 useEffect(() => {
   let ignore = false;
   fetchResults(query, page).then(json => {
     if (!ignore) {
       setResults(json);
     }
   });
   return () => ignore = true;
 }, [query, page]);

Иногда можно заметить, что код внутри useEffect() выполняется дважды. Это происходит из-за
того, что React в режиме разработки один раз размонтирует каждый компонент, сразу после
первоначального монтирования (чтобы найти эффекты которые нуждаются в очистке). Появление
же багов при повторной отработке эффекта будет свидетельствовать от том, что что-то упущено,
т.к. эффект должен всегда отрабатывать корректно при повторных вызовах.

Логику, которая должна выполняется только один раз (например при инициализации приложения)
необязательно выносить в эффект (в этом случае придется создавать доп. условие isInitialized,
т.к. в режиме разработки эффект запускается дважды). Вместо этого, такую логику можно 
просто вынести в отдельный JS-модуль, чтобы она выполнялась при импорте.

Хук useEffect() реагирует только на изменения реактивных переменных. Мутации обычных
переменных ничего не вызывают. Но если требуется, чтобы и от их изменения происходил эффект,
то можно использовать хук useSyncExternalStore().

Иногда требуется, чтобы эффект не зависил от реактивных переменных. В этом случае их можно 
не указывать в качестве зависимостей, но тогда появится ошибка линтера, т.к. React требует
чтобы все реактивные переменные, что присутствуют внутри эффетка, находились в зависимостях.
Элегатным решением для этого является использ. события эффекта через useEffectEvent().

 const onConnected = useEffectEvent(() => {
   showNotification('Connected!', theme);  // them передается через пропсы
 });

 useEffect(() => {
   const connection = createConnection(serverUrl, roomId);
   connection.on('connected', onConnected);
   return () => connection.disconnect();

 }, [roomId]);  // теперь theme можно не указывать

В некоторых случаях, чтобы избежать подобной проблемы, достаточно просто не считывать
реактивные переменные в эффекте напрямую:

 connection.on('message', (msg) => {       connection.on('message', (msg) => {
   // В этом случае messages придется        // А в этом случае, не придется
   // указывать в зависимостях               setMessages((messages) => [...messages, msg]);
   setMessages([...messages, msg]);        });
 });

Эффекты нужно использовать с осторожностью, т.к. они часто приводят к багам. 
Код эффекта - этот тот, который выполняется только потому, что компонент был показан 
на экране (т.е. колбек для рендеринга).

Эффекты лучше размещать в пользовательских хуках. Это позволит инкапсулировать зависимости 
от вмешательства со стороны других разработчиков, а также сделает поток данных понятнее.

Чтобы кешировать дорогостоящее вычисление, можно использовать хук useMemo(). Он возвращает
последний "мемоизированный" результат если заданные зависимости не были изменены с последнего
рендера. В противном случае - результат нового вычисления. Дорогостоящими считаются
вычисления, которые занимают 1 мс и более.

  const visibleTodos = useMemo(() => {
    // Не вызовется повторно, пока todos или filter не изменятся
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);

Большую часть императивной логики следует выносить в классы!
Подробнее здесь: https://ru.react.dev/learn/reusing-logic-with-custom-hooks

 const useFadeIn = (ref, duration) => {

   useEffect(() => {
     const anim = new FadeInAnimation(ref.current);
     anim.start(duration);
     return () => anim.stop();
 
   }, [ref, duration]);
 };

-------------

МАРШРУТИЗАЦИЯ

...

-------------

РАЗНОЕ

Создание нового проекта:           npx create-react-app my-app
Создание проекта с маршрутизацией: npx create-react-router@latest
Создание проекта на Next.js:       npx create-next-app@latest
Создание проекта на Expo:          npx create-expo-app      

Приложение с бекендом на Next.js можно выложить на любом хостинге, который поддерживает
Node.js или Docker-контейнеры.

Поток данных в React-компонентах является однонаправленным. Это означает что данные не имеют
двухсторонней привязки. Обратный поток данных - это когда данные передаются не от родителей 
к потомкам, а от потомков к родителям. Реализуется он через колбеки, которые передаются
потомкам через пропсы.

Компоненты не нужно определять через анонимную ф-цию (т.е. так: export default () => {}),
иначе в React Dev Tools они будут без названия.

React Dev Tools используется для инспекции компонентов, редактирования пропсов и состояний, 
а также для выявления проблем с производительностью. Для браузеров Chrome, Firefox, Edge его
можно установить через браузерные расширения. Для Safari и других браузеров через npm.

React не трогает DOM, если результат рендеринга такой же, как и в прошлый раз.

Для хранения выбранного/активного элемента списка, стейт должен содержать только его id 
а не весь объект. А уже на основе id можно вычислять объект элемента и передавать его 
на верх, при выборе/активации.

Нельзя измененять DOM-элементы нативным способом, если они уже управляются React'ом.
(например нужно избегать случаем, когда элемент отрисовывается через условный рендеринг 
и тут же, через ref, изменяется с пом. DOM-API)

Дочерние компоненты не должны получать данные, чтобы потом передавать их родительскому
компоненту. Вместо этого нужно, наоборот, получать данные в родительском компоненте, 
и передавать их дочерним. Это проще и делает поток данных предсказуемым.

Проблема сетевых водопадов - это когда дочерний компонент дожидается получения сетевых
ответов от всех родительских компонентов, чтобы отрисовать свое содержимое.

Если ф-ция не начинается с префикса use*, то в ней не получится вызывать другие хуки. 
Ф-ции, которые не вызывают другие хуки, и сами не должны быть хуками!

