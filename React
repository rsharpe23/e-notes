ОСНОВЫ

Версия 19.1

Компонент - это элемент пользовательского интерфейса, у которого есть своя логика 
и представление. Компонент в React представляет из себя ф-цию, возвращающую JSX разметку.
Название ф-ции должно начинаться с заглавной буквы, иначе компонент не будет работать 

В одном файле может определяться сразу несколько компонентов. Компонент, чье название
соответсвует названию файла, обычно экспортируется через экспорт по умолчанию, а все
вспомогательные компоненты - через именованный экспорт.

Компонент должен всегда возвращать только один корневой элемент. Если корневых элементов
несколько, то их нужно обернуть (обычно во фрагмент, но можно просто в <div>).

Фрагмент определяется как тег без названия (краткий синтаксис): <> ... </>

JSX - это синтаксическое расширение для JS, позволяющее писать HTML-подобную разметку 
в JS-файле. React активно использует JSX, но сам по себе JSX не являет его core-особенностью.

Если JSX разметка находится на той же строке, где и return, то ее можно указывать без скобок,
иначе со скобками, т.к. все что идет после return будет проигнорировано.

JSX требует чтобы одиночные теги всегда закрывались (т.е. так <br />). Названия атрибутов
почти такие же, как и в HTML, но записываются в camelCase (кроме aria-* и data-*). 
Вместо атрибута class используется className, поскольку слово class зарезервировано JS.

Чтобы передать в JSX значение переменной или JS-выражение, нужно использовать 
фигурные скобки. Атрибут style нужно задавать через объект.

 <h1>To Do List for {formatDate(today)}</h1>
 <img className="My avatar" src={avatar} alt={description} />
 <img style={{ width: mySize, height: mySize }} />

Чтобы получить доступ к пропсам компонента, нужно обратиться к первому (и единственному)
параметру ф-ции. Пропсы представлены объектом, который обычно деструктуризируют. 

Если при деструктуризации пропсу указать значение по умолчанию, то его можно не устанавливать
из вне. Но если ему передать null или 0, то значение по умолчанию работать не будет.

Если компонент имеет какое-то содержимое между своими тегами, то это содержимое можно
получить с пом. специального пропса - children.

 const Card = ({ children }) => {
   return <div className="card">{children}</div>
 };

Пропсы должны быть иммутабельными внутри своего компонента. Изменять пропсы могут только
родительские компоненты, путем передачи дочерним компонентам новых значений.

Условный рендеринг выполняется с пом. обычного JS-выражения. Для этого используется либо
оператор if/else, либо тернарный оператор, либо оператор &&. Оператор && следует использовать
с осторожностью, т.к. если значение левого операнда будет 0, то вместо того, чтобы ничего не
рендерить, React просто покажет 0 (т.е. левый операнд нужно всегда явно приводить к bool).

Если из компонента (например при условном рендеринге) вернуть null, undefined 
или false, то он ничего не отрендерит.

Чтобы отобразить список компонентов, используется, обычно, ф-ция map(), которая принимает
какие-то данные и возвращает JSX (цикл не подойдет, т.к. компонент должен всегда что-то
возвращать). Несколько удобных способов создания массива для работы с map():

 Array(9).fill(null)        // массив из 9 эл-тов, раных null  
 Array.from({ length: 9 })  // массив из 9 пустых эл-тов

При отображении списка элементов, каждому эл-ту нужно задавать ключ. Ключ - это своего рода
идентификатор (строка или число), который отделяет один элемент от другого. React использ.
ключи при добавлении, удалении или изменении элементов в списке, чтобы отображать их 
в правильном порядке.

 // Элементы, созданные через map(), всегда должны иметь ключи.
 // Ключи нужно включать в данные, а не генерировать на лету.

 const people = [{ id: 1, name: 'Креола' }, { id: 2, name: 'Марио' }];
 const items = people.map(person => <li key={person.id}>{person.name}</li>)

Cледует учитывать, что краткий синтаксис фрагмента не позволяет передать key, поэтому 
если требуется чтобы элемент состоял из нескольких DOM-узлов, то их можно обернуть 
либо в тег (например <div>), либо более явный <Fragment>.

Следует избегать использования индексов в качестве ключей, т.к. может произойти их
переупорядочевание, если какие-то эл-ты будут удалены, или добавлены новые.

Ф-ции компонентов должны быть чистыми. Это означает, что они всегда должны возвращать
предсказуемый JSX, который зависит только от пропсов и локальных переменных. 

 // Изменяя глобальную переменную, ф-ция выполняет сайд эффект, 
 // в результате которого каждый новый вызов приводит 
 // к непредсказуемому результату

 let guest = 0;
 const Cup = () => {
   guest = guest + 1;                          // Чистые ф-ции никогда не мутируют 
   return <h2>Tea cup for getst: {guest}</h2>  // переменные из внешней области видимости!
 };

В примере выше, сайд эффект выполняется при рендеринге. Это неправильно! 
Сайд эффекты могут выполняться только после рендеринга (например при обработке события 
или при использовании хука useEffect).

Приложение на React представляет собой дерево рендеринга, где каждый узел это какой-то
компонент. Правильно составленное дерево рендеринга увеличивает производительность.
Так, например, компоненты верхнего уровня должны содержать наибольшую сложность, а конечные
компоненты, наоборот, должны быть простыми, т.к. часто рендерятся повторно.

Кроме дерева рендеринга, приложение также имеет дерево зависимостей, где каждый узел это
импортируемый js-модуль. Оно необходимо сборщикам для объединения используемого кода 
(чтобы на выходе иметь оптимизированный бандл), а также для определения наиболее 
тяжелых модулей, которые задерживают отрисовку UI и др.

-------------

ИНТЕРАКТИВНОСТЬ

Обработчики событий принято называть либо с префиксом on*, либо с handle*

Все события в JSX всплывают наверх, за исключением события скрола.
Остановить дальнейшее всплытие можно с пом. метода e.stopPropagation().

 // При клике по кнопке, сначала выведется "Клик по кнопке", 
 // а затем "Клик по тулбару"

 <div className="Toolbar" 
   onClick={() => alert('Клик по тулбару')}>
   <button onClick={() => alert('Клик по кнопке')}>Play</button>
 </div>

Обработчики событий часто передают через пропсы, от родителей к детям. 
Это хорошая практика, вместо использования всплытия событий.

 const Button = ({ onClick, children }) => {
   const _onClick = (e) => {
     e.stopPropagation();
     // Какое-то доп. действие
     onClick();
   };
   return <button onClick={_onClick}>{children}</button>
 };

 <div className="Toolbar">
   <Button onClick={() => alert('Клик по тулбару')}>Play</Button>
 </div>

Хук - это ф-ция, содержащая какую-то логику отрисовки (обычно завязанную на состояниях) 
для переиспользования ее в разных компонентах. Хуки могут вызываться только в начале
компонента (при инициализации). Их нельзя вызывать в цикле или в условии. 
Названия хуков начинаются с префикса use*

Для определения состояния используется хук useState(). Обновление состояния приводит к новому
рендеру. Состояние изменяется только после отрисовки компонента (но не во время отрисовки).

 const Counter = () => {
   // Хотя состояние и определяется как локальная переменная, 
   // но на самом деле оно хранится в памяти отдельно от компонента.

   const [value, setValue] = useState(0);

   return (
     <button onClick={() => {
       setValue(value + 1);    // несмотря на то, что состояние обновляется 3 раза -
       setValue(value + 1);    // value изменится только один раз (выполнится
       setValue(value + 1);    // только самый последний setValue)

       // На каждый рендер - свой фиксированный snapshot состояния, 
       // (даже если к состоянию обратиться через время)

       setTimeout(() => alert(value), 3000);  -->  0

     }}>Inc</button>           
   );
 };

Обновление состояния начинается только после того, как выполнится весь код в обработчике
события. Это называется batching. Батчинг позволяет избежить лишних переотрисовок. 

Однако, если все же требуется обновить состояние несколько раз за одну отрисовку, 
то нужно использовать сеттер с колбеком.

 setValue(value + 5);
 setValue((value) => value + 1); 

 alert(value)  -->  6

Если состояние является объектом, то для изменения его свойст нужно задавать 
новый объект, с обновленными свойствами. 

 setPerson({ 
   ...person, 
   artwork: { 
     ...person.artwork,
     city: 'Краков'
   } 
 });

Тоже самое касается и массивов. При работе с массивами нужно избегать мутирующих методов,
например: splice(), sort(), push() и т.п. Для изменения эл-тов хорошо подходит 
метод map(), а для удаления эл-тов - метод filter().

 setArtists([
   ...artists.slice(0, idx),
   { id: someId, name: someValue },   // правильная вставка между эл-тами
   ...artists.slice(idx)
 ]);

Для удобного обновления объектов и массивов можно использовать библиотеку Immer. 
Она предоставляет мутирующий синтаксис, но не мутирует сам стейт:

 updatePerson((draft) => {
   draft.artwork.city = 'Лагос';
 });

Не рекомендуется создавать состояния с глубоковложенными объектами (и массивами), поскольку
за ними тяжело следить и любая случайная мутация может привести к багам. Вместо этого, 
лучше разбивать такие объекты на несколько более плоских или использовать Immer.

-------------

УПРАВЛЕНИЕ СОСТОЯНИЕМ

Reacting to Input with State...

-------------
 
РАЗНОЕ

Создание нового проекта:           npx create-react-app my-app
Создание проекта с маршрутизацией: npx create-react-router@latest
Создание проекта на Next.js:       npx create-next-app@latest
Создание проекта на Expo:          npx create-expo-app      

Приложение с бекендом на Next.js можно выложить на любом хостинге, который поддерживает
Node.js или Docker-контейнеры.

Поток данных в React-компонентах является однонаправленным. Это означает что данные не имеют
двухсторонней привязки. Обратный поток данных - это когда данные передаются не от родителей 
к потомкам, а от потомков к родителям. Реализуется он через колбеки, которые передаются
потомкам через пропсы.

Компоненты не нужно определять через анонимную ф-цию (т.е. так: export default () => {}),
иначе в React Dev Tools они будут без названия.

React Dev Tools используется для инспекции компонентов, редактирования пропсов и состояний, 
а также для выявления проблем с производительностью. Для браузеров Chrome, Firefox, Edge его
можно установить через браузерные расширения. Для Safari и других браузеров через npm.

React не трогает DOM, если результат рендеринга такой же, как и в прошлый раз.

