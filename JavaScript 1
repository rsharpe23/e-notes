Типы данных.

Примитивные: number, bigint, string, boolean. null, undefined, symbol.
Ссылочные: object. 

Числа, строки и булевые значения как и объекты имеют свои методы, 
хотя являются примитивами. Когда мы пытаемся получить к ним доступ, 
внутри JS создается временный объект-обертка, с использованием встроенного 
конструктора String, Number или Boolean, который предоставляет эти методы 
и после этого исчезает.

Значеня null и undefined не имеют объектов-оберток, поэтому для них 
нет никаких методов, ни прототипов.

----------------------------------------------

Строгий режим (Use Strict).

1. Если функция-конструктор вызывается по обычному (не через new), то this внутри нее
будет равнятся undefined. В нестрогом режиме this будет равен глобальному объекту
window.

2. Если код хочет получить доступ к внешней переменной, которая не найдена, то
произойдет ошибка. В нестрогом режиме будет создана новая глобальная переменная 
с таким же именем.

---------------------------------------------

Преобразования типов.

Численные преобразования:
- undefined -> NaN,
- null -> 0,
- true/false -> 1/0,
- string -> Пробелы обрезаются. Стока должна состоять только из чисел, если помимо
чисел есть буква (123z) тогда будет NaN. Пустая строка -> 0.

Если выполняется математическая операция (-, *, /, % и т.д.) над строками, 
тогда те автоматически преобразовываются в числа перед этим, кроме операции +, 
которая означает конкатеницаю строк, а не прибавление. В этом случае, даже если второй
операнд не является строкой он все равно будет преобразован в строку и конкатенирован к
первому операнду.

Логические преобразования:
- интуитивно пустые значения (0, null, undefined, NaN, "") -> false,
- все остальное -> true.

Преобразования объектов в примитивы:
- если к объекту применяется математическая операция, тогда вызывается его метод
valueOf(), а если он не определен, то toString();
- если объект вызывается как строка, либо используется для конкатенации со строкой,
тогда вызывается его метод toString(), а если он не определен, то valueOf();

Помимо переопределения этих методов, можно еще переопределить универсальный метод:
[Symbol.toPrimitive](hint) { ... }

---------------------------------------------

Операторы сравнения.

Оператор == означает сравнение с приведением типов, т.е. сначала опреранды приводятся к
числу и затем сравниваются между собой.

Оператор === означает строгое сравнение, без приведения типов. В динамических языках
программирования он приоритетнее чем ==.

Сравнения разных типов (==, >=, <, > и т.д.) работают также как и оператор ==.

Сравнение null и undefined при не строгом равенстве равны друг другу 
и не равны никаким другим значениям. Есть исключение, когда сравниваются null >= 0. В
этом случае получаем true. Это из-за того, что сначала выполняется оператор > и null
приводится к 0. После, получам равенство 0 = 0, и как результат true.

Сравнение строк:
Сначала сравниваются первые символы строк, если символ одной строки больше символа
другой, то первая строка больше второй, если они равны, тогда сравниваются вторые
символы строк и т.д. Иначе, большей считается более длинная строка.
Символы сравниваются по значению юникода, из таблицы кодирования (UTF-16).

Сравнение объектов:
Операторы == и === в этом случае работают одинаково.
При сравнении объекта с примитивом, объект преобразовывается в примитив и дальше
выполняется сранение.

---------------------------------------------

Коллекции.

Методы массива push() и pop() работают быстрее чем shift() и unshift().
Свойство массива length - это индекс последнего элемента + 1, а не его размер.
Если задать ему значение 0, то массив очистится/укоротится.

Объекты, имеющие индексированные свойства и length, называются псевдомассивами.
Array.from() создает настоящий массив из итерируемого объекта или псевдомассива.

Итерируемый объект - это объект, который реализует метод [Symbol.iterator]().
Данный метод возвращает другой объект с методом next(). 
Метод next(), в свою очередь, возвращает объект со свойствами value и done. 
Благодаря этому такие объекты могут перебираться циклом for of.

Map отличается от объекта тем, что позволяет указывать любой тип данных для ключа 
(в том числе и объект), а объект приводит все ключи к строке:
- map.get(1) и map.get("1") будут хранить разные значения, в отличии от объекта.
В отличии от объектов, в Map перебор элементов происходит в порядке добавления.

Set - это коллекция, которая хранит только уникальные значения (без ключей).

WeakMap - это коллекция, которая принимает в качестве ключа только объект.
Если такой объект больше нигде не используется (недостижим), кроме как в качестве ключа
в WeakMap, то он будет удален из коллекции автоматически, вместе со значением.
В обычном Map ключ-объект будет хранится в памяти до тех пор, пока существует сам Map.
WeakMap хорошо использовать тогда, когда нужно отслеживать какой то объект; и когда
ссылка на него будет удалена, подчистить какие-то связанные с ним данные из коллекции.

WeakSet подобен WeakMap, в качестве элементов может содержать только объекты.

WeakMap и WeakSet нельзя перебрать через цикл, либо получить все элементы сразу. 
Можно только получить какой-то отдельный элемент за раз.

---------------------------------------------

Структуры данных.

- Массив.
- Связанный список.
- Двухсторонняя очередь.

Каждая из структур данных подбирается под необходимый алгоритм. 
Например алгоритм требует быстро добавлять/удалять элементы в начале коллекции.
Массив для этого не подойдет, т.к. чтобы добавить элемент в начало, он должен свдинуть
все элементы вперед, а затем пересчитать свойство length. Тоже самое касается и
удаления. Массив работает быстро только когда добавляется/удаляется элемент с конца.
Для такой задачи подойдет связанный список.

Связанный список позволяет быстро добавлять/удалять элементы в начале коллекции, 
но не подходит, если надо обращаться к элементам по индексу.

Реализуется как объект со значением и доп. свойством (next), указывающим на следующий
объкт: let list = { value: 1, next: { value: 2, next: { value: 3, next: null } } };

Добавление в начало:
list = { value: 0, next: list };

---------------------------------------------

Рекурсия.

Общее кол-во вызовов - глубина рекурсии.
Последний вызов - база рекурсии.
Промежуточный вызов - шаг рекурсии.

Все рекурсивные вызовы сначала записываются в контекст выполнения 
(специальная структура данных, в виде стека, хранящая информацию о вызовах ф-ции).
Затем выполняются по порядку, передавая свои результаты предыдущим вызовам, пока не
дойдут до конца.

---------------------------------------------

Замыкание.

Переменная - это свойство объекта EnvironmentRecord.
Изменить переменную означает изменить свойство этого объекта.

Лексическое окружение - это объект, который стостоит из EnvironmentRecord и ссылки
outer на внешнее окружение.

Ф-ции, также как и переменные, попадают в лексическое окружение.
У каждого блока кода/ф-ции/скрипта свое лексическое окружение.
Лексическое оружение скрипта называется глобальным.

Лексическое окружение создается:
- при запуске скрипта;
- при выполнении ф-ции;
- при выполнении блока кода (в том числе if, for, while).

При каждом вызове ф-ции либо итерации цикла создается свое отдельное лексическое
окружение.

В ES5 блок кода не имел своего лексического окружения. 
Поэтому приходилось использовать IIFE (immediately-invoked function expression).

Когда код хочет получить доступ к переменной, сначала он ищет ее в своем локальном
лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Все ф-ции при создании получают скрытое свойство [[Environment]], которое ссылается 
на лексическое окружение места, где они были созданы; т.е. [[Environment]] это и есть
outer.

Замыкание - это функция, которая запоминает свои внешние переменные и может получить 
к ним доступ. Или короче - функция, со своими внешними переменными.

В JavaScript все ф-ции являются замыканиями.

---------------------------------------------

JSON.

В метод JSON.stringify() можно передать 2й параметр, который принимает массив
допустимых свойств в объекте (1й параметр) для кодирования. 
Вместо массива можно также передать ф-цию.

Подобно toString(), существует похожий метод - toJSON(); он определят как будет
сериализоваться объект в методе JSON.stringify().

В методе JSON.parse() также существует 2й аргумент, он принимает ф-цию которая вместо
обычного свойства может вернуть что-то более функциональное, например объект.
Обычную строку с датой можно заменить на полноценный объект Date и т.п.

---------------------------------------------

Флаги свойств.

Чтобы ограничить свойства объекта, нужно при инициализации задать им определенные флаги:
- writable -> если false, свойство только для чтения.
- enumerable -> если false, свойство не перечисляется в циклах.
- configurable -> если false, свойство нельзя удалить и нельзя более изменять его флаги.

Есть специальные методы, которые задают эти ограничения сразу всем свойствам объекта:
- Object.preventExtensions(obj) -> запрещает добавлять новые свойства.
- Object.seal(obj) -> тоже, что и { configurable: false }.
- Object.freeze(obj) -> тоже, что и { configurable: false: writable: false }.

---------------------------------------------

Прототипы.

У объектов есть скрытое свойство [[Prototype]]. 

Когда вызывается свойство/метод, а его нет в текущем объекте, JS автоматически берет
его из прототипа.

Чтобы получить доступ к прототипу можно воспользоваться его геттером/сеттером -
"__proto__", значением корого может быть только объект или null.

У каждой ф-ции по умолчанию есть свойство prototype. При создании объекта через new,
значение из prototype будет установлено в [[Prototype]]:

function Fn() { ... }

Fn.prototype = someObj -> на этом этапе someObj еще не прототип obj, 
а обычное свойство с некотором значением.

let obj = new Fn() -> теперь someObj становиться прототипом для obj,
т.е. obj.__proto__ == someObj.

По умолчанию Fn.prototype - это объект со свойством "constructor", которое есть ссылка
на Fn -> { constructor: Fn }.

Отсюда следует, что можно напрямую обратиться к этому свойству и создавать объекты, 
не зная при этом, какой конструктор необходимо использовать.
 
let obj = new Fn("Hello");
let obj2 = new obj.constructor("World");

Это полезно, когда есть объект из сторонней библиотеки и нужно создавать другие
однотипные ему объекты.

Раньше наследование на прототипах реализовывалось так:

function FnBase() { ... }

function Fn() { ... }
Fn.prototype = Object.create(FnBase.prototype);
Fn.prototype.constructor = Fn;

let obj = new Fn();

Все методы в основном записываются в прототив объекта, а сам объект хранит только
свойства. У свойства prototype также есть свой прототип:

obj.__proto__ == Fn.prototype,
Fn.prototype.__proto__ == FnBase.prototype.

---------------------------------------------

Классы.

Классы как и ф-ции можно создавать через "expression" подход, а также возвращать из 
ф-ции как результат:

let MyClass = class { ... };
function fn() { return class { ... } }

Синтаксис классов позволяет указывать после extends не только класс, но и любое
выражение; например ф-цию, которая генерирует класс динамически, в зависимости 
от условий:

class MyClass extends f() { ... } -> Ф-ция fn() возвращает класс.

Если в дочернем классе опрделяется собственный конструктор, в нем обязательно нужно
вызывать super() и делать это перед первым обращением к this. Это необходимо потому,
что в классах-наследниках конструктор не создает пустой объект для записи в this. 
Это делает родительский конструктор при вызове super(). 

Статические методы/свойства это тоже самое, что присвоить метод/свойство напрямую 
как свойство ф-ции:

class MyClass { ... }
MyClass.doSomething = function () { ... };
MyClass.message = "Hello";

тоже что и: 

function Fn() { ... }
Fn.doSomething = function () { ... };
Fn.message = "Hello";

---------------------------------------------

Обработка ошибок.

В JS, в качестве объекта ошибки можно передать все что угодно, даже примитив: 
throw 1/"hello"/new Error() и т.д.

Если есть секция finally, то она выполнится в любом случае.
Если ошибка есть: try -> catch -> finally.
Если нет ошибки: try -> finally.

Секция finally выполнится даже в том случае, если в try происходит return.

В браузере есть специальное свойство window.onerror, в которое передается колбэк.
Этот колбэк срабатывает когда падает скрипт, после необработанной ошибки.
Это называется настроить "глобальный обработчик ошибок".
Полезно для отправки логов на сервер и т.п.

В JS нет практики использовать несколько блоков catch для обработки разных ошибок. 
Это из-за динамеческое типизации. Поэтому блок catch один, а ошибки обрабатываются
через if. Обычно все низкоуровненые классы ошибок, оборачиваются в какой-то один
высокоуровневый, а тот обрабатывается уже на самом верхнем уровне.

---------------------------------------------

Промисы, async/await.

Скрипты загружаются асинхронно, т.е. вся логика внутри них также выполняется
асинхронно, после загрузки.

Чтобы промисы выполнялись по цепочке, ножно последовательно добавлять новый then, 
к предыдущему then, т.к. then неявно возвращает свой промис. Если добавить много then 
к одному промису, то все они будут получать одно и тоже значение и выполнятся
независимо, как много обработчиков одного события.

Если then явно возвращает промис, тогда последующие then, будут ожидать его выполнения,
и только после этого получат результат.

Обработчик then может возвращать не только промис, но и любой объект у которого есть
свой метод then. В этом случае этот объект будет обработан как промис: 
new Promise((resolve, reject) => { ... }).then(result => new Thenable()).

Хорошей практикой считается когда все асинхронные действия возвращают промис.
Это позволяет планировать какие-то дополнительные действия в будущем, даже если такой
функционал не нужен прямо сейчас. 

Существует специальный метод Promise.resolve(value), который из обычного значения
создает промис. Удобен, когда нужно вернуть значение из кеша, вместо загрузки и т.п.

Вызов reject внутри промиса тоже самое, что бросить исключение через throw.

Для промисов также существует глобальный обработчик ошибок. Его можно использовать 
в случае необработанной ошибки промиса. В браузере это делается с помощью события
window.addEventListener('unhandledrejection', function () { ... }).

Обработчики промисов then/catch/finally всегда асинхронны, поэтому они, как и колбеки
для setTimeout, вызываются после выполнения текущего кода.

Promise.resolve().then(() => alert('Hello')); -> Hello будет после World
alert('World'); -> сначала World

Ф-ция (или метод класса), объявленная с async, всегда возвращает промис. 
Даже если указан какой-то другой тип, он все равно будет обернут в промис: 
async function fn() { return 1; } fn() -> вернет Promise.resolve(1).

Асинхронные ф-ции работают параллельно, не блокируя основной поток выполнения.
Внутри асинхронных ф-ций можно отлавливать ошибки промисов через обычный try..catch.

Ключевое слово await ждет выполнение промиса и возвращает его результат.
Await может использоваться только внутри асинхронных ф-ций:

async function fn() {
  let result = await new Promise(resolve => { ... });
  alert(result); -> будет ждать result и только потом выполнится.
}

Await также работает с "thenable"-объектами: await new Thenable().

---------------------------------------------

Генераторы.

Функция-генератор - это ф-ция, которая возвращает перебераемый объект генератор.
Этот точно такой же объект с методом next(), который возвращают итераторы.
Метод next(), в генераторе, неявно обращается к констуркции yield. 
По сути, функция-генератор это укороченный вариант реализации итератора.

Одни генераторы можно вставлять в другие генераторы, это назыавется композицией
генераторов.

Через yield можно передавать во внешний код шаг генератора, а из внешнего кода, 
через метод next(), возвращать обратно ответ шагу:

function* fn() {
  let a = yield 1;
  alert(a);
  let b = yield 2;
  alert(b);
}

let generator = fn(); -> Сначала получаем объект-генератор.

alert(generator.next()) -> При вызове next() переходим к первому yield. 
Yield передает во внешний код шаг, т.е. объект { value: 1, done: false }

alert(generator.next("hello")) -> Следующий next() передает ответ шагу, и переменная
"a", внутри генератора, получает значение "hello". В тоже время во внешний код
передается новый шаг: { value: 2, done: false }

alert(generator.next("world")) -> Последний next() передает ответ "world", переменная
"b" примет это значение и на этом все закончится. Результат последнего шага будет
{ done: true }.

Асинхронные генераторы нужны там, где требуется перебирать данные, поступающие
асинхронно, например когда что то загружается по сети по частям. Они всегда возвращают
промисы. Перебор таких генераторов осуществяется через цикл for await..of.
Существуют также и асинхронные итераторы.

---------------------------------------------

Модули.

Код в модуле выполняется только один раз при импорте. Если объект экспортируется в
одном модуле, то все другие, которые импортируют его, получат один и тот же экземпляр.
С помощью такого подхода удобно инициализировать все объекты в обном месте, 
а использовать, в последующем, уже везде где только надо:

Module1.js:
export let obj = {};
export function fn() { alert(obj.message); }

Module2.js:
import {obj} from 'Module1.js';
obj.message = "Hello";

В модулях "this" не определен на самом верхнем уровне, в отличии от обычных скриптов.
Там "this"- это глабольный объект. В каждом модуле своя область видимости.

Модульные скрипты в браузере (<script type="module">...</script>):
- выполняются только после полной загрузки страницы;
- не блокируют обработку html.

Модульный скрипт с атрибутом async будет выполнен сразу после готовности, 
не дожидаясь полной загрузки страницы.

Внешние модульные скрипты:
- запускаются только один раз, если у них одинаковые атрибуты src;
- требуют заголовков CORS, если загружаются с другого домена.

Экспорт модуля:
- перед объявлением: export [default] class/function/variable;
- отдельный: export {x [as y], ...};
- реэкспорт: export {x [as y], ...} from "module"; 
             export * from module (без default);
             export {default [as y]} from "module"; (только default)

Импорт модуля:
- именованного: import {x [as y], ...} from "module";
- по умолчанию: import x from "module";
                import {default as x, ...} (когда кроме default нужны именнованые);
- все сразу: import * as obj from "module";
- только подключить: import "module" (просто запустится код и все).

Реэкспорт полезен для того, чтобы в одном (главном) файле был доступ ко всем
необходимым модулям, чтобы не искать те в подкаталогах. 

Динамическией импорт загружает модуль и возвращает промис. 
Результат промиса - объект модуля, содержащий все его импорты. 

Такой импорт можно использовать в рантайме: 
import(modulePath).then(obj => alert(obj.default));

Или так: let { fn1, fn2 } = await import(modulePath);

Браузер не поддерживает импорт голых модулей (см. Node JS), но чтобы частично обойти 
это ограничение можно использовать импортмап. Импортмап задаётся через тег script 
с типом importmap (на странице разрешен только один тег с типом importmap).

<script type="importmap">
{
  "imports": {
    "lodash": "/node_modules/lodash-es/lodash.js",   // доступ к lodash.js
    "lodash/": "/node_modules/lodash-es/",           // доступ к доп. файлам
    "lodash/util": "/node_modules/lodash-es/util.js" // доступ к доп. конкетному файлу
    "vue": "https://www.unpkg.com/vue.esm.js"        // доступ к файлу из cdn
  }
}
</script>

import _ from "lodash";
import fp from "lodash/fp.js";
import util from "lodash/util";

Также импортмап можно подключить и через src: 
<script type="importmap" src="import-map.importmap"></script>

---------------------------------------------

Proxy и Reflect.

Прокси - это обертка над объектом, которая перехватывает оберации над ним (такие как
чтени/запись свойств, вызов метода и т.п.) и позволяет что-то сделать до и/или после.
Для перехвата объявляются специальные ловушки (get, set, apply и т.п.), а иначе
операции просто перенаправляется на оригинальный объект:

let obj = {};
let objProxy = new Proxy(obj, { /* ловушки */ });

Это позволяет создавать "виртуальные" свойства и методы, реализовывать значения по
умолчанию, наблюдаемые объекты, функции декораторы и многое другое.

Reflect API создано как дополнение к Proxy. Для любой ловушки из Proxy существует метод
в Reflect с теми же аргументами. Следует использовать его, если нужно перенаправить
вызов на оригинальный объект правильно, без потери контекста и т.п.

---------------------------------------------

Разное.

Для проверки, сущесвует ли свойство в объекте, можно использовать оператор in.
Но обычно используют проверку на undefined.

Неизвестным или пустым значениям нужно присваивать null. Undefined указывает на то, 
что переменная не существует или еще не проинициализирвана.

Все ключи в объекте автоматически приводятся к строке:
let obj = { 1: "Hello!" } -> obj[1] либо obj["1"], без разницы.
let obj2 = { prop: "World" } -> obj2.prop либо obj2["prop"].

Целочисленные ключи, при переборе объекта, перечисляются по возрастанию, а строковые 
в порядке создания. При этом стоит учесть что "23" это также целочисленный ключ, 
т.к. он может быть конвертирован в число, а "+23" уже строковый ключ. 

Все что создается через new - это ссылочные типы, т.е. объекты. Массивы и функции 
это ссылочные типы, т.к. их можно создать через new.

В JS - значение this, внутри ф-ции, определяется во время вызова и может меняться 
в зависимости от заданного объекта, например:

let fn = function () { alert(this.name) };
let a = { name: 'A', fn };
let b = { name: 'B', fn };
a.fn(); -> A
b.fn(); -> B

Метод объекта без скобок называется ссылочным типом: a.fn.

Если присвоить ссылочный тип переменной и далее эту переменную вызвать, 
то this потеряется: let f = a.fn; f() -> this - undefined.

Чтобы не потерять this, ссылочный тип должен быть со скобками: 
a.fn() -> this - это всегда объект перед точкой! Т.е "a".

Стрелочные ф-ции:
- не имеют своего this/super.
- не имеют объекта arguments.
- не могут быть вызываны с new, как конструкторы.

Когда ф-ция вызывается как конструктор, через new, она неявно возвращает this.
Этот this создается перед основным кодом как пустой объект, и затем, явно заполняется.
Если функция-конструктор явно возвращает значение, то это сработает только, если
возвращается какой-то объект. Если возвращается примитив, то он будет отброшен, а сама
ф-ция, как и по умолчанию, вернет this.

Опциональная цепочка ?. останавливает вычисление левой части, если она не существует
или равна null: user?.sayHi(x++) -> если нет метода sayHi, то x++ не будет выполняться.
Также можно сделать так: user.sayHi?.() -> нужно для того, чтобы вызвать метод у разных
объектов. Там, где есть метод, он будет вызван, а где его нет - вернется undefined.

Тип данных symbol необходим для создания уникальных идентификаторов или ключей для
объекта. Его основные назначения это: скрытые свойства объекта и переопределение
некоторых встроенных поведений объекта, например переопределение итерации через
глобальный символ Symbol.iterator и т.д.

Если нужно вызывать метод у числа, а не его переменной, то это делается так
123..toString(), либо просто (123).toString().

Деструктуризация параметров может использовать объект, как значение по-умолчанию:
function fn({ name = "A", age = 23 } = {}) { ... }
Деструктуризация можно объявлять со свойствами объекта:
[this.name, this.surname] = fullName.split(" ");

Переменная var, в отличии от let, не имеет блочной области видимости и ограничивается
только либо телом ф-ции, либо скриптом.

Также var допускает повторное объявление:
var v = 23; var v = 1; -> Здесь должна быть ошибка, но не в случае с var

К переменной var можно обратиться раньше ее объявления. 

В браузере глобальные ф-ции и переменные, объявленные с помощью var, становятся
свойствами объекта window (ES5). 

Все свойства объекта window доступны для вызова напрямую: 
alert() тоже самое что и window.alert() и т.д.

globalThis - это универсальное имя глобального объекта. 
В браузере это window, а в Node.js - global.

Ф-ции имеют свои внутренние свойства name и length:
function fn() { ... } fn.name; fn.length;

При помощи new Function() можно создавать ф-ции динамически, из строки. 

setTimeout() с нулевой задержкой/без задержки запустит колбэк после выполнения текущего
кода; т.е. сначала отработает весь скрипт и только после этого вызовется колбэк.

setTimeout() в браузере, по умолчанию, устанавливает this = window, 
для вызова переданной ф-ции.

Заимствование метода - это такой трюк, когда берется метод из одного объекта, и
выполяется в контексте другого. Например: [].join.call(arguments). Здесь arguments -
это итерируемый объект и псевдомассив, но не настостоящий массив. Поэтому он не имеет
методов массива, в том числе join(). Но алгоритм join() работает так, что ему
достаточно только свойств псевдомассива, поэтому все работает как надо.

С помощью метода fn.bind() можно привязывать к ф-ции не только контекст, но параметры.
Например для ф-ции function fn(a, b) { ... } вместе с контекстом можно привязать и
первый параметр: fn.bind(null, 23). В таком случае, ее можно вызвать только с одним
параметром: fn("Hello") -> a = 23, b = "Hello". Такие ф-ции называются "частичными".

Продвинутая проверка типа, которая возвращает строку. Хорошо работает как 
с примитивами, так и с объектами: {}.toString.call(context).

При вызове fetch, сначала возвращается первый промис. Результатом его выполнения
является объект response. Он содержит заголовки ответа от сервера, при этом весь ответ
еще не полностью загружен. Чтобы получить полный ответ, надо вызвать метод
response.text/json(). Он возвращает второй промис, который выполняется, 
когда данные полностью загружены и к ним можно обратиться:
fetch(url).then(res => res.text()).then(text => { ... }).

Оператор нулевого слияния "??" похож на оператор ИЛИ "||", но отличается тем что ||
не различает: false, 0, "", null, undefined. Оператор ?? проверят только на null 
или undefined.

В JS, в отличии от многих языков, логические операторы работают по другому. Например
оператор ИЛИ "||" находит первое истинное значение и возвращает его в исходном виде,
без преобразования. Тоже касается оператора И "&&", который находит первое ложное
значение и также возвращает его, как есть:

let a = false || "" || 1; -> a = 1.
let b = true && 1 && ""; -> b = "".

Также допустимы и такие записи: 

obj && obj.fn(); -> вызовет метод, если obj не пустой объект.
let obj = value || {}; -> obj примет value, если оно есть, или пустой объект.

Побитовый левый сдвиг почти равен умножение на 2:
3 << 1 == 6, 3 << 2 == 12 и т.д.

Побитовый правый сдвиг почти равен делению на 2 (для положительных чисел):
100 >> 1 == 50, 100 >> 2 == 25, 100 >> 3 == 12 и т.д.

С помощью специального объекта Intl можно выводить различные даты, числа, 
валюту и т.п. в интернациональном формате, либо сравнивать строки в зависимости 
от языковых правил. Это очень удобно тем, что не нужно создавать вручную 
никаких шаблонов вывода для этого.

Чтобы преобразовать объект Date к строке, используется метод toLocaleDateString.
Например в БД хранится запись в виде строки "2021-06-08T06:23:27.597Z", которая
при считывании преоразовывается в объект Date. Если у этого объекта вызвать
данный метод, то вернется строка в более читаемом формате.

Отличие console.log() и console.dir() в том, что для JS объектов они выводят одно 
и тоже, а для DOM-элементов работают по-разному:
- console.log() выводит элемент в виде DOM-дерева;
- console.dir() выводит элемент в виде DOM-объекта (удобно для анализа его свойств).

С помощью eval можно не только запускать произвольный код из строки, но и вызывать 
ф-ции: eval('myFunction')();  -->  Динамический вызов

Когда и какую применять сущность:
* класс - когда требуется создавать больше чем один экземпляр;
* литерал объекта - когда требуется только один экземпляр, но при этом не нужна 
предварительная инициализация данных (не нужен метод init).
* паттерн "модуль" - когда требуется только один экземпляр, но при этом нужно 
предварительно проинициализировать данные.

Паттерн "модуль" необязательно делать через IIFE. Можно ограничиться и обычной ф-цией.

Оператор void. Он вычисляет передаваемое выражение (любое) и возвращает undefined.
Раньше, в старых барузерах, можно было создать переменную с именем undefined
и поэтому, чтобы присвоить тип undefined, писали void(0).
...
let a = void 0;   -->  вместо 0 может стоять что угодно
let b = void(0);  -->  это тоже самое
var undefined = void(0);  -->  в старом браузере будет работать

Оператор void часто использовался в протоколе javascript. Этот протокол записывается 
в атрибуте href. Он вычисляет всё, что идёт после двоеточия и заменяет содержимое
страницы возвращённым значением, если оно не равно undefined.
...
<a href="javascript:void(0);">        -->  по нажатию ничего не произойдет
<a href="#" onclick="return false;">  -->  современный вариант
<a href="javascript:23">              -->  страница будет отображать только 23

// По нажатию, изменится цвет фона страницы
<a href="javascript:void(document.body.style.background = 'green');">

В современной практике void может использоваться при записи стрелочных ф-ций.

В примере ниже, если printMsg захочет вернуть какое-то значение, то void перекроет его
на undefined и стрелочная ф-ция не изменится (в JS ф-ции без возвращаемого значения 
под капотом всё равно возвращают undefined).
...
button.onclick = () => void printMsg();

Префиксы ф-ций: get, calc, create, check, show:

* show - показать что-то визуальное.
* get - вернуть значение, получая его каким-то образом, но не создавая новый экземпляр;
* check - проверить что-то и вернуть логическое результат;
* create - создать экземпляр значения и вернуть его;
* calc - посчитать что-то и вернуть результат; ключевое слово здесь "посчитать", 
то есть выполнить мат. операцию;

Шаблонная строка (или шаблонный/строковый литер) поддерживает ф-цию шаблонизации. 
Она вызывается след. образом: fn``; и может возвращать что угодно, не обазат. строку.

const apples = 3, oranges = 5;
const str = fn`Sum of ${apples} + ${oranges} = ${apples + oranges}`;

function fn(strings, values) {
  console.log(strings);      -->  ['Sum of ', ' + ', ' = ']
  console.log(strings.raw);  -->  тот же массив, но не парсит спец. символы (\n и пр.)
  console.log(values);       -->  [3, 5, 8]
}

Создание переменной внутри if не поддерживается в строгом режиме:
if (value = getValue()) {}  // см. Строгий режим

