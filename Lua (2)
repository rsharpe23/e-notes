АНАТОМИЯ АДДОНА

Аддон начинается с toc-файла (Table of Contents), который содержит метаданные.
Toc-файл должен иметь такое же название как и папка аддона. Каждая строка метаданных
(директива) начинается с ##. После метаданных указываются файлы аддона (*.xml и *.lua).

Пример простого toc-файла: 

 ## Interface: 30300
 ## Title: My Addon Name
 ## Author: My Name
 ## Notes: This is my simple addon

 MyAddon.xml
 MyAddon.lua

Список стандартных директив:

 * Interface - число, которое игровой клиент использует для версионирования аддона 
   (когда открывается меню аддонов на главном экране). Если версия аддона не совместима 
   с текущим клиентом, то аддон будет либо "устаревшим", либо "несовместимым".

   (Аддон считается устаревшим, когда меняется минорный патч. Такие аддоны все еще могут
   работать если отметить соответсвующую галочку вверху. Несовместимым аддон считается 
   тогда, когда меняется мажорный патч. Такие аддоны не работают.)

   Число (интерфейса) строится исходя из текущего патча. Например для патча 
   3.3.0 оно будет таким: 30300

 * Title - заголовок, который отображается в меню аддонов. Заголовок может быть
   локализованным. Например, чтобы добавить текст на испанском нужно объявить 
   такую директиву: ## Title-esES: Hola Amigo

   Если у пользователя клиент на испанском, то ему выведится именно такая строка.

 * Notes - более длинное описание, чем в Title. Также может быть локализованным.

 * Dependencies или RequiredDeps - список зависимостей (название аддононов через запятую).
   Например: ## Dependencies: Juggernaut, Alpha

   Когда аддону не хватает требуемых зависимостей, он будет отключен. 
   Зависимости гарантируют, что аддоны будут загружен в правильном порядке. 

 * OptionalDeps - список необязательных зависимостей с кот. может взаимодействовать аддон.

 * LoadOnDemand - число 0 или 1, которое означает что это LoD-аддон. Такие аддоны
   подгружаются динамически, в ответ на какое-то событие в игре. Все Blizzard-аддоны 
   являются динамически подгружаемыми.

 * LoadsWith - динамически-подгружаемая зависимость для LoD-аддона. 
   Комбинируется с LoadOnDemand. Например: ## LoadsWith: Blizzard_RaidUI

 * DefaultState - состояние аддона по умолчанию: enabled или disabled.

 * LoadManager - указывает на аддон, который может загружать текущий аддон. 
   Например: ## LoadManager: AddonLoader

   AddonLoader может загружать другие аддоны в зависимости от специальных условий 
   в toc-файле. Например, если прописать: ## X-LoadOn-Class: Rogue 
   то текущий аддон будет загружаться только для роги.

 * SavedVariables - название Lua-переменной, в которой хранятся межсессионные данные. 
   Например: ## SavedVariables: JuggernautDB

   Единсвенный способ сохранить данные аддона, это объявить переменную в Lua-коде и передать
   ее имя в директиву SavedVariables. После этого игра будет записывать данные из этой
   переменной в файл, при выходе из игры, и считывать данные в переменную при входе.
   Переменная может быть след. типа: string, number, boolean или table. 

 * SavedVariablesPerCharacter - делает тоже самое, но сохраняет данные 
   для каждого персонажа в отдельные файлы.
 
Пользовательские директивы определяются так: X-Метка. Например: X-FAQ, X-Website и т.п.
Они могут содержать только строки до 1000 символов и быть локализованными.

 ## X-Website: http://www.myaddon.com
 ## X-Website-esES: http://www.myaddon.com/esES

Чтобы получить корректную версию веб-сайта, нужно воспользоваться ф-цией 
GetAddOnMetadata() в Lua-скрипте.

Аддону можно задать категорию с помощью директивы X-Category. 
Например: ## X-Category: Auction 

Полный список всех категорий на стр. 132.

XML-файлы хранят разметку аддона. Они также могут загружать lua-скрипты через тег 
<Script file="my-file.lua"/>. Каждый XML-файл должен содержать на самом верхнем уровне 
тег <Ui>. Этот тег должет также содержать schema-информацию для валидации XML-файла, 
как в примере ниже: 

 <Ui xmlns="http://www.blizzard.com/wow/ui/"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.blizzard.com/wow/ui/
                         http://wowprogramming.com/FrameXML/UI.xsd">
 </Ui>

Атрибут xmlns задает пространство имен для XML-файла (или название схемы).
  
Атрибут xmlns:xsi говорит валидационной программе к какому schema-экземпляру 
будет соответствовать схема XML-файла.

Атрибут xsi:schemaLocation - это пара строк, которые указывают, где можно найти схему. 
Т.е. схему с названием http://www.blizzard.com/wow/ui/ можно найти по адресу 
http://wowprogramming.com/FrameXML/UI.xsd

По мере загрузки XML-файлов, в файл Logs\Framexml.log могут записываться разные ошибки.
Если аддон ведет себя не правильно, рекомендуется проверить этот файл.

Lua-файлы загружаются, парсятся и выполняются в том порядке, который указан в toc-файле.
Аддон может включать пользовательскую графику, звуки и шрифты.

WoW поддерживает два графических формата, когда загружает текстуры для фреймов: blp и tga. 
В дополнение к этому, каждый графический элемент (картинка) должен соответствовать 
следующим требования (для того, чтобы быть загруженым):

1) Ширина и высота должны быть больше или равны 2, но меньше 1024 пикселя.
2) Ширина и высота файла должны быть равны степени двойки (т.е. 32х64, но не 512х400)

Каждый визуальный компонент в аддоне начинается с фрейма, который служит контейнером 
для текста и графики. Фреймы бывают разных типов, например: CheckBotton, EditBox,
StatusBar (отображает число), ScrollingMessageFrame (отображает серию текстовых 
сообщений в прокручиваемой области) и пр.

Базовым фреймами для отображения шрифта и текстуры являются FontString и Texture.
Все фреймы на экране привязываются через anchor'ы.

Обработка игровых событий происходит также через фреймы. Для регистрации события можно 
вызвать метод Frame:RegisterEvent(), которому передается название события. 

В примере ниже создается фрейм без отображения, который печатает сообщение 
во фрейм чата, когда персонаж заходит и выходит из боя:

 -- Первый аргумент это тот самый тип фрейма (Frame, StatusBar, EditBox и пр.)
 CreateFrame("Frame", "MyFrame", UIParent)

 - Состояние боя можно определить по событиям регенерации здоровья, 
 - т.к. в бою здоровье не восстанавливается

 MyFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
 MyFrame:RegisterEvent("PLAYER_REGEN_DISABLED")

 fucntion MyFrame_OnEvent(self, event, ...)
   if event == "PLAYER_REGEN_ENABLED" then
     print("Leaving combat")
   elseif event == "PLAYER_REGEN_DISABLED"
     print("Entering combat")
   end
 end

 MyFrame:SetScript("OnEvent", MyFrame_OnEvent)

Этапы загрузки аддона в игру описаны на стр. 141.
Процесс локализации аддона описан на страницах 134-138.

Дефолтные (близардовские) XML-фреймы и Lua-файлы находятся в папке FrameXML.
Но чтобы получить к ней доступ, нужно извлечь ее из клиента с пом. специальной утилиты, 
либо взять отсюда https://github.com/tekkub/wow-ui-source

-----------------------

РАБОТА С ФРЕЙМАМИ И ДР. ГРАФИЧ. ЭЛ-ТАМИ

Хотя фреймы можно создавать и через Lua, использование XML будет предпочтительнее, 
т.к. он может валидировать их через XML-схему, а также дает возможность 
разделять логику от разметки.

Создание фрейма через XML:

  <Frame name="BagBuddy" parent="UIParent">
    <Size x="384" y="512"/>
    <Anchors>
      <Anchor point="CENTER" relativeTo="UIParent" relativePoint="CENTER"/>
    </Anchors>
  </Frame>

В примере выше создается фрейм с типом "Frame", названием "BagBuddy" 
и родителем "UIParent". Он имеет заданные размеры и привязан к центру UIParent.

Большинство дефолтных (близардовских) фреймов являются потомками UIParent.
UIParent - это общий родительский фрейм для всего интерфейса. 

По умолчанию родительский фрейм устанавливается просто через его вложенное 
местолоположение в файле XML.

Фрейму можно задать размеры, как в аблолютных значениях, так и в относительных. 
Абсолютные значения задаются через тег <AbsDimension>, а относительные через <RelDimension>.
Относительные значения задаются в процентах, от 0 до 1.

 <Size>                                  <Size> 
   <AbsDimension x="384" y="512"/>        <RelDimension x="0.5" y="0.5"/> 
 </Size>                                 </Size>
   
Запись <Size x="384" y="512"/> - это сокращенный вариант с абсоютными значениям.
Якоря задаются с помощью тега <Anchor>. Смещение - через <Offset> (вложенным в <Anchor>).

Тоже самое, только на Lua:

 CreateFrame("Frame", "BagBuddy", UIParent)
 BagBuddy:SetWeidth(384)
 BagBuddy:SetHeight(512)
 BagBuddy:SetPoint("CENTER", UIParent, "CENTER")

Фреймы рендерятся послойно. За порядок отображения отвечает атрибут frameStrata. 
Он принимает следующие значения: BACKGROUND, LOW, MEDIUM, HIGHT, DIALOG и др.
Фреймы с более высокими значениями перекрывают те, у которых значения ниже.
Полный список можно посмотреть на стр. 151. 

Под капотом frameStrata использует frameLevel, но его можно задать и вручную для более 
тонкой настройки. Этот атрибут принимает число. Также можно задать атрибут toplevel. 
Фрейм с toplevel автоматически становится самым "высоким" (в заданной страте), 
когда на него кликают. Это полезно при реализации перетаскиваемых фреймов.

 <Frame name="MyFrame" frameStrata="HIGHT" frameLevel="5" toplevel="true"></Frame>

 -- Или через Lua
 MyFrame = CreateFrame("Frame", "MyFrame")
 MyFrame:SetFrameStrata("HIGHT")
 MyFrame:SetFrameLevel(5)
 MyFrame:SetToplevel(true)

Все текстуры и шрифты в пределах фрейма должны быть сгруппированы в графические слои:
Графические слои определяются с пом. тега <Layer>. Он имеет следующие уровни:

 * BACKGROUND - здесь располагается фоновая текстура;
 * BORDER - рамки, которые отрисовываются поверх фоновой текстуры;
 * ARTWORK - декоративные элементы, которые располагаются поверх рамки и фона;
 * OVERLAY - элементы, которые распологаются выше всех предыдущих, например текст;

 * HIGHTLIGHT - элементы, которые появляются при наведении мыши и перекрывают 
   все остальные (фрейм должен обрабатывать события mouseover);
 
Пример создания текстуры (верхняя левая часть окна банка):

 <Layers>
   <Layer level="BORDER">
     <Texture file="Interface\BankFrame\UI-BankFrame-TopLeft">
       <Anchors>
         <Anchor point="TOPLEFT"/>
       </Anchors>
     </Texture>
   </Layer>
 <Layers>

Чтобы сделать простую заливку цветом и градиент, используются теги <Color> и <Gradient>.
Пример создания красного квадратика в центре экрана. Атрибут setAllPoints устанавливает 
элементу теже якоря и размеры, как и в родительском фрейме.

 <Frame name="RedSquare" parent="UIParent">
   <Size x="50" y="50"/>
   <Anchors>
     <Anchor point="CENTER"/>
   </Anchors>
   <Layers>
     <Layer level="BACKGROUND" setAllPoints="true">
       -- Возможно, следует дополнительно обернуть в тег <Texture>
       <Color r="1.0" g="0.0" b="0.0" a="0.5"/>  
     </Layer>
   </Layers>
 </Frame>
  
Создание текстуры через Lua:

 BagBuddy.bg = BagBuddy:CreateTexture("MyTexture", "BACKGROUND")
 BagBuddy.bg:SetWidth(60)
 BagBuddy.bg:SetWidth(60)
 BagBuddy.bg:SetPoint("TOPLEFT", 7, -6)

 BagBuddy.bg:SetTexture("Interface\\Icons\\INV_Misc_EngGizmos_30")

 -- Вместо текстуры устанавливаем цветовую заливку
 BagBuddy.bg:SetTexture(0.0, 0.0, 1.0, 0.5)

Текст создается с помощью тега <FontString>. Он имеет такие атрибуты как: font, text,
spacing, outline, justifyH/V и др. Полный список можно посмотреть на стр. 164. 

 <Layer level="OVERLAY">
   <FontString name="$parent_Title" parentKey="title" 
               inherits="GameFontNormal" text="BagBuddy">
     <Anchors>
       <Anchor point="TOP">
         <Offset x="0" y="-18"/>
       </Anchor>
     </Anchors>
 </Layer>

В примере выше, текст наследуется от стандратного шаблона GameFontNormal. Атрибут parentKey
это ключ, по которому этот текст будет доступен в родительском фрейме (BagBuddy.title).
Шаблон $parent хранит название родительского фрейма (получится BagBuddy_Title).

Создание текста через Lua:

 BagBuddy.title = BagBuddy:CreateFontString("BagBuddy_Title", "OVERLAY", "GameFontNormal")
 BagBuddy.title:SetPoint("TOP", 0, -18)
 BagBuddy.title:SetText("BagBuddy")

Фрейм можно показать и скрыть с пом. методов Show() и Hide(). Метод IsShown() проверяет
показан ли фрейм, а IsVisiable() - показан ли фрейм и все его предки.

-----------------------

ШАБЛОНЫ ФРЕЙМОВ

Шаблоны помогают переиспользовать уже готовые части XML-разметки с их стилями. 
Унаследовать шаблон можно с помощью атрибута inherits.

 <Button name="BtnTemplate" virtual="true">
   <Size x="16" y="16"/>
   <Layers>
     <Layer level="BACKGROUND">
       <Texture name="$parentIcon" parentKey="icon">
         <Color r="1.0" g="1.0" b="1.0"/>
       </Texture>    
     <Layer>
   </Layers>
 </Button>

 <Button name="Btn1" inherits="BtnTemplate"/>
 <Button name="Btn2" inherits="BtnTemplate">
   <Anchors>
     <Anchor point="TOPLEFT" relativePoint="TOPRIGHT" relativeTo="Btn2"/>
   </Anchors>
 </Button>

Стандартные шаблоны из клиентского файла UIPanelTemplates.xml:

 * UIPanelButtonTemplate - стандартная кнопка;
 * UIPanelCloseButton - кнопка "Х" из левого верхнего угла окна;
 * UIPanelScrollBarTemplate - скроллбар окна или чата;
 * InputBoxTemplate - поле ввода, как у чата;
 * UICheckButtonTemplate - стандартный чекбокс;
 * UIRadioButtonTemplate - стандартная радиокнопка;

 * TabButtonTemplate - кнопка таба, как у окна чата при переключении каналов; 
   для работы с табами можно использовать готовые утилиты из файла UIPanelTemplates.lua;

Более подробное описание стандартных шаблонов можно найти на стр. 179-183.

-----------------------

РАБОТА С WOW API

Большинство встроенных ф-ций основаны на C, а не Lua. Ф-ции из папки FrameXML предоставляют
множество полезных утилит, но под капотом они также обращаются к встроенным C-ф-циям.

Защищенные ф-ции могут быть вызваны только из встроенного кода. Некоторые ф-ции являются
защищенными только в бою. WoW умеет определять когда код выполняется из макроса или аддона, 
и когда из встроенного файла.

Движение, таргетинг, использование абилок и манипуляции с action bar'ом - 
все это защищенные ф-ции. Чтобы написать аддон, который как-то взаимодействует с этим
перечнем, используются безопасные шаблоны (secure templates, глава 15).

Каждая ф-ция, связанная с юнитом, может принимать на вход специальный unitID, 
который представлен в виде токена. Ниже приведен список базовых токенов (unitIDs):

 * player - персонаж, управляемый игроком (т.е. мной);
 * pet - пет игрока;
 * Vehicle - транспорт игрока;
 * target/playertarget - выбранная цель;
 * focus - цель в фокусе;

 * mouseover - цель под курсором, как та, что в 3х мерном мире, 
   так и фрейм с установленным атрибутом "unit". 

 * partyN - N-член группы, от 1 до 4; на игрока не ссылается;
 * partypetN - пет N-члена группы;

 * raidN - N-член рейда; самый высокое число указывает на игрока, 
   а самое низкое - на рейд-лидера;

 * raidpetN - пет N-члена рейда;
 * arenaN - N-противник на арене;
 * npc - текущий выбранный NPC;

 * none - нет юнита (был создан чтобы разрешить активацию курсора выбора цели 
   когда ты выбираешь что-то уявзвимое для спела, который кастуешь...) 

UnitHealth("Healadin")  -->  кол-во hp игрока с ником Healadin
UnitHealth("player")    -->  кол-во hp моего персонажа
UnitExists("npc")       -->  1 если выбран какой-то NPC

Каждый предмет (item) в Wow имеет уникальный числовой ID. Многие предметы имеют одинаковые
названия, но itemID у них всегда разный. Его можно узнать на тематических сайтах.

 * Hearthstone - 6948;
 * Insignia of the Alliance - 18864 (классовая тринька для пала);
 * Insignia of the Alliance - 29593 (классовая тринька для шамы);
 * Militia Dagger - 2224;

Чтобы предоставить дополнительную информацию о предмете, например кто его создал, 
какой у него уровень и пр. Нужно использовать строковый идентификатор. 
Задается он так: item:0:0:0:0:0:0:0:0

Каждый 0 - это какой-то уточняющий ID, например: item:41319:3842:3642:3466:0:0:0:0:80 
это Hateful Gladiator’s Kodohide Helm с чаркой на +30 стамины и +25 реса и камнем на +32
стамины и бонусом против огнушения, а также камнем на +9 к силе заклинаний и +12 стамины. 

Список всех уточнений предмета приведен на стр. 196.

На предмет можно также создать гиперссылку по такому шаблону: |H<DATA>|h<DISPLAYTEXT>|h
Следующий пример выведет надпись [Hearthstone] белого цвета, кликнув по которой можно будет
узнать более детальную информацию (как линкануть предмет в чате):

 print("|cffffffff|Hitem:6948:0:0:0:0:0:0:0:0|h[Hearthstone]|h|r")

Принципы поиска подходящего API:

1) Изучение категорий API.

2) Просмотр примеров кода из папки FrameXML. Очень много ф-ционала уже реализовано, 
по умолчанию. Например, если нужно реализовать полоску каста, то можно с помощью
команды /framestack выяснить, где примерно находится подходящий фрейм и далее,
проанализировав его исходный код, сделать нечно подобное. 

Чтобы проверить тот или иной функционал, API можно вызывать напрямую: 
 /run print(GetCombatRatin(CR_HAST_MELEE))

3) Искать нужный ф-ционал в похожих аддонах.

-----------------------

ВЗАИМОДЕЙСТВИЕ С ВИДЖЕТАМИ

Стр. 207

