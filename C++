ОСНОВЫ ЯЗЫКА

Каждая инструкция заканчивается точкой с запятой.
Код может группироваться простыми фигурными скобками, как в JS.

Ф-ция main может определяться как без параметров, так и с параметрами:
int main(int argc, char* argv[]) {}

Инициализация - это когда переменной вместе с объявлением сразу присваивается 
какое-то значение, например: int a = 23;

Переменные примитивных типов, которые объявлены без инициализации, внутри ф-ции и вне
её могут принимать разные значения. Так например тип int по умолчанию инициализируется
значением 0 если переменная объявлена вне ф-ции, а если внутри неё, то она может иметь
неопределенное значение, либо вообще ошибку (в зависимости от компилятора).

Типы данных:

Символьные:
* char - символ в кодировке ASCII; занимает 1 байт; от -128 до 127, либо от 0 до 255;
* signed char - знаковый char, т.е. только от -128 до 127;
* unsigned char - беззнаковый char, т.е. только от 0 до 255;
* wchar_t - беззнаковый символ, занимающий на Windows 2 байта, а на Linux 4 байта;
* char16_t - беззнаковый символ в кодировке Unicode; занимает 2 байта;
* char32_t - беззнаковый символ в кодировке Unicode; занимает 4 байта.

Целочисленные:
* short - число, занимающее 2 байта; синонимы short int, signed short int, signed short;
* unsigned short - беззнаковый short; синонимы: unsigned short int;
* int - число, занимающее 2 или 4 байта, в зависимости от архитектуры процессора;
синонимы: signed int, signed;
* long - число, занимающее 4 байта; синонимы: long int, signed long int, signed long;
* unsigned long - беззнаковый long; синонимы: unsigned long int;
* long long - число, занимающее 8 байт; синониы: long long int, signed long long,
signed long long int;
* unsigned long long - беззнаковый long long; 

С плавающей точкой:
* float - число, занимающее 4 байта;
* double - число, занимаюшее 8 байт;
* long double - число, не менее 8 байт, диапазон значений может отличаться в
зависимости от размера памяти.

Остальные:
* bool - логический тип; размер памяти точно не определен;
* void - тип без значения;
* string - строка (требует подключения библиотеки).

Символы char16_t и char32_t новые и для работы с ними пока нет потоков, поэтому при
выводе, их необходимо преобразовывать к char или wchar_t.

Чтобы узнать сколько памяти занимает переменная, нужно использовать оператор sizeof().

С помощью ключевого слова auto определяются переменные, тип которых задается
динамически, исходя из присвоенного значения: auto num = 23;

Если переменной присвоить значение другого типа, то компилятор попытается неявно
преобразовать его к нужному, самостоятельно:
...
int num = 'g';  -->  переменной присвоится код символа 'g' из таблицы ASCII.

Неявные преобразование типов:
* bool - если присваивается 0 то будет false, во всех остальных случаях - true;
* числовой или символьный тип - если присваевается true то будет 1, false - 0;
* целочислен. тип - если присваиваивается дробное число, то дробная часть отбрасывается;
* беззнаковый тип - если присваивается значение вне диапазона, то результатом будет
остаток от деления по модулю, например если unsigned char (0-255, т.е всего 256
значений) присвоить значение -1 то результат будет рассчитываться так: 256 - |-1/256|;
* знаковый тип - если присваивается значение вне диапазона, то результат может быть
неадекватным, в зависимости от того, как поведет себя программа.

Если результат преобразовывается от меньшего типа к большему, то такие преобразования
являются безопасными: bool -> char -> short -> int -> double.

Константы объявляются так: const int a = 23;

Операции - это то, что производится над переменными, например +/-/* и т.п.
Операнды - это значения, которые участвуют в операции, т.е. сами переменные.

Операции могут быть унарными, бинарными и тернарными. Все зависит от кол-во операндов,
принимающий участие в процессе.

При делении, если в операции участвуют целые числа, то и результат будет округлен к
целому числу, даже если указан тип с плавающей точкой:
...
double a = 10 / 4;   -->  результат будет 2
dobule b = 10.0 / 4  -->  а тут правильный результат, 2.5

Операция остатка от деления (%) рассчитывается так:
int c = 22 % 4;  -->  22 - 4 * 5
int d = 39 % 6;  -->  39 - 6 * 6

Операции инкремента/декремента имеют более высокий приоритет, чем другие. Но при этом
следует также учитывать особенности присвоения значений при постфиксном и префиксном
вариантах.

Операция присвоения выполняется справа налево: 
a = b = c = 32;  -->  сначала c = 32, затем b = c, потом a = b

Прямой код - это битовое представление числа.
Обратный код - это инверсия всех битов прямого кода, кроме последнего.
Дополнительный код - это обратный код числа + 1.

Последний бит любого числа всегда определяет знак, где 1 это отрицательное число, 
а 0 - положительное: 0000 0100 == 4, 1000 0100 == -4.

Положительное число в прямом, обратном и дополнительном кодах всегда одинаковое:
0010 -> 0010 -> 0010

При сложении положительного числа с отрицательным, на уровне битов происходит следующее:
1) Отрицательное число преобразовывается в дополнительный код.
2) Выполняется сложение прямого и дополнительного кодов.

При сложении прямого и дополнительного кодов, последний бит результирующего числа
всегда отбрасывается!

Пример сложения (-2 + 3):
1) 1000 0010 -> 1111 1110
2) 1111 1110 + 0000 0011 = 1|0000 0001 = 0000 0001

Побитовое НЕ (~) просто инвертирует все биты числа и преобразовывает результат
в дополнительный код, например ~3 == -4.
...
0000 0011  -->  число 3 в прямом коде
1111 1100  -->  то, что получается при ~3
1000 0100  -->  предыдущий результат преобразовывается в доп. код

Пространство имен определяется так: namespace ns_name { }
Также, пространство имен может быть определено без имени: namespace { }
В этом случае все его содержимое будет доступно только в том файле, где объявлено.

Чтобы обратиться к пространству имен, используется оператор области видимости ::
std::cout  -->  std это пространство имен, а cout - объект

Чтобы подключить пространство имен, нужно использовать оператор using:
...
using namespace ns_name  -->  подключение всего пространсва имен
using ns_name::объект    -->  подключение объекта из пространства имен

Если подключить пространство имен целиком, то в глобальное пространство добавятся 
все его компоненты. Это может привести к конфликтам имен.

Ссылка - это по сути альтернативное имя переменной. 
Ссылку нельзя просто объявить, она также должна быть проинициализирована. 
Ссылке нельзя присвоить литеральное значение.
...
int num = 23;
int& refNum = num;

Ссылка на константу должна быть константной, но при этом константная ссылка может
указывать и на обычные переменные.
...
const int num = 23;
const int& refNum = num;

Объявление и инициализация массивов выглядит так:
...
int arr1[4];  -->  пустой массив из 4х элементов
int arr2[4] = { 1, 2, 3, 4 };  -->  массив с элементами
int arr3[7] = { 2, 3 };        -->  инициализация только первых 2х элементов
int arr4[]  = { 4, 6, 2 };     -->  размер массива может вычисляться автоматически

Символьный массив может инициализироваться сразу строкой, но в этом случае массив будет
иметь на 1 элемент больше, т.к. будет автоматич. добавляться символ '\0'. Этот символ
сигнализирует об окончании строки, при различных переборах и т.п.
... 
char arr[] = "hello!";  -->  здесь будет 7 элементов

Нельзя присвоить один массив другому:
...
int arr1[] = { 1, 2, 3 };
int arr2[] = arr1;  -->  ошибка!

Узнать кол-во элементов массива можно так: sizeof(arr) / sizeof(arr[0])
Цикл foreach реализуется также, как и в Java: for (int num : arr) {}

Так выглядят многомерные массивы. Размерность подмассивов указывать обязательно:
...
int arr1[3][2] = { {1, 2}, {3, 4}, {5, 6} };
int arr2[][2] = { 1, 2, 3, 4, 5, 6 };  -->  можно разместить всё в одних скобках
int arr3[][2] = { {1, 2}, {}, {7} }    -->  можно инициализировать не все элементы

Перебор многомерных массивов через foreach:
...
for (auto& subArr : arr) {  -->  подмассив должен задаваться через ссылку
  for (int num : subArr) {
    cout << num << endl;
  }
}

Строки определяются следующим образом:
...
string str1;  -->  пустая строка
string str2 = "hello!";
string str3("welcome");  -->  как обычный класс
string str4(5, 'h');     -->  здесь получится "hhhhh"

При сравнении результат true будет в том случае, если все символы обеих строк будут
равны, включая регистр. Другие операторы сравнения (<, <=, >, >=) будут сравнивать
строки также в зависимости от регистра и алфавитного порядка символов.

Размер строки можно узнать с помощью метода size: str.size().
Чтобы проверить наличие символов в строке, используется метод empty: str.empty().
Cтрока может давать доступ к какому-то отдельному символу (как в JS): char ch = str[0];

Массив символов, у которого последний элемент '\0', может использоваться как строка:
char str[] = { 'h', 'e', 'l', 'l', 'o', '\0' };

--------------------------------------

ПОТОКИ ВВОДА/ВЫВОДА

Для работы с потоками ввода/вывода используется библиотека iostream. Она содержит:
* istream/wistream - читают данные с потока;
* ostream/wostream - записывают данные в поток;
* iostream/wiosream - читают и записывают данные в поток.

Типы, которые начинаются на w предназначены для поддержки wchar_t.

Для работы с консолью определены объекты - cout (console out), cerr, cin.
Для вывода символов на консоль используется объект cout, с перегруженным оператором <<.
Для чтения символов с консоли используется объект cin, с перегруженным оператором >>.

Т.к. оператор << возвращает левый операнд, т.е объект cout, то с помощью цепочки
операторов можно вывести много значений. Кроме того вывод можно завершать endl'ом. 
Этот endl делает перевод строки и сброс буффера. Оператор >> также возвращает 
левый операнд. Множественный ввод выполняется через пробел.
...
cout << name << age << endl;
cerr << "Error occured" << endl;
cin >> age >> name;

Чтобы поместить всю строку с пробелами в одну переменную, используется ф-ция getline:
getline(cin, name);  -->  считывает строку из консоли и помещает её в name

Чтобы вывести на консоль символ типа wchar_t нужно использовать не cout, a wcout.
Обычный cout вместо символа выведет числовой код wchar_t.

Для работы с файлами используется библиотека fstream. Она содержит:
* ifstream/wifstream - для чтения с файла;
* ofstream/wofstream  - для записи в файл;
* fstream/wfstream - совмещает чтение и запись.

При работе с файлом, его вначале необходимо открыть с пом. метода open. Он принимает
два параметра: путь и режим. По умолчанию режимы задаются такие: ios::in/ios::out.
После завершения работы с файлом, его нужно закрыть с пом. метода close.

Режимы для открытия файла могут быть такими:
* ios::in - файл открывается для чтения;
* ios::out - файл открывается для записи; 
* ios::app - файл открывается для дозаписи (старые данные не удаляются);
* ios::ate - после открытия файла, указатель перемещается в конец;
* ios::trunc - файл усекается при открытии;
* ios::binary - файл открывается в бинарном режиме.

ofstream out;
out.open("D:\\hello.txt");
if (out.is_open()) {
  out << "hello!" << endl;  -->  запись в файл делается также, как и вывод 
}                                на консоль, с помощью оператора "<<"
out.close();

Также, можно обойтись вызовом конструктора. В этом случае метод open не нужен.
...
string result;
ifstream in("D:\\hello.txt");  
if (in.is_open()) {
  while(getline(in, result)) { }  -->  такой вариант предподчительнее
  while(in >> result) { }         -->  оператор ввода тоже можно использовать
}
in.close();

Оператор ввода хорошо работает с примитивными типами, но для использования с объектами
классов его необходимо переопределять: https://metanit.com/cpp/tutorial/8.4.php

--------------------------------------

ФУНКЦИИ

В C++, компилятор должен знать о ф-циях до их вызова. Поэтому вызываться они должны
строго после объявления. Чтобы обойти это ограничение, можно вместо определения в
начале, указать прототип ф-ции, т.е. её сигнатуру:
...
void printMsg(string);  -->  прототип ф-ции перед вызовом; имена параметров 
                             указывать не обязательно
int main() {
  printMsg("hello!");
  return 0;
}

void printMsg(string msg) {
  cout << msg << endl;
}

Также, разделить код можно с помощью заголовочных файлов. В них обычно размещаются
прототипы разных ф-ций/классов. Подключаются они через директиву #include.
Все директивы препроцессоров начинаются со знака решетки #.
...
Файл print-msg.h:
void printMsg(string);

Файл main.cpp:
include "print-msg.h"  -->  таким образом, мы как бы подключаем прототипы ф-ций, 
                            которые заранее объявлены, где-то в другом месте
int main() {
  printMsg("hello!");
  return 0;
}

void printMsg(string msg) {
  cout << msg << endl;
}

Помимо прототипов ф-ций, в заголовочных файлах можно размещать и переменные. В этом
случае они будут считаться внешними, а их объявление должно быть с ключ. словом extern.
...
Файл message.h:
extern string msg;

Файл message.cpp:
string message = "hello!";

Файл main.cpp:
#include "message.h"

int main() {
  cout << message << endl;
  return 0;
}

Параметры по умолчанию определяются также, как и в JS. Кроме того, параметры по
умолчанию могут задаваться в прототипе. В этом случае в ф-ции их задавать уже не
обязательно, т.к. они будут браться из прототипа.
...
int multiply(int n, int m = 3);

int multiply(int n, int m) { 
  return n * m;
}

Параметры могут определяться как по значению, так и по ссылке. Параметры по ссылке
нужны для того, чтобы ф-ция могла возвращать сразу несколько значений. Кроме того, 
они необходимы, чтобы улучшить производительность, т.к. в этом случае идет обращение
напрямую, к уже ранее созданным значениям, и их не нужно копировать.
...
void square(int& a, int& b) {
  a = a * a;
  b = b * b; 
}

Параметры по значению лучше использовать для небольших примитивных типов. 
Также стоит учесть что передача ссылок по значению, это не тоже самое, что передача
параметров по ссылке.
...
int a = 23;
int& aRef = a;
pow(aRef);  -->  выведет 23 

void pow(int n) {  -->  параметр определен по значению; т.е. создана копия ссылки aRef;
  n = n * n;            изменение копии не затронит оригинальный aRef
}                       

Параметры могут быть константными, в этом случае их значения не могут меняться:
void pow(const int a) { }

Если ф-ция определяет константные параметры по ссылке, то передаваться ей также
должны константы.

Ф-ции могут возвращать ссылочные результаты. В этом случае следует избегать того, 
чтобы они возвращали ссылки на локальные переменные.
...
int& myFunc() {
  int a = 23;
  return a;  -->  локальная переменная будет удалена после выполнения ф-ции
}

В С++ функции могут возвращать только единичное значение, будь то примитив или объект
класса/структуры. Массивы возвращать нельзя. Вместо них возвращают указатель на 
первый элемент. При этом сам массив должен быть динамическим (через new), иначе он
удалится после выполнения ф-ции и указатель потеряет свое значение.

Посему, вместо возврата нового массива, иногда передают результирующ. массив по ссылке,
через параметры, и заполняют его нужными данными.

Когда ф-ция возвращает результат по значению, то, как и в случае с параметрами,
в памяти будет создана копия результата, которая затем вернется в область видимости,
откуда была вызвана эта ф-ция.
...
object getObj() {
  object obj;
  return obj;
}

object obj2 = getObj();  -->  obj2 получит копию obj, а сам obj 
                              удалится из стека, после выполения ф-ции.

Помимо константных переменных есть еще и статические. Особенностью таких переменных
является то, что они не уничтожаются при завершении работы ф-ции, а их инициализация
происходить только один раз.
...
void increment() {  -->  переменная i инициализируется только при первом вызове ф-ции, 
  static int i = 0;      а при всех последующих вызовах, сохряет свое предыдущие 
  i++;                   состояние и продолжает увеличиваться дальше
}

--------------------------------------

УКАЗАТЕЛИ

В них хранятся адреса переменных в памяти. В отличии от ссылок их не обязательно
инициализировать при объявлении. Опредяются они следующим образом:
...
int num = 23;      -->  типы переменной и указателя должны совпадать
int* pNum = &num;  -->  для получения адреса также применяется знак &
cout << pNum;      -->  выведет шестнадцатиричное значение

Чтобы получить значение переменной, на которую указывает указатель, нужно выполнить
операцию разыменования "*": cout << *pNum;  -->  выведет 23

Значения переменных, которые хранятся в указателях, можно менять: *pNum = 24;
Это тоже самое, как если изменить значение по ссылке: refNum = 24;
Указателю можно присвоить другой указатель: pA = pB;

Нулевой указатель это тот, который не указывает ни на какой адрес. 
Создать нулевой указатель можно так:
...
int* p1 = nullptr;
int* p2 = NULL;
int* p3 = 0;

На указатель также можно сделать ссылку, в этом случае можно эффективно манипулировать
объектом, на который он ссылается:
...
int* p = 0;
int*& pRef = p;

Указатель также имеет свой адрес в памяти, чтобы его получить нужно применить всё ту же
операцию "&": cout << &p;  -->  выведет адрес указателя

К указателям можно применять операции сравнения (>, >=, <, <=, ==, !=). В этом случае
сравниваться будут их шестнадцатиричные значения.

Указатели, в отличии от переменных, могут быть с типом void. Также их типы можно
приводить из одного в другой. Это делается с помощью операции (тип_указателя*):

Указатель типа char при выводе на консоль интерпритируется как строка. 
Чтобы получить адрес такого указателя, нужно привести его к типу int или void, 
но обычно используется именно тип void.
...
char ch = 'P';
char* pCh = &ch;  -->  выведет не адрес, а просто 'P'
int* pInt = (int*) pCh;     -->  выведет адрес
void* pVoid = (void*) pCh;  -->  тоже выведет адрес

С указателями можно выполнять арифметические операция, например прибавлять к ним число
или отнимать один указатель от друг. В этом случае будет меняться их шестнадцатиричное
значение, например если к указателю типа int прибавить 1, то его код увеличиться на 4,
т.к. int занимает именно столько байт в памяти и т.д. (0x60fe[98] -> 0x60fe[9c]).
...
int* p = 23;
p++;

Результатом разности двух указателей является расстояние между ними в памяти:
int res = pA - pB;  -->  (0x60fe9c - 0x60fe98) / 4 = 1

Чтобы определить указатель на константу, нужно записать его с ключевым словом const, 
но это не сделает его константным.
...
const int num = 10;
const int* pNum = &num;  -->  *pNum = 11; так сделать нельзя, но сам указатель 
                              изменить можно: pNum = &newNum;

Констатный указатель выглядит так: 
int* const pNum = 23;  -->  pNum = &newNum; так сдедать нельзя

Констатный указатель на константу делает невозможным изменение значения самого
указателя, а также переменной, на которую он указывает.
...
const int* const pNum = 23;  -->  *pNum = 24; pNum = &newNum; так сделать нельзя 

В C++, компилятор обычно преоразует массив в указатели. С помощью указателей можно
манипулировать элементами массива. Имя массива является адресом его первого элемента.
...
int arr[] = { 1, 2, 3, 4 };
cout << *arr;  -->  выведет 1, т.е. arr[0]

Прибавляя к адресу массива некоторое число, можно получить определенный элемент:
cout << *(arr + 2);  -->  веведет 3; но можно и по обычному: arr[2]

При этом адрес самого массива изменить нельзя, т.к. его имя это не станд. указатель:
arr++; arr = &value;  -->  так сделать нельзя

С помощью указателей можно легко перебирать массивы:
...
for (int* pItem = arr; pItem <= &arr[3]; pItem++) {
  cout << *pItem << endl;
}

Указатель в параметрах ф-ции реализовывается так:
...
int num = 10;
increment(&num);  -->  чтобы задать указатель в параметрах, 
                       достаточно просто передать адрес переменной
void increment(int* n) {
  (*n)++;  -->  скобки нужны потому, что операция "++" имеет больший приоритет чем "*"
}

Если в параметрах ф-ции определяется массив, то по сути он автоматически преобразуется
в указатель на его первый элемент. Из-за этого появляются некоторые ограничения,
например не получится посчитать длину такого массива, а также перебрать его 
через цикл foreach.
...
void print(int nums[]);  -->  преоразуется в void print(int* nums); 

void print(int nums[]) {
  int size = sizeof(nums) / sizeof(nums[0]);  -->  так сделать нельзя
  for (int n : nums) { }  -->  так сделать нельзя
}

Чтобы обойти эти ограничения, в ф-цию может передаваться доп. маркер, указывающий на
размер массива, либо указатели на его начало и конец.
...
print(nums, length);

int* begin = begin(nums);
int* end = end(nums);  -->  ф-ция end возвращает указатель не на последний элемент, 
print(begin, end);          а на адрес за последним элементом в массиве

void print(int* begin, int* end) {
  for (int* ptr = begin; ptr != end; ptr++) {
    cout << *ptr << endl;
  }
}

Если не нужно изменять массив внутри ф-ции, то эти указатели лучше делать констатными:
void print(const int*, const int*);

Многомерный массив - это последовательность элементов, которая в памяти занимает
непрерывный участок, размером n * m. Поэтому его можно перебрать всего одним циклом.

Многомерный массив в качестве параметра может быть определен так: int (*nums)[size];
Эту запись не стоит путать с: int* nums[size]; здесь массив указателей.

Массив указателей по другому можно записать так: int** nums; Его также можно
представить в виде многомерного массива: int** nums = new int*[size]; 
Но такая запись не пройдет: int** nums = { {1, 2}, {3, 4} };

Указателем на ф-цию является её имя. Он хранит адрес ф-ции, т.е. адрес первого байта 
в памяти, по которому располагается её код. Определить такой указатель в виде
переменной можно так: тип (*имя_указателя)(параметры);
...
void (*print)();   -->  такой указатель может указывать на любую ф-цию 
print = printMsg;       без параметров, с типом void

print();     -->  так можно обращаться к указателю на ф-цию
(*print)();  -->  альтернативный вариант обращения

void printMsg() {
  cout << "hello!" << endl;
}

Также можно определить массив указателей на ф-ции: 
...
void add(int, int);
void substract(int, int);
void multiply(int, int);

int (*actions[])(int, int) = { add, substract, multiply };

for (int i = 0; i < 3; i++) {
  actions[i](2, 3);
}

Указатель на ф-цию может быть также параметром в другой ф-ции:
...
void action(int (*)(int, int));

int multiple(int a, int b) {
  return a * b;
}

int main() {
  action(multiple);
  return 0;
}

void action(int (*fn)(int, int)) {
  cout << fn(2, 3);
}

Кроме того, указатель на ф-цию может быть типом возвращаемого значения:
...
int (*action())(int, int);  -->  cначала указывается тип возвращаемой ф-ции, т.е. int;
                                 далее в скобках идёт имя текущей ф-ции и её параметры,
int main() {                     т.е. action(); и в последних скобках идут типы
  int (*fn)(int, int);           параметров возвращаемой ф-ции.

  fn = action();
  fn(2, 3);

  return 0;
}

int (*action())(int, int) {
  return multiple;
}                                 

Глобальные и локально-статические переменные размещаются в статической памяти. 
Они освобождаются при завершении работы программы. А обычные локальные переменные
размещаются в стеке. Переменные из статической памяти и стека удаляются компилятором.

В дополнении к этому, в C++ можно создавать динамические переменные. 
При создани, они находятся в куче, пока не будут удалены оттуда явным образом. 

Для управления динамическими переменными используются операторы new и delete.
Оператор new выделяет место в памяти для переменной и возвращает указатель на неё.
Оператор delete получает указатель на переменную и удаляет её из памяти.

int* ptr1 = new int();    -->  значение по умолчанию, т.е. 0
int* ptr2 = new int(23);
delete ptr2;  -->  данные удалены из кучи, но указатель по прежнему доступен
ptr2 = NULL;  -->  затереть неактуальный указатель (NULL это макрос, указывающий на 0)  

Нужно внимательнее следить за тем, когда на один динамический объект есть несколько
указателей. При освобождении одного, второй также станет недоступен. 

Кроме того, стоит помнить, что после освобождения памяти, указатель по прежнему
остается доступен и может впоследствии указывать на что-то другое. Чтобы этого не
допустить нужно также затирать и его, с помощью макроса NULL или значения 0
(т.к. указатель представляет адрес памяти в виде числа).

Также есть еще такой тип как nullptr. Он аналогичен NULL, но более эффективен, 
т.к. не позволяет системе перепутать между нулем и нулевым указателем.
...
clearData(0);  -->  если есть два варианта ф-ции, один с указателем, а другой со
                    значеним типа int, то компилятор не поймет какой из них вызывать
clearData(nullptr)  -->  здесь система понимает что вызывается вариант с указателем

Можно также создавать и динамические массивы: 
...
int* nums1 = new int[4];    -->  у каждого элемента неопределенное значение
int* nums2 = new int[4]();  -->  у каждого элемента значение по умолчанию, т.е. 0

int* nums3 = new int[3] { 1, 2, 3 }  -->  если переданных значений меньше, то оставш.
                                          элементы будут иметь значения по умолчанию
delete[] nums3;  -->  удаляются они так

--------------------------------------

ООП

При определении классов, нужно обязательно указывать точку c запятой после фигурных
скобок: class MyClass { };

Модификаторы членов указываются единожды на целую группу. 
Если модификатор отсутствует, то по умолчанию задается private.
...
class Person 
{
  string name;  -->  приватные члены класса
  int age;

public:
  void move() { }

private:
  void doMove() { }

protected:
  void onMovement() { }
};

Объект класса может создаваться простым объявлением его переменной:
...
Person person;  -->  вызывается конструктор по умолчанию
person.name = "Stroustrup";  -->  пустые публичные переменные можно задать 
person.move();                    во внешнем коде

Для доступа к членам класса, при обращении через обычную переменную используется точка,
а если обращение идет через указатель, тогда вместо точки должна быть стрелка "->".
...
Person* personPtr = &person;
personPtr->age = 19;

Конструктор объявляется следующим образом:
...
class Person 
{
public:
  string name;
  string age;

  Person(string _name, int _age) {
    name = _name;
    age = _age;  
  }

  Person() : Person("Trump", 23)  -->  вызов одного конструктора из другого
  { 
  }
};

Если у класса есть конструкторы, то при создании объекта нужно вызывать хотя бы один:
...
Person person1 = Person("Aik", 23);
Person person2("Luka", 16);  -->  сокращенный вариант объявления

Константы и ссылки внутри класса инициализируются особым образом. Это из-за того, 
что они уже должны быть заданы до того, как код внутри конструктора начнет выполнятся.
...
const string name;
int& age;

Person(string _name, int _age) 
  : name(_name), age(_age)  -->  иногда таким образом ещё  
{                                инициализируют поля базовых классов
}

В С++ почти всегда разделяют определение и реализацию классов/ф-ций. 
Определение задается в заголовочных файлах, а реализация - в файлах cpp. 

Когда во внешний код подключается заголовочный файл с определением, то линковщик
автоматически подтягивает и одноименный cpp-файл с реализацией.

Если вместо заголовочного файла попытаться подключить файл cpp, то нарушится правило
множественного определения. Это из-за того, что директива #include просто скопирует 
все его содержимое в главный файл и определений станет несколько.

При этом, похожая ошибка может быть и при подключении заголовочных файлов, если
подключить их несколько раз, в разных местах проекта. Посему содержимое заголовочных
файлов принято оборачивать в директивы #ifndef #define #endif.

Но самая главная проблема, которую решает такое разделение, это когда два класса
ссылаются друг на друга. В этом случае не понятно что подключать раньше.

Иногда в заголовочных файлах все же оставляют и реализацию. Это происходит в тех
случаях, когда объявляются шаблонные классы/ф-ции, либо когда сама реализация
достаточно примитивная. И здесь лучше использовать ключевое слово inline.

Прототим метода в файле cpp записывается так: тип класс::метод(параметры) {}.

Файл person.h:
...
class Person 
{
public:
  string name;
  int age;
  Person(string _name, int _age);
  void move();
};

Файл person.cpp:
...
Person::Person(string _name, int _age) {
  name = _name;
  age = _age;
}
void Person::move() {
  cout << name << " is moving!" << endl;
}

Заголовочный файлы это что-то вроде интерфейсов. Они придают свою, особенную, 
специфику разработки. Например некоторые проекты бывают построены по такому принципу, 
что предоставляют только одну спецификацию т.е. набор заголовочных файлов. А конкретной 
реализацией занимается уже отдельный поставщик. Библиотека OpenGL как раз имеет только 
одну спецификацию, а для реализации обычно берут библитеку GLAD.

В C++ существуют дружественные ф-ции. Их особенность в том, что они имееют доступ 
к приватным членам класса, хотя при этом сами не входят в него. По смыслу этот 
функционал напоминает методы расширения в C#.
...
class Product
{
  friend void buy(Product&);  -->  какая-то внешняя ф-ция

public:
  Product() {
    price = 23;
  }

private:
  int price;
};

void buy(Product& product) {
  cout << "Bought at price " + prouct.price;
}

int main() {
  Product product();
  buy(product);
  return 0;
}

Дружественными могут быть и методы другого класса, но если в перспективе планируется
расширять их кол-во, то лучше сделать дружественным весь класс.
...
class Product;  -->  что-то вроде прототипа класса

class Customer
{
  void buy(Product& product) {
    cout << "Bought at price " + prouct.price;
  }
};

class Product 
{
  friend class Customer;

public:
  Product() {
    price = 23;
  }

private:
  int price;
};

int main() {
  Product product();
  Customer customer;
  customer.buy(product);
  return 0;
}

Ключевое слово this означает указатель на текущий объект класса, внутри него самого.
...
class Point {
  int x;
  int y;

public:
  Point(int x, int y) {
    this->x = x;  -->  в основном this применяется чтобы разграничить параметры, 
    this->y = y;       которые имеют такие же названия что и поля
  }

  Point& move() {
    x++;
    y++;
    return *this;  -->  this это указатель и его надо разыменовать перед тем как
  }                     возвращать, ну а возвращать надо именно тот объект, в котором
};                      произошли изменения, а не его копию, поэтому по ссылке

int main() {
  Point point(5, 10);
  point.move().move();
  return 0;
}

Статические члены класса определяются с ключ. словом static:
...
class Accout
{
  const static bool vip = true;  -->  статич. константы могут быть заданы 
  static int rate;                    сразу, внутри класса
public:
  static int getRate() {
    return rate;
  }
}

int Account::rate = 8;  -->  статич. поля должны инициализир. вне класса, 
                             иначе к ним не получится обращаться внутри класса
int main() {
  Account accout;
  cout << Account::getRate();  -->  доступ к статич. членам осуществл. через ::
  cout << accout.getRate();    -->  но можно и через переменную класса
  return 0;
}

В C++, структуры это почти тоже самое что и классы. В основном они используются для
группировки связанных данных. Все её члены по умолчанию имеют модификатор public.
...
struct person_data {
  int id;        -->  структуры должны быть набором публичных,
  string phone;       открытых переменных
};

person_data data;  -->  структуры, возможно, лучше именовать с маленькой буквы
data.id = 23;
data.phone = "+10223412";

Кроме того, структуры можно инициализировать с помощью синтаксиса, как в массивах:
person_data data = { 24, "+27563619" };

Перечисления - это наборы числовых констант. Каждой константе присваевается числовое
значение, начиная с нуля. Записываются они так:
...
enum seasons {
  spring,      -->  значение по умолчанию, т.е. 0  
  summer = 2,  -->  теперь все послед. значения будут идти после 2
  autumn,
  winter
};

cout << seasons::winter;  -->  так можно обратиться к отдельной константе

cout << winter;  -->  сокращенный вариант, если обращение находится в той же 
                      области видимости, где и определение

Наследование выполняется с помощью двоеточия, после которого идет название базового
класса с модификатором доступа. Модификатор указывает, какие члены будут доступны 
в производном классе.

Как и во многих других языках, конструкторы из базового класса (объявленные явно) 
не наследуются, поэтому в производном классе один из них нужно вызывать явно.

class Printer {
  string msg;

public:
  Parent(string msg) {
    this->msg = msg;
  }
};

class Scanner : public Printer {  -->  сканер имеет доступ к публичным 
  bool mode;                           членам принтера

public:
  Scanner(string msg, bool mode) : Printer(msg)  -->  так вызываются констукторы 
  {                                                   базовых классов 
    this->mode = mode;
  }
};

Члены, помеченные модификатором protected в базовом классе, также доступны и 
в производном, даже если при наследовании для класса указан модификатор public. 

Наследование можно запрерить с помощью модификатора final: class User final { };
А если пометить этим модификатором метод, то его нельзя будет определить в наследниках.

Для того, чтобы переопределить метод базового класса, он должен быть объявлен с ключ.
словом virtual. В производном же классе, новый метод должен быть помечен override.
...
class Person {
public:
  virtual void display() { }
};

class Employee : public Person {
public:
  void display() override 
  {
    Person::display();  -->  обращение к базовому методу
  }
};

Если же не указывать все эти ключ. слова, то новый метод просто перекроет старый.

Классы, которые определяют или наследуют вирт. методы, называются полиморфными.
В примере выше и Person, и Employee являются таковыми.

Вызвать реализацию метода именно базового класса, во внешнем коде можно так:
...
Employee empl("Bob", 32, "IBM");
empl.Person::display();

Абстрактный класс в понятии C++ этот тот, который содержит хотя бы одну чистую
виртуальную ф-цию. Чистая виртуальная ф-ция это ф-ция без определения, всегда
завершающаяся записью "= 0".
...
class Figure {
public:
  virtual double getSize() = 0;
  virtual void show() = 0;
};

Объект абстрактного класса создать нельзя, но можно создать указатель на него:
...
Figure figure;      -->  так работать не будет
Figure* figurePtr;  -->  а так всё работает

Деструктор нужен для освобождения различных ресурсов, а также для удаления
нестатических переменных объекта. Он определяется также, как и конструктор, но без
параметров, а перед его названием всегда указывается тильда. Если у класса деструктор
явно не определен, то он все равно будет создан автоматически (неявно).

Деструктор вызывается тогда, когда из памяти удаляется объект.
...
class Person {
public:
  ~Person() { } -->  деструктор, который определен явно
};

Person* person = new Person();
delete person;   -->  происходит вызов деструктора

Person person2;  -->  деструктор этого объекта вызовется, когда 
                      его (объекта) область видимости завершит выполнение 

Виртуальный деструктор обычно делают в базовом классе. Это гарантирует, что деструктор
производного класса будет также вызван, если он объявлен явно. При этом он, как и методы
должен переопределяться через override.
...
A* obj = new B();  -->  если в A деструктор невиртуальный, тогда при уничтожении obj 
                        деструктор из B никогда не вызовется, а если в нём есть 
                        очистка, то произойдет утечка памяти

Посему, если в классе есть виртуальные методы, значит будут и наследники, а раз так, 
то, как правило, нужно делать виртуальным и деструктор.

Виртуальный деструктор можно объявить просто с пустыми фигурными скобками, либо через 
ключевое слово default: virtual ~A() {}, тоже что и: virtual ~A() = default;

Хорошей практикой считается когда деструктор базового класса либо открытый и 
виртуальный, либо защищенный и невиртуальный.

В С++ можно перегружать операторы. Перегрузку можно реализовать как внутри класса, 
так и глобально. Отличие будет только в кол-ве параметров:
...
class Counter {
public:
  int value;

  Counter(int value) {
    this->value = value;
  }

  Counter operator + (double value) {  -->  перегрузка внутри класса (1 параметр)    
    return Counter(this->value + value);
  }
};

Counter operator + (Counter a, Counter b) {  -->  глобальная перегрузка (2 параметра)
  return Counter(c1.value + c2.value);
}

int operator + (Counter c, int value) {  -->  чтобы складывать класс с числом
  return c.value + value;
}

Counter c1(20);
Counter c2(10);

Counter c3 = c1 + c2;
c3 = c3 + 5;
c3 = c3 + 23.7;

Также есть ряд операторов, которые нужно перегружать парами, например если
перегружается "==", то надо перегружать и "!=" и т.д. Кроме того, при перегрузке
инкремента/декремента, нужно переопределять как префиксную, так и постфиксную форму.

Префиксные операторы должны возвращать ссылку на текущий объект:
...
Counter& operator++ () {
  value += 5;
  return *this;
}

Чтобы отличать префиксную и постфиксную формы, при перегрузке, последняя должна
получать дополнительный (неиспользуемый) параметр типа int:
...
Counter operator++ (int) {  
  Counter prev = *this;
  ++*this;      -->  постфиксная форма, определенная ранее
  return prev;  -->  возвращает значение до инкремента
}

Кроме перегрузки есть ещё операторы преобразования типов: operator тип() const { }
Они также могут быть явными. В этом случае определение должо быть со словом explicit.
Слово const в конце любого метода означает что в нём нельзя изменять состояния объекта.
...
class Counter {
  int value;
public:
  Counter(int value) {
    this->value = value;
  }

  Counter(const string& str) {  -->  так реализуется обратное преобразование,
     value = stoi(str);              т.е. из string в Counter
  }

  operator int() const {  -->  для неявного преоразования
    return value;
  }

  explicit operator string() const {  -->  для явного преоразования
    return to_string(value);
  }
};

Counter counterFromSrt("300");  -->  если ссылочный параметр является также
                                     константным, то ему можно передавать литерал;
Counter counter(60);                 это относится не только к преобразованию типов
int num = counter;                                      
string str = (string)counter;
                
--------------------------------------

ИСКЛЮЧЕНИЯ

Все исключения представлены типом exception из файла <exception>.
Чтобы выбросить исключение, используется оператор throw.
...
throw "Division by zero!";
throw exception("Division by zero!");

Обработать исключение можно так:
...
try 
{
  divide();
} 
catch(const char* msg)  -->  можно использовать несколько блоков catch
{
  cout << *msg << endl;
}
catch(const exception& ex)  -->  константную ссылку определять не обязательно 
{
  cout << ex.what() << endl;
}
catch(...)  -->  троеточие позволяет обрабатывать любое исключение
{  
  cout << "Something wrong" << endl;
}

Иключения должны перехватываться в порядке от более частных к более общим. 
От типа exception можно наследоваться, создавая тем самым пользовательские исключения.

Тип exception для g++ не может инициализироваться строкой. Это доступно только в VS. 
Но зато, строкой могут инициализироваться производные от него типы.

Некоторые типы общих исключений: https://metanit.com/cpp/tutorial/6.3.php

--------------------------------------

ШАБЛОНЫ

Шаблон класса определяется с помощью ключ. слова template c угловыми скобками, 
в которых указываются обобщенные параметры. А те в свою очередь определяются 
через typename.
...
template <typename T, typename V>
class Accout {
public:
  Accout(T primaryId, V secondaryId) {
    m_primaryId = primaryId;
    m_secondaryId = secondaryId;
  }

private:
  T m_primaryId;
  V m_secondaryId;
};

Account<int, string> account(234524, "jzxcj234f");

Шаблон ф-ции определяется также, как и для класса, но при вызове такой ф-ции, не нужно
явно задавать типы обобщений. Они определяются сами, исходя из переданных значений.
...
template<typename T>
T fn(T a, T b) {
  return a + b;
}

int res1 = fn(200 + 35);     
double res2 = fn(10.5, 3.2);

-------------------

СТАНДАРТНАЯ БИБЛИОТЕКА ШАБЛОНОВ (STL)

Представляет собой набор коллеций и алгоритмов, для работы с ними. Эти коллекции и
алгоритмы встроены в компилятор, однако не все компиляторы поддерживают их полные
возможности. Например у моб. платформ некоторый ф-ционал может отсутствовать.

Для того чтобы работать с той или иной коллекцией, нужно подключить соответствующий
заголовочный файл, например #include <vector> для векторов и пр.

Коллекции, используемые наиболее часто:
* vector - динамический массив, в который можно добавлять/удалять эл-ты в любом 
  месте, а также получать произвольный доступ к любому эл-ту;
* list - двусвязный список; эл-ты можно добавлять/удалять в начало и в конец;
  доступен только последовательный, двухнаправленный доступ к эл-там;
* map - ассоциативный массив, хранящий пары вида <Key, Value>;
* set - множество (коллекция, содержащая только уникальные значения);
* multimap - map, в котором ключи могут дублироваться;
* multiset - set, с дублирующимися элементами;

Другие коллекции:
* forward_list - односвязный список (здесь однонаправленный доступ к эл-там);
* deque - двусторонняя очередь; эл-ты можно добавлять/удалять в начало и в конец;
  также можно получать произвольный доступ к любому эл-ту;
* array - массив фиксированного размера; доступен произвольный доступ к эл-там, 
  но их нельзя ни добавлять, ни удалять;
* string - коллекция (подобна вектору) однобайтовых символов в формате ASCII;
* wstring - коллекция двухбайтовых символов в формате Unicode.

Пример определения вектора:
...
vector<int> v;  -->  пустой вектор
vector<int> v2(v);  -->  вектор, копия v
vector<int> v3(5);  -->  вектор, состоящий из 5 чисел;
vector<int> v4(5, 2);  -->  вектор, состоящий из 5 чисел, каждое число равно 2 
vector<int> v5 = { 1, 2, 3 };  -->  вектор, состоящий из чисел 1, 2, 3
vector<int> v6 { 1, 2, 3 };    -->  вектор, из чисел 1, 2, 3 (краткая запись)

Пример работы с ассоциативным массивом:
...
map<string, int> m;
m.emplace("Coffee", 2);  -->  упрощенное заполнение
m.insert(pair<int, string>("Tomato", 1));  -->  заполнение через пару
m["Potato"] = 3;  -->  заполнение через квадратные скобки

for (auto& item : m) {  -->  item это пара <string, int>
  cout << item.first << item.second << endl;  
}

auto item1 = m["Potato"];  -->  получение отдельной пары
auto item2 = m.find("Coffee");  -->  альтернативный вариант

Пара для map определяется с помощью структуры pair<K, V>. У неё есть два поля 
first и second. Первое поле возвращает ключ, а второе - значение.
...
pair<string, int> p("Tomato", 1);
cout << p.first << p.second;  -->  "Tomato" 1

Коллекции set и multiset - это по сути бинарные деревья (упорядоченные множества).
При переборе, их элементы всегда будут выводиться в от меньшего к большему, 
даже если добавлялись в произвольном порядке.

Коллекция multiset, при сравнивании её с обычным массивом, используется тогда, 
когда требуются преимущества бинарных деревьев.

Коллекци map и multimap также устроены на основе бинарного дерева. Но ассоциативные
массивы могут иметь разные варианты реализации (см. Алгоритмы [хеш-таблицы]).

Объекты array более гибкие чем обычные массивы. Таким объектам например, можно 
напрямую присваивать значения других таких же объектов array:
...
array<int, 5> arr1 = { 1, 2, 3 };
array<int, 5> arr2 = arr1;  -->  в обычных массивах так сделать не получится

Двусторонняя очередь deque похожа на вектор, она также работает по принципу FIFO, но
отличается от вектора более сложной внетренней реализацией. Её лучше использовать
при работе с очень длинными последовательностями.

Коллекции равны, если они содержат одинаковые элементы на всех позициях. 

В одну коллекцию можно вставить элементы из другого коллекции, передав в первую
соответсвующие указатели begin и end, той, другой коллекции.

У каждой коллекции есть итератор. Он определен соответсвующим типом inerator. 
Чтобы его получить, нужно вызвать метод begin, либо метод end. Первый возвращает
итератор, указывающий на первый элемент коллекции, а второй - итератор, указывающий 
на конец коллекции (т.е. на позицию после последнего элемента).
...
vector<int> vect = { 1, 2, 3 };
vector<int>::iterator it = v.begin();  -->  it указывает на первый элемент

while (it != v.end()) {
  cout << *it << endl;
  ++it;  -->  перемещение выполняется c пом. инкремента/декремента  
}

Итераторы позволяют изменять элементы коллекции при переборе. Чтобы сделать элементы
неизменяемыми, нужно определить константную коллекцию либо использовать методы 
cbegin и cend из обычной коллекции.

Реверсивный итератор позволяет перебрать элементы коллекции в обратном порядке.
Он определен типом reverse_iterator, а для его получения есть методы rbegin и rend.

Почти все итераторы (кроме list и forward_list) поддерживают такие операции как:
it +/- n, it +=/-= n, it1 - it2, а также операции сравнения: >, >=, <, <=.

Для получения итератора в forward_list используется метод before_begin. Он указывает 
на несуществ. элемент, перед началом списка. К его значению обратиться нельзя, но зато
можно применять операции инкремента/декремента (для перемещения по коллекции). 

Чтобы получить первый/последний элементы из list, нужно использ. методы front/back.

Строковый поток создается с помощью типа stringstream. Это буфер данных с нуль-символом
в конце. Он позволяет связать поток ввода-вывода со строкой в памяти. Его удобно
использовать для форматирования сложных строк.

Общие методы коллекций:
* at - возвращает элемент по указанному индексу;
* assign - присваивает всем элементам заданное значение;
* empty - проверяет коллекцию на пустоту;
* size - возвращает кол-во элементов в коллеции;
* resize - изменяет размерность; если размерность больше изначальной, то метод, 
  подобно asign, заполняет новые элементы заданным значением;
* clear - удаляет все элементы;
* erase - удаляет элемент на указанной позиции;
* swap - обменивается элементами с другой коллекцией;
* insert - добавляет элемент на заданную позицию (копирует элемент в коллекцию);
* push_back - добавляет элемент в начало;
* pop_back - удаляет элемент с конца;
* emplace - добавляет элемент на заданную позицию (создает элемент внутри коллекции);
* emplace_back - добавляет элемент в конец;
* capacity - вместимость коллекции (см. Алгоритмы).

Некоторые коллекции, в зависимости от особенностей построения, могут иметь другие
методы, либо частитно не иметь того, что перечислено выше.

Алгоритмы (ф-ции из библиотеки <algorithm>):

* Переборы элементов: count, count_if, find, find_if, adjacent_find, for_each,
  mismatch, equal, search, copy, copy_backward, swap, iter_swap, swap_ranges, fill,
  fill_n, generate, generate_n, replace, replace_if, transform, remove, remove_if,
  remove_copy, remove_copy_if, unique, unique_copy, reverse, reverse_copy, rotate,
  rotate_copy, random_shuffle, partition, stable_partition.

* Сортировки: sort, stable_sort, partial_sort, partyal_sort_copy, nth_element,
  binary_search, lower_bound, upper_bound, equal_range, merge, inplace_merge, includes,
  set_union, set_intersection, set_difference, set_symmetric_difference, make_heap,
  push_heap, pop_heap, sort_heap, min, max, min_element, max_element, next_permutation,
  prev_permutation, lexographical_compare.

* Арифметические операции над элементами: Accumulate, inner_product, 
  partial_sum, adjacent_difference.

Многие из этих методов для выполнения используют пользовательские предикаты.
Но существует также и набор стандартных предикатов.

--------------------------------------

РАЗНОЕ

Чтобы установить локаль, нужно воспользоваться ф-цией setlocale, например так можно
установить кириллицу: setlocale(LC_ALL, "");

Числа с плавающей точкой можно сравнивать так: 
abs(x - y) > epsilon  -->  если результат больше epsilon, то числа не равны

При компиляции кода вручную, через команд. строку, часто нужно указывать флаг -static. 
Кроме того компилятору g++ нужно передавать все cpp-файлы, что не очень удобно.

Вместо того, чтобы вручную компилировать через g++, можно использовать утилиту make.
Она автоматически подтягивает все зависимости проекта с помощью конфигурационного файла
Makefile и выполняет на его основе компиляцию, что в разы проще.

Синтаксис инициализации, как в массивах, доступен многоим типам: int num = {5};

В С++ могут попадаться кастом. типы, например вместо string может быть my_string и т.п.
В С++ оператор switch может принимать только целочисленные значения!

Директива #include может подключать файл как в угловых скобках, так и в кавычках.
Разница лишь в том, что первый вариант приводит к поиску файла в стандарных каталогах, 
а второй вариант - к поиску в каталогах проекта.

Усли ф-ция возвращает указатель, значит тот 100% из динамической памяти и его нужно
очистить в итоге, т.к. в C++ нельзя возвращать из ф-ций стэковые указатели.

Ссылка на ссылку означает совсем другое. Так обозначается rValue reference, 
т.е. ссылка на значение, а не переменную, как принято обычно:  
...
int&  a = 2;  -->  так нельзя, можно const int& a = 23; но тогда "a" неизменяемая
int&& b = 5;  -->  так можно, и "b" в этом случае можно изменять

В С++ компилятор не контролирует выход за границы массива (как статического, так 
и динамического). Поэтому можно легко обратиться к несуществующему элементу и ошибки 
никакой не будет, а вместо этого будет получен доступ к какой-то чужой переменной.

Динамические библиотеки отличаются от статических тем, что при сборке проекта они не
попадают в исполняемый файл, а существуют сами по себе. В этом их преимущество, т.к. 
они могут заменяться на более новые версии, чего нельзя сделать со статическими.

Статические библиотеки всегда встраиваются в бинарник программы. 
Чтобы обновить статическую библиотеку нужно пересобрать заново весь проект.

Ключевое слово inline используется для оптимизации. Оно встраивает содержимое ф-ции в 
то место, где должен быть её вызов. Это позволяет сократить накладные расходы от вызова.
Inline можно использовать только для маленьких ф-ций, без условий, циклов или рекурсий.
В заголовочных файлах inline позволяет игнорировать правило двойного определения.

Библиотеки имееют такие расширения:
* .dll/.lib - динамическая/статическая библиотека для Windows
* .so/.a - динамическая/статическая библиотека для Linux

В C++ не принято разделять файлы на подпапки. Вместо этого используют фильтры.
Многие IDE вообще не поддерживают такой ф-ционал, как создание каталога. Это из-за
каких-то внутренних особенностей компиляции или сборки. Обычно для всех заголовочных
файлов используют одну папку - "include", а для файлов cpp - "src".

Никогда не нужно подключать пространство имен std (т.е. писать using namespace std).
Оно очень большое и содержит огромное кол-во разных классов/ф-ций. Это может вызвать
конфликты имен. К тому же оно постоянно расширяется, что может привести к ним позже.

