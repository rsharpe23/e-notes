ВВЕДЕНИЕ

Angular 20 требует Node.js 24 или ^22.12 или ^20.19, TypeScript от 5.8 до 5.9 
и Angular CLI 20. Возможно также потребуется обновить npm.

Установка Angular CLI: npm install -g @angular/cli

Узнать версию Angular CLI: ng version
Обновить Angular CLI: ng update
Справка Angular CLI: ng help

Создать приложение: ng new <project-name>
Запустить веб-сервер и приложение: ng serve
Скомпилировать приложение: ng build

Если команде ng serve передать флаг --open, то автоматически откроется браузер с приложением.
Если команде ng new педерать флаг --no-standalone, создастся приложение с модульной системой.

При использовании PowerShell в Windows стоит учесть, что по умолчанию там отключено
выполнение скриптов (а они нужны при работе с anglular cli). Чтобы включить выполнение
скриптов, нужно ввести такую команду:

 Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned

Чтобы развернуть сторонний проект, нужно просто взять готовый package.json со всеми 
необходимыми зависимостями и выполнить команду: npm install.

Минимальный набор конфигурационных файлов проекта на Angular: 
package.json, tsconfig.json, angular.json.

Файл package.json определяет зависимости проекта.
Файл tsconfig.json определяет конфигурации компилятора ts.
Файл angular.json определяет конфигурации проекта и CLI. 

Проект обычно состоит из главной html-страницы, bootstrap-файла и набора компонентов.
Каждый компонент может быть представлен либо одним файлом, где все состовляющие определены 
в одном месте, либо набором разделенных файлов: .ts, .html, .css и т.п.

Минимальный проект на Angular:

 Файл компонента src/my-component.ts

 import { Component } from "@angular/core";
 @Component({
   selector: 'my-app',
   standalone: true,
   template: `<h1>Добро пожаловать!</h1>`
 })
 export class MyComponent {}

 -----

 Boostrap-файл src/main.ts

 import { bootstrapApplication } from "@angular/platform-browser";
 import { MyComponent } from "./my-component";
 bootstrapApplication(MyComponent); 

 -----

 Главная страница src/index.html

 <!DOCTYPE html>
 <html>
   <head>
     <meta charset="utf-8" />
     <title>Angular Test</title>
   </head>
   <body>
     <my-app></my-app>
   </body>
 </html>

 -----

 Файл package.json

 { 
   "name": "helloapp",       
   "version": "1.0.0",        
   "scripts": {              
     "start": "ng serve",
     "build": "ng build"
   },
   "dependencies": {                   // Все модули установятся локально. 
     "@angular/common": "~20.0.0",     // Если некоторые из этих модулей установлены 
     "@angular/compiler": "~20.0.0",   // глобально, то они перекроются локальными.
     "@angular/core": "~20.0.0",
     "@angular/forms": "~20.0.0",
     "@angular/platform-browser": "~20.0.0",
     "@angular/router": "~20.0.0",
     "rxjs": "~7.4.0",
     "zone.js": "~0.15.1"    // библиотека полифилов
   },
   "devDependencies": {
     "@angular-devkit/build-angular": "~20.0.0",
     "@angular/cli": "~20.0.0",
     "@angular/compiler-cli": "~20.0.0",
     "typescript": "~5.8.0"
   }
 }

 -----
 
 Файл tsconfig.json

 {
   "compileOnSave": false,
   "compilerOptions": {
     "baseUrl": "./",
     "sourceMap": true,
     "declaration": false,
     "downlevelIteration": true,
     "experimentalDecorators": true,
     "module": "ES2022",
     "moduleResolution": "node",
     "target": "ES2022",
     "typeRoots": ["node_modules/@types"],
     "lib": ["ES2022", "dom"]
   },
   "files": ["src/main.ts"],
   "include": ["src/**/*.d.ts"]
 }

 -----

 Файл angular.json

 {
   "version": 1,      // версия конфигурации
   "projects": {      // настройки для проекта helloapp
     "helloapp": {
       "projectType": "application",  // тип проекта (application - это приложение, 
                                      // которое можно запускать в браузере)

       "root": "",          // папка файлов (пустое значение это корневая папка)
       "sourceRoot": "src", // папка src-файлов 

       "architect": {       // настройки для команд ng build и ng serve соответсвенно 
         "build": {

		   // Инструмент построения проекта; build-angular:browser использует webpack 
           // для сборки проекта, а build-angular:dev-server запускает сервер 
           // и развертывает на нем скомпилированое приложение
           "builder": "@angular-devkit/build-angular:browser",

		   "options": {     // параметры для команды build  

             "outputPath": "dist/helloapp",   // путь для скомпилированного приложения
             "index": "src/index.html",       // путь к главной странице приложения
             "main": "src/main.ts",           // путь к bootstrap-файлу
             "polyfills": ["zone.js"],        // путь к файлам полифилов   
             "tsConfig": "tsconfig.json",  

             "aot": true     // будет ли использоваться предварительная компиляция 
                             // перед выполнением (Ahead-Of-Time)
           }
         },
         "serve": {
           "builder": "@angular-devkit/build-angular:dev-server",
           "options": {

			 // Cсылка на конфигурацию команды build. Т.е. команда serve
             // использует ту же конфигурацию, что и команда build
             "buildTarget": "helloapp:build"
           }    
         }
       }
     }
   }
 }

По умолчанию, файлы компилируются в режиме production. Чтобы вручную настроить режим
компиляции (например для разработки), нужно задать подсекцию configurations для секции build
и указать необходимый флаг при вызове команды ng build.

 "build": {
   ...
   "configurations": {
     "production": {

       "optimization": true,     // будет ли использоваться оптимизация

       "outputHashing": "all",   // бедут ли в названиях генерируемых файлов 
								 // добавляться хеш-значения

       "sourceMap": false,       // будут ли генерироваься sourceMap-файлы

       "namedChunks": false,     // будут ли использ. имена файлов для
								 // именованных подгружаемых чанков

       "vendorChunk": false,     // будут ли создаваться для сторонних библиотек
                                 // отдельные файлы
                   
       "buildOptimizer": true    // подключает пакет @angular-devkit/build-optimizer
								 // при использовании aot
     },
     "development": {
       "optimization": false,
       "sourceMap": true
     }
   }  
 } 

 ng build --configuration development  // билд для разработки

Режим компиляции никак не влияет на процесс разработки, запускаемый командой ng serve.
Эта команда не будет применять никаких оптимизаций из "production".

-----------------

ОСНОВЫ ANGULAR

Компонент - это класс, помеченный декоратором @Component. Этот декоратор в качестве 
параметра принимает объект с конфигурацией компонента.

Конфигурация компонента состоит из множества свойст, например:
 * selector - задает селектор (тег) компонента в html;
 * standalone - указывает, будет ли компонент автономным;
 * imports - задает набор модулей, которые нужно импортировать в компонент; 
 * template - шаблон компонента (html-разметка с интерполяциями);
 * templateUrl - внешний файл с шаблоном (используется вместо template);
 * styles - задает стили для компонента;
 * styleUrls - задает внешние файлы со стилями;

Начиная с Angular 16, рекомендуется использовать автономные компоненты. Их особенность
в том, что они могут использоваться без модулей, сами по себе. Также они сами управляют
своими зависимости (раньше зависимостями управляли модули, а не компоненты).

Для загрузки корневого компонента используется ф-ция bootstrapApplication(), которая
вызывается в bootstrap-файле. Эта ф-ция возвращает промис Promise<ApplicationRef> из котор.
можно получить объект ApplicationRef, представляющий приложение Angular.

Стилизацию компонента можно реализовать как через свойство styles, так и через внешние 
файлы стилей. Стилизация компонента применяется только к его шаблону. Чтобы задать стили 
для тега компонента, используется селектор :host.

 Файл my-component.ts

 @Component({
   selector: 'my-app',
   standalone: true,
   templateUrl: './my-component.html',
   styleUrls: ['./my-conponent.css']
 })
 export class MyComponent { }

 -----

 Файл my-coponent.html

 <h1>Hello Angular</h1>
 <p>Приложение Angular состоит из компонентов</p>

 -----

 Файл my-component.css

 h1, h2 { color: navy; }
 p { font-size: 13px; }
 /* Обращение к <my-component> */
 :host {  
   font-family: Verdana;
   color: #555;
 }

С помощью механизма привязки, различные части шаблона могут быть привязаны к свойствам 
компонента. В Angular есть следующие формы привязки:

 * привязка элемента к свойству компонента: <h1>{{myTitle}}</h1>
 * привязка свойства элемента к свойству компонента: <p [textContent]="myText">
 * привязка html-атрибута к свойству компонента: <input type=text [attr.value]="myInput">

 * привязка css-класса к свойству компонента: <div [class.box]="isShown"></div>
   (если свойство isShow равно true, то к div добавится класс box)

 * привязка css-свойства к свойству компонента: <img [style.margin]="isShown ? '1rem': '0'"> 
   (css-свойство можно указывать как в camelCase так и в kebab-case)

 * привязка события к методу компонента: <button (click)="addItem($event)">Add</button>
   (информация о событии доступна через объект $event)

 * двусторонняя привязка элемента к свойству компонента (т.е. изменение элемента 
   затрагивает изменение свойства и наоборот): <input type=text [(ngModel)]="myInput">

Событие элемента может также привязываться через выр-е: on-event="method(arg1, argN)"
Двусторонняя привязка, как правило, используется с элементами ввода.

В Angular 18 появились новые конструкции @if/@else, @for, @switch для управления разметкой.
Раньше вместо них использовались структурные директивы ngIf, ngFor, ngngSwitch.

Конструкция @if/@else определяется так:

 @if (myProp == 1 || myProp == 2) {
   <h4>Какая-то разметка {{myTitle}}<h4>
 } @else if (myProp == 3) {
   <p>Какая-то разметка</p>
 } @else {
   <p>Какая-то разметка</p>
 }

Конструкция @switch определяется так:

 @switch (myProp) {
   @case ('hello') {
     <p>Какая-то разметка</p>	
   }
   @case ('world') {
	 <p>Какая-то разметка</p>
   }
   @default {
	 <p>Какая-то разметка</p>
   }
 }

Конструкция @for определяется так:

 @for (item of myItems; track item) {
   <li>{{item}}</li>
 }

При переборе коллекций нужно также использовать выр-е track <id>. Оно помечает каждый 
dom-элемент, который связан с элементом коллекции, уникальным идентификатором. 

Это необходимо для оптимизации, чтобы когда коллекция изменится, Angular мог определить 
какие именно элементы были изменены и перерисовать только их связанные dom-элементы, 
а не все целиком.

В примере выше, в качестве идентификатора используется сам item, но лучше задавать 
другое значение, например его id или index, т.к. название item может быть неуникальным.

Внутри цикла можно использовать ряд специальных значений:
 $index - индекс элемента в коллекции;
 $count - кол-во элементов коллекции;
 $first - является ли текущий элемент первым в коллекции;
 $last - является ли текущий элемент последним в коллекции;
 $even - является ли индекс текущего элемента четным;
 $odd - является ли индекс текущего элемента нечетным;

 @for (item of myItems; track $index) {
   <li>{{item}} {{$last ? "последний" : ""}}</li>
 } 

Чтобы один компонент мог использовать в своем шаблоне другой компонент, он должен также
импортировать его через свойство imports:

 import { MyToolbar } from './my-toolbar';

 @Component({
   selector: 'my-component',
   standalone: true,
   imports: [MyToolbar],
   template: `
     <h1>Заголовок</h1>
     <my-toolbar>
       <span>Привет {{text}}</span>
     </my-toolbar>
   `,
   styles: `span { color: red; }`
 })
 export class MyComponent {
   text = 'Мир';
 }

Встроенный элемент <ng-content> позволяет дочернему компоненту вывести разметку, 
заданную в родительком компоненте. Причем эта разметка будет стилизована теми стилями, 
что заданы в родитеском компоненте.

 @Component({
   selector: 'my-toolbar',
   standalone: true,
   template: `<p><ng-content></ng-content></p>`,  // выведет <p><span>Привет Мир</span></p>
   styles: `span { color: green; }`               // с красным текстом
 })
 export class MyToolbar { 
   text = 'Angular';
 }

Если требуется передать данные из родительского компонента в дочерний, то родительский
компонент должен привязать дочернее свойство к своему свойству. При этом дочернее свойство
должно быть помечено декоратором @Input. Привязывать можно и дочерние сеттеры.

 import { Component, Input } from '@angular/core';

 @Component({
   ...
   template: `<p>Возраст: {{userAge}}</p>`  // 24
 })
 class ChildComponent {
   @Input() userAge = 0;
 }

 @Component({
   ...
   imports: [ChildComponent],
   template: `<child-component [userAge]="age"></child-component>`
 })
 class ParentComponent {
   age = 24;
 }

Если требуется передать данные из дочернего компонента в родительский, то дочерний компонент
должен испустить событие, а родительский компонент подписаться на него (в шаблоне).
При этом эмитер события события должен быть помечен декоратором @Output.

 import { Component, EventEmitter, Output } from '@angular/core';

 @Component({
   ...
   template: `<button (click)="onClick(24)">Change</button>`,
 })
 class ChildComponent {
   @Output() onChange = new EventEmitter<number>();

   onClick(value) {
     this.onChange.emit(value);
   }
 }

 @Component({
   ...
   imports: [ChildComponent],
   template: `
     <child-component (onChange)="onChange($event)"></child-component>
     <p>Возраст: {{age}}</p>  // 24
   `,
 })
 class ParentComponent {
   age = 0;

   onChange(value) { 
     age = value; 
   }
 }

К качестве альтернативы, можно использовать двустороннюю привязку между 
родительским и дочерним свойством.

 @Component({
   ...
   template: `<button (click)="onClick(24)">Возраст</button>`
 })
 class ChildComponent {
   @Input() userAge = 0;
   
   onClick(value) {
     this.userAge = value;
   }
 }

 @Component({
   ...
   imports: [ChildComponent],
   template: `
     <child-component [(userAge)]="age"></child-component>
     <p>Возраст: {{age}}</p>  // 24
   `
 })
 export class ParentComponent {
   age = 0;
 }

Односторонняя привязка: [otherProp]=myProp (otherProp изменяется при изменении myProp).
Двусторонняя привязка: [(otherProp)]=myProp (тоже самое, но работает в обе стороны).

Жизненный цикл компонента состоит из множества разных методов, каждый из которых вызывается 
в определенный момент времени. Например сначала вызвается конструктор компонента. После,
вызывается метод ngOnChanges (при начальной установке свойств или изменении @Input свойств).
Затем, метод ngOnInit (вызывается один раз, после инициализации всех свойств, но до
инициализации шаблона). Метод ngOnDestroy вызывается перед тем, как фреймворк удалит
компонент и т.д. Подробнее здесь https://metanit.com/web/angular2/2.8.php

Большая часть подобных методов определена в отдельных интерфейсах, которые имеют 
одноименные названия, но без префикса "ng".

 import { Component, OnInit, OnDestroy } from '@angular/core';

 @Component({ ... });
 class MyComponent implements OnInit, OnDestroy {
   constructor() { }  // здесь обычно инициализируются свойства
   ngOnInit() { }     // здесь выполняются какие-то подготовительные действия
   ngOnDestroy() { }  // здесь освобождаются ресурсы, удалятся подписки на события и пр.
 }

Внутри шаблона можно также объявлять переменные. Обычно такие переменные ссылаются на 
какой-то dom-элемент или компонент. Но их область видимости ограничеватся только шаблоном.

 template: `
   <span #mySpan>{{text}}</span>  // вместо span мог бы быть и компонент
   <p>{{mySpan.textContent}}</p>
 `

Чтобы к шаблонной переменной можно было обращаться из кода, нужно привязать ее 
к свойству компонента с помощью декоратора @ViewChild.
 
 @ViewChild('mySpan', { static: false })
 myProp: ElementRef | undefined;

 someMethod() {
   console.log(this.myProp);  // span
 }

Первым параметром @ViewChild может быть не только имя шаблонной переменной, 
но и селектор элемента и даже дочерний компонент (в этом случае селектор будет взят 
из его декоратора @Component)

Если дочерний компонент, посредством <ng-content>, получает разметку из родительского
копмопнента, у которой есть шаблонная переменная, то он также может привязать ее к своему
свойству через декоратор @ContentChild.

 @Component({
   ...
   template: `
     <child-component>
       <h2 #headerContent>Добро пожаловать!</h2>
     </child-component>
   `
 })
 class ParentComponent { }

 @Component({
   ...
   template: `<p><ng-content></ng-content></p>`  
 })
 class ChildComponent {
   @ContentChild('headerContent', { static: false })
   myProp: ElementRef | undefined;
 }

-----------------

ДИРЕКТИВЫ

Это классы с директивными метаданными (т.е. помеченные декоратором @Derective).
Они определяют инструкции, которые используются при рендеринге html.

В Angular есть 3 типа директив:

 * Компоненты - это теже директивы, т.к. декоратор @Component расширяет @Derective 
   и добавляет ф-ционал по работе с шаблонами;

 * Атрибутивные - изменяют элементы, к которым применяются.
   Например: ngModel, ngStyle, ngClass и т.п.

 * Структурные - изменяют dom путем добавления, изменения, удаления 
   каких-то html-вставок. Например: ngFor, ngIf и т.п.

Директива ngClass задает набор css-классов для элемента через привязку объекта.
Ключи объекта - это названия классов, а значения - true/false.

 import { NgClass } from '@angular/common';
 
 @Component({
   ...
   imports: [NgClass],
   template: `
     div [ngClass]="{ verdanaFont: true, redColor: isRed }">
       <p [ngClass]="contentClasses">Hello world</p>
     </div>
   `,
   styles: `
     .verdanaFont { font-size: 13px; font-family: Verdana; }
     .redColor { color: red; }
     .bgLight { color: black; background: white; }
     .bgDark { color: white; background: black; }
   `
  })
  class MyComponent {
    isRed: false;
    contentClasses = { bgLight: true, bgDark: false };
  }

Директива ngStyle задает набор css-стилей, точно также через привязку объекта.
Ключи объекта - это названия css-свойств, а значения - собственно значения этих свойств.

 <div [ngStyle]="{ 'font-size': '14px', 'font-family': 'Verdana' }"></div>

Альтернативный вариант: [class.cssClass]="true/false" и [style.cssProp]="cssPropValue"

 <div [class.visibility]="isVisible"></div>
 <div [style.display]="isVisible ? 'block' : 'none'"></div>

Создание атрибутивной директивы:

 import { Directive, ElementRef, Renderer2 } from '@angular/core';

 @Directive({
   selector: '[myDir]'  // селектор атрибута, с кот. ассоциируется директива
   standalone: true,
   host: {                         // через host можно подписаться на события элемента;
     '(mouseenter)': 'onEnter()',  // onEnter() вызовется, когда пользователь наведет мышь
   }                               // на элемент, помеченный атрибутом myDir
 })                                
 class MyDirective {
   constructor(private elemRef: ElementRef, private renderer: Renderer2) {

     // Установка стиля для элемента с атрибутом myDir
     this.renderer.setStyle(this.elementRef.nativeElement, 'font-weight', 'bold');

     // Альтернативный вариант, без использ. renderer
     // this.elemRef.nativeElement.style.fontWeight = 'bold';
   }

   onEnter() { }

   // Вместо host можно сразу пометить метод @HostListener
   @HostListener('mouseleave') onLeave() { } 

   // Через @HostBinding можно связать css-свойство элемента со значением геттера
   @HostBinding('style.fontWeight')
   get fontWeight() { return 'normal'; }
 }

 @Component({
   ...
   standalone: true,
   imports: [MyDirective],
   template: `<p myDir>Hello World</p>`  // атрибут myDir сделает шрифт жирным
 })
 class MyComponent { }
 
Директиве можно также задавать параметры. Делается это след. способами:
 
 <div myDir hoverSize="16px" ></div>  // первый способ

 // Если параметр задается через квадратные скобки, то его значение 
 // нужно дополнительно заключать в одинарные кавычки:
 <div myDir [hoverSize]="'16px'"></div>

Чтобы обратиться к параметрам из класса, нужно создать одноименные свойства, 
помеченные декоратором @Input.

 @Directive({ ... })
 class MyDirective {
   @Input hoverSize = '';
 }

Если в @Input передать селектор директивы, то параметр можно задать еще проще:
 @Input('bold') hoverSize = '';  -->  <div [myDir]="'16px'"></div>

Создание структурной директивы:

 import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

 @Directive({ selector: '[myIf]', standalone: true })
 class IfDirective {
   constructor(
     private templ: TemplateRef<any>,       // объект для доступа к шаблону
     private viewCntrRef: ViewContainerRef  // объект рендерера
   ) { }

   // С пом. входного сеттера получаем из шаблона значение condition
   @Input set myIf(condition: boolean) {
     if (condition) {
       this.viewCntrRef.createEmbeddedView(this.templ);
     } else {
       this.viewCntrRef.clear();
     }
   }
 }

 @Component({
   ...
   standalone: true,
   imports: [IfDirective]
   template: `
     <p *myIf="condition">Hello</p>   // структурная директива задается через звездочку
     <p *myIf="!condition">World</p>
   `
 })
 class MyComponent {
   condition = true;
 }

-----------------

СЕРВИСЫ

Это классы с дополнительной логикой, к которой не относится логика отображения. 
Например логгирование, работа с данными, работа с api и т.п.

Пример реализации компонента с сервисом:

 class DataService {
   private data: string[] = ['Tom', 'Bob', 'Sam'];   
   getData(): string[] { return this.data; }
 }

 @Component({
   ...
   providers: [DataService],  // чтобы внедрить сервис в компонент (с пом. DI),
   template: `                // нужно добавить его в providers.
     <ul>
       @for (item of items; track $index) {
         <li>{{item}}</li>
       }
     </ul>
   `
 })
 class MyComponent {
   items: string[] = [];
   constructor(private dataService: DataService) { }
 
   ngOnInit() {
     this.items = this.dataService.getData();
   }
 } 

Если один сервис использут внутри себя другой сервис, то его класс должен быть помечен
декоратором @Injectable. Но разраработчики Angular рекомендуют помечать @Injectable 
любой класс сервиса.

 @Injectable
 class LogService {
   write(msg: string) { console.log(msg) }
 }

 @Injectable
 class DataService {
   ...
   constructor(private logService: LogService) { }

   getData(): string[] {
     this.logService.write('hello!');
     return this.data;
   }
 }

Если компонент использует сервис, который зависит от другого сервиса, то он обязан в своем
providers указать оба сервиса, даже если не использует второй напрямую.

 @Component({
   ...
   providers: [DataService, LogService]
 })
 class MyComponent {
   ...
   constructor(private dataService: DataService) { }
 }

Зависимый сервис можно сделать опциональным, пометив его декоратором @Optional(). В этом
случае, если не указать его в providers, он будет просто недоступен, но ошибки не будет.

 constructor(@Optional() private logService: LogService) { }

При внедрении сервиса в разные компоненты, каждый компонент будет получать отдельный
экземпляр сервиса. Но если требуется, чтобы все компоненты работали с одним экземпляром
сервиса, то его можно внедрить в какой-то родительский компонент. При этом компоненты 
теперь не должны содержать общие сервисы в своих providers.

 @Component({
   selector: 'my-component',
   standalone: true,
 }) 
 class MyComponent {
   constructor(private dataService: DataService) { }
 }

 @Component({
   selector: 'other-component',
   standalone: true,
 }) 
 class OtherComponent {
   constructor(private dataService: DataService) { }
 }

 @Component({
   selector: 'app-component'
   standalone: true,
   providers: [DataService, LogService]
   template: `
     <my-component></my-component>        // каждый из компонентов получит
     <my-component></my-component>        // один и тот же экземпляр DataService 
     <other-component></other-component>
   `
 })
 class AppComponent { }

В качестве альтернативы, общие сервисы можно задавать в bootstrapApplication()

 bootstrapApplication(AppComponent, { 
   providers: [DataService, LogService] 
 });

-----------------
 
РАБОТА С ФОРМАМИ

Для работы с формами используется модуль FormsModule, который необходимо указать 
в коллекции imports компонента. Но чтобы этот модуль был доступен, нужно также добавить
зависимость "angular/forms" в package.json.

 "dependencies:" {
   ...
   "@angular/forms": "~20.0.0"
 }

Чтобы привязать свойство компонента к элементу ввода используется директива ngModel. 
Эта директива создает объект FormControl, через который идет отслеживание значения модели,
(т.е. привязанного свойства) и добавление к элементу ввода css-классов состояния.

 import { FormsModule } from '@angular/forms';

 @Component({
   ...
   imports: [FormsModule]
   template: `
     <input name="title" [ngModel]="title">  // односторонняя привязка title к input.value
     <input name="text" [(ngModel)]=text>    // двусторонняя привязка text к input.value
     <input name="age" [(ngModel)]="user.age">  // привязка вложенного свойства
   `
 })
 class MyComponent {
   title = '';
   text = '';
   user = new User();
 }

Существует также директива ngModelChange, к котороый привязывается обработчик события. 
С пом. этой директивы можно удобно обрабатывать ввод каждого нового символа. 

 // Обычное событие change срабаывает только когда input теряет фокус.
 <input name="text" [(ngModel)]="title" (ngModelChange)=onChange>

Получить доступ к ngModel можно через шаблонную переменную:
 <input [(ngModel)]="title" #myModel="ngModel"> 

Директива ngModel добавляет к элементу ввода след. css-классы состояния:
 * ng-untouched - элемент ввода еще не получал фокус;
 * ng-touched - элемент ввода уже получал фокус;
 * ng-dirty - первоначальное значение элемента ввода было изменено;
 * ng-pristine - первоначальное значение не изменялось (с момента загрузки страницы);
 * ng-valid - значение элемента ввода корректно;
 * ng-invalid - значение элемента ввода некорректно;

К этим состояниям можно также обратиться напрямую из модели:

 // Вместо pattern="..." можно указать директиву email
 <input name="email" [(ngModel)]="myEmail" #eModel="ngModel" required 
        pattern="^[a-zA-Z0-9.!#$%&’*+/=?^_{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$">

 <div class="alert" [hidden]="eModel.valid || eModel.untouched">Некорректный email</div>

Чтобы отслеживать состояние всей формы, можно использовать директиву ngForm, которая не
задается явно для элемента form (Angular сам это делает), но при этом требует явного импорта
модуля NgForm из "angular/forms". Эта директива создает объект FormGroup, который хранит
состояния формы, а также ссылки на элементы ввода, помеченные ngModel: 

 import { FormsModule, NgForm } from '@angular/forms';

 @Component({
   ...
   imports: [FormsModule],
   template: `

     // Атрибут novalidate отключает встроенную валидацию браузера
     // Через шаблонную переменную можно обратиться к ngForm
     // Событие ngSubmit возникает при нажатии на input[type=submit]

     <form #myForm="ngForm" novalidate (ngSubmit)="onSubmit(myForm)">  
       <input name="email" ngModel required email>
       <input name="phone" ngModel required pattern="[0-9]{10}">
       <input type="submit" [disabled]="myForm.invalid" value="Отправить">
     </form>
   `
 })
 class MyComponent {
   ...
   onSubmit(form: NgForm) {
     form.controls      // ссылки на элементы ввода, помеченные ngModel
     form.value.email   // значение input[name=email]
   }
 }

Вместо использования ngModel и ngForm можно также применять подход реактивных форм. 
Он заключается в том, что объекты FormGroup и FormControl создаются самостоятельно из кода, 
а затем привязываются к dom-элементам через директивы formGroup и formControlName.

 import { FormsModule, FormGroup, FormControl, Validators, 
          ReactiveFormsModule } from '@angular/forms';

 @Component({
   ...
   imports: [FormsModule, ReactiveFormsModule]  // использ. FormGroup, FormControl и т.п
   template: `                                  // требует модуля ReactiveFormsModule
     <form [formGroup]="myForm" novalidate>
       <input name="email" formControlName="myEmail">  // элемент ввода будет привязан
                                                       // к myEmail из FormGroup

       @if (myForm.controls['myEmail'].invalid && myForm.controls['myEmail'].touched) {
         <div class="alert">Некорректный email</div>
       }
     </form>
   `
 })
 class MyComponent {
   myForm = new FormGroup({
     'myEmail': new FormControl('', [Validators.required, Validators.email]),
     'myPhone': new FormControl('+1', Validators.pattern('[0-9]{11}')), 
   });
 }

Первый параметр FormControl - это значение по умолчанию для элемента ввода, 
а второй параметр - это набор валидаторов.

Валидатор в данном случае - это ф-ция, которая принимает элемент ввода и возвращает 
объект, где ключ - строка, а значение boolean. 

 function myValidator(control: FormControl): { [key:string]: boolean } | null {
	if (control.value === 'world') {
      return { 'myInput': true };  // true означает, что элемент ввода
    }                              // не прошел валидацию
    return null;
 }

 new FormGroup({ 'myInput': new FormControl('hello', myValidator) });

Если элементы ввода создаются динамически, то для них нужно использовать массив FormArray,
который постепенно будет наполняться объектами FormControl. FormArray привязывается к общему
контейнеру всех элементов через директиву formArrayName. А каждый элемент в качестве
названиия для formControlName теперь использует свой индекс.

 import { ..., FormArray } from '@angular/forms';

 @Component({
   ...
   template: `
     <form [formGroup]="myForm" novalidate>
       <div formArrayName="myPhones">
         @for (phone of getPhones(); track $index) {
           <input formControlName="{{$index}}">
         }
       </div>
       <button (click)="addPhone()">Добавить телефон</button>
     </form>
   `
 })
 class MyComponent {
   myForm = new FormGroup({ 
     'myPhones': new FormArray()
   });

   getPhones() {
     return <FormArray>this.myForm.controls['phones'];
   }
 
   addPhone() {
     getPhones().push(new FormControl('+1', Validators.required));
   }

 }

Для упрощенного создания реактивных форм можно также использовать сервис FormBuilder.
Его метод group() создает объект FormGroup, а каждый FormControl задается в виде массива.
 
 @Component({ ... });
 class MyComponent {
   myForm: FormGroup;

   constructor(formBuilder: FormBuilder) {
     this.myForm = formBuilder.group({
       myEmail: ['', [Validators.required, Validators.email]],
       myPhone: formBuilder.array([])
     });
   }   
 }

-----------------

РАБОТА С HTTP

Для этого в Angular используется сервис HttpClient, который под капотом использует RxJS.
Поэтому перед началом работы нужно указать их в package.json.

 dependencies: {
   "@angular/common": "~20.0.0",  // для HttpClient
   "rxjs": "~7.8.1"
 }

Сервис HttpClient обычно задается глобально, для всего приложения, в bootstrapApplication().
После чего он может внедряться во все компоненты, и все @Injectable-сервисы.

 import { provideHttpClient } from '@angular/common/http';

 bootstrapApplication(MyComponent, { 
   providers: [provideHttpClient()] 
 });

 iterface User {
   name: string;
   age: number;
 }

 class UserService {
   constructor(private http: HttpClient) { }

   getData() {
     // { "userList": [{"name": "Bob", "age": "25"}, {"name": "Tom", "age": "32"}] }
     const data = this.http.get('src/assets/data.json');
     return data['userList'];
   }
 } 

 @Component({
   ...
   providers: [UserService]
   template: `
     <ul>
       @for (user of users; track $index) {
         <li>Имя: {{user.name}} Возраст: {{user.age}}</li>
       }
     </ul>	
   `,
 })
 class MyComponent implements OnInit {
   ngOnInit() {
     users: User[] = [];

     this.userService.getData()
       .subscribe({ next: data => this.users = data; })
   }
 }

Библиотека RxJS реализует паттерн "асинхронный наблюдатель". С ее помощью можно удобно
обрабатывать потоки данных в декларативном стиле. Например так:

 getData() {
   // { "userList": [{"n": "Bob", "a": "25"}, {"n": "Tom", "a": "32"}] }
   return this.http.get('src/assets/data.json')
     .pipe( map(data => {
       const users = data['userList'];
       return users.map( user => ({ name: n, age: a }) );
     }) );
 }

Все методы HttpClient после выполнения запроса возвращают объект Observable из RxJS.
К которому можно всегда подцепить доп. обработки через pipe().

Для обработки http-ошибок в ф-цию pipe() вторым аргументом можно передать вызов ф-ции
catchError(). Эта ф-ция принимает колбек, в котором можно обработать ошибку. При этом колбек
должен также вернуть объект Observable, но вместо него можно указать пустой массив.

 getData(): Observable<User[]> {
   return this.http.get('...').pipe( 
     map(data => ...),                // map - это т.н. оператор из RxJS
     catchError(err => {
       console.log(err.message, err.status);

       return [];  // будет создан Observable<User[]> с пустым массивом 
     })            // и этот пустой массив будет передан в subscribe({ error })
   );
 }

Для определения параметров запроса, можно использовать объект HttpParams.

 const params = new HttpParams().set('a', '1').set('b', 'hello');
 this.http.get('http://localhost:3000/user', { params });

Кроме GET-запросов, можно отправлять и другие запросы: POST, PUT, DELETE.
А также устанавливать различные заголовки при отправке.

 const headers = new HttpHeaders().set('Accept', 'application/json');
 const body = { name: 'Bob', age: 25 };
 this.http.post('http://localhost:300/user', body, { headers });

-----------------

МАРШРУТИЗАЦИЯ

Для работы с маршрутизацией используется модуль RouterModule. Чтобы этот модуль был 
доступен, нужно добавить зависимость "@angular/router" в package.json. 

 "dependencies:" {
   ...
   "@angular/router": "~20.0.0"
 }

Сами маршруты и их обработка задаются так:

 import { provideRouter, Routes, RouterOutlet } from '@angular/router';
 
 // Также понадобиться указать тег <base> в главном html-файле, 
 // для установки базового пути всем маршрутам

 const routes: Routes = [                         // коллекция маршрутов, где каждый маршрут
   { path: '', component: HomeComponent },        // сопоставляется какому-то компоненту;
   { path: 'about', component: AboutComponent },  // '**' - это любой путь
   { path: '**', component: NotFoundComponent },
 ];

 @Component({ 
   ...
   imports: [RouterOutlet],
   template: `
     <h1>Angular App</h1>
     <router-outlet></router-outlet>  // вместо <router-outlet> будет рендериться 
   `                                  // компонент, выбранный для обработки маршрута
 })
 class AppComponent { }

 bootstrapApplication(AppComponent, {
   providers: [provideRouter(routes)]  // маршруты устанавливаются через сервис Router,
 });                                   // который строится методом provideRouter() 

В примере выше, AppComponent выступает в качестве контейнера для маршрутных компонентов.
Но чтобы внедрить в него тот компонент, который обрабатывает маршрут, необходимо 
использовать RouterOutlet.

При определении маршрутов нужно учитывать их порядок. Более общие маршруты нужно опредять
после более конкретных. Иначе конкретные маршруты никогда не обработаются.

 const routes: Routes = [                         // в таком порядке, маршрут 'about' бедет
   { path: '**', component: NotFoundComponent },  // всегда обрабатываться маршрутом'**', 
   { path: 'about', component: AboutComponent },  // т.к. '**' подходит для любых маршрутов  
 ];

Маршруту можно задать критерий соответсвия (pathMatch) и переадресацию (redirectTo).

 { path: 'about', pathMatch: 'full' },  // full указывает на полное соответствие указанному
 { path: '**', redirectTo: '/' },       // маршруту (т.е. только /about, но не /about/1)

Для создания маршрутных ссылок используется директива routerLink, которая задается 
элементам <a>. Этой директиве передается путь маршрута. Для стилизации активных ссылок
используется директива routerLinkActive, которой передается css-класс активации.

 import { RouterLink, RouterLinkActive } from '@angular/router';

 @Component({
   imports: [RouterLink, RouterLinkActive],
   styles: `.active { color: red }`,
   template: `
     <nav>
       <a routerLink="" routerLinkActive="active">Главная</a>
       // Если в адресе есть "/home", то у элемента появится класс "active"
       <a routerLink="/home" routerLinkActive="active">О сайте</a> 
     </nav>
   `
 })

Стоит учитывать, что по умолчанию маршрутные ссылки обрабатываются неполным соответствием,
Это означает, что под routerLink="" будет подпадать любой адрес, в т.ч. и "/home".
Посему, при клике на вторую ссылку, первая также станет активной.

Чтобы это исправить, ссылке с routerLink="" нужно задать дополнительную директиву
routerLinkActiveOptions и передать ей "exact:true". Теперь для установки активной ссылки
будет применятся полное соотвествие.
 
 <a routerLink="" routerLinkActive="active" 
   [routerLinkActiveOptions]="{exact:true}">Главная</a>

Чтобы определить маршрут с параметром, нужно к названию пути добавить токен, через двоеточие.
А для обращения к параметру из кода - использовать сервис ActivatedRoute.

 { path: 'user/:id', component: UserComponent },
 
 // Свойство snapshot хранит состояние маршрута,
 // а то, в свою очередь, содержит переданные параметры

 constructor(private route: ActivatedRoute) {
   this.id = route.snapshot.params['id']; 
 }  

Чтобы задать параметр в маршрутной ссылке, нужно указать его значение через слэш:
 <a routerLink="user/5">Tom Soer</a>

Если есть несколько ссылок с одинаковым маршрутом, но разными параметрами, то при переходе 
на любую из них, связанный компонент будет получать только параметр из первой ссыки. 

 <a routerLink="user/5">Tom Soer</a>
 <a routerLink="user/7">Jonh Doe</a>  // при клике, компонент получит 5

Чтобы решить эту проблему, нужно в коде подписаться на изменение параметра маршрута.
В этом случае компонет будет получать всегда новое значение.

 constructor(private route: ActivatedRoute) {
   route.params.subscribe(params => this.id = params['id']);
 }

Параметры запроса (query params) не влияют на определения маршрутов. Задаются они с помощью
директивы queryParams, а получить их можно, подписавшись на измениние queryParams.

 <a routerLink="user/5" [queryParams]="{'product': 'phone', 'price': 80}">Tom Soer</a>

 constructor(private route: ActivatedRoute) {
   route.queryParams.subscribe(params => this.product = params['product']);
 }

Вместо навигации через маршрутные ссылки можно также использовать програмную навигацию.
Для этого используется метод navigate(), сервиса Router. Его первый параметр - это массив 
с маршрутными данными (первый элемент - путь, а все последующие - параметры маршрута).
Второй параметр - это объект, где устанавливается queryParams.

 constructor(private router: Router) { }

 goHome() { 
   this.router.navigete(['']); 
 }

 goToUser(user: User) {
   this.router.navigate(['/user', this.id], { 
     queryParams: { 
       'product': this.product 
     } 
   });
 }

Дочерние маршруты реализуются с помощью свойства children, объекта Route. Но компонент
родительский маршрута, в этом случае, должен также вызывать <router-outlet>.

 сonst routes: Routes = [
   { 
     path: 'item',
     component: ItemComponent,
     children: [
       { path: 'details', component: ItemDetailsComponent },
       { path: 'stat', component: ItemStatComponent },
     ] 
   }
 ];

 @Component({
   ...
   imports: [RouterOutlet]
   template: `
     <h2>Мой товар</h2>
     <router-outlet></router-outlet>
   `
 })
 class ItemComponent { }

Чтобы ограничить навигацию по определенным маршрутам, нужно использовать guard-функции.
Эти ф-ции задаются в свойствах canActive и/или canDeactive, объекта Route 
(при определении маршрутизации), как элементы массива.

Guard-функции напоминают middleware. canActive проверяет возможность перехода на определенный
компонент, а canDeactive проверяет возможность ухода с определенного компонента. 

 // Guard-функции могут принимать различные параметры, 
 // но всегда возвращают boolean

 const adminGuard = () => {
   const authService = inject(AuthService);
   return authService.isLoggedIn;
 };

 const userGuard = (component: UserComponent) => {
   if (!component.isDataSaved) {
     return confirm('Вы хотите покинуть страницу?')
   }
   return true;
 };

 const routes: Routes = [
   { path: '', component: HomeComponent },
   { path: 'admin', component: AdminComponent, canActive: [adminGuard] },
   { path: 'user', component: UserComponent, canDeactive: [userGuard] },
 ];

-----------------

РАБОТА С PIPES

Это инструменты для форматирования выводимых данных в шаблоне, которые задаются через
вертикальный слэш и могут объединяться в цепочку. 

 <div>{{myDate}}</div>         // Wed Apr 12 1961 00:00:00 GMT+0300 (без pipe)
 <div>{{myDate | date}}</div>  // Apr 12, 1961

Встроенные классы Pipes (задают одноименные директивы, но без суффикса Pipe):
 * CurrencyPipe - форматирует валюту;
 * PercentPipe - форматирует проценты;
 * UpperCasePipe - переводить строку в верхний регистр;
 * LowerCasePipe - переводить строку в нижний регистр;
 * DatePipe - форматирует дату;
 * DecimalPipe - задает формат числа;
 * SlicePipe - обрезает строку;

 <div>{{myDate | date | uppercase}}</div>  // APR 12, 1961

В Pipes можно передавать аргументы через двоеточия:

 <div>{{myText | slice:6:11}}</div>         // обрезать строку с 6, по 11 индекс
 <div>{{myDate | date:"dd/MM/yyyy"}}</div>  // задать собственный шаблон даты

 // Здесь шаблон задается так "minIntegerDigits.minFractionDigits-maxFractionDigits"
 // minIntegerDigits - минимальное количество цифр в целой части;
 // minFractionDigits - минимальное количество цифр в дробной части;
 // maxFractionDigits - максимальное количество цифр в дробной части;

 <div>{{PI | number:"3.5-5"}}</div>  // 003.14150 (DecimalPipe)

Чтобы создать собственный Pipe, нужно пометить класс декоратором @Pipe и реализовать
интерфейс PipeTransform, содержащий один метод transform() для обработки входных значений.

Первый параметр transform() - значение любого типа, к которому применяется Pipe, а все
последующие, необязательные параметры - передаваемые аргументы из шаблона.

 // Pipe определятеся как автономный, чтобы его можно было 
 // импортировать в другие автономные компоненты

 @Pipe({ name: 'format', standalone: true })  
 class FormatPipe implements PipeTransform {

   transform(value: number, args?: any): string {
     return value.toString().replace('.', ',');    // здесь обрабатывается дробное число,  
   }                                               // чтобы вместо точки была запятая
 }

 @Component({
   ...
   imports: [FormatPipe],
   template: `<p>До {{x}} после {{x}}</p>`  // До 15.45 после 15,45
 })
 class MyComponent { ... }

При создании Pipe, по умолчанию он станет pure. Это значит, что он будет реагировать только
на изменение значений примитивных типов и изменение ссылок у ссылочных типов. 

Но если требуется, чтобы Pipe реагировал и на изменение значений ссылочных типов (например
при добавлении новых элементов в массивы), то он должен быть impure. Для этого, нужно 
в его декораторе установить pure: false. Но у ImpurePipe хуже производительность.

 @Pipe({ name: 'join', standalone: true, pure: false })
 class JoinPipe implements PipeTransform {
   transform(arr: string[], start?: number | undefined): string {
     let res = arr;
     if (start) {
       res = arr.slice(start, arr.length);
     }
     return res.join('-');
   }
 }

 @Component({
   ...
   imports: [JoinPipe],
   template: `
     <button (click)="users.push('Nick')">Добавить</button>
     <p>{{users | join:2}}</p>
   `
 })
 class MyComponent {
   // Любое изменение массива заставит join обрабатывать его заново.
   users = ['Tom', 'Alice', 'Sam', 'Kate', 'Bob'];
 }

Для удобного вывода данных, полученных по сети (или другим асинхронным способом), использ.
AsyncPipe. Он автоматически отслеживает объекты Promise и Observable и возвращает 
полученные из них значения. AsyncPipe по умолчанию impure.

 import { AsyncPipe } from '@angular/common';
 import { Observable } from 'rxjs';

 @Component({
   ...
   imports: [AsyncPipe],
   template: `
     <ul>
       @for (user of users | async; track $index) {  // async применяется к users
         <li>{{user.name}} - {{user.age}}</li>
       }
     </ul>
   `
 })
 class MyComponent implements OnInit {
   users: Observable<Object> | undefined;
   constructor(private http: HttpClient) { }
   ngOnInit() { this.users = this.http.get('users.json'); }
 }
 
-----------------

РАЗНОЕ

Элемент ng-template определяет встраиваемый шаблон, который сам не является частью DOM
(подобно стандартному <template>), но который можно внедрить куда-то.

Внедрить ng-template можно с помощью директивы ngTemplateOutlet. Обычно ng-template
встраивается в элемент ng-container, который используется для группировки элементов,
но без добавления дополнительного уровня DOM (как фрагмент).

 import { NgTemplateOutlet } from '@angular/common'; 

 @Component({
   ...
   imports: [NgTemplateOutlet],
   template: `
     <div>
       <h1>Заголовок</h1>
       <ng-container [ngTemplateOutlet]="templ1"><ng-container>
     </div>

     <ng-template #templ1>
       <p>Текст из первого шаблона</p>
     </ng-template>

     <ng-template #templ2>
       <p>Текст из второго шаблона</p>
     </ng-template>
   `
 })
 class MyComponent {
   isFirstTempl = true;
 }

С помощью директивы ngTemplateOutletContext можно передать аргументы для ng-template.
Эта директива задается у контейнера и принимает контекстный объект, в котором и определяются
передаваемые аргументы. Сам ng-template принимает параметры через директивы let-param1, 
let-param2 и т.д. Значения let-директив - это названия ключей из контекстного объекта.

 <ng-container 
   [ngTemplateOutlet]="isFirstTempl ? templ1 : templ2" 
   [ngTemplateOutletContext]={ $implicit: 23, myArg: 'Иван'}>
 <ng-container>

 // Если для let-параметра не задан ключ из контекстного объекта,
 // то он примет значение по умолчанию $implicit 

 <ng-template #templ1 let-age let-username="myArg">  
   <p>Имя: {{username}}</p>
   <p>Возраст: {{age}}</p>
 </ng-template>

С помощью декоратора @ViewChild можно получить встраиваемый шаблон в коде компонента.

 class MyComponent {
   // Если встраиваемый шаблон один, то к нему можно обратиться напрямую
   @ViewChild(TemplateRef) templ: TemplateRef<any> | undefined;

   // Если встраиваемых шаблонов несколько, то нужно указывать их названия
   @ViewChild('templ1', { static: false }) templ1: TemplateRef<any> | undefined;
   @ViewChild('templ2', { static: false }) templ2: TemplateRef<any> | undefined;
 }

Структурные директивы ngIf, ngFor, ngSwitch применяются к элементам, 
чтобы как-то ими манипулировать в DOM-дереве.

Директива ngIf принимает логическое выражение и в зависимости от его значения, 
отображает или скрывает элемент и его содержимое:  

 <p *ngIf="isLoggedIn">Добро пожаловать!</p>

Директива ngFor принимает выражение, в котором итерируется какая-то коллекция, и для каждого
item'а коллекции создает экземпляр элемента, к которому применяется данная директива:

 <ul>
   <li *ngFor="let item of myArr; trackBy item.id">{{item.name}}</li>
 </ul>

Директива ngSwitch принимает некоротое значение и на его основе выполняет ветвление 
с помощью доп. директив ngSwitchCase и ngSwitchDefault:

 <div [ngSwitch]="myRole">
  <p *ngSwitchCase="'admin'">Администратор</p>
  <p *ngSwitchCase="'editor'">Редактор</p>
  <p *ngSwitchDefault>Обычный пользователь</p>
 </div>

Символ звездочки рядом со структурной директивой - это синтаксический сахар, с помощью
которого элемент директивы оборачивается в ng-template, а сама директива 
заключается в квадратные скобки, но уже в ng-template.

 <div *ngIf="hero">{{hero.name}}</div>  -->  

   <ng-template [ngIf]="hero"><div>{{hero.name}}</div><ng-template>  

 -----

 <div *nfFor="let here of heroes; let i=index;">{{hero.name}}<div>  -->

   <ng-template ngFor let-hero [ngForOf]="heroes" let-i="index">
     <div>{{hero.name}}</div>
   <ng-template>
 
Раньше Angular использовал модульную систему. Модуль - это класс, помеченный декоратором
@NgModule. Модуль служит для объединения нескольких компонентов одной группы или домена
(например для dashboard), предоставляет зависимости для своих компонентов и т.п. 

Декоратор @NgModule имеет такие свойства:

 * declarations - здесь указываются классы представлений  
  (компоненты, директивы, каналы (pipes)), принадлежащие модулю;

 * imports - здесь указываются импортируемые модули;

 * exports - здесь указываются экспортируемые классы представлений 
  (которые будут использоваться в других модулях);

 * providers - сервисы, использумые классами модуля;
 * bootstrap - корневой компонент приложения;

Пример приложения с использованием модульной системы:

 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 import { BrowserModule } from '@angular/platform-browser';
 import { FormsModule } from '@angular/forms';

 @Component({
   selector: 'my-component',
   template: `
     <div>
       <h2>Компонент использующий модуль формы</h2>
       <input name="text" [(ngModel)]=prop>
     </div>
   `
 })
 class MyComponent { 
   prop = ''; 
 }

 @NgModule({
   declarations: [MyComponent],
   imports: [BrowserModule, FormsModule],  // модуль BrowserModule необходим  
   exports: [MyComponent],                 // для работы с бразером
 })
 class MyModule { }

 -----

 @Component({
   selector: 'app-component',
   template: `
     <div>
       <h1>Корневой компонент</h1>
       <my-component></my-component>
     </div>
   `
 })
 class AppComponent { }

 @NgModule({
   declarations: [AppComponent],
   imports: [BrowserModule, MyModule],  // если не импортировать MyModule, то AppComponent 
   bootstrap: [AppComponent],           // не сможет обращаться к <my-component>
 })
 class AppModule { } 

 const platform = platformBrowserDynamic();
 platform.bootstrapModule(AppModule); 
 
При использовании модульной системы, сервисы имеют три уровня предоставления:

 1) Корневой уровень. Сервис предоставляется для всего приложения. Устанавливается 
    путем добавления сервиса в providers главного модуля или через декоратор 
    @Injectable({ providedIn: 'root' })

 2) Уровень модуля. Сервис предоставляется только для модуля и всех его классов.
    Устанавливается путем добавления сервиса в providers модуля или через декоратор
    @Injectable({ providedIn: MyModule }) 

 3) Уровень компонента. Сервис предоставляется только компоненту. Для каждого компонента
    создается отдельный экземляр сервиса. Устанавливается путем добавления сервиса
    в providers компонента.

В случаях, когда уровень предосталения задается через декоратор, сервис уже не нужно
добавлять в providers (нужного модуля/компонента).

RxJS - это библиотека для реактивного программирования. С пом. нее можно декларативно
обрабатывать потоки данных, а также выполнять привязки данных (data binding).

Поток данных в RxJS представлен объектом Observable. Его можно сравнить с массивом, 
значения которого формируются с задержкой, т.е. асинхронно (например данные, непрерывно
поступающие из сети или от события). 

Чтобы обработать данные, нужно у потока Observable вызвать метод pipe(). 
В этот метод передаются операторы обработки. 

Эти операторы представлены в виде ф-ций, которые можно разбить на категории.
 * cоздание нового потока (of, from, fromEvent, interval);
 * преобразование (map, scan, buffer);
 * фильтрация (filter, take, skip, distinct);
 * обработка ошибок (catchError, retry, onErrorResumeNext);
 * условия (skipUntil, skipWhile, takeUntil, takeWhile);
 * математические (min, max, count);
 * утилиты (tap, delay);
 * для Connectable Observable (share, shareReplay, publish).

Чтобы получить обработанные данные, нужно подписаться на поток с пом. метода subscribe().
Если данные больше не нужны, нужно отписываться от потока с пом. метода unsubscribe().

 import { Observable } from 'rxjs'; 
 import { tap, map } from 'rxjs/operators';

 const observable = new Observable(subscriber => {
   subscriber.next(1);
   subscriber.next(2);
   subscriber.next(3);
   subscriber.complete();
 });

 const newObservable = observable.pipe(
   tap(x => console.log(x)),  // оператор для side-эффектов
   map(x => x * 10)
 );

 const subsciption = newObservable.subscribe({
   next(x) { console.log(`Получено значение: ${x}`); }
   error(err) { console.log(`Ошибка: ${err}`); }
   complete() { console.log('Завершено'); }
 });

 subsciption.unsubscribe(); 

Пример реализации автозаполнения в поисковой строке, которая отправляет запросы
по мере ввода текста пользователем:

 import { fromEvent } from 'rxjs';
 import { debounceTime, map, switchMap } from 'rxjs/operators';
 import { ajax } from 'rxjs/ajax';

 const searchBox = document.getElementById('search-box');

 // К переменной потока обычно добавляют знак $ в конце.
 // Оператор map преобразует события в строки.
 // Оператор switchMap отменяет предыдущую асинхронную операцию, 
 // когда приходит новое значение.

 const seach$ = fromEvent(searchBox, 'input').pipe(
   debounceTime(300),
   map(event => event.target.value),
   switchMap(query => ajax.getJSON(`/api/search?q=${query}`))
 );

 search$.subscribe(data => console.log(data));

----------------- 

Внедрение зависимостей через интерфейсы...

Сигналы (в будущем практически полностью заменят rxjs)...

Angular-анимации...

