ВВЕДЕНИЕ

Angular 20 требует Node.js 24 (или ^22.12 или ^20.19), TypeScript от 5.8 до 5.9 
и Angular CLI 20. Возможно также потребуется обновить npm.

Установка Angular CLI: npm install -g @angular/cli

Проверить версию Angular CLI: ng version
Обновление Angular CLI: ng update
Создать приложение: ng new <project-name>
Запустить веб-сервер и приложение: ng serve
Скомпилировать приложение: ng build

Если команде ng serve передать флаг --open, то автоматически откроется 
браузер с приложением.

При использовании PowerShell в Windows стоит учесть, что по умолчанию там отключено
выполнение скриптов (а они нужны при работе с anglular cli). Чтобы включить выполнение
скриптов, нужно ввести такую команду:

 Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned

Чтобы развернуть сторонний проект, нужно просто взять готовый package.json со всеми 
необходимыми зависимостями и выполнить команду: npm install.

Минимальный набор конфигурационных файлов проекта на Angular: 
package.json, tsconfig.json, angular.json.

Файл package.json определяет зависимости проекта.
Файл tsconfig.json определяет конфигурации компилятора ts.
Файл angular.json определяет конфигурации проекта и CLI. 

Проект обычно состоит из главной html-страницы, bootstrap-файла и набора компонентов.
Каждый компонент может быть представлен либо одним файлом, где все состовляющие определены 
в одном месте, либо набором разделенных файлов: .ts, .html, .css и т.п.

Минимальный проект на Angular:

 Файл компонента src/my-component.ts

 import { Component } from "@angular/core";
 @Component({
   selector: 'my-app',
   standalone: true,
   template: `<h1>Добро пожаловать!</h1>`
 })
 export class MyComponent {}

 -----

 Boostrap-файл src/main.ts

 import { bootstrapApplication } from "@angular/platform-browser";
 import { MyComponent } from "./my-component";
 bootstrapApplication(MyComponent); 

 -----

 Главная страница src/index.html

 <!DOCTYPE html>
 <html>
   <head>
     <meta charset="utf-8" />
     <title>Angular Test</title>
   </head>
   <body>
     <my-app></my-app>
   </body>
 </html>

 -----

 Файл package.json

 { 
   "name": "helloapp",       
   "version": "1.0.0",        
   "scripts": {              
     "start": "ng serve",
     "build": "ng build"
   },
   "dependencies": {                   // Все модули установятся локально. 
     "@angular/common": "~20.0.0",     // Если некоторые из этих модулей установлены 
     "@angular/compiler": "~20.0.0",   // глобально, то они перекроются локальными.
     "@angular/core": "~20.0.0",
     "@angular/forms": "~20.0.0",
     "@angular/platform-browser": "~20.0.0",
     "@angular/router": "~20.0.0",
     "rxjs": "~7.4.0",
     "zone.js": "~0.15.1"    // библиотека полифилов
   },
   "devDependencies": {
     "@angular-devkit/build-angular": "~20.0.0",
     "@angular/cli": "~20.0.0",
     "@angular/compiler-cli": "~20.0.0",
     "typescript": "~5.8.0"
   }
 }

 -----
 
 Файл tsconfig.json

 {
   "compileOnSave": false,
   "compilerOptions": {
     "baseUrl": "./",
     "sourceMap": true,
     "declaration": false,
     "downlevelIteration": true,
     "experimentalDecorators": true,
     "module": "ES2022",
     "moduleResolution": "node",
     "target": "ES2022",
     "typeRoots": ["node_modules/@types"],
     "lib": ["ES2022", "dom"]
   },
   "files": ["src/main.ts"],
   "include": ["src/**/*.d.ts"]
 }

 -----

 Файл angular.json

 {
   "version": 1,      // версия конфигурации
   "projects": {      // настройки для проекта helloapp
     "helloapp": {
       "projectType": "application",  // тип проекта (application - это приложение, 
                                      // которое можно запускать в браузере)

       "root": "",          // папка файлов (пустое значение это корневая папка)
       "sourceRoot": "src", // папка src-файлов 

       "architect": {       // настройки для команд ng build и ng serve соответсвенно 
         "build": {

		   // Инструмент построения проекта; build-angular:browser использует webpack 
           // для сборки проекта, а build-angular:dev-server запускает сервер 
           // и развертывает на нем скомпилированое приложение
           "builder": "@angular-devkit/build-angular:browser",

		   "options": {     // параметры для команды build  

             "outputPath": "dist/helloapp",   // путь для скомпилированного приложения
             "index": "src/index.html",       // путь к главной странице приложения
             "main": "src/main.ts",           // путь к bootstrap-файлу
             "polyfills": ["zone.js"],        // путь к файлам полифилов   
             "tsConfig": "tsconfig.json",  

             "aot": true     // будет ли использоваться предварительная компиляция 
                             // перед выполнением (Ahead-Of-Time)
           }
         },
         "serve": {
           "builder": "@angular-devkit/build-angular:dev-server",
           "options": {

			 // Cсылка на конфигурацию команды build. Т.е. команда serve
             // использует ту же конфигурацию, что и команда build
             "buildTarget": "helloapp:build"
           }    
         }
       }
     }
   }
 }

По умолчанию, файлы компилируются в режиме production. Чтобы вручную настроить режим
компиляции (например для разработки), нужно задать подсекцию configurations для секции build
и указать необходимый флаг при вызове команды ng build.

 "build": {
   ...
   "configurations": {
     "production": {

       "optimization": true,     // будет ли использоваться оптимизация

       "outputHashing": "all",   // бедут ли в названиях генерируемых файлов 
								 // добавляться хеш-значения

       "sourceMap": false,       // будут ли генерироваься sourceMap-файлы

       "namedChunks": false,     // будут ли использ. имена файлов для
								 // именованных подгружаемых чанков

       "vendorChunk": false,     // будут ли создаваться для сторонних библиотек
                                 // отдельные файлы
                   
       "buildOptimizer": true    // подключает пакет @angular-devkit/build-optimizer
								 // при использовании aot
     },
     "development": {
       "optimization": false,
       "sourceMap": true
     }
   }  
 } 

 ng build --configuration development  -->  билд для разработки

Режим компиляции никак не влияет на процесс разработки, запускаемый командой ng serve.
Эта команда не будет применять никаких оптимизаций из "production".

-----------------

ОСНОВЫ ANGULAR

Компонент - это класс, помеченный декоратором @Component. Этот декоратор в качестве 
параметра принимает объект с конфигурацией компонента.

Конфигурация компонента состоит из множества свойст, например:
 * selector - задает селектор (тег) компонента в html;
 * standalone - указывает, будет ли компонент автономным;
 * imports - задает набор модулей, которые нужно импортировать в компонент; 
 * template - шаблон компонента (html-разметка с интерполяциями);
 * templateUrl - внешний файл с шаблоном (используется вместо template);
 * styles - задает стили для компонента;
 * styleUrls - задает внешние файлы со стилями;

Автономные компоненты появились в 16й версии. Автономные компоненты могут не быть частью
модулей и использоваться сами по себе. Такие компоненты сами управляют своими зависимостями
через свойство imports. Использование автономных компонентов является предпочтительным.

Для загрузки корневого компонента используется ф-ция bootstrapApplication(), которая
вызывается в bootstrap-файле. Эта ф-ция возвращает промис Promise<ApplicationRef> 
из которого можно получить объект ApplicationRef, представляющий приложение Angular.

Стилизацию компонента можно реализовать как через свойство styles, так и через внешние 
файлы стилей. Стилизация компонента применяется только к его шаблону. Чтобы задать стили 
для тега компонента, используется селектор :host.

 Файл my-component.ts

 @Component({
   selector: 'my-app',
   standalone: true,
   templateUrl: './my-component.html',
   styleUrls: ['./my-conponent.css']
 })
 export class MyComponent { }

 -----

 Файл my-coponent.html

 <h1>Hello Angular</h1>
 <p>Приложение Angular состоит из компонентов</p>

 -----

 Файл my-component.css

 h1, h2 { color: navy; }
 p { font-size: 13px; }
 /* Обращение к <my-component> */
 :host {  
   font-family: Verdana;
   color: #555;
 }

С помощью механизма привязки, различные части шаблона могут быть привязаны к свойствам 
компонента. В Angular есть следующие формы привязки:

 * привязка элемента к свойству компонента: <h1>{{myTitle}}</h1>
 * привязка свойства элемента к свойству компонента: <p [textContent]="myText">
 * привязка html-атрибута к свойству компонента: <input type=text [attr.value]="myInput">

 * привязка css-класса к свойству компонента: <div [class.box]="isShown"></div>
   (если свойство isShow равно true, то к div добавится класс box)

 * привязка css-свойства к свойству компонента: <img [style.margin]="isShown ? '1rem': '0'"> 
   (css-свойство можно указывать как в camelCase так и в kebab-case)

 * привязка события к методу компонента: <button (click)="addItem($event)">Add</button>
   (информация о событии доступна через объект $event)

 * двусторонняя привязка элемента к свойству компонента (т.е. изменение элемента 
   затрагивает изменение свойства и наоборот): <input type=text [(ngModel)]="myInput">

Событие элемента может также привязываться через выр-е: on-event="method(arg1, argN)"
Двусторонняя привязка, как правило, используется с элементами ввода.



-----------
Двусторонняя привязка, как правило, используется с элементами ввода. Но чтобы применять ее 
к полям формы, необходимо импортировать в компонент модуль FormsModule. 

 import { FormsModule } from '@angular/forms';

 @Component({
   ...
   imports: [FormsModule]
   template: `<input type=text [(ngModel)]=myInput>`
 })
 export class MyComponent {
   myInput = "Tom";
 }
--------------



В Angular 17 появились новые синтаксические конструкции if/switch/for для управления
разметкой шаблона. Раньше вместо них использовались директивы.

Конструкция if определяется так:

 @if (myProp == 1 || myProp == 2) {
   <h4>Какая-то разметка {{myTitle}}<h4>
 } @else if (myProp == 3) {
   <p>Какая-то разметка</p>
 } @else {
   <p>Какая-то разметка</p>
 }

Конструкция switch определяется так:

 @switch (myProp) {
   @case ('hello') {
     <p>Какая-то разметка</p>	
   }
   @case ('world') {
	 <p>Какая-то разметка</p>
   }
   @default {
	 <p>Какая-то разметка</p>
   }
 }

Конструкция for определяется так:

 @for (item of myItems; track item) {
   <li>{{item}}</li>
 }

При переборе коллекций нужно также использовать выр-е track <id>. Оно помечает каждый 
dom-элемент, который связан с элементом коллекции, уникальным идентификатором. 

Это необходимо для оптимизации, чтобы когда коллекция изменится, Angular мог определить 
какие именно элементы были изменены и перерисовать только их связанные dom-элементы, 
а не все целиком.

В примере выше, в качестве идентификатора используется сам item, но лучше задавать 
другое значение, например его id или index, т.к. название item может быть неуникальным.

Внутри цикла можно использовать ряд специальных значений:
 $index - индекс элемента в коллекции;
 $count - кол-во элементов коллекции;
 $first - является ли текущий элемент первым в коллекции;
 $last - является ли текущий элемент последним в коллекции;
 $even - является ли индекс текущего элемента четным;
 $odd - является ли индекс текущего элемента нечетным;

 @for (item of myItems; track $index) {
   <li>{{item}} {{$last ? "последний" : ""}}</li>
 } 

Чтобы один компонент мог использовать в своем шаблоне другой компонент, он должен также
импортировать его через свойство imports:

 import { MyToolbar } from './my-toolbar';

 @Component({
   selector: 'my-component',
   standalone: true,
   imports: [MyToolbar],
   template: `
     <h1>Заголовок</h1>
     <my-toolbar>
       <span>Привет {{text}}</span>
     </my-toolbar>
   `,
   styles: `span { color: red; }`
 })
 export class MyComponent {
   text = 'Мир';
 }

Встроенный элемент <ng-content> позволяет дочернему компоненту получить разметку из
родителького компонента. Причем эта разметка будет стилизована теми стилями, 
что заданы в родитеском компоненте.

 @Component({
   selector: 'my-toolbar',
   standalone: true,
   template: `<p><ng-content></ng-content></p>`,  // выведет <p><span>Привет Мир</span></p>
   styles: `span { color: green; }`               // с красным текстом
 })
 export class MyToolbar { 
   text = 'Angular';
 }

Если требуется передать данные из родительского компонента в дочерний, то родительский
компонент должен привязать дочернее свойство к своему свойству. При этом дочернее свойство
должно быть помечено декоратором @Input. Привязывать можно и дочерние сеттеры.

 import { Component, Input } from '@angular/core';

 @Component({
   ...
   template: `<p>Возраст: {{userAge}}</p>`  // 24
 })
 class ChildComponent {
   @Input() userAge = 0;
 }

 @Component({
   ...
   imports: [ChildComponent],
   template: `<child-component [userAge]="age"></child-component>`
 })
 class ParentComponent {
   age = 24;
 }

Если требуется передать данные из дочернего компонента в родительский, то дочерний компонент
должен испустить событие, а родительский компонент подписаться на него (в шаблоне).
При этом эмитер события события должен быть помечен декоратором @Output.

 import { Component, EventEmitter, Output } from '@angular/core';

 @Component({
   ...
   template: `<button (click)="onClick(24)">Change</button>`,
 })
 class ChildComponent {
   @Output() onChange = new EventEmitter<number>();

   onClick(value) {
     this.onChange.emit(value);
   }
 }

 @Component({
   ...
   imports: [ChildComponent],
   template: `
     <child-component (onChange)="onChange($event)"></child-component>
     <p>Возраст: {{age}}</p>  // 24
   `,
 })
 class ParentComponent {
   age = 0;

   onChange(value) { 
     age = value; 
   }
 }

К качестве альтернативы, можно использовать двустороннюю привязку между 
родительским и дочерним свойством.

 @Component({
   ...
   template: `<button (click)="onClick(24)">Возраст</button>`
 })
 class ChildComponent {
   @Input() userAge = 0;
   
   onClick(value) {
     this.userAge = value;
   }
 }

 @Component({
   ...
   imports: [ChildComponent],
   template: `
     <child-component [(userAge)]="age"></child-component>
     <p>Возраст: {{age}}</p>  // 24
   `
 })
 export class ParentComponent {
   age = 0;
 }

Односторонняя привязка: [otherProp]=myProp (otherProp изменяется при изменении myProp).
Двусторонняя привязка: [(otherProp)]=myProp (тоже самое, но работает в обе стороны).



-----------------
 @Component({
   ...
   imports: [FormsModule],

   // ngModel - это свойство input.value, 
   // ngModelChange - это событие input.change

   template: `<input [ngModel]="userAge" (ngModelChange)="onChange($event)">`
 })
 export class ChildComponent {
   @Input() userAge = 0;

   onChange(value: string) {
     this.userAge = value;	
   }
 }

 @Component({
   imports: [ChildComponent],
   template: `<child-component [(userAge)]="age"></child-component> `,
 });
 export class ParentComponent {
   age = 0;
 }

В примере выше ngModel и userAge имеют одностороннюю привязку, поэтому дополнительно
обрабатывается событие ngModelChange. Но это можно было бы опустить, если бы 
ngModel и userAge имели также двустороннюю привязку.
-----------------



Жизненный цикл компонента состоит из множества разных методов, каждый из которых вызывается 
в определенный момент времени. Например сначала вызвается конструктор компонента. После,
вызывается метод ngOnChanges (при начальной установке свойств или изменении @Input свойств).
Затем, метод ngOnInit (вызывается один раз, после инициализации всех свойств, но до
инициализации шаблона). Метод ngOnDestroy вызывается перед тем, как фреймворк удалит
компонент и т.д. Подробнее здесь https://metanit.com/web/angular2/2.8.php

Большая часть подобных методов определена в отдельных интерфейсах, которые имеют 
одноименные названия, но без префикса "ng".

 import { Component, OnInit, OnDestroy } from '@angular/core';

 @Component({ ... });
 class MyComponent implements OnInit, OnDestroy {
   constructor() { }  // здесь обычно инициализируются свойства
   ngOnInit() { }     // здесь выполняются какие-то подготовительные действия
   ngOnDestroy() { }  // здесь освобождаются ресурсы, удалятся подписки на события и пр.
 }

Внутри шаблона можно также объявлять переменные. Обычно такие переменные ссылаются на 
какой-то dom-элемент или компонент. Но их область видимости ограничеватся только шаблоном.

 template: `
   <span #mySpan>{{text}}</span>  // вместо span мог бы быть и компонент
   <p>{{mySpan.textContent}}</p>
 `

Чтобы к шаблонной переменной можно было обращаться из кода, нужно привязать ее 
к свойству компонента с помощью декоратора @ViewChild.
 
 @ViewChild('mySpan', { static: false })
 myProp: ElementRef | undefined;

 someMethod() {
   console.log(this.myProp);  // span
 }

Первым параметром @ViewChild может быть не только имя шаблонной переменной, 
но и селектор элемента и даже дочерний компонент (в этом случае селектор будет взят 
из его декоратора @Component)

Если дочерний компонент, посредством <ng-content>, получает разметку из родительского
копмопнента, у которой есть шаблонная переменная, то он также может привязать ее к своему
свойству через декоратор @ContentChild.

 @Component({
   ...
   template: `
     <child-component>
       <h2 #headerContent>Добро пожаловать!</h2>
     </child-component>
   `
 })
 class ParentComponent { }

 @Component({
   ...
   template: `<p><ng-content></ng-content></p>`  
 })
 class ChildComponent {
   @ContentChild('headerContent', { static: false })
   myProp: ElementRef | undefined;
 }

-----------------

ДИРЕКТИВЫ

Это классы с директивными метаданными (т.е. помеченные декоратором @Derective).
Они определяют инструкции, которые используются при рендеринге html.

В Angular есть 3 типа директив:

 * Компоненты - это теже директивы, т.к. декоратор @Component расширяет @Derective 
   и добавляет ф-ционал по работе с шаблонами;

 * Атрибутивные - изменяют элементы, к которым применяются.
   Например: ngModel, ngStyle, ngClass и т.п.

 * Структурные - изменяют dom путем добавления, изменения, удаления 
   каких-то html-вставок. Например: ngFor, ngIf и т.п.

Директива ngClass задает набор css-классов для элемента через привязку объекта.
Ключи объекта - это названия классов, а значения - true/false.

 import { NgClass } from '@angular/common';
 
 @Component({
   ...
   imports: [NgClass],
   template: `
     div [ngClass]="{ verdanaFont: true, redColor: isRed }">
       <p [ngClass]="contentClasses">Hello world</p>
     </div>
   `,
   styles: `
     .verdanaFont { font-size: 13px; font-family: Verdana; }
     .redColor { color: red; }
     .bgLight { color: black; background: white; }
     .bgDark { color: white; background: black; }
   `
  })
  class MyComponent {
    isRed: false;
    contentClasses = { bgLight: true, bgDark: false };
  }

Директива ngStyle задает набор css-стилей, точно также через привязку объекта.
Ключи объекта - это названия css-свойств, а значения - собственно значения этих свойств.

 <div [ngStyle]="{ 'font-size': '14px', 'font-family': 'Verdana' }"></div>

Альтернативный вариант: [class.cssClass]="true/false" и [style.cssProp]="cssPropValue"

 <div [class.visibility]="isVisible"></div>
 <div [style.display]="isVisible ? 'block' : 'none'"></div>

Создание атрибутивной директивы:

 import { Directive, ElementRef, Renderer2 } from '@angular/core';

 @Directive({
   selector: '[myDir]'  // селектор атрибута, с кот. ассоциируется директива
   standalone: true,
   host: {                         // через host можно подписаться на события элемента;
     '(mouseenter)': 'onEnter()',  // onEnter() вызовется, когда пользователь наведет мышь
   }                               // на элемент, помеченный атрибутом myDir
 })                                
 class MyDirective {
   constructor(private elemRef: ElementRef, private renderer: Renderer2) {

     // Установка стиля для элемента с атрибутом myDir
     this.renderer.setStyle(this.elementRef.nativeElement, 'font-weight', 'bold');

     // Альтернативный вариант, без использ. renderer
     // this.elemRef.nativeElement.style.fontWeight = 'bold';
   }

   onEnter() { }

   // Вместо host можно сразу пометить метод @HostListener
   @HostListener('mouseleave') onLeave() { } 

   // Через @HostBinding можно связать css-свойство элемента со значением геттера
   @HostBinding('style.fontWeight')
   get fontWeight() { return 'normal'; }
 }

 @Component({
   ...
   standalone: true,
   imports: [MyDirective],
   template: `<p myDir>Hello World</p>`  // атрибут myDir сделает шрифт жирным
 })
 class MyComponent { }
 
Директиве можно также задавать параметры. Делается это след. способами:
 
 <div myDir hoverSize="16px" ></div>  // первый способ

 // Если параметр задается через квадратные скобки, то его значение 
 // нужно дополнительно заключать в одинарные кавычки:
 <div myDir [hoverSize]="'16px'"></div>

Чтобы обратиться к параметрам из класса, нужно создать одноименные свойства, 
помеченные декоратором @Input.

 @Directive({ ... })
 class MyDirective {
   @Input hoverSize = '';
 }

Если в @Input передать селектор директивы, то параметр можно задать еще проще:
 @Input('bold') hoverSize = '';  -->  <div [myDir]="'16px'"></div>

Создание структурной директивы:

 import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

 @Directive({ selector: '[myIf]', standalone: true })
 class IfDirective {
   constructor(
     private templRef: TemplateRef<any>,    // объект для доступа к шаблону
     private viewCntrRef: ViewContainerRef  // объект рендерера
   ) { }

   // С пом. входного сеттера получаем из шаблона значение condition
   @Input set myIf(condition: boolean) {
     if (condition) {
       this.viewCntrRef.createEmbeddedView(this.templRef);
     } else {
       this.viewCntrRef.clear();
     }
   }
 }

 @Component({
   ...
   standalone: true,
   imports: [IfDirective]
   template: `
     <p *myIf="condition">Hello</p>   // атрибут задается через звездочку
     <p *myIf="!condition">World</p>
   `
 })
 class MyComponent {
   condition = true;
 }

-----------------

СЕРВИСЫ

Это классы с дополнительной логикой, к которой не относится логика отображения (логику
отображения лучше реализовывать в компонентах). Например логгирование, работа с данными,
работа с api. Файл сервиса должен содержать в своем названии подстроку .service

Пример реализации компонента с сервисом:

 class DataService {
   private data: string[] = ['Tom', 'Bob', 'Sam'];   
   getData(): string[] { return this.data; }
 }

 @Component({
   ...
   providers: [DataService],  // чтобы внедрить сервис в компонент (с пом. DI),
   template: `                // нужно добавить его в providers.
     <ul>
       @for (item of items; track $index) {
         <li>{{item}}</li>
       }
     </ul>
   `
 })
 class MyComponent {
   items: string[] = [];
   constructor(private dataService: DataService) { }
 
   ngOnInit() {
     this.items = this.dataService.getData();
   }
 } 

Если один сервис использут внутри себя другой сервис, то его класс должен быть помечен
декоратором @Injectable. Но разраработчики Angular рекомендуют помечать @Injectable 
любой класс сервиса.

 @Injectable
 class LogService {
   write(msg: string) { console.log(msg) }
 }

 @Injectable
 class DataService {
   ...
   constructor(private logService: LogService) { }

   getData(): string[] {
     this.logService.write('hello!');
     return this.data;
   }
 }

Если компонент использует сервис, который зависит от другого сервиса, то он обязан в своем
providers указать оба сервиса, даже если не использует второй напрямую.

 @Component({
   ...
   providers: [DataService, LogService]
 })
 class MyComponent {
   ...
   constructor(private dataService: DataService) { }
 }

Зависимый сервис можно сделать опциональным, пометив его декоратором @Optional(). В этом
случае, если не указать его в providers, он будет просто недоступен. Но ошибки не будет.

 constructor(@Optional() private logService: LogService) { }

При внедрении сервиса в разные компоненты, каждый компонент будет получать отдельный
экземпляр сервиса. Но если требуется, чтобы все компоненты работали с одним экземпляром
сервиса, то его можно внедрить в какой-то родительский компонент. При этом теперь 
компоненты не должны содержать сервис в своих providers.

 @Component({
   selector: 'my-component',
   standalone: true,
 }) 
 class MyComponent {
   constructor(private dataService: DataService) { }
 }

 @Component({
   selector: 'other-component',
   standalone: true,
 }) 
 class OtherComponent {
   constructor(private dataService: DataService) { }
 }

 @Component({
   selector: 'app-component'
   standalone: true,
   providers: [DataService, LogService]
   template: `
     <my-component></my-component>        // каждый из компонентов получит
     <my-component></my-component>        // один и тот же экземпляр сервиса 
     <other-component></other-component>
   `
 })
 class AppComponent { }

-----------------
 
РАБОТА С ФОРМАМИ


