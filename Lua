ВВЕДЕНИЕ В РАЗРАБОТКУ АДДОНОВ

Аддоны Wow могут состоять из следующих файлов:
* toc-файл, который идентифицирует аддон и файлы для загрузки;
* медиа-файлы (картинки, музыка);
* lua-скрипты (поведение аддона);
* xml-файлы (в них определяются элементы визуализации).

Что нельзя делать через аддоны:
* автоматическое перемещение персонажа;
* автоматический выбор цели;
* автоматический выбор и использование способностей или предметов;
* коммуницировать в реальном времени с внешними программами.

Аддоны могут только отображать информацию и предоставлять более простой доступ к
различным действия, но при этом автоматические действия для пользователя запрещены.

Аддоны хранятся в директории Wow/Interface/AddOns.

Аддоны Blizzard загружаются только тогда, когда это необходимо. 
Например аддон Blizzard_AuctionUI загрузится, когда пользователь посетит аукцион.
Ф-ционал этих аддонов можно переопределять. Вот их список:

* Blizzard_AchievementUI - окно достижений игрока;
* Blizzard_ArenaUI - показывает вражеские юнит-фреймы на арене;
* Blizzard_AuctionUI - окно акциона с ф-ционалом торговли;
* Blizzard_BarbershopUI - кастомизация персонажа в парикмахерской;
* Blizzard_BattlefieldMinimap - миниверсия мировой карты, включая PvP-задачи;
* Blizzard_BindingUI - настройка привязки клавиш;
* Blizzard_Calendar - показывает календарь и игровые события;
* Blizzard_CombatLog - боевой журнал с настройками стилизации;
* Blizzard_CombatText - боевые события во всплывающем тексте (исцеление, урон);
* Blizzard_DebugTools - предост. командную строку и утилиты для разработчиков аддонов;
* Blizzard_GMChatUI - окно чата для общения с GM;
* Blizzard_GMSurveyUI - окно опроса, отправленного от GM;
* Blizzard_GlyphUI - окно символов персонажа;
* Blizzard_GuildBankUI - окно гильдейского банка;
* Blizzard_InspectUI - окно осмотра другого персонажа, его экипировки, талантов и т.д.;
* Blizzard_ItemSocketingUI - окно вставки камней в экипировку;
* Blizzard_MacroUI - окно макросов персонажа;
* Blizzard_RaidUI - рейдовое окно с персонажами;
* Blizzard_TalentUI - окно дерева талантов;
* Blizzard_TimeManager - часы и таймер (возле миникарты);
* Blizzard_TokenUI - отображает различные валюты и токены персонажа;
* Blizzard_TradeSkillUI - окно профессии;
* Blizzard_TrainerUI - окно тренира.

Каждая из этих папок имеет только один файл, с расширением .pub. Это своего рода
подпись, по которой игра распознает подлинность аддонов от Blizzard. Такие аддоны
получают специальный "безопасный" флаг, который позволяет им выполнять защищенные
действия. Код этих аддонов на самом деле хранится в файлах игры и его нельзя изменять.

Создание простейшего аддона:

1. Создадим папку HeyThere и в ней 2 файла: HeyThere.toc и HeyThere.lua.
2. В файле HeyThere.toc пропишем:
...
## Interface: 30300
## Title: Hey There!
## Notes: Provides slash commands to greet other players
HeyThere.lua

3. В файле HeyThere.lua пропишем:
...
SLASH_HEYTHERE1 = "/hey"
SLASH_HEYTHERE2 = "/heythere"

SlashCmdList["HEYTHERE"] = function (self, txt)
  if UnitExist("target") then
    SendChatMessage("Hello " .. UnitName("target"), "SAY")
  else
    SendChatMessage("Hey there everybody!")
  end
end

Этот аддон добаляет две новые слэш-команды, которые позволяют приветствовать игроков.
Если ввести /heythere или просто /hey, то в зависимости о того, взят ли игрок в цель,
выведет сообщение: "Hello Nickname". А если нет цели, то "Hello there everybody!".

-------------------------

ОСНОВЫ LUA + XML

В Lua есть 8 примитивных типов данных:
* number - число;
* string - строка;
* boolean - логический тип;
* function - функция;
* table - таблица (смесь словаря и массива);
* nil - отсутствие значения;
* thread - значением этого типа является корутина (использ. в асинхронных вычислен.);
* userdata - структура данных (как в C).

Все числа по умолчанию являются вещественными (как в JS).
С пом. ф-ции type() можно получить тип значения: type(1)  -->  "number".

Переменная объявляется так: x = 23 (можно сразу несколько: x, y = 3, 5).
Если переменной не присвоить никакого значения, то по умолчанию она будет с nil.

Операторы сравнения:
* == - равно;
* < - меньше;
* > - больше;
* <= - меньше или равно;
* >= - больше или равно;
* ~= - не равно;

Строки, как и числа, можно сравнивать с пом. операторов < и >.
Конкатенация строк выполняется c пом. двух точек: "hello" .. "world".

Для создания строк можно использовать как двойные, так и одинарные кавычки.
Многострочные строки создаются с пом. двойных квадратных скобок: [[ Hello \nWorld ]].
Если внутри такой строки есть символы "]]", то многострочный формат задается так: 
[==[ Hello ]] World ]==]. Здесь кол-во == эквивалентно кол-ву ].

Конвертировать число в строку можно с пом. ф-ции tostring().
Конвертировать строку в число можно с пом. ф-ции tonumber().

Получить длину строки можно с пом. оператора #, либо через string.len():
#"Hello"  -->  5, string.len("Hello")  -->  5.

Логические операторы:
* and - И;
* or - ИЛИ;
* not - НЕ.

Логические операторы работают также, как в JS (возвращают по итогу значение 
конкретного типа, а не булевое значение [где допустимо]).
...
false and "World"  -->  false
true and "Hello"   -->  Hello 
false or "Hello"   -->  Hello
not "Hello World"  -->  false

По умолчанию все переменные являются глобальными, даже если объявены внутри ф-ции 
или любого другого блока кода (if, for, while и т.п.). 

Чтобы переменная была локальной, она должна объявляться с ключевым словом local.
...
do
  local x = 7

  do
    local x = 10
    print(x)  -->  10
  end
  
  print(x)  -->  7
end

При разработке аддонов, если переменные объявлять без local, то у них может быть
коллизия с другими переменными, из других аддонов. Это стоит учитывать!

Локальные переменные из одного файла не могут быть доступны в других файлах.
Кроме того, если локальная переменная объявлена вне блока, то она не будет
видна даже на другой строке:
...
local x = 10
print(x)  -->  nill

Локальная переменная должна быть объявлена внутри блока. Обычный блок кода 
создается с помощью операторов do и end.
...
do
  local x = 10
  print(x)  -->  10
end

---------

Ф-ции в Lua - это обычные значения, только с типом function. Это означает, что их можно
сравнивать через операторы сравнения, присваивать переменным, передавать в параметры
либо возвращать из других ф-ций. 

Значение, которое можно вызывать как ф-цию называется "объектом первого класса".
Говорят что, если язык поддерживает такой способ вызова, значит он имеет 
"ф-ции первого класса".

Ф-цию можно объявить двумя способами (как в JS):
...
function hello(msg)
  print(msg)
end

hello_done = function(msg)
  print(msg)
  return "done!"
end

hello("Punk!")  -->  если return отсутсвует, то результатом вызова будет nil (как в JS)
hello_done()    -->  если не передать аргумент, то msg будет c nil (как в JS)
hello2 = hello  -->  теперь (hello == hello2) будет true

Кроме того, ф-цию можно сделать локальной (зачем они нужны, рассказывается далее):
...
local function hello()
  print(msg)
end

Условный оператор if определяется так (скобки ставить не обязательно):
...
if (value == 23) then
  print("hello!")
elseif value and type(value) == "number" then
  print("world!")
else
  print("done")
end

Цикл while/do определяется подобным образом:
...
while (value > 0) do 
  print("hello!")
  value--
end

Аналогом цикла do/while в Lua служит цикл repeat/until:
...
repeat
  print("hello")
  value--
until (value > 0)

А вот так определяется цикл for. Здесь переменная i локальная по умолчанию.
...
for i = 0, 3, 1 do   -->  i = 0; i <= 3; i += 1
  print(i)
end

for i = 3, 1, -1 do  -->  i = 3; i >= 1; i -= 1
  print(i)
end

Кроме того шаг можно вообще не указывать. В этом случае его прирощение будет на 1.
...
for i = 1, 3 do  -->  i = 1; i <= 3; i++
  print(i)
end

-------------------------

РАЗНОЕ

Ф-ция print() выводит сообщение на консоль.
Ф-ция error() выводит сообщение об ошибке (исключение).
Ф-ция type() возвращает название типа (передаваемого значения).

Комментарий в Lua начинается с знаков -- перед началом строки:
 -- это закоментированная строка

