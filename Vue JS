ОСНОВЫ VUE.JS

Концепция Vue операется на реактивность данных. Его главная фишка это двустороння
привязка данных в html и js. Когда данные изменяется в js, происходит перерисовка 
html-шаблона (который их выводит) и наоборот.

Благодаря двухсторонней привязке, Vue реализует часть паттерна MVVM, где View - это
html-шаблон, а ViewModel - то, что реализуется с помощью js.

Чтобы начать работать с Vue, нужно создать его объект, а затем связать его с элементом
на странице. Внутри этого элемента будут доступны все свойства и методы объекта Vue, 
а также директивы и интерполяция. 

Объект Vue создается с помощью метода Vue.createApp({...}), в который передается
параметрический объект. C элементом он связывается с помощью метода mount('selector').

Параметрический объект состоит из:
* метода data - он возвращает объект свойств (подобно объекту state в React);
* свойства methods - в нем определяются методы;
* свойства computeds - в нем определяются вычисляемые свойства;
* свойства watch - в нем определяются наблюдаемые свойства;
* свойства compontents - в нем определяются локальные компоненты;
* свойства mixins - в нем определяются миксины;
* методов жизненного цикла.

Свойства объекта Vue обладают реактивностью. При изменении их в JS, результат также
обновляется и в html.

Внутри интерполяции (фигурных скобок в html) помимо свойст объекта Vue можно также
вызывать и методы. Здесь также допустимы и любые другие выражения JS, например
тернарная операция и т.п.

Свойства и методы объекта Vue не обязательно вызывать именно в html. Их можно вызывать
и в JS, в других файлах к примеру.

Альтернатива интерполяции это атрибут v-text. В нем указывается название свойства,
значен. которого необход. вывести: <div v-text="prop"></div>  -->  <div>{{prop}}</div>

Чтобы связать атрибуты html-тега со свойствами объекта Vue, нужно использовать
директиву v-bind или сокращенно двоеточие: <a v-bind:href="prop1">{{prop2}}</a>  
  -->  data() { return { prop1: '#', prop2: 'hello' }; }

Чтобы отобразить только первоначально значение свойства, без реактиновсти, нужно
использовать директиву v-once: <p v-once>{{prop}}</p>

Интерполяция выводит экранированное значение. 
Чтобы вывести значение в сыром виде, применяется директива v-html: 
<div v-html="prop"></div>  -->  data() { return { prop: '<p>hello</p>' }; }

Чтобы обработать событие, нужно воспользоваться директивой v-on: или сокращенно @
...
<button v-on:click="handler"></button>  -->  methods: { handler() { ... } }
<button @click="или любой код JS"></button>

В обработчик можно также передавать пареметры. Объект события скрывается под
псевдонимом $event. <button v-on:click="handler($event, 23)"></button>  
  -->  methods: { handler(event, someArg) { ... } }

Событию можно задать сразу несколько обработчиков (можно как со скобками, так и без):
<button v-on:click="handler1(), handler2()"></button>

Двухсторонняя привязка реализуется с помощью директивы v-model. Она может применяеться
только к элементам ввода или к компонентам. Ее смысл в том, что сначала элементу
задается некоторое значение из JS, а далее элемент сам меняет это значение 
при вводе данных со страницы:
...
<input type="text" v-model="prop">  -->  data() { return { prop: '' }; }
<input type="text" v-model="prop.value">  
  -->  data () { return { prop: { value: '' } }; }

Директива v-model игнорир. явно заданные значен. в атрибутах: value, checked, selected.

Вычисляемые свойства нужны, чтобы добавить логику к обычным свойствам из data. 
В основном они используются как геттеры в html-шаблоне. Преимущество вычисляемых свойст
над методами в том, что они кешируются на основе своих реактивных зависимостей, т.е.
свойств из data.
...
<input type="text" v-model="name">
<input type="text" v-model="age">
<p>{{accessInfo}}</p>  -->  вместо метода getAccessInfo()

{
  data() {
    return { name: 'Vasya', age: 16 };
  },
  computed: {
    accessInfo() {
      const value = this.age < 18 ? 'запрещен' : 'разрешен';
      return `Доступ ${value}`;
    }
  }
}

Вычисляемое свойство может быть и как getter/setter:
...
{
  computed: {
    accessInfo: {
      get() { return this.value; }
      set(value) { this.value = value }
    }
  }
}

Наблюдаемые свойства нужны для выполнения асинхронных действий. В примере ниже в watch
имеется метод age. Этот метод вызывется тогда, когда изменится свойство age из data(),
а его новое значение будет передано в параметр value.
...
{
  data() {
    return { age: 0, result: '' };
  },
  watch: {
    age(value) {
      setTimeout(() => this.result = `Новый возраст ${value}`, 1000); 
    } 
  }
}

Привязка класса реализуется с помощью записи: 
v-bind:class="{className1: true|false, 'class-name-N': true|false}".
<div v-bind:class="{active: isActive}"></div>  
  -->  data() { return { isActive: false }; }

Если надо привязать много классов, то для этого можно использ. вычисляемое свойство:
<div v-bind:class="cProp"></div>  
  -->  computed: { cProp() { return { class1: value1, class2: value2 }; } }

Также можно сделать простую привязку класса к свойству, которое хранит его название:
<div v-bind:class="prop"></div>  -->  data() { return { prop: 'className' }; }

Простая привязка к множеству свойств с названиями классов:
<div v-bind:class="[prop1, propN]"></div>  
  -->  data() { return { prop1: 'className1', prop2: 'className2' }; }

Подобно привязке классов существует и привязка стилей. 
Здесь используется все те же правила записей что и для классов: 
<div v-bind:style="{color: 'blue', 'background-color': '#fff'}"></div>

Чтобы получить доступ к html-эл-ту и управлять им напрямую по ссылке, можно
воспользоваться атрибутом refs. Доступ к такому элементу внутри JS можно получить 
через специальное свойство $refs.
...
<h2 refs="header">Заголовок</h2>
<button v-on:click="change"></button>

{
  methods: {
    change() { this.$refs.header.innerText = 'Привет!'; } 
  }
}

--------------------------------

ЖИЗНЕННЫЙ ЦИКЛ

При создании объекта Vue:
1) Сначала происходит инициализация (при вызове createApp({...}).mount('...')).
2) После инициализации вызывается метод beforeCreate().
3) Далее происходит создание объекта Vue и установка всех его свойств, методов и т.д.
4) После этого вызывается метод created(), но объект Vue пока еще не связан с элементом
из метода mount().
5) Далее происходит компиляция всех инструкций, которые относятся к Vue, внутри
связанного элемента.
6) Вызывается метод beforeMount().
7) Элемент, который был передан в метод mount() заменяется скомпилированным шаблоном.
8) Вызывается метод mounted() и после уже можно работать с объектом Vue.

При обновлении данных:
1) Сначала изменяются данные.
2) Вызывается метод beforeUpdate().
3) Просходит обновление DOM на основе виртуального DOM. 
4) Вызывается метод updated(). DOM в этот момент уже обновлен и можно работать дальше.

При отвязке объекта Vue от html-элемента, вызывается метод beforeUnmount(), 
а после того как отвяжется - метод unmounted().

Все методы жизненного цикла определяется за пределами объекта methods:
...
{
  methods: {},
  ...
  beforeCreate() {},
  created() {},
  beforeMount() {},
  mounted() {},
  beforeUpdate() {},
  updated() {},
  beforeUnmount() {},
  unmounted() {}
}

--------------------------------

УСЛОВНЫЙ РЕНДЕРИНГ И МАССИВЫ

Директивы v-if|v-else|v-else-if позволяют отображать html-элементы по условию. 
В качестве значения принимается либо свойство с логическим значением, либо выражение JS.
...
<div v-if="prop1">...</div>
<div v-else-if="prop2 == 0">...</div>
<div v-else>...</div>

{
  data() {
    return { prop1: false, prop2: 0 };
  }
}

Директива v-show аналогична v-if, но применяется, когда нужна хорошая производительн.
Она не изменяет структуру DOM, а просто манипулирует свойством display. 
...
<div v-show="prop"></div>  -->  data() { return { prop: true }; }

Директива v-for необходима для перебора массивов:
<p v-for="item in list">{{item}}</p>  --> если у массива 3 эл-та, то вывед 3 параграфа

При переборе доступны также индексы элементов, а еще можно перебирать объекты:
...
<div v-for="(item, index) in list"></div>
<div v-for="(value, key) in obj"></div>

Директива v-for помимо массивов и объектов позволяет перебирать и числа:
<div v-for="n in 10">{{n}}</div>  --> Выведется 1, 2, ..., 10

Дерективы v-if и v-for не следует использовать на одном элементе. 
В этом случае v-if будет иметь больший приоритет даже если стоит после v-for.
...
<div v-for="item in data" v-if="item.value == 0"></div>  -->  Здесь будет ошибка, т.к.
сначала выполнится директива v-if, которая будет обращаться к несуществующ перемен item.

Во Vue в основном все методы для работы с массивами являются обертками вокруг стандарт:
push(), pop(), shift(), unshift(), splice(), sort(), reverse(). Их задача - уведомить
фреймворк после какой либо операции над массивом и соответсвенно вызвать для него
повторный рендеринг страницы.

Есть такие методы, которые не изменяют текущий массив, а возвращают новый: filter(),
concat(), slice(). Результат таких методов рекомендуется привязывать к вычисляемым
свойствам, для лучшей производительности.
...
{
  computed: {
    filteredList() {
      return this.list.filter(item => item % 2 === 0);
    }
  }
}

При работе с v-for каждый элемент списка необходимо помечать ключом v-bind:key. 
В этом случае фреймворк будет точно знать в каком порядке нужно перерисовать элементы,
когда список изменится. Значением key должно быть какое-то уникальное число, 
например id объекта и т.п.
...
<button v-on:click="change"></button>
<my-component v-for="item in list" v-bind:key="item.id"></my-component>

{
  data() {
    return { list: [{ id: 1 }, { id: 2 }] };
  }
  methods: {
    change() {
      this.list.pop();
    }
  }
}

В примере выше, если изменить список, то элементы перерисуются корректно. 
Но если убрать связку v-bind:key, тогда элементы не будут перерисовываться вовсе.

--------------------------------

РАБОТА С ФОРМАМИ

Работа с элементами формы (input, textarea, select) происходит с помощью двухсторонней
связки. Директива v-model связывает атрибут value со свойством из JS и использует
события input для отслеживания изменений.

Если textarea имеет двухстороннюю связку, то внутри него нельзя поместить текст.

При работе с чекбоксами и радиокнопками v-model связывается с checked, а не value. 
Для отслеживания изменений используется событие change. Кроме того, значения чекбоксов
также можно связывать со свойствами из JS:
...
<input type="ckeckbox" v-model="prop" v-bind:true-value="on" v-bind:false-value="off">
<div v-if="prop === on">...</div>  -->  "on" связано со значением чекбокса (true/false)

data() { return { prop: false, on: true, off: false }; }

Такую связку можно сократить. В этом случае значения on/off будут строками, 
а свойство prop будет либо 'on', либо 'off':
...
<input type="checkbox" v-model="prop" true-value="on" false-value="off">
<div v-if="prop === 'on'">...</div>

data() { return { prop: false }; }

Группу чекбоксов можно привязывать к массиву. В этом случае при нажатии на чекбокс, 
его значение из value попадет в массив. Если значение чекбокса/радиокнопки это объект,
тогда вместо value пишем v-bind:value:
...
<input type="checkbox" value="A" v-model="list">
<input type="checkbox" value="B" v-model="list">
<input type="checkbox" v-bind:value="obj" v-model="list">

data() { return { list: [] }; }  -->  Если отметить А и B, тогда list будет ['A', 'B']

При работе со списком (select) его v-model связывается с value которые от options, 
а атрибут selected игнорируется.

Для эффективной работы с формами можно использовать модификаторы полей ввода. 
Они применяются при вводе данных. Добавляются они следующим образом: 
v-model.mod1.modN="prop". 

Список некоторых модификаторов:
* .lazy - меняет событие отслеживания ввода с input на change (для <input>);
* .number - при вводе конвертирует значение со строки в число;
* .trim - при вводе автоматически обрезает у значения начальные и конечные пробелы.

--------------------------------

КОМПОНЕНТЫ

Компонент создается с помощью метода component() у объекта Vue. В этот метод передаются
два аргумента: название компонента и параметрический объект компонента. После этого
компонент доступен для html в виде тега с одноименным названием.
...
const app = Vue.createApp({});  -->  при создан. компонентов, app может быть без парам.
app.component('my-component', { template: '<h1>Hello</h1>' });               
app.mount('#app');

<div id="app"><my-component></my-component></div>

Компонент можно использовать только внутри элемента, который связан с его объектом Vue.
...
<div id="app"></div>
<my-component></my-component>  -->  Так нельзя

Локальный компонент создается с помощью свойства components объекта Vue. Глобальные
компоненты отличаются от локальных тем, что доступны для других компонентов. Когда
локальный компонент регистрируется для объекта Vue, то он доступен только внутри его
html-шаблона. При этом локальным, компонент может быть и по отношению к другому компон.
...
Vue.createApp({ 
  components: { 'local-component1': {...}, 'local-componentN': {...} } 
}).mount('...');

Объект Vue можно определить одновременно и с параметрами, и с компонентами. 
В этом случае внутри связанного элемента будут доступны как свойства/методы самого
объекта так и компоненты.
...
<div id="app">
  <h1>{{title}}</h1>
  <my-component></my-component>
</div>

const app = Vue.createApp({ data() { return { title: 'Hello' }; } });
app.component('my-component', { template: '<p>Some text</p>' });
app.mount('#app');

Параметрический объект компонента также может иметь data() для определения собственных
свойст или methods, для определения собственных методов.

Чтобы передать компоненту данные из вне, нужно опделить в нем свойство props. 
Это свойство - массив ключей, где каждый ключ определяет название какого то пропса.
...
component('my-component', {
  props: ['title', 'text'],
  template: `
    <h2>{{title}}</h2>
    <p>{{text}}</p>
  `
});

<my-component title="привет" text="мир"></my-component>

Вместо передачи пропсов по отдельности, к компоненту можно привязать объект,
соответствующий структуре пропсов: <my-component v-bind="message"></my-component>  
  -->  здесь message это объект { title: '', text: '' }

Если у компонента заданы и пропсы, и свойства через метод data(), тогда при одинаковых
названиях между ними будет коллизия. Объекты и массивы перед. через пропсы по ссылке.

Для того чтобы пропсы имели валидацию, необходимо определить свойство props как объект.
В этом случае ключ объекта будет названием пропса, а значение - набор валидируемых 
параметров: props: { name: { type: String }, age: { type: Number, required: true } } 

Валидируемые параметры:
* type - тип пропса (вместо него можно писать так  -->  props: { name: String });
* required - если true, то пропс должен обязательно иметь значение;
* default - значение по умолчанию или ф-ция (когда пропсу ничего не передается);
* validator - ф-ция которая валидирует значение и возвращает true/false.

Если пропс это объект или массив, то для значения по умолчанию параметр default должен
быть ф-цией, которая возвращает соответсвующее значение (объект или массив).

Получить доступ к дочернему компоненту из родительского можно с помощью ссылки refs:
<child-component ref="child"></child-component>  -->  теперь компонент доступен внутри
  родительского как: this.$refs.child, где child это объект компонента; 
  можно манипулировать его свойствами из метода data() и т.д.

Ссылка $refs устанавливается только после рендеринга компонента. Поэтому не стоит 
ее использовать внутри шаблона компонента или в вычисляемых свойствах.

Свойства объекта props доступны только для чтения.

Чтобы прокинуть данные из дочернего компонента в родительский (либо во внешний объект
Vue), то необходимо на дочернем компоненте определить пользовательское событие, а затем
сгенерировать его из JS кода, с помощью метода $emit('event_name', arg1, argN).
...
<div id="app">
  <p>{{value}}</p>
  <child-component v-on:myinput="handler"></child-component>
</div>

const app = Vue.createApp({
  data() { 
    return { value: '' }; 
  },
  methods: {
    handler(value) { this.value = value; }
  }
});

app.component('child-cmponent', {
  template: `<input type="text" v-on:input="myInput"></input>`,
  methods: {
    myInput(value) { this.$emit('myinput', value); }
  }
});

app.mount('#app');

Чтобы реализовать взаимодействие между сестринскими компонентами, нужно использовать их
родительский компонент, как медиатор. Он будет хранить общие данные и передавать их
компонентам через пропсы. 

При изменении данных в одном из компонентов, они должны передаваться обратно медиатору
через событие. Медиатор, обработав событие и обновив общие данные, снова должен
передать их всем сестринским компонентам.

Помимо пользовательских событий, в дочерние компоненты можно еще пробрасывать колбеки.

Расширить ф-ционал компонентов можно с помощью миксинов. Миксин - это неполный
параметрический объект. В него выносят общие методы/свойства от разных копонентов.
Миксины добавлются через свойство mixins, которое является массивом.

Если и компонент, и миксин определяют одни и те же методы/свойства, тогда миксин
отбрасывается. Чтобы добавить миксин глобально, нужно использовать метод mixin() 
у объекта Vue.

--------------------------------

СЛОТЫ

Тег <slot></slot> необходим чтобы заменить собой внетреннее содержимое компонента. 
Он используется только внутри шаблона компонента и может применятся более одного раза.
Без слотов, все внутренне содержимое компонента будет заменяться его шаблоном.
...
<div id="app">
  <my-component>Привет мир</my-component>
</div>

component('my-component', {
  template: `
    <slot></slot>
    <h3>Заголовок</h3>
    <slot></slot>
  `
});

<div id="app">
  Привет мир
  <h3>Заголовок</h3>
  Привет мир
</div>

Если внутри слота разместить контент, то он будет отображаться по умолчанию, когда
внутреннее содержимое у компонента отсутствует.

Слоты могут быть именованными. Для этого тегу слота необходимо добавить атрибут name.
Если слот без атрибута name, то по умолчанию он имеет имя default.
...
<div id="app">
  <my-component>
    <template v-slot:header><h1>Заголовок</h1><template>
    <template v-slot:default>Какой то текст</template>
  </my-component>
</div>

component('my-conponent', {
  template: `
    <div>
      <slot name="header"></slot>
      <slot></slot>
      <slot name="footer">
        <p>Текст по умолчанию, для слота, который не задан в компоненте</p>
      </slot>
    </div>
  `
});

<div id="app">
  <div>
    <h1>Заголовок</h1>
    Какой то текст
    <p>Текст по умолчанию, для слота, который не задан в компоненте</p>
  </div>
</div>

Чтобы пробросить данные из компонента наружу, можно воспользоваться ограниченными
слотами (scoped slots):
...
<div id="app">
  <my-component>
    <template v-slot:default="props">
      <p>{{props.text}}</p>
    </template>
  </my-component>
</div>

component('my-component', {
  data() {
    return { value: 'Привет мир' };
  },
  template: `
    <div>
      <slot v-bind:text="value"></slot>
    </div>
  `
});

<div id="app">
  <div>
    <p>Привет мир</p>
  </div>
</div>

--------------------------------

МАРШРУТИЗАЦИЯ

Реализуется с помощью расширения vue-router. Чтобы она работала, приложение должно
запускаться на стороне сервера.

Если требуется использовать вне модулей, необходимо дополнительно подключить
соответсвующий JS-файл. 

Общий принцип такой, что каждому маршруту должен соответствовать определенный
компонент. За вывод заданного компонента отвечает тег <router-view></router-view>.
...
<div id="app">
  <router-view></router-view>
</div>

const Home = { template: '<h1>Home page</h1>' };
const About = { template: '<h1>About page</h1>' };

const router = VueRouter.createRouter({
  history: VueRouter.createWebHistory(),
  routes: [ 
    { path: '/', component: Home }, 
    { path: '/about', component: About }
  ],
});

const app = Vue.createApp({});
app.use(router);
app.mount('#app');

Чтобы добавить в шаблон маршрутные ссылки, нужно использовать специальный тег 
<router-link></router-link>.

При клике по ссылке, к ней также будет добавлен класс активности .router-link-active,
но название можно изменить с помощью атрибута active-class.
...
<div id="app">
  <nav>
    <router-link to="/">Home</router-link>
    <router-link to="/about" active-class="active">About</router-link>
  </nav>
</div>

Параметры в маршруте определяются следующим образом:
{ path: '/route/:param1/:paramN', ... }

А передать их можно так:
<router-link to="cars/red">Здесь 1 параметр<router-link>
<router-link to="products/phones/2">Здесь 2 параметра</router-link

Внутри компонента, который загружается по маршруту с параметрами, их можно получить
через свойство $route.params:
...
const About = { template: '<h1>Страница об {{ $route.params.author }}</h1>' }
{ path: 'about/:author', component: About }

В названии маршрута можно использовать регулярные выражения:
:id?       -->  вопросительный знак означает что параметр не обазателен;
:id(\d+)   -->  параметр должен быть только числом;
:id(\d+)?  -->  первый и второй варианты вместе.

Чтобы обработать несуществующий маршрут нужно сделать такую запись:
{ path: ':pathMatch(.*)*', component: MyComponent }

С помощью свойства children можно определить вложенные маршруты.

Маршруты могут быть именованными:
{ path: '/products/:id', component: MyComponent, name: 'products' }
<router-link v-bind:to="{ name: 'products', params: { id: 1 } }">Товар 1</router-link>

Именованными могут быть и представления. Это необходимо в той ситуации, когда по
разными маршрутам нужно рендерить свой набор компонентов.
...
<div id="app">
  <router-view name="header"></router-view>
  <router-view></router-view>
  <router-view name="footer"></router-view>
</div>

const Header = { template: '<p>Header</p>' };
const Page1 = { template: '<p>Page1</p>' };
const Page2 = { template: '<p>Page2</p>' };
const Footer = { template: '<p>Footer</p>' };

[
  {
    path: '/',
    components: {
      header: Header,
      default: Page1
    }
  },
  {
    path: '/about',
    components: {
      header: Header,
      default: Page2,
      footer: Footer
    }
  }
]

Переадресация маршрутов выполняется так:
...
{ path: '/a', redirect: '/b' }
{ path: '/page/:id', redirect: '/ru/page/:id' }
{ path: '/c', redirect: to => '/404' }

{ path: '/', component: MyComponent, name: 'home' }
{ path: '/d', redirect: { name: 'home' } }

Чтобы управлять маршрутизацией из JS, нужно использовать метод $router.push().

--------------------------------

НОВЫЕ ВОЗМОЖНОСТИ

Начиная с версии фреймфорка 3+ приложение создается так:

 import { createApp, ref } from 'vue';

 createApp({
   setup() {
	 const count = ref(0);
     return { count };	
   }	
 }).mount('#app');

 <div id="app">
   <button @click="count++">Счетчик: {{ count }}</button>
 </div>

Теперь в основе лежат две вещи: Composition API и реактивность. Также стоит учитываться, 
что если проект предполагает сборку, то следует использовать однофайловые компоненты (SFC).

Однофайловые компоненты объединяют в себе логику (JS), шаблон (HTML) и стили (CSS).
Они располагаются в файлах с расширением .vue (HTML-подобный формат).

Файл my-component.vue

 <script setup>
   import { ref } from 'vue';
   const count = ref(0);
 </script>

 <template>
   <button @click="count++">Счетчик: {{ count }}</button>
 </template>

 <style scoped>
   button { font-weight: bold; }
 </style>

Файл main.js

 import { createApp } from 'vue';
 import MyComponent from './my-component.vue';
 createApp(MyComponent).mount('#app');
 
В SFC для использования Composition API нужно чтобы тег script был помечен как setup. 
Это необходимо компилятору для добавления доп. преобразований. 

SFC + Composition API:

 <script setup>
   import { ref, onMounted } from 'vue';

   const count = ref(0);

   function increment() {
     count.value++;
   }

   onMounted(() => {
     console.log(`Стартовое значение: ${this.count}`);
   });
 </script>

 <template>
   <button @click="increment">Счётчик: {{ count }}</button>
 </template>

SFC + Optional API (использует Composition API внутри):

 <script>
   export default {
     data() {
       return { count: 0 };
     },

     methods: {
       increment() { 
         this.count++; 
       } 
     },

     mounted() {
       console.log(`Стартовое значение: ${this.count}`);
     }
   };
 </script>

 <template>
   <button @click="increment">Счётчик: {{ count }}</button>
 </template>

Optional API можно выбрать если в приложении не используются инструменты сборки или Vue
используется частично. Composition API + SFC выбирают при созданании полноценных приложений.

Для создания приложения нужен Node.js версии ^20.19.0 || >=22.12.0
В качестве сборщика используется Vite.

 npm create vue@latest
 cd <project-folder>
 npm install

Запуск приложения: npm run dev
Сборка для prod-версии: npm run build 

Использование через CDN: <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
Однофайловые компоненты работать не будут, но можно делать так:

Файл my-component.js (на основе Composition API)

 import { ref } from 'vue';
 export default {
   setup() {
     const count = ref(0);
     return { count }
   },
   template: `<div>Счётчик: {{ count }}</div>`
 }

Файл main.js

 import { createApp } from 'vue';
 import MyComponent from './my-component.js';
 createApp(MyComponent).mount('#app');

Метод mount() следует вызывать после выполнения всех конфигураций приложения и регистрации
нужных ресурсов. Он возвращает экземляр корневого компонета, а не экземляр приложения.

Vue позволяет создавать сразу несколько приложений, каждое из которых будет иметь 
собственную область для конфигурации и глобальных ресурсов. Такой подход рекомендуется
использовать при частичном использовании фреймворка, когда HTML приходит с сервера.

 const app1 = createApp(...).mount('#container1');
 const app2 = createApp(...).mount('#container2');

Если связанный атрибут (через v-bind) получит значение null или undefined, 
то он удалися из отрисовываемого элемента.

Во Vue 3.4, если название атрибута совпадает с названием привязываемой переменной, 
то значение можно не указывать:

 <div v-bind:id></div>  -->  <div v-bind:id="id"></div>

Привязка нескольких атрибутов:

 // const myAttrs = { id: 'container', class: 'wrapper' };
 <div v-bind="myAttrs"></div>  

Если в шаблоне используется код JS, то он имеет ограниченный список глобальных свойств, 
к которым можно обращаться (например Math или Date). Но его можно расширить, 
добавив новые свойства через app.config.globalProperties.

Директивы - это особые атрибуты Vue. Они добавляют какое-то реактивное поведение 
к отрисовываемому DOM-элементу. Все директивы имеют префикс "v-". Аргумент директивы
указывается после двоеточия (например в v-on:click - click будет аргументом).

Аргумент директивы может вычисляться из переменной. В этом случае он должен 
оборачиваться в квадрачные скобки.

 // const myAttr = 'href'; const myEvent = 'click';

 <a v-bind:[myAttr]="url"></a> или <a :[myAttr]="url"></a>
 <a v-on:[myEvent]="doSomething"></a> или <a @[myEvent]="doSomething"></a>

Когда Vue используется вне SFC, то в шаблонах следует избегать именования атрибутов 
в camelCase, т.к. DOM будет преобразовывать их в нижний регистр.

Директивы можно использовать с модификаторами, которые указываются через точку.
Например модификатор prevent указывает v-on вызывать обработчик c e.preventDefault()

 <form @submit.prevent="onSubmit"></form>

Основы реактивности...

