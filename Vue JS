ОСНОВЫ VUE.JS

Концепция Vue операется на реактивность данных. Его главная фишка это двустороння
привязка данных в html и js. Когда данные изменяется в js, происходит перерисовка 
html-шаблона (который их выводит) и наоборот.

Благодаря двухсторонней привязке, Vue реализует часть паттерна MVVM, где View - это
html-шаблон, а ViewModel - то, что реализуется с помощью js.

Чтобы начать работать с Vue, нужно создать его объект, а затем связать его с элементом
на странице. Внутри этого элемента будут доступны все свойства и методы объекта Vue, 
а также директивы и интерполяция. 

Объект Vue создается с помощью метода Vue.createApp({...}), в который передается
параметрический объект. C элементом он связывается с помощью метода mount('selector').

Параметрический объект состоит из:
* метода data - он возвращает объект свойств (подобно объекту state в React);
* свойства methods - в нем определяются методы;
* свойства computeds - в нем определяются вычисляемые свойства;
* свойства watch - в нем определяются наблюдаемые свойства;
* свойства compontents - в нем определяются локальные компоненты;
* свойства mixins - в нем определяются миксины;
* методов жизненного цикла.

Свойства объекта Vue обладают реактивностью. При изменении их в JS, результат также
обновляется и в html.

Внутри интерполяции (фигурных скобок в html) помимо свойст объекта Vue можно также
вызывать и методы. Здесь также допустимы и любые другие выражения JS, например
тернарная операция и т.п.

Свойства и методы объекта Vue не обязательно вызывать именно в html. Их можно вызывать
и в JS, в других файлах к примеру.

Альтернатива интерполяции это атрибут v-text. В нем указывается название свойства,
значен. которого необход. вывести: <div v-text="prop"></div>  -->  <div>{{prop}}</div>

Чтобы связать атрибуты html-тега со свойствами объекта Vue, нужно использовать
директиву v-bind или сокращенно двоеточие: <a v-bind:href="prop1">{{prop2}}</a>  
  -->  data() { return { prop1: '#', prop2: 'hello' }; }

Чтобы отобразить только первоначально значение свойства, без реактиновсти, нужно
использовать директиву v-once: <p v-once>{{prop}}</p>

Интерполяция выводит экранированное значение. 
Чтобы вывести значение в сыром виде, применяется директива v-html: 
<div v-html="prop"></div>  -->  data() { return { prop: '<p>hello</p>' }; }

Чтобы обработать событие, нужно воспользоваться директивой v-on: или сокращенно @
...
<button v-on:click="handler"></button>  -->  methods: { handler() { ... } }
<button @click="или любой код JS"></button>

В обработчик можно также передавать пареметры. Объект события скрывается под
псевдонимом $event. <button v-on:click="handler($event, 23)"></button>  
  -->  methods: { handler(event, someArg) { ... } }

Событию можно задать сразу несколько обработчиков (можно как со скобками, так и без):
<button v-on:click="handler1(), handler2()"></button>

Двухсторонняя привязка реализуется с помощью директивы v-model. Она может применяеться
только к элементам ввода или к компонентам. Ее смысл в том, что сначала элементу
задается некоторое значение из JS, а далее элемент сам меняет это значение 
при вводе данных со страницы:
...
<input type="text" v-model="prop">  -->  data() { return { prop: '' }; }
<input type="text" v-model="prop.value">  
  -->  data () { return { prop: { value: '' } }; }

Директива v-model игнорир. явно заданные значен. в атрибутах: value, checked, selected.

Вычисляемые свойства нужны, чтобы добавить логику к обычным свойствам из data. 
В основном они используются как геттеры в html-шаблоне. Преимущество вычисляемых свойст
над методами в том, что они кешируются на основе своих реактивных зависимостей, т.е.
свойств из data.
...
<input type="text" v-model="name">
<input type="text" v-model="age">
<p>{{accessInfo}}</p>  -->  вместо метода getAccessInfo()

{
  data() {
    return { name: 'Vasya', age: 16 };
  },
  computed: {
    accessInfo() {
      const value = this.age < 18 ? 'запрещен' : 'разрешен';
      return `Доступ ${value}`;
    }
  }
}

Вычисляемое свойство может быть и как getter/setter:
...
{
  computed: {
    accessInfo: {
      get() { return this.value; }
      set(value) { this.value = value }
    }
  }
}

Наблюдаемые свойства нужны для выполнения асинхронных действий. В примере ниже в watch
имеется метод age. Этот метод вызывется тогда, когда изменится свойство age из data(),
а его новое значение будет передано в параметр value.
...
{
  data() {
    return { age: 0, result: '' };
  },
  watch: {
    age(value) {
      setTimeout(() => this.result = `Новый возраст ${value}`, 1000); 
    } 
  }
}

Привязка класса реализуется с помощью записи: 
v-bind:class="{className1: true|false, 'class-name-N': true|false}".
<div v-bind:class="{active: isActive}"></div>  
  -->  data() { return { isActive: false }; }

Если надо привязать много классов, то для этого можно использ. вычисляемое свойство:
<div v-bind:class="cProp"></div>  
  -->  computed: { cProp() { return { class1: value1, class2: value2 }; } }

Также можно сделать простую привязку класса к свойству, которое хранит его название:
<div v-bind:class="prop"></div>  -->  data() { return { prop: 'className' }; }

Простая привязка к множеству свойств с названиями классов:
<div v-bind:class="[prop1, propN]"></div>  
  -->  data() { return { prop1: 'className1', prop2: 'className2' }; }

Подобно привязке классов существует и привязка стилей. 
Здесь используется все те же правила записей что и для классов: 
<div v-bind:style="{color: 'blue', 'background-color': '#fff'}"></div>

Чтобы получить доступ к html-эл-ту и управлять им напрямую по ссылке, можно
воспользоваться атрибутом refs. Доступ к такому элементу внутри JS можно получить 
через специальное свойство $refs.
...
<h2 refs="header">Заголовок</h2>
<button v-on:click="change"></button>

{
  methods: {
    change() { this.$refs.header.innerText = 'Привет!'; } 
  }
}

--------------------------------

ЖИЗНЕННЫЙ ЦИКЛ

При создании объекта Vue:
1) Сначала происходит инициализация (при вызове createApp({...}).mount('...')).
2) После инициализации вызывается метод beforeCreate().
3) Далее происходит создание объекта Vue и установка всех его свойств, методов и т.д.
4) После этого вызывается метод created(), но объект Vue пока еще не связан с элементом
из метода mount().
5) Далее происходит компиляция всех инструкций, которые относятся к Vue, внутри
связанного элемента.
6) Вызывается метод beforeMount().
7) Элемент, который был передан в метод mount() заменяется скомпилированным шаблоном.
8) Вызывается метод mounted() и после уже можно работать с объектом Vue.

При обновлении данных:
1) Сначала изменяются данные.
2) Вызывается метод beforeUpdate().
3) Просходит обновление DOM на основе виртуального DOM. 
4) Вызывается метод updated(). DOM в этот момент уже обновлен и можно работать дальше.

При отвязке объекта Vue от html-элемента, вызывается метод beforeUnmount(), 
а после того как отвяжется - метод unmounted().

Все методы жизненного цикла определяется за пределами объекта methods:
...
{
  methods: {},
  ...
  beforeCreate() {},
  created() {},
  beforeMount() {},
  mounted() {},
  beforeUpdate() {},
  updated() {},
  beforeUnmount() {},
  unmounted() {}
}

--------------------------------

УСЛОВНЫЙ РЕНДЕРИНГ И МАССИВЫ

Директивы v-if|v-else|v-else-if позволяют отображать html-элементы по условию. 
В качестве значения принимается либо свойство с логическим значением, либо выражение JS.
...
<div v-if="prop1">...</div>
<div v-else-if="prop2 == 0">...</div>
<div v-else>...</div>

{
  data() {
    return { prop1: false, prop2: 0 };
  }
}

Директива v-show аналогична v-if, но применяется, когда нужна хорошая производительн.
Она не изменяет структуру DOM, а просто манипулирует свойством display. 
...
<div v-show="prop"></div>  -->  data() { return { prop: true }; }

Директива v-for необходима для перебора массивов:
<p v-for="item in list">{{item}}</p>  --> если у массива 3 эл-та, то вывед 3 параграфа

При переборе доступны также индексы элементов, а еще можно перебирать объекты:
...
<div v-for="(item, index) in list"></div>
<div v-for="(value, key) in obj"></div>

Директива v-for помимо массивов и объектов позволяет перебирать и числа:
<div v-for="n in 10">{{n}}</div>  --> Выведется 1, 2, ..., 10 (начало не с 0, а с 1)

Дерективы v-if и v-for не следует использовать на одном элементе. 
В этом случае v-if будет иметь больший приоритет даже если стоит после v-for.
...
<div v-for="item in data" v-if="item.value == 0"></div>  -->  Здесь будет ошибка, т.к.
сначала выполнится директива v-if, которая будет обращаться к несуществующ перемен item.

Во Vue в основном все методы для работы с массивами являются обертками вокруг стандарт:
push(), pop(), shift(), unshift(), splice(), sort(), reverse(). Их задача - уведомить
фреймворк после какой либо операции над массивом и соответсвенно вызвать для него
повторный рендеринг страницы.

Есть такие методы, которые не изменяют текущий массив, а возвращают новый: filter(),
concat(), slice(). Результат таких методов рекомендуется привязывать к вычисляемым
свойствам, для лучшей производительности.
...
{
  computed: {
    filteredList() {
      return this.list.filter(item => item % 2 === 0);
    }
  }
}

При работе с v-for каждый элемент списка необходимо помечать ключом v-bind:key. 
В этом случае фреймворк будет точно знать в каком порядке нужно перерисовать элементы,
когда список изменится. Значением key должно быть какое-то уникальное число, 
например id объекта и т.п.
...
<button v-on:click="change"></button>
<my-component v-for="item in list" v-bind:key="item.id"></my-component>

{
  data() {
    return { list: [{ id: 1 }, { id: 2 }] };
  }
  methods: {
    change() {
      this.list.pop();
    }
  }
}

В примере выше, если изменить список, то элементы перерисуются корректно. 
Но если убрать связку v-bind:key, тогда элементы не будут перерисовываться вовсе.

--------------------------------

РАБОТА С ФОРМАМИ

Работа с элементами формы (input, textarea, select) происходит с помощью двухсторонней
связки. Директива v-model связывает атрибут value со свойством из JS и использует
события input для отслеживания изменений.

Если textarea имеет двухстороннюю связку, то внутри него нельзя поместить текст.

При работе с чекбоксами и радиокнопками v-model связывается с checked, а не value. 
Для отслеживания изменений используется событие change. Кроме того, значения чекбоксов
также можно связывать со свойствами из JS:
...
<input type="ckeckbox" v-model="prop" v-bind:true-value="on" v-bind:false-value="off">
<div v-if="prop === on">...</div>  -->  "on" связано со значением чекбокса (true/false)

data() { return { prop: false, on: true, off: false }; }

Такую связку можно сократить. В этом случае значения on/off будут строками, 
а свойство prop будет либо 'on', либо 'off':
...
<input type="checkbox" v-model="prop" true-value="on" false-value="off">
<div v-if="prop === 'on'">...</div>

data() { return { prop: false }; }

Группу чекбоксов можно привязывать к массиву. В этом случае при нажатии на чекбокс, 
его значение из value попадет в массив. Если значение чекбокса/радиокнопки это объект,
тогда вместо value пишем v-bind:value:
...
<input type="checkbox" value="A" v-model="list">
<input type="checkbox" value="B" v-model="list">
<input type="checkbox" v-bind:value="obj" v-model="list">

data() { return { list: [] }; }  -->  Если отметить А и B, тогда list будет ['A', 'B']

При работе со списком (select) его v-model связывается с value которые от options, 
а атрибут selected игнорируется.

Для эффективной работы с формами можно использовать модификаторы полей ввода. 
Они применяются при вводе данных. Добавляются они следующим образом: 
v-model.mod1.modN="prop". 

Список некоторых модификаторов:
* .lazy - меняет событие отслеживания ввода с input на change (для <input>);
* .number - при вводе конвертирует значение со строки в число;
* .trim - при вводе автоматически обрезает у значения начальные и конечные пробелы.

--------------------------------

КОМПОНЕНТЫ

Чтобы использовать компоненты, нужно их зарегистрировать. Глобальная регистрация доступна
через метод component() объекта Vue. В этот метод передаются два аргумента: название
компонента и параметрический объект компонента.
...
const app = Vue.createApp({});  -->  при создан. компонентов, app может быть без парам.
app.component('my-component', { template: '<h1>Hello</h1>' });               
app.mount('#app');

<div id="app"><my-component></my-component></div>

Компонент можно использовать только внутри элемента, который связан с его объектом Vue.
...
<div id="app"></div>
<my-component></my-component>  -->  Так нельзя

Локальные компоненты регистрируются с пом. свойства components объекта Vue или другого
компонента. В отличие от глобальных, они доступны только там, где регистрируются.
...
Vue.createApp({ 
  components: { 
    'local-component': {...},   // Эти компоненты будут доступны только в объекте Vue
    'local-component2': {...}   // и недоступны в других компонентах
  } 
}).mount('...');

Объект Vue можно определить одновременно и с параметрами, и с компонентами. 
В этом случае внутри связанного элемента будут доступны как свойства/методы самого
объекта так и компоненты.
...
<div id="app">
  <h1>{{title}}</h1>
  <my-component></my-component>
</div>

const app = Vue.createApp({ data() { return { title: 'Hello' }; } });
app.component('my-component', { template: '<p>Some text</p>' });
app.mount('#app');

Параметрический объект компонента также может иметь data() для определения собственных
свойст или methods, для определения собственных методов.

Чтобы передать компоненту данные из вне, нужно опделить в нем свойство props. 
Это свойство - массив ключей, где каждый ключ определяет название какого то пропса.
...
component('my-component', {
  props: ['title', 'text'],
  template: `
    <h2>{{title}}</h2>
    <p>{{text}}</p>
  `
});

<my-component title="привет" text="мир"></my-component>

Вместо передачи пропсов по отдельности, к компоненту можно привязать объект,
соответствующий структуре пропсов: <my-component v-bind="message"></my-component>  
  -->  здесь message это объект { title: '', text: '' }

Если у компонента заданы и пропсы, и свойства через метод data(), тогда при одинаковых
названиях между ними будет коллизия. Объекты и массивы перед. через пропсы по ссылке.

Для того чтобы пропсы имели валидацию, необходимо определить свойство props как объект.
В этом случае ключ объекта будет названием пропса, а значение - набор валидируемых 
параметров: props: { name: { type: String }, age: { type: Number, required: true } } 

Валидируемые параметры:
* type - тип пропса (вместо него можно писать так  -->  props: { propName: String });
* required - если true, то пропс должен обязательно иметь значение;
* default - значение по умолчанию или ф-ция (когда пропсу ничего не передается);
* validator - ф-ция которая валидирует значение и возвращает true/false.

Тип пропса может быть составным. В этом случае все заданные типы перечесляются в массиве.
propName: [String, Number]  -->  propName или строка или число

Если пропс это объект или массив, то для значения по умолчанию параметр default должен
быть ф-цией, которая возвращает соответсвующее значение (объект или массив).

Получить доступ к дочернему компоненту из родительского можно с помощью ссылки refs:
<child-component ref="child"></child-component>  -->  теперь компонент доступен внутри
  родительского как: this.$refs.child, где child это объект компонента; 
  можно манипулировать его свойствами из метода data() и т.д.

Ссылка $refs устанавливается только после рендеринга компонента. Поэтому не стоит 
ее использовать внутри шаблона компонента или в вычисляемых свойствах.

Свойства объекта props доступны только для чтения.

Чтобы прокинуть данные из дочернего компонента в родительский (либо во внешний объект
Vue), то необходимо на дочернем компоненте определить пользовательское событие, а затем
сгенерировать его из JS кода, с помощью метода $emit('event_name', arg1, argN).
...
<div id="app">
  <p>{{value}}</p>
  <child-component v-on:myinput="handler"></child-component>
</div>

const app = Vue.createApp({
  data() { 
    return { value: '' }; 
  },
  methods: {
    handler(value) { this.value = value; }
  }
});

app.component('child-cmponent', {
  template: `<input type="text" v-on:input="myInput"></input>`,
  methods: {
    myInput(value) { this.$emit('myinput', value); }
  }
});

app.mount('#app');

Чтобы реализовать взаимодействие между сестринскими компонентами, нужно использовать их
родительский компонент, как медиатор. Он будет хранить общие данные и передавать их
компонентам через пропсы. 

При изменении данных в одном из компонентов, они должны передаваться обратно медиатору
через событие. Медиатор, обработав событие и обновив общие данные, снова должен
передать их всем сестринским компонентам.

Помимо пользовательских событий, в дочерние компоненты можно еще пробрасывать колбеки.

Расширить ф-ционал компонентов можно с помощью миксинов. Миксин - это неполный
параметрический объект. В него выносят общие методы/свойства от разных копонентов.
Миксины добавлются через свойство mixins, которое является массивом.

Если и компонент, и миксин определяют одни и те же методы/свойства, тогда миксин
отбрасывается. Чтобы добавить миксин глобально, нужно использовать метод mixin() 
у объекта Vue.

--------------------------------

СЛОТЫ

Тег <slot></slot> необходим чтобы заменить собой внетреннее содержимое компонента. 
Он используется только внутри шаблона компонента и может применятся более одного раза.
Без слотов, все внутренне содержимое компонента будет заменяться его шаблоном.
...
<div id="app">
  <my-component>Привет мир</my-component>
</div>

component('my-component', {
  template: `
    <slot></slot>
    <h3>Заголовок</h3>
    <slot></slot>
  `
});

<div id="app">
  Привет мир
  <h3>Заголовок</h3>
  Привет мир
</div>

Если внутри слота разместить контент, то он будет отображаться по умолчанию, когда
внутреннее содержимое у компонента отсутствует.

Слоты могут быть именованными. Для этого тегу <slot> необходимо добавить атрибут name.
Если слот без атрибута name, то по умолчанию он имеет имя default. 

Чтобы задать содержимое для именованого слота, нужно использовать тег <template с директивой
v-slot, а директиве передать имя слота, на месте которого будет этот <template>. 

Содержимое, не обернутое в <template>, будет неявно подставляться на место default-слота.

<div id="app">
  <my-component>
    Текст для слота по умолчанию
    <template v-slot:header><h1>Заголовок</h1><template>
  </my-component>
</div>

component('my-conponent', {
  template: `
    <div>
      <slot name="header"></slot>
      <slot></slot>
      <slot name="footer">
        <p>Текст для слота, который не задан в компоненте</p>
      </slot>
    </div>
  `
});

<div id="app">
  <div>
    <h1>Заголовок</h1>
    Текст для слота по умолчанию
    <p>Текст для слота, который не задан в компоненте</p>
  </div>
</div>

Запись v-slot: имеет сокращение #, поэтому <template v-slot:header> 
можно сократить до <template #header>

Чтобы проверить, было ли передано содержимое в слот, можно использовать свойство $slots
...
<div v-if="$slots.header" class="header">
  <slot name="header" />
</div

Чтобы пробросить данные из компонента наружу, можно воспользоваться слотами 
с ограниченной областью видимости (scoped slots):
...
<div id="app">
  <my-component>
    <template v-slot:default="props">
      <p>{{props.myText}}</p>
    </template>
  </my-component>
</div>

component('my-component', {
  data() {
    return { value: 'Привет мир' };
  },
  template: `
    <div>
      <slot v-bind:myText="value"></slot>
    </div>
  `
});

<div id="app">
  <div>
    <p>Привет мир</p>
  </div>
</div>

Компоненты, которые ничего не отображают, но содержат логику и пробрасывают ее наружу,
называются компонентами без рендеринга (renderless components), но вместо них 
рекомендуется использовать composable-функции, т.к. создание экземпляров компонентов 
требует большей производительности:
...
<mouse-tracker v-slot="{ x, y }">  // здесь для props задана декструктуризация
  Позиция: {{ x }}, {{ y }}
</mouse-tracker>

--------------------------------

МАРШРУТИЗАЦИЯ

Реализуется с помощью библиотеки vue-router. Чтобы она работала, приложение должно
запускаться на стороне сервера.

Если требуется использовать вне модулей, необходимо дополнительно подключить
соответсвующий JS-файл. 

Общий принцип такой, что каждому маршруту должен соответствовать определенный
компонент. За вывод заданного компонента отвечает тег <router-view></router-view>.
...
<div id="app">
  <router-view></router-view>
</div>

const Home = { template: '<h1>Home page</h1>' };
const About = { template: '<h1>About page</h1>' };

const router = VueRouter.createRouter({
  history: VueRouter.createWebHistory(),
  routes: [ 
    { path: '/', component: Home }, 
    { path: '/about', component: About }
  ],
});

const app = Vue.createApp({});
app.use(router);
app.mount('#app');

Чтобы добавить в шаблон маршрутные ссылки, нужно использовать специальный тег 
<router-link></router-link>.

При клике по ссылке, к ней также будет добавлен класс активности .router-link-active,
но название можно изменить с помощью атрибута active-class.
...
<div id="app">
  <nav>
    <router-link to="/">Home</router-link>
    <router-link to="/about" active-class="active">About</router-link>
  </nav>
</div>

Параметры в маршруте определяются следующим образом:
{ path: '/route/:param1/:paramN', ... }

А передать их можно так:
<router-link to="cars/red">Здесь 1 параметр<router-link>
<router-link to="products/phones/2">Здесь 2 параметра</router-link

Внутри компонента, который загружается по маршруту с параметрами, их можно получить
через свойство $route.params:
...
const About = { template: '<h1>Страница об {{ $route.params.author }}</h1>' }
{ path: 'about/:author', component: About }

В названии маршрута можно использовать регулярные выражения:
:id?       -->  вопросительный знак означает что параметр не обазателен;
:id(\d+)   -->  параметр должен быть только числом;
:id(\d+)?  -->  первый и второй варианты вместе.

Чтобы обработать несуществующий маршрут нужно сделать такую запись:
{ path: ':pathMatch(.*)*', component: MyComponent }

С помощью свойства children можно определить вложенные маршруты.

Маршруты могут быть именованными:
{ path: '/products/:id', component: MyComponent, name: 'products' }
<router-link v-bind:to="{ name: 'products', params: { id: 1 } }">Товар 1</router-link>

Именованными могут быть и представления. Это необходимо в той ситуации, когда по
разными маршрутам нужно рендерить свой набор компонентов.
...
<div id="app">
  <router-view name="header"></router-view>
  <router-view></router-view>
  <router-view name="footer"></router-view>
</div>

const Header = { template: '<p>Header</p>' };
const Page1 = { template: '<p>Page1</p>' };
const Page2 = { template: '<p>Page2</p>' };
const Footer = { template: '<p>Footer</p>' };

[
  {
    path: '/',
    components: {
      header: Header,
      default: Page1
    }
  },
  {
    path: '/about',
    components: {
      header: Header,
      default: Page2,
      footer: Footer
    }
  }
]

Переадресация маршрутов выполняется так:
...
{ path: '/a', redirect: '/b' }
{ path: '/page/:id', redirect: '/ru/page/:id' }
{ path: '/c', redirect: to => '/404' }

{ path: '/', component: MyComponent, name: 'home' }
{ path: '/d', redirect: { name: 'home' } }

Чтобы управлять маршрутизацией из JS, нужно использовать метод $router.push().

--------------------------------

НОВЫЕ ВОЗМОЖНОСТИ

Начиная с версии фреймфорка 3+ приложение создается так:

 import { createApp, ref } from 'vue';

 createApp({
   setup() {
	 const count = ref(0);
     return { count };	
   }	
 }).mount('#app');

 <div id="app">
   <button @click="count++">Счетчик: {{ count }}</button>
 </div>

Теперь в основе лежат две вещи: Composition API и реактивность. Также стоит учитываться, 
что если проект предполагает сборку, то следует использовать однофайловые компоненты (SFC).

Однофайловые компоненты объединяют в себе логику (JS), шаблон (HTML) и стили (CSS).
Они располагаются в файлах с расширением .vue (HTML-подобный формат).

 <script setup>
   import { ref } from 'vue';
   const count = ref(0);
 </script>

 <template>
   <button @click="count++">Счетчик: {{ count }}</button>
 </template>

 <style scoped>
   button { font-weight: bold; }
 </style>
 
В SFC для использования Composition API нужно чтобы тег script был помечен как setup. 
Это необходимо компилятору для добавления доп. преобразований. 

SFC + Composition API:

 <script setup>
   import { ref, onMounted } from 'vue';

   const count = ref(0);

   function increment() {
     count.value++;
   }

   onMounted(() => {
     console.log(`Стартовое значение: ${this.count}`);
   });
 </script>

 <template>
   <button @click="increment">Счётчик: {{ count }}</button>
 </template>

SFC + Optional API:

 <script>
   export default {
     data() {
       return { count: 0 };
     },

     methods: {
       increment() { 
         this.count++; 
       } 
     },

     mounted() {
       console.log(`Стартовое значение: ${this.count}`);
     }
   };
 </script>

 <template>
   <button @click="increment">Счётчик: {{ count }}</button>
 </template>

Optional API можно выбрать если в приложении не используются инструменты сборки или Vue
используется частично. Composition API + SFC выбирают при созданании полноценных приложений.

Для создания приложения нужен Node.js версии ^20.19.0 || >=22.12.0
В качестве сборщика используется Vite.

 npm create vue@latest
 cd <project-folder>
 npm install

Запуск приложения: npm run dev
Сборка для prod-версии: npm run build 

Использование через CDN: <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
Однофайловые компоненты работать не будут, но можно определить модуль компонента:

Файл my-component.js (Optional API)

 import { ref } from 'vue';
 export default {
   setup() {
     const count = ref(0);
     return { count }
   },
   template: `<div>Счётчик: {{ count }}</div>`  // вместо разметки можно задать селектор
 }

Файл main.js

 import { createApp } from 'vue';
 import MyComponent from './my-component.js';
 createApp(MyComponent).mount('#app');

Метод mount() следует вызывать после выполнения всех конфигураций приложения и регистрации
нужных ресурсов. Он возвращает экземляр корневого компонета, а не экземляр приложения.

Vue позволяет создавать сразу несколько приложений, каждое из которых будет иметь 
собственную область для конфигурации и глобальных ресурсов. Такой подход рекомендуется
использовать при частичном использовании фреймворка, когда HTML приходит с сервера.

 const app1 = createApp(...).mount('#container1');
 const app2 = createApp(...).mount('#container2');

Если связанный атрибут (через v-bind) получит значение null или undefined, 
то он удалися из отрисовываемого элемента.

Во Vue 3.4, если название атрибута совпадает с названием привязываемой переменной, 
то значение можно не указывать:

 <div v-bind:id></div>  -->  <div v-bind:id="id"></div>

Привязка нескольких атрибутов:

 // const myAttrs = { id: 'container', class: 'wrapper' };
 <div v-bind="myAttrs"></div>  

Если в шаблоне используется код JS, то он имеет ограниченный список глобальных свойств, 
к которым можно обращаться (например Math или Date). Но его можно расширить, 
добавив новые свойства через app.config.globalProperties.

Директивы - это особые атрибуты Vue. Они добавляют какое-то реактивное поведение 
к отрисовываемому DOM-элементу. Все директивы имеют префикс "v-". Аргумент директивы
указывается после двоеточия (например в v-on:click - click будет аргументом).

Аргумент директивы может вычисляться из переменной. В этом случае он должен 
оборачиваться в квадрачные скобки.

 // const myAttr = 'href'; const myEvent = 'click';

 <a v-bind:[myAttr]="url"></a> или <a :[myAttr]="url"></a>
 <a v-on:[myEvent]="doSomething"></a> или <a @[myEvent]="doSomething"></a>

Когда Vue используется вне SFC, то в шаблонах следует избегать именования атрибутов 
в camelCase, т.к. DOM будет преобразовывать их в нижний регистр.

Директивы можно использовать с модификаторами, которые указываются через точку.
Например модификатор prevent указывает v-on вызывать обработчик c e.preventDefault()

 <form @submit.prevent="onSubmit"></form>

В Composition API для определения реактивного состояния используется ф-ция ref().
Она принимает какое-то значение и возвращает его обертку со свойством value.

 const count = ref(23);
 console.log(count.value);  // 23

Обертка делает свое значение глубоко реактивным. Это означает, что обнаружения изменений
происходит даже при мутации вложенных объектов или массивов.

Чтобы отказаться от глубокой реактивности, нужно использовать ф-цию shallowRef(). 
Это полезно при оптимизации или когда внутреннее состояние управляется внешней библиотекой.

Если вместо SFC используется модуль компонента, то реактивное состояние нужно объявлять 
в методе setup(), а затем возвращать его, чтобы оно могло быть доступно в шаблоне. 
Внутри setup() можно также объявлять вспомогательные ф-ции.

 export default {
   setup() {
     const count = ref(0);

     function increment() {
       count.value++;
     }

     return { count, increment }; 
   }
 };

При обновлении состояния, DOM обновляется автоматически, но не сразу. Чтобы дождаться 
обновления DOM после изменения состояния можно использовать ф-цию nextTick().

 import { nextTick } from 'vue';

 async function increment() {
   count.value++;
   await nextTick();
 }

Если реактивное состояние является объектом, то вместо ref() можно использовать reactive().
Эта ф-ция создает реактивное прокси для передаемого объекта (до самой глубины), а не
оборачивает его. Под капотом ref() для объектов также использует reactive(). 

Для неглубокой реактивности объекта нужно использовать shallowReactive().
При деструктуризации реактивного объекта, локальные переменные теряют реактивность.

Если реактивное состояние является свойством реактивного объекта, то при обращении к нему
через объект, оно автоматически разворачивается и ведет себя как обычное свойство:

 const count = ref(23);
 const state = reactive({ count });
 console.log(state.count);  // 23

Но если реактивное состояние является элементом реактивного массива или нативной коллекции
(например Map), то автоматического разворачивания не будет.

Вычисляемые свойства объявляются с помощью ф-ции computed(), которая возвращает ref-значени.
Когда нет надобности в кэшировании, то нужно использовать обычныю ф-цию.

 const author = reactive({ name: 'John Doe', age: 23 });
 const isValidAge = computed(() => author.age > 18);

Вычисляемое свойство может иметь также сеттер:

 сonst firstName = ref('John');
 сonst secondName = ref('Doe');

 const fullName = computed({
   get() { 
     return firstName.value + ' ' + lastName.value; 
   }
   set(value) { 
     [firstName.value, lastName.value] = value.split(' '); 
   }
 });

Во Vue 3.4+ вычисляемое свойство может иметь доступ к предыдущему значению:

 const count = ref(2);
 const myProp = computed(prev => {
   return count.value <= 3 ? count.value : prev;
 });

Популярные способы привязки css-классов и стилей:

1) Через вычисляемое свойство:

 const isActive = ref(true);
 const error = ref(null);

 const classObj = computed({
   active: isActive.value && !error.value,
   'text-danger': error.value && error.value.type === 'fatal',
 });

 <div :class="classObj"></div>

2) Через массив:

 const activeClass = ref('active')
 const errorClass = ref('text-danger')

 <div :class="[isActive ? activeClass : '', errorClass]"></div>
 <div :class="[{ [activeClass]: isActive }, errorClass]"></div>

При использовании атрибута class на компоненте, класс будет устанавливаться на корневом
элементе шаблона (это относится ко всем стандартным HTML-атрибутам). Но если корневых
элементов несколько, то для них нужно явно указать, через $attrs.class, какому именно эл-ту
будут задаваться классы (в $attrs содержатся все стандартные HTML-атрибуты, что заданы для
компонента; его можно даже привязать к конкретному элементу в шаблоне через v-bind):

 <my-component class="foo" />  
 // Корневой элемент в шаблоне компонента
 <p class="foo">Hello!<p>

 <my-component class="bar" /> 
 // Если корневых элементов несколько
 <p :class="$attrs.class">Hello!<p>  // или так <p v-bind="$attrs">...</p>
 <p>World</p>
 
Директивы :class, :style могут использоваться вместе а одноименными атрибутами.
При указании стилей Vue автоматически добавляет вендорные префиксы.

Если на корневом элементе компонента уже имеются атрибуты class или style, то они будут
объеденены с теми, что заданы для компонента. Но такое поведение можно отключить с помощью
опции inheritAttrs: false, передаваемой в макрос defineOptions().

Для указания множества значений для одного стиля, можно использовать массив:

 // Будет выбрано только одно значение из массива, которое поддерживается браузером
 <div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>

Если нужно сделать условную группу элементов, то вместо div можно использовать template.

 <template v-if="type === 'A'">
  <h1>Заголовок</h1>
  <p>Параграф 1</p>
 </template>

Директиву v-show нельзя использовать на элементе template и она не работает с v-else.
Ее следует использовать когда переключение элементов слишком частые, но при этом следует
помнить, что слушатели событий и дочерние компоненты будут работать даже если блок скрыт.

При использовании v-for, итерируемый элемент можно деструктуризировать.
Вместо ключевого слова in можно также использовать of.

 <li v-for="{ message } in items">{{ message }}</li>
 <li v-for="({ message }, index) in items">{{ message }} - {{ index }}</li>

 // Если items - это объект, то item будет соответствовать value из kvp
 <div v-for="item of items"></div>

Директиву v-for можно также использовать с template.

Привязка :key использует только примитивные значения. Ее можно вообще не указывать, если
итерируемые элементы простые (т.е. не компоненты и не элементы с состоянием).

Передать итерируемые данные в компонент можно так:

 // key - это не входной параметр, а специальная привязка для правильной работы v-for
 <my-component v-for="item in items" :item="item" :key="item.id" />

Модификаторы событий: .stop, .prevent, .self, .capture, .once, .passive

 // Всплытие события click будет остановлено
 <a @click.stop="doThis"></a>

 // Событие submit перестанет перезагружать страницу
 <form @submit.prevent="onSubmit"></form>

 // Модификаторы можно объединять в цепочки
 <a @click.stop.prevent="doThat"></a>

 // Можно использовать без указания обработчиков
 <form @submit.prevent></form>

 // Вызов обработчика только в случае наступления события непосредственно
 // на данном элементе (то есть не на дочернем компоненте)
 <div @click.self="doThat">...</div>

Для событий можно также использовать модификаторы клавиш. В этом случае события будут
обрабатываться только если нажата определенная клавиша.

 // Вызвать submit() только если `key` клавиши будет `Enter`
 <input @keyup.enter="submit" />

 // Названия модификаторов клавиш соответсвуют KeyboardEvent.key в kebab-case.
 <input @keyup.page-down="onPageDown" />

Модификаторы частых клавиш: .enter, .tab, .delete, .esc, .space, .up, .down, .left, .right
Модификаторы системных клавиш: .ctrl, .alt, .shift, .meta (⌘ на Mac или ⊞ на Windows)
Модификаторы кнопок мыши: .left, .right, .middle (основная, вторичная и вспомогательная)

 // Alt + Enter
 <input @keyup.alt.enter="clear" />

 // Ctrl + Click
 <div @click.ctrl="doSomething">...</div>

Модификатор .exact контролирует точную комбинацию модификаторов системных клавиш:

 // Сработает, даже если также будут нажаты Alt или Shift
 <button @click.ctrl="onClick">A</button>

 // Сработает, только когда нажат Ctrl и не нажаты никакие другие клавиши
 <button @click.ctrl.exact="onCtrlClick">A</button>

 // Сработает, только когда не нажаты никакие системные клавиши
 <button @click.exact="onClick">A</button>
 
Внутри элемента textarea интерполяция не работает. Нужно использовать только v-model.

При использовании v-model с элементом select, если начальное значение v-model не соотвествует
ни одному из вариантов списка, то select будет отображаться в невыбранном состоянии. В iOS
это приведет к тому, что пользователь не сможет выбрать первый элемент. Поэтому первым
элементом select вседа следует указывать откюченный option c пустым значением.

Выбор нескольких вариантов из списка с привязкой к массиву:

 // Все выбранные option попадут в массив myList по аналогии с checkbox 
 // (а точнее тот текст, что находится между тегов)

 <select v-model="myList" multiple>
  <option>А</option>
  <option>Б</option>
 </select>

Привязка состояния к радиокнопке:

 // Состояние pick будет установлено в first при выборе первой радиокнопки 
 // и в second, при выборе второй

 <input type="radio" v-model="pick" :value="first" />
 <input type="radio" v-model="pick" :value="second" />

Для запуска сайд-эффектов, в ответ на изменение состояний, используются вотчеры.
В Composition API они объявляются с помощью ф-ции watch().

 const question = ref('');
 const answer = ref('Вопросы заканчиваются знаком вопроса');

 watch(question, async (newQuestion, oldQuestion) => {
   if (newQuestion.includes('?')) {
     const res = await fetch('https://...');
     answer.value = await res.json();
   }
 });

Первый параметр watch() может быть ref, реактивный объект, ф-ция (по типу вычисляемого
свойства) или массив из переменных от этого перечня. При этом за отдельным свойством
реактивного объекта наблюдать нельзя. Вместо этого нужно использовать ф-цию.

 сonst obj = reactive({ count: 0 });

 // Это работать не будет    // Нужно делать так
 watch(obj.count, ...);      watch(() => obj.count, ...);

Но если указать вотчеру реактивный объект, а не его свойство, то наблюдение будет 
до самой глубины. Глубину наблюдения можно настраивать с пом. опции deep.

Если требуется, чтобы вотчер запускался только единожды, то нужно указать опцию once.

По умолчанию, вотчер запускается при изменении состояния. Но если требуется чтобы он
запускался сразу, например для получения начальных данных, то нужно указать опцию immediate.
 
 watch(todoId, async () => {
  const res = await fetch(`https://typicode.com/todos/${todoId.value}`);
  data.value = await response.json();
 }, { immediate: true });

Вотчер выше можно заменить на ф-цию watchEffect(). Она делает тоже самое, но ей не нужно
указывать никаких состояний для отслеживания. Эта ф-ция сама отслиживает изменения 
всех состояний внутри своего колбека (но после await уже не работает).

 // Если todoId.value где-то изменится, то watchEffect это сам отследит 
 // (аналогично вычисляемому свойству) и вызовет колбек.

 watchEffect(async () => {
   const res = await fetch(`https://typicode.com/todos/${todoId.value}`);
   data.value = await response.json();
 });

Бывает так, что наблюдаемое состояние меняется до того, как будет получен ответ от 
сайд-эффекта и результат получается уже неактуальным. В таких ситуациях сайд-эффект можно
отменять. Это делается либо через отдельную ф-цию onWatcherCleanup() внутри колбека 
(также не работает после await), либо через третий параметр колбека.

 // Здесь колбек синхронный. При изменении source, запрос отменится.

 watch(source, (newValue, oldValue, onCleanup) => {
   const controller = new AbortController();
   fetch(url, { constroller.signal }).then(...)
   onCleanup(() => controller.abort());
 });

По умолчанию, колбек вотчера вызывается до обновления DOM. Если нужно получить доступ к DOM
из вотчера после того, как Vue обновит его, нужно указать опцию { flush: 'post' }
Также существует аналогичная ф-ция watchPostEffect().

По умолчанию вотчер останавливается автоматически, при размонтировании компонента. Но если
вотчер вызывается в асинхронном потоке, то его нужно останавливать вручную, иначе будут
утечки памяти. Это делается с пом. ф-ции unwatch, которую возвращает сам вотчер.

 setTimeout(() => {
   const unwatch = watchEffect(() => { });
   ...
   unwatch();
 }, 100);

Во Vue 3.5+ чтобы получить ссылку на DOM-элемент, используется хелпер useTemplateRef().
Ссылка будет доступна только после того, как смонтируется компонент. Ссылку можно
устанавливать не только на DOM-элементы, но и на компоненты.

 <script setup>
   const input = useTemplateRef('my-input'); 

   onMounted(() => {
     input.value.focus();
   });
 </script>

 <template>
   <input ref="my-input" />
 </template>

Компоненты, использующие <script setup> по умолчанию являются приватными. Обращаясь к таким
компонентам по ссылке не получится получить доступ ни к чему, пока тот не раскроет 
публичный интерфейс с помощью макроса defineExpose.

Для ref в шаблоне можно указать не только строку, но и ф-цию. В этом случае ref должен
задаваться через привязку. Ф-ция получая ссылку в параметрах.

 <input :ref="(el) => { }">

Чтобы компонент был доступен в внутри другого компонента, его нужно просто 
импортировать в <script setup>. 

В SFC рекомендуется именовать компоненты в PascalCase, чтобы отличать их от HTML-элементов.
Все что указано внутри vue-файла самостостоятельно экспортируется как компонент.
Компоненты можно указывать через самозакрывающиеся теги (<MyComponent />).

Входные параметры компонента можно получить через макрос defineProps(). Этот макрос
используется только внутри <script setup> и его не нужно явно импортировать. 
Он принимает список имен входных параметров.

 Файл сhild-сomponent.vue

 <script setup>
   const props = defineProps(['title', 'text']);
   console.log(props.title);  // 'hello'
 </script>

 Файл parent-component.vue
 
 <script setup>
   import ChildComponent from './child-component';
 </script>
 
 <template>
   <ChildComponent title="hello" text="world" />
 </template>

Если во входные параметры нужно передавать динамические значения, например состояния, 
или если передаваемые значения не статические строки, то атрибуты должны быть с привязкой.

 <ChildComponent :title="post.title" :text="post.text" />
 <ChildComponent :count="42" :is-published="false" />

Кроме списка имен, defineProps() может также принимать объект с валидациями, такой же 
как и при определении свойства props в Optional API (см. в начале конспекта).

Чтобы зарегистрировать события для компонента, нужно использовать макрос defineEmits().
Он возвращает ф-цию emit() с пом. которой можно испустить событие из кода.
Чтобы испустить событие из шаблона, используется метод $emit().

 Файл child-component.vue

 <script setup>
   const emit = defineEmits(['my-event', 'my-event2']);
   emit('my-event', 23);
 </script> 

 <template>
   <button @click="$emit('myEvent')">Кнопка</button>
 </template>

 Файл parent-component.vue

 <script setup>
   import ChildComponent from './child-component';
   function myListener(value) { }
 </script>

 <template>
   <ChildComponent @my-event="myListener" />
 </template>

Входные парметры и события (да и все атрибуты в целом) следует именовать в kebab-case.

Если вместо SFC используется модуль компонента, то входные параметры должны быть
зарегистрированы в опции props, а события - в опции emits. Получить входные параметры 
и доступ к методу emit() можно в setup().

 export default {
   props: ['title', 'text'],
   emits: ['my-event', 'my-event2'],

   setup(props, ctx) { 
     console.log(props.title);
     ctx.emit('my-event');
   }
 }

По аналогии с пропсами, в defineEmits() можно также передавать объект с валидациями.
Ключами будут названия событий, а значениями - валидирующие ф-ции, возвращающие boolean.

 const emit = defineEmits({

   click: null,  // событие без валидации

   submit: payload => {
     return payload.email && payload.password; 
   },
 }); 

Если требуется переключать компоненты динамически, то это можно сделать с помощью элемента
component с атрибутом is. Значением is может быть имя компонента или объект с настройками
компонента. При переключении компонентов, отключаемый будет размонтирован.

 <component :is="tabs[currentTab]"></component>

Если шаблоны Vue определяются непосредственно в HTML-файлах, то из за спецификации HTML 
будут накладываться некоторые ограничения.

1) Теги компонентов, а также атрибуты должны указываться в kebab-case.
2) Компоненты нельзя указывать через самозакрывающиеся теги.

3) Некоторые элементы (например table, ul, select) не допускают чтобы внутри них были
сторонние теги. В этом случае парсер HTML будет выносить их за пределы. Чтобы такого не было,
нужно использовать атрибут is, как при определении дочернего веб-компонента. Но чтобы
отделить стандартный веб-компонент от компонента Vue, перед названием компонента должен
указываться специальный префикс vue:

 <table><tr is="vue:my-component"></tr></table>

Чтобы использовать хуки, нужно их импортировать в <script setup> и при вызове 
передать им нужный колбек.

При использовании SFC со <script setup> импортированные компоненты могут быть использованы 
в шаблоне без регистрации. Если вместо SFC используется модуль компонента, то импортируемые
компоненты нужно регистрировать либо локально (через опцию components), либо глобально.

Теги компонентов, в шаблоне Vue, могут указываться как в PascalCase, так и в kebab-case.

Для реализации двухстороннего связывания используется макрос defineModel(). Под капотом он
определяет для компонента входной параметр v-model, который можно связать с каким-то
состоянием из родительского компонента.

 Файл child-component.vue

 <script setup>
   // Если изменять myModel, то будет изменяться и привязанное 
   // состояние родительского компонента (т.е. myRef)

   const myModel = defineModel();  // myModel - это myRef
 </script>

 Файл parent-component.vue

 <script setup>
   // Если изменять myRef то будет изменяться и привязанное 
   // состояние дочернего компонента (т.е. myModel)

   const myRef = ref(23);
 </script>

 <template>
   <ChildComponent v-model="myRef" />
 </template>

Поскольку defineModel() определяет входной параметр, то в него также можно 
передать объект валидации.

Директива v-model может принимать аргумент. В этом случае, чтобы получить к нему доступ, 
в макрос defineModel() нужно передать строку с его названием.

 <MyComponent v-model:title="bookTitle" />
 ...
 const title = defineModel('title'); 

Таким образом на одном компоненте можно указать сколь угодно v-model, но с разными
аргументами. Если аргументу нужно задать валидацию, то объект валидации 
нужно передавать после строки.

Директиве v-model можно задавать пользовательские модификаторы. А чтобы получить к ним доступ
нужно деструктуризировать возвращаемое значение из defineModel(). В этом случае первой
переменной будет сама модель, а второй - объект с модификаторами.

Чтобы изменить поведение v-model, исходя из переданных модификаторов, в defineModel() 
нужно передать опцию set, где и будет вся логика измененного поведения.

 <MyComponent v-model.capitalize="myText" />
 ...
 const [model, modifiers] = defineModel({
   set(value) {
     if (modifiers.capitalize) {
       return value.charAt(0).toUpperCase() + value.slice(1);
     }
     return value;
   }
 });

Чтобы получить доступ к стандартным HTML-атрибутам компонента, используется ф-ция useAttrs().
Они также доступны из параметра ctx, метода setup() в модульном компоненте.

Когда требуется передать данные от родительского компонента к глубоко вложенному, то вместо 
пробрасывания их по всей цепочке компонентов можно использовать ф-ции provide/inject.
Предоставлять данные можно только от родителя к потомкам.

 Файл parent-component.vue

 <script setup>
   import { provide } from 'vue';
   provide('message', 'hello!');  // данные могут быть любого типа, даже ref.
 </script>

 Файл child-component.vue

 <script setup>
   import { inject } from 'vue';
   const msg = inject('message');  // ключом может быть строки или Symbol
 </script>

Предоставление данных может быть и на уровне приложения. В этом случае данные будут 
доступны для всех компонентов. Это полезно при написании плагинов.

 import { createApp } from 'vue';
 const app = createApp({});
 app.provide(myKey, myValue);

Если несколько родительских компонентов предоставляют данные с одинаковым ключом, 
то inject() будет использовать значение из ближайшего родителя.

Если в inject() передать второй аргумент, то он будет использоваться как значение по умолчан,
когда данные не продоставляются через provide(). Второй аргумент может быть как 
обычным значением, так и фабричной ф-цией.

Если требуется, чтобы потомки мутировали реактивное значение, то вместе с ним можно также 
предоставлять и мутирующую ф-цию (чтобы потомки не делали этого напрямую). 

Если значение нужно только для чтения, то его можно доп. обернуть через ф-цию readonly().

 provide('location', { location, updateLocation });
 provide('count', readonly(count));  

Ключи рекомендуется делать через Symbol и хранить их в отдельном файле.

Для реализации lazy loading нужно использовать асинхронные компоненты. Они определяются 
с помощью ф-ции defineAsyncComponent() в котороый передается колбек-закрузчик. 
Колбек должен возвращать Promise().

 const AsyncComponent = defineAsyncComponent(() => { 
   return import('./components/my-component.vue'); 
 });

Вместо колбека можно также указать параметрический объект:

 const AsyncComponent = defineAsyncComponent({
   loader: () => import('./my-component.vue');  // колбек-загрузчик

   loadingComponent: LoadingComponent,     // компонет, который отображается 
                                           // пока не загрузится нужный

   delay: 200,                             // задержка перед отображением нужного
                                           // (чтобы не было мерцания)

   errorComponent: ErrorComponent,         // компонент, который отображается если 
                                           // не удалось загрузить нужный 

   timeout: 3000,                          // время ожидания нужного компонента, по истечен. 
                                           // кот. будет отображаться errorComponent

   hydrate: myHydrateStrategy(),           // гидрация компонента
 });                                     

Гидрация - это процесс превращение полученного с сервера html в интерактивный компонет. 
Используется в основном при SSR. Стратегии гидрации бывают разными.

Composable-функция - это та, что использует Composition API для инкапсуляции логики 
с реактивным состоянием. Такая ф-ция начинаются с префикса use.

Composable-функция может подключаться к жизненному циклу своего компонента.
Это означает, что в ней можно определять различные хуки.

 export function useMouse(url) {
   const data = ref(null);
   const error = ref(null);

   watchEffect(() => {
     fetch(toValue(url))                   // использование toValue() внутри watchEffect()
       .then(res => res.json())            // даст правильное отслеживание изменений
       .then(json => data.value = json)
       .catch(err => error.value = err);	 
   });

   return { data, error };
 }

 const url = ref('/home');
 const { data, error } = useFetch(url); 
 url.value = '/about';  // вызовет повторный запрос

Одна composable-функция может использовать внутри себя другую composable-функцию.
Composable-функции должны вызываться только синхронно. Единственное место, 
где можно вызывать composables после await - это <script setup>.

В отличие от хуков React, composable-функции основаны на сложной системе реактивности, 
которая отличается от модели выполнения хуков React.

VueUse - богатая бибиотека composable-функций для самых распространенных задач.

Vue позволяет определять пользовательские директивы. Они необходимы для повторного 
использования логики, связанной с низкоуровневым доступом к DOM. Чтобы определить директиву, 
нужно в <script setup> задать объектный литерал с хуками жизненного цикла, 
которые аналогичны тем, что в компоненте.

 <script setup>
   const vActive = {
     mounted: (el) => {
       el.classList.add('active');
     },
   };
 </script>

 <template>
   <p v-active>Какой-то текст</p>
 </template>

Глобальное определение директивы на уровне приложения делается так:

 const app = createApp({});
 app.directive('active', { });

Хуки директивы могут принимать такие параметры:

 * el - элемент, на котором используется директива;

 * binding - объект с данными директивы, хранящий: агрумент директивы, 
   передаваемое значение, модификаторы, экземпляр компонента и др.;

 * vNode - node связанного элемента;
 * prevVnode - node предыдущего связанного элемента;

Если директиве нужны только хуки mounted и updated, то ее можно определить через функцию:

 // Ф-ция будет вызываться как для mounted, так и для updated
 app.directive('color', (el, binding) => { });

Пользовательские директивы не рекомендуется применять к компонентам. При применении 
к компоненту такие директивы будут применятся к корневому элементу шаблона. Если корневых
элементов несколько, то они не будут применятся вообще.

Плагин добавляет функционал на уровне приложения. Он представляет из себя объектный литерал
с методом install(), который принимает два параметра: приложение и доп. настройки. 
Вместо объектного литерала может быть и ф-ция, которая работает как install().

 const myPlugin = {
   install: (app, myOptions) => {
     app.provide('i18n', myOptions);
   }
 };
 
 const app = createApp({});
 app.use(myPlugin, myOptions);

Встроенные компоненты Vue:

 * Transition - добавляет анимацию переходов для содержимого; 
   используется для реализации плавного появления и затухания;

 * TransitionGruop - делает тоже самое, но для элементов списка, 
   когда те создаются/пересоздаются через v-for;

 * KeepAlive - кеширует динамически переключаемые компоненты;

 * Teleport - визуально перемещает содержимое в другую DOM-иерархии, 
   но при этом никак его затрагивает уже построенную иерархию;

 * Suspense - берет на себя обработку загрузки асинхронного содержимого, 
   например асинхронных компонентов, чтобы на странице не было 
   много разных прелоадеров от каждого из них.

При использовании встроенных компонентов важно соблюдать правильный порядок вложенности:
Пример здесь https://ru.vuejs.org/guide/built-ins/suspense.html

  <RouterView> 
    <Transition> 
      <KeepAlive> 
        <Suspense>

