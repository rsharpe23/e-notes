ФРЕЙМЫ И ОКНА

Чтобы открыть новую вкладку либо окно (попап), используется метод window.open(url).
Такие окна в современно вебе используются редко, но до сих пор востребованы 
при OAuth-авторизации.

У них своя отдельная навигация, а также свое отдельное JS-окружение. Поэтому открытие
попапа со стороннего, не доверенного сайта, вполне безопасно.

Современные браузеры блокируют попапы, если вызов window.open произошел не по
инициативе пользователя (например вне события onclick).

Если при вызове window.open задать аргумент name, при условии что окно с таким
названием уже существует, то попап откроется в нем, иначе будет создано новое окно.
Также вместо попапа откроется вкладка, если при вызове open не указаны размеры.

Кроме того, попап можно всячески кастомизировать с помощью аргумента params 
(отображать панель навигации, адресную строку, строку состояния и т.п.).

Метод window.open возвращает ссылку на созданное окно. 

Попап может обратиться к открывшему его окну, с помощью специального свойства
window.opener. Оно равно null для всех окон, кроме попапов.
...
const popup = window.open(url);  -->  url - это та страница, что откроется в попапе
popup.document.write(                 
  '<script>window.opener.document.body.innerHTML = 'test!';</script>'
);

Окна могут свободно читать и изменять друг друга только если они с одного источника
(имеют общий протокол, домен и порт [политика одинакового источника]).

Чтобы закрыть попап, используется метод window.close. Если окно не было создано 
с помощью open, то этот метод будет игнорироваться браузерами.

Попапы нельзя свернуть или развернуть на весь экран. За это отвечает функции
операционной системы, и они скрыты для фронтенда.

Политика одинакового источника заключается в том, что если у пользователя открыто две
страницы но с разных источников, то скрипт из одной страницы не сможет получить доступ
к другой странице (к её DOM-элементам и т.п.), за исключением изменения её объекта
location, но не чтения (чтобы не было утечек информации).

Если у страниц отличаются только поддомены, то это ограничение можно обойти, вызвав:
document.domain = 'mysite.come'; в каждом окне.

Еще одним способом интерактивности между страницами являются ифреймы. С помощью них
можно размещать одни страницы, внутри других. Внутри ифрейма находится отдельное окно 
с собственными объектами document и window. Обратиться к ним можно так:
iframe.contentWindow, iframe.contentDocument.

У ифрейма есть один подвох. Когда он создается, в нем сразу есть документ, но он
другой, не тот, который будет загружег в итоге!
...
const oldDoc = iframe.contentDocument;
iframe.onload = () => {
  const newDoc = iframe.contentDocument;
  oldDoc == newDoc;  -->  false!
};

Некоторые свойства window, касающиеся ифреймов:
* frames - коллеция дочерних window, от каждого фрейма;
* parent - ссылка на родительский/внешний window;
* top - ссылка на самого верхнего родителя.

Свойство top можно использовать для проверки, открыт ли текущ. документ внутри ифрейма 
или нет: if (window != top) { /* скрипт запущен во фрейме! */ }.

К window.frames можно также обращаться как к объеткту.

Атрибут sandbox накладывает максимум ограничений на действия внутри ифрейма. 
Чтобы снять некоторые из них, задаются специальные исключения, например: 
<iframe sandbox="allow-forms allow-popups" src="/">.

Если в ифрейме с этим атрибутом нет исключения "allow-same-origin", то он будет
принудительно считаться пришедшим из другого источника. Это можно использовать для
запуска ненадежного кода с того же сайта.

Список исключений sandbox:
* allow-same-origin - отключает ограничение "Same Origin";
* allow-top-navigation - позволяет ифрейму менять parent.location;
* allow-forms - позволяет отправлять формы из ифрейма;
* allow-scripts - позволяет загружать скрипты из ифрейма;
* allow-popups - позволяет открыть попапы из ифрейма, с пом. window.open

Важно понимать, что атрибут sandbox не может ослабить ограничения, накладываемые
браузером на ифрейм, который приходит из другого источника!

Чтобы обойти политику одинакового источника, можно воспольз. методом postMessage.
Вызываться он должен из того окна, которому нужно отправить сообщение.
...
const win = window.frames.myFrame;
win.postMessage('hello!', 'http://frame-site.com');

Первый параметр - это сообщение. Может быть как строкой, так и объектом (IE понимает
только строку). Второй - источник получателя, т.е. при указании, попап только с этого
источника сможет получать сообщения. Этот параметр необходим в мерах безопасности. 
Если не нужно проверять источник, то вместо него можно указать звездочку.

Чтобы получить сообщение, у окна-получателя должен быть обработчик события message.
...
window.addEventListener('message', e => {
  e.data;    -->  сообщение 'hello!'
  e.origin;  -->  источник отправителя 'http://main-site.com'
  e.source;  -->  ссылка на окно-отправитель (можно отправить что-то в ответ)
});

Между postMessage и событием message нет задержки, т.е. событие происходит синхронно,
быстрее, чем setTimeout(callback, 0);

Ифреймы могут применяться для хакерской атаки - clickjacking. Эта атака позволяет
вредоносной странице делать клики на целевом сайте, от лица жертвы. 

Сначала пользователя заманивают на вредоносный сайт. Затем его соблазняют кликнуть на
определенную кнопку. Но кнопка, на самом деле, будет перекрываться ифреймом, и когда
пользователь кликнет по ней, он кликнет по ифрейму. 

В итоге произойдет какое-то побочное действие, например пользователь, будучи в этот
момент авторизир. в соц. сетях, может совершить какое-то скрытое действие от своего
лица и т.п. Вместо ифреймов могут быть скрытые ссылки, открывающие рекламные сайты.

Чтобы защитить от этого свой сайт, можно запрерить открывать его в ифрейме, другим
сайтам, с помощью http-заголовка X-Frame-Options. Т.е. сервер должен отдавать 
html-страницы с заголовком X-Frame-Options: SAMEORIGIN.

Если вместо заголовка будет просто указан тег <meta http-equiv="X-Frame-Options">,
внутри html-страницы, то это не сработает.

Но если сайт все же должен открываться в ифрейме, то можно сделать скрипт, который
будет добавлять перекрывающий div, если сайт открыт в ифреме. В этом случае, даже если
он будет размещен на вредосносной странице, пользователи будут кликать (скрыто) 
только по перекрывающему div'у.

---------------------------------

БИНАРНЫЕ ДАННЫЕ И ФАЙЛЫ

Операции над бинарными данными являются высокопроизводительными!
Базовый класс для работы с бинарными данными - ArrayBuffer. Объект этого класса
представляет собой ссылку на непрерывную область памяти, фиксированной длины.

ArrayBuffer - это не массив. Его длина фиксирована, её нельзя увеличить или уменьшить.
Для доступа к отдельным байтам нужен объект-представление, buffer[index] не сработает.
Информации что конкертно хранится в буфере нет. Это просто сырая порция байтов.

Объкты-представления интерпритируют бинарные данные в числа. Их типы:
* Uint8Array - представляет каждый байт как беззнак. число, состоящее из 8 бит;
* Uint16Array - представляет каждые 2 байта как беззнак. число из 16 бит;
* Uint32Array - представляет каждые 4 байта как 32-битное число;
* Float64Array - каждые 8 байт как знаковое число, с плавающей точкой;
* Int8Array, Int16Array, Int32Array - целые знаковые числа;
* Uint8ClampedArray - числа обрезаются по верхней и нижней границе, при присвоении.

Общий термин для таких типов - это TypedArray, типизированный массив. 
Они уже больше напоминают массив. Их можно перебирать и обращаться по индексу.
...
const buffer = new ArrayBuffer(16);  -->  буфер из 16 байт, заполненный нулями
const view = new Uint32Array(buffer);

Uint32Array.BYTES_PER_ELEMENT;  -->  4

view.length;  -->  4
view.buffer;  -->  ArrayBuffer
view.byteLength;  -->  16 (размер ArryBuffer)

view[0] = 123;
for (const it of view) {
  it;  -->  123
}

Если число выйдет за пределы границ, то старшие биты отбросятся:
...
const arr = new Uint8Array(16);
arr[0] = 255;  -->   [11111111]  -->  255
arr[1] = 256;  -->  1[00000000]  -->  0
arr[2] = 257;  -->  1[00000001]  -->  1
clampedArr = 257;  -->  обрежет до 255

DataView - это нетипизированное представление данных. DataView позволяет получать
данные разных типов хранящиееся в одном буфере.
...
const view new DataView(buffer);
view.getUint8(0);   -->  255 (максимальное 8-битное)
view.getUint16(0);  -->  65535 (максимальное 16-битное)
view.getUint32(0);  -->  4294967295 (максимальное 32-битное)

Общее название для всех представлений - ArrayBufferView, а общее название для
ArrayBuffer и ArrayBufferView - BufferSource.

Чтобы декодировать бинарные данные в строку, используется класс TextDecoder.
А чтобы наоборот, закодировать строку в бинарный массив - TextEncoder.
...
const view = new Uint8Array([104, 101, 108, 108, 111]);
new TextDecoder().decode(view);     -->  hello
new TextEncoder().encode('hello');  -->  104, 101, 108, 108, 111

Blob (binary large object) - это объект, который хранит в себе различные данные 
в бинарном виде, а также их mime-type. Данные могут быть в виде строк, представлять
ArrayBuffer или другой Blob. Создается он так: new Blob(blobParts, options);

Blob можно конвертировать в строку с кодировкой base64 (называется DataURL). 
Она представляет из себя набор ASCII-кодов, в диапазоне от 0 до 64, и имеет формат
data:<mediatype>;base64,<data>. Т.е. по сути это представление двоичных данных в виде
строки, с безопасными для чтения символами. Двоичные данные могут быть как картинкой,
так и скомпилированным кодом. Обычно этот вариант применяют для создания иконок.
...
const blob = new Blob(['hello!'], { type: 'text/plain' });
new FileReader().readAsDataURL(blob);  -->  data:text/plain;base64,R0lGODlhDAAMAKI

Но в основном Blob используется для того, чтобы на его основе сгенерировать уникальный
ObjectURL в формате blob:<origin>/<uuid>, который будет ссылаться на какие-то двоичные
данные в памяти. Например это может быть видео стрим с камеры, который при помощи
такого url воспровизводится в видеоплеере на веб-странице и т.п.
...
const blob = new Blob('hello!', { type: 'text/plain' });
const url = URL.createObjectURL(blob);  -->  blob:http://mysite.com/1e67e00e-860d

URL.removeObjectURL(url);  -->  удаляет внутреннюю ссылку на объект, 
                                что позволяет запуститься сборщику мусора

Чтобы создать Blob для изображения, нужно сначала добавить это изображения на canvas, 
а затем вызвать метод toBlob: imgCanvas.toBlob(blob => {}, 'image/png');

Класс File наследуется от Blob. Файлы из <input type="file"> или других интерфейсов
браузера, как раз такого типа. Это означает, что при отправке файла по сети, 
по сути отправляется Blob. А File - это просто абстракция.

Класс FileReader - необходим для чтения данных из Blob и, следовательно, из File. 
Его основные методы: readAsArrayBuffer, readAsText, readAsDataURL.

---------------------------------

СЕТЕВЫЕ ЗАПРОСЫ И URL

Выполняются с помощью метода fetch, который работает в два этапа. На первом этапе он
дает возможность получить только статус ответа, а также его заголовки. 
На втором этапе можно получить тело ответа. 

Тело ответа выделено в отдельный этап, т.к. оно формируется не сразу. 
Для этого нужно время, т.к. данные приходят по частям.

Методы для получения тела ответа: 
* text - возвращает ответ как обычный текст;
* json - декодирует ответ в формате JSON (парсится автоматич.); 
* formData - возвращает ответ как объект FormData;
* blob - возвращает ответ как Blob (бинарные данные с mime-типом);
* arrayBuffer - как ArrayBuffer (низкоуровневое представление бинарных данных).

Чтобы считать тело ответа по частям, используется свойство body.
Без опций, fetch делает обычный GET-запрос, скачивающий содержимое по url.

Получение картинки по сети:
...
const res = await fetch('logo.svg');
const blob = await res.blob();

const img = document.createElement('img');
img.src = URL.createObjectURL(blob);

document.body.append(img);

Заголовки ответа хранятся в коллекции headers. Её можно перебирать через цикл.
Заголовки запроса задаются через опцию с таким же названием - headers.

Для отправки POST-запроса необходимо устанавливать опции method и body. 
Кроме того можно дополнительно установить заголовок Content-Type. Это необходимо, 
при отправке json-строк, т.к. по умолчанию все строки имеют тип text/plain.

Заголовок Content-Type всегда формируется автоматически, исходя из значений body.
Body может принимать значения таких типов: String, FormData, Blob, URLSearchParams.
Content-Type для URLSearchParams - это "x-www-form-urlencoded" (используется редко).

Отправка картинки по сети:
...
const blob = await new Promise(res => imgCanvas.toBlob(res), 'image/png');
const res = await fetch('logo/add', { method: 'POST', body: blob });
await res.json();  -->  подтверждение отправки

Чтобы получить данные с формы, используется объект FormData: new FormData(formElem);
Этот объект является коллекцией и его можно перебирать через цикл.

Метод fetch позволяет отслеживать процесс получения данных. Но отслеживать отправку
данных он не может. Для этого использ. объект XMLHttpRequest.
...
const reader = response.body.getReader();
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  value.length;  -->  получаемый размер в байтах, на каждой итерации
}

Полную длину ответа можно узнать из загаловка Content-Length, но при запросах на 
другой источник он может быть нечитаемым (см. про CORS).

Чтобы прервать fetch, используется объект AbortController. Кроме того, его можно
использовать для отмены любых асинхронных задач. Чтобы узнать об отмене, нужно
повесить слушатель на объект signal.
...
const controller = new AbortController();

controller.signal.addEventListener('abort', () => log('обычный слушатель'));
fetch(url, { signal: controller.signal });  -->  отмена fetch

new Promise((resolve, reject) => {
  controller.signal.addEventListener('abort', reject);  -->  отмена промиса
});

controller.abort();

Все опции fetch:
* method - метод запроса; 
* headers - заголовки запроса; 
* body - тело запроса; 
* referrer - устанавливает заголовок Referer; по умолчанию в нём содержится путь 
с которого пришел запрос; 
* referrerPolicy - устанавливает общие правила для Referer; 
* mode - защита от нечаянной отправки запроса на другой источник; 
* credentials - указывает, должен ли fetch отправлять куки и авторизацион. заголовки
вместе с запросом; 
* cache - настройка кеширования запросов; 
* redirect - настройка редиректов; 
* integrity - проверяет, соответствует ли ответ известной заранее контрольной сумме; 
* keepalive - позволяет запросу пережить страницу, которая его отправила;
* signal - необходим для прерывания запроса; 
* window - window?

Когда документ выгружается, все связанные с ним запросы прерываются!

Если страница, перед закрытием, посылает последний запрос, в событии onunload, 
то он обязательно должен иметь опцию keapalive:true. Эта опция указывает браузеру
выполнять запрос в фоновом режиме, даже после того, как пользователь покинет страницу.

Лимит тела для запроса с keepalive - 64кб. Обрабоать ответ от сервера не получится,
если запрос сделан из onunload, т.к. в тот момент документ уже будет выгружен.
Обычно сервер посылает пустой ответ на такие запросы.

Класс URL предоставляет удобный интерфейс для создания и разбора url-адресов.
Его объект можно передавать почти куда угодно вместо строки (fetch, XMLHttpRequest).
...
const url = new URL('/page', 'http://my-site.com');
url.protocol;  -->  http:
url.host;      -->  my-site.com
url.pathname;  -->  /page

Подробнее о том, из каких частей состоит url-адрес, а также о спец. компонентах user 
и password, для http-аутентификации: https://learn.javascript.ru/url

Для корректной работы с параметрами, используется класс URLSearchParams. 
Объект этого типа также содержится и в классе URL, в виде свойства searchParams.
...
const sParams = new URLSearchParams('foo=bar&value=1');
sParams.get('foo');  -->  bar

const url = new URL('http://my-site.com?foo=bar');
const queryStr = url.searchParams.toString();  -->  строка с правильно закодирован.
                                                    пробелами и т.п.

Если в объекте URL есть нелатинские буквы или пробелы, то они будут закодированы по
стандарту RFC3986, так например пробелы кодируются знаком "+". 

Если нужно кодировать/декодировать url-адрес самостоятельно, то можно воспользоваться 
ф-циями encodeURI/decodeURI соответственно. Они подходят только для тех адресов,
которые не содержат доп. компоненты (параметры, хеш и т.п.).
...
encodeURI('http://site.com/привет');  -->  http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0

Если в адресе есть компоненты, то их нужно кодировать отдельно с помощью
encodeURIComponent. Иначе строка будет закодирована неправильно, т.к. encodeURI
пропускает спец. символы: #, $, &, +, ? и т.д.
...
encodeURI('Rock&Roll');  -->  Rock&Roll (знак & остался, это ломает форматирование,
                                         т.к. парсер будет думать что это 2 параметра)

encodeComponentURI('Rock&Roll')  -->  Rock%26Roll (теперь все нормально!)

Ф-ции типа encode* некорректно кодируют url-адреса с IPv6, из-за старого 
стандарта RFC2396 (и возможно что-то еще, но по большей части работают хорошо).

Подробнее о http-протоколе и заголовках:
https://developer.mozilla.org/ru/docs/Web/HTTP/Overview
https://developer.mozilla.org/ru/docs/Web/HTTP/Headers

---------------------------------

ЗАПРОСЫ НА ДРУГОЙ ИСТОЧНИК

Они требуют специальных заголовков от удаленной стороны. Эта политика называется CORS.

Её суть заключается в том, что сайт по API может запросить данные только с того 
веб-сервера, на котором размещён сам. Если же он запросит данные с другого сервера, 
то получит ошибку вида "Access has been blocked by CORS policy".

При запросе на другой источник браузер добавляет от себя заголовок Origin.
Например, запрашивая: http://anywhere.com/request со страницы http://mysite.com/page,
заголовки будут такими (Origin - это протокол + домен + порт):
...
GET /request
Host: anywhere.com
Origin: http://mysite.com

Если сервер согласен принять такой запрос, то к ответу он должен добавить заголовок
Access-Control-Allow-Origin со значен. http://mysite.com, или звёздочку (любой Origin).
Это касается всех запросов, как простых, так и непростых!

Также, в кроссдоменных запросах, клиент получает доступ только к простым заголов ответа:
Cache-Control, Content-Language, Content-Length, Content-Type, Expires и т.д.

Чтобы разрешить доступ к любым заголовкам ответа, сервер должен вернуть заголовок
Access-Control-Expose-Headers, в котором перечислено всё необходимое.
...
Content-Type: text/html; charset=UTF-8
Access-Control-Allow-Origin: http://mysite.com, http://javascript.info
Access-Control-Expose-Headers: Content-Encoding, API-Key  -->  нужные нам заголовки

Раньше, когда отсутствовала политика CORS, использовался протокол JSONP. Его идея
заключалась в следующем. На странице, которой нужно было получить данные с другого
источника, объявлялась глобальная ф-ция, например myFunc. Также на ней размещался
специальный скрипт, с src вида: http://another-site.com?callback=myFunc. 

При загрузке такого скрипта на сервер источника отправлялся запрос. Сервер должен был
его как-то обработать и в ответ прислать JS-код, в котором есть вызов myFunc. Обычно в
такую колбек ф-цию передавались необходимые аргументы, ради которых и создавался весь
этот процесс. Это работало т.к. скрипты можно загружать откуда угодно.

На практике это выглядело примерно так:
...
function getWeather(data) {
  // Здесь вся работа с полученными данными
  data.temperature;  -->  24
  data.humidity;  -->  78
}

Где-то, на запрашиваемой странице:
<script src="http://sinoptik.com/weather.json?callback=getWeather"></script>

Ответ сервера, на PHP: 
echo "getWeather({ temperature: 24, humidity: 78 })";

В современном вебе есть два вида запросов на другой источник: простые и все остальные.
Их отличие в том, что простые запросы могут выполняться через <form> и <script>, 
в то время как непростые долгое время были невозможны для браузеров.

Простой запрос удовлетворяет след. условиям:
1) Метод только: GET, POST или HEAD.
2) Заголовки только: Accept, Accept-Language, Content-Language, Content-Type 
со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.

Когда выполняется непростой запрос, браузер сначала посылает (за кулисами) специальный
подзапрос, который спрашивает у сервера - согласен ли он принять такой запрос?

Подзапрос использует метод OPTIONS. У него нет тела, но есть три заголовка:
* Origin - источник основного запроса;
* Access-Control-Request-Method - метод основного запроса;
* Access-Control-Request-Headers - заголовки основного запроса;

Если сервер согласен принять непростой запрос, то он должен ответить без тела, 
со статусом 200 и заголов.: Access-Control-Allow-Origin, Access-Control-Allow-Methods,
Access-Control-Allow-Headers. Второй опред. разреш. методы, а третий разреш. заголовки.
И только после этого браузер пошлёт основной запрос (если позволят заголовки ответа).

Обычно, запрос всегда сопровождается куками со своего домена. Но запрос на другой
источник не содержит ни кук, ни авторизационных данных. Чтобы их включить, 
нужно в fetch добавить опцию credentials:true.

Теперь fetch вместе с запросом будет посылать и куки (для домена another-site.com).
Если сервер согласен принять запрос с credentials, он должен добавить к ответу заголов.:
Access-Control-Allow-Credential:true, в дополнение к Access-Control-Allow-Origin.

Последнему заголовоку в этом случае запрещено использовать звёздочку (мера безопасности)
Сервер должен дейсвтительно знать, кому он доверяет делать такие запросы.

---------------------------------

ЗАПСРОСЫ С ПОМОЩЬЮ XML_HTTP_REQUEST

XMLHttpRequest - это встроенный в браузер объект, позволяющий делать http-запросы 
на сервер без перезагрузки веб-страницы. Но метод fetch более современный.

Чтобы сделать запрос, нужно выполнить три шага:
...
const xhr = new XMLHttpRequest();  -->  создать объект
xhr.open(method, url);  -->  указать метод запроса и url-адрес
xhr.send(body);  -->  послать запрос (тело указывать необязательно)          

Чтобы получить ответ, нужно подписаться на события: load, error и/или progress.
...
xhr.onload = () => alert(xhr.status + xhr.response);  -->  загружено
xhr.onerror = () => alert('error');  -->  когда совсем не получилось выполнить
xhr.onprogress = e => alert(e.loaded + e.total);  -->  прогресс загрузки данных; 
  total доступен только если сервер присылает заголовок Content-Length.

Чтобы указать тип ответа, используется свойство responseType, например:
... 
xhr.responseType = 'json';  -->  тогда xhr.respose - это объект
xhr.responseType = 'text';  -->  xhr.respose - строка

Также можно указать таймаут (время, которое клиент готов ждать для ответа): 
xhr.timeout = 3000;

Если responseType указан как "document", то в ответе ожидается xml-документ.
Свойства responseType, timeout и пр. должны указываются перед вызовом метода send.

У XMLHttpRequest есть состояния, которые меняются по мере выполнения запроса. 
Текущее состояние можно посмотреть в свойстве readyState. При изменении состояния
запускается событие readystatechange.

Запрос можно отменить с пом. метода abort. При этом будет также запущено и одноименное
событие. А если необходимо чтобы запрос был синхронным, то при вызове метода open 
нужно указать третий аргумент (async) как false.

Для управления заголовками используются методы getResponseHeader, getAllResponseHeaders
и setRequestHeader. Заголовки установленные через setRequestHeader отменить нельзя!

Список заголовков, которыми управляет только браузер: 
https://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method

POST-запрос можно послать как с FormData, так и с json-строкой: 
...
xhr.open('POST', '/article/add');
xhr.send(new FormData(form));

XMLHttpRequest при запросах на другой источник, как и fetch, не отсылает куки 
и заголовки http-авторизации. Исправить это можно так: xhr.withCredentials = true;

Для отслеживания отправки используется свойство upload. События теже:
* loadstart - начало отправки данных;
* progress - прогресс отправки данных;
* abort - отправка прервана;
* error - ошибка, не связанная с http;
* load - отправка успешно завершена;
* timeout - срабатывает только если указан таймаут;
* loadend - отправка завершена, неважно, успешно или нет.

Пример возобновляемой отправки файла:
...
const fileId = file.name + file.size + file.lastModifiedData;
const res = await fetch('status', { headers: { 'X-File-Id': fileId } });
const startByte = +await res.text();

xhr.open('POST', 'upload');
xhr.setRequestHeader('X-File-Id', fileId);
xhr.setRequestHeader('X-Start-Byte', startByte);

xhr.upload.onprogress = e => {
  console.log(`Uploaded ${startByte + e.loaded} of ${e.total}`);
};

xhr.send(file.slice(startByte));

Сначала нужно создать id файла. Это нужно, чтобы при возобновлении отправки, сервер
понимал с каким файлом работать. Далее, посылается запрос на сервер, с просьбой указать
кол-во уже полученных байтов (startByte). Затем, используя метод slice объекта Blob,
данные отправляются начиная с позиции startByte.

---------------------------------

LONG POLLING И SERVER-SENT EVENTS

Длинные опросы - это простой способ поддерживать постоянное соединение с сервером, 
без исползования веб-сокетов или Server-Sent Events. Они реализуется так: ф-ция делает
запрос на сервер, затем ожидает ответ, обрабатывает его и снова вызывает сама себя.
...
async function subscribe() {
  const res = await fetch('/subscribe');  -->  сервер может задерживать ответ
  if (res.status == 502) {  -->  502 это таймаут соединения
    await subscribe();
  } else if (res.status != 200) {  -->  если другая ошибка, переподключ. через сек.
    await new Promise(_ => setTimeout(_, 1000));
    await subscribe();
  } else {
    await res.text();  -->  обработка ответа
    await subscribe();
  }
}

При этом сервер должен поддерживать много ожидающих соединений. Лучше всего для этого
подходит Node.js. PHP или Ruby наоборот, не очень хорошо подходят, т.к. запускают
каждое соединение в отдельном процессе, а каждый процесс занимает значительный объем
памяти. Так много соединений просто поглотят всю память.

Длинные опросы прекрасно работают когда сообщения приходят редко. 
Если сообщения приходят очень часто, то лучше использовать веб-сокеты или SSE.

Server-Sent Events - это спецификация, которую реализует встроенный класс EventSource.
Он позволяет поддерживать постоянное соединение с сервером и получать от него ответы.
При этом используется обычный http-протокол. Данные посылает только сервер.
При потере соединения, переподключение происходит автоматически.

SSE подходит тем приложениям, где не требуется вся мощь веб-сокетов.

Чтобы открыть соединение, нужно создать отбъект EventSource. Сервер должен ответить со
статусом 200 и заголовком Content-Type: text/event-stream. После чего ему необходимо
поддерживать соединение и отправлять сообения в формате "data: текст".
При каждом сообщении на клиенте вызывается событие message.
...
const eSource = new EventSource(url); 
eSource.onmessage = e => alert(e.data);

Чтобы послать авторизационные данные на другой источник, нужно установить доп. опцию
withCredentials, пример: new EventSource(url, { withCredentials: true });

Чтобы указать задержку переподключен., сервер должен послать сообщение: "retry: 10000".
Если сервер хочет остановить попытки переподключен., он должен ответить со статусом 204.
Если клиент хочет прекратить соединение, он должен вызвать: eSource.close().

Кроме того переподключение остановится, если в ответе указан неверный Content-Type 
или статус отличается от 301, 307, 200 и 204.

Если соединение окончательно закрыто, то переоткрыть его уже нельзя. 
Чтобы возобновить подключение, нужно создать еще один объект EventSource. 

Для правильного переподключения, сообщения должны быть с id:
...
data: Сообщение 1
id: 1  -->  id должен идти после data

data: Сообщение 2
id: 2 

Получив сообщение с id, браузер подставит его в свойство eSource.lastEventId, а также
при переподключении отправит заголовок Last-Event-ID с этим id (чтобы сервер мог
переслать сообщения, в правильном порядке).

С пом. свойства readyState можно узнать текущее состояние объекта EventSource.

По умолчанию EventSource генерирует 3 события: message, open, error. Но сервер может
вызвать свое событие, если в начале сообщения указать event:
...
event: join
data: {"user": "Вася", "age": "52"}

Пользовательские события можно прослушивать только с помощью addEventListener:
eSource.addEventListener('join', e => alert(e.data));

---------------------------------

ВЕБ-СОКЕТЫ

Это протокол, обеспечивающий постоянное соединение между браузером и сервером.
Он передает данные в обоих направлениях в виде "пакетов".

Чтобы открыть соединение, нужно создать объект WebSocket, указав в url-адресе 
протокол ws://, а чтобы отправить данные, нужно вызвать метод send.

По аналогии с https существует также wss:// протокол. Он более предпочтительный.

У объекта WebSocket всего 4 события:
* open - соединение установлено;
* message - получены данные;
* error - ошибка;
* close - соединение закрыто;

Код на клиенте:
...
const socket = new WebSocket('wss://my-site.com/chat');
socket.onopen = e => socket.send('Привет!');
socket.onmessage = e => alert(e.data);
socket.onclose = e => alert(`Соединение закрыто, ${e.code} ${e.reason}`);

Код на сервере:
...
const http = require('http');
const ws = require('ws);

const wsServer = new ws.Server({ noServer: true });
http.createServer((req, res) => {
  wsServer.handleUpgrade(req, req.socket, Buffer.alloc(0), onConnect);
}).listen(8080);

function onConnect(ws) {
  ws.on('message', msg => {
    ws.send(`Привет с сервера, ${msg}`);
    setTimeout(() => ws.close(1000, 'Пока!'), 3000);
  });
}

При установке соединения сначала браузер делает http-запрос, к которому автоматически
добавляет спец. заголовки. Далее, при помощи них он спрашивает сервер, поддерживает ли
тот веб-сокеты?  Если да, то сервер также должен ответить со спец. заголовками, и
только после этого начнется клиент-серверное общение по этому протоколу.

Пример заголовков, которые браузер посылает серверу: 
...
GET /chat
Host: my-site.com
Origin: https://my-site.com
Connection: Upgrade  -->  говорит, что клиент хотел бы изменить протокол
Upgrade: websocket   -->  запрошен протокол websocket
Sec-WebSocket-Key: Iv8io/9s+lYgZW  -->  случ. ключ, созд. браузером для безопасн.
Sec-WebSocket-Version: 13  -->  версия протокола websocket

Если сервер согласен переключиться на веб-сокеты, то он должен ответить со 
статусом 101 и следующими заголовками:
...
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDlZAlC2g=  -->  это Sec-WebSocket-Key, но доп. перекодир.;
  браузер использует его, чтобы убедиться, что ответ соответсвует запросу.

Браузер может посылать доп. заголовки Sec-WebSocket-Extensions и Sec-WebSocket-Protocol.
Первый, отправляется автоматически. Он хранит в себе список всех расширений протокола,
которые поддерживает браузер. Второй означает формат данных. Он устанавливается
самостоятельно, через второй параметр конструктора WebSocket.

Поток данных в веб-сокетах состоит из фреймов. Это такие фрагменты данных, которые
могут быть отправлены любой стороной. В браузере напрямую можно работать только 
с текстовыми и бинарными фреймами. Помимо них есть еще пинг-понг фреймы, 
закрытия соединения и другие служебные.

Когда одна из сторон хочет закрыть соединение, она отправляет фрейм закрытия соединен.
с кодом закрытия и указывает причину (в виде текста): socket.close(code, reason);
Противоположная сторона получит эти данные в обработчике onclose.

Код закрытия это не любое число, а специальный номер. 
Подробнее о них написано здесь: https://learn.javascript.ru/websocket

Получить состояние соединения можно через свойство readyState. Значения такие:
...
* 0 - (connecting) соединение ещё не установлено;
* 1 - (open) обмен данными;
* 2 - (closing) соединение закрывается;
* 3 - (closed) соединение закрыто.

У веб-сокетов нет ограничений, связанных с кросс-доменными запросами!

Веб-сокеты не имеют такого функционала, как переподключение при обрыве соединения,
аутентификации пользователей и т.п. Это все реализуется отдельно. Иногда, чтобы добавить
веб-сокеты к уже существующ. проекту, запускают параллельно сокет-сервер на поддомене.

---------------------------------

КУКИ И АУТЕНТИФИКАЦИЯ

Куки - это небольшая строка с данными, которая хранится в браузере. Куки является
частью http-протокола и обычно устанавл. веб-сервером при помощи заголовка Set-Cookie.

Для каждого домена в браузере хранится своя отдельная куки-строка. Почти каждый запрос
сопровожается такой строкой, которая передается через заголовок Cookie. 
(кроме запросов на другие источники)

Чтобы получить доступ к куки из браузера, используется св-во: document.cookie.
Его значение - это строка вида "key1=value1; key2=value2; ...". 
Каждая отдельная пара "ключ=значение" - это одна кука.

Если этому св-ву присвоить какое-то своё значение, то оно добавится в конец строки:
document.cookie = 'hello';  -->  'key1=value1; key2=value2; hello'

Если добавить "куку", которая уже имеется в общей строке, то она перезапишется:
document.cookie = 'key2=hello';  -->  'key1=value1; key2=hello'

Для правильного форматирования, добавляемая пара должна быть закодирована:
document.cookie = `${encodeURIComponent('key2')}=${encodeURIComponent('hello')}`;

Кука не может быть большого размера. Максимальный размер одной пары не более 4кб, 
а их общее кол-во на один домен примерно 20+ (зависит от браузера). 

Куки, добавленные через document.cookie, сохраняются и доступны даже после 
перезагрузки страницы! Но доступны они только тому домену, который их установил. 
Это означает что other.com никогда не получит доступ к куки из my-site.com.

Для куки можно задать настройки. Они добавляются после всех пар "ключ=значение" 
и должны также разделяться точкой с запятой:
...
document.cookie = 'key2=hello; path=/; max-age=3600';

Настройка path задает путь, по котор. будет доступна куки. Например при path=/admin,
куки доступна только на страницах /admin и ниже (/admin/posts и т.п).

Настройка domain необходима, чтобы сделать куки видимой для субдоменов:
...
document.cookie = 'user=Vasya; domain=site.com';  -->  устанавливая на site.com
alert(document.cookie);  -->  user=Vasya станет доступна и на forum.site.com 

Настройки expires и max-age задают время жизни куки. По умолчанию, если куки не имеет
ни одной из них, то она считается сессионной и удалится при закрытии браузера. 

Значение expires должно быть только в формате GMT. Получить его можно так:
date.toUTCString(); Вместо expires можно указать max-age. Эта настройка определяет 
срок действия куки в секундах с текущего момента.

Чтобы удалить куки вручную, можно задать прошедшую дату для expires либо 
отрицательное значение для max-age.

Настройка secure означает, что куки будет доступна только через https.
document.cookie = 'user=Vasya; secure';

Настройку httpOnly может задать только веб-сервер. Она запрещает любой доступ к куки 
из JavaScript, т.е. куки станет недоступна через document.cookie.

Настройку samesite применяют для защиты от XSRF-атак (межсайтовая подделка запроса).
У неё есть два значения: strict (тоже самое, что samesite без значения) и lax.
Подробнее про них здесь: https://learn.javascript.ru/cookie

Атака XSRF - это когда пользователь, будучи авторизован на каком-то сайте, параллельно
заходит на вредоносный сайт. А тот в свою очередь делает POST-запрос на сайт жертвы. 
И получается что запрос делается как бы от лица того самого пользователя. А раз так, 
то вместе с запросом посылаются и авторизацион. куки. Таким образом сайт жертвы считает
что запрос был сделан именно самой жертвой, что приводит к несанкционирован. доступу.

Такие POST-запросы обычно выполняются автоматически, через отправку формы. 
Раньше, чтобы уберечься от этого, все формы должны были иметь поле с XSRF-токеном. 
Этот токен генерировался на сервере и передовался форме при её формирован на странице.
При отправке формы, на сервере происходила проверка того, что было сгенерировано ранее,
с тем, что пришло. И если токен не проходил валидацию, то отправка не выполнялась.

Хакеры не могут получить доступ к такому токену, потому что он всегда разный и
генерируется лишь в тот момент, когда пользователь загружает страницу.

Помимо этого есть еще одна уязвимость, связанная с куки. Сторонние ресурсы,
встраиваемые на сайте, могут отслеживать действия пользователей.

Допустим есть сайт, который размещает у себя картинку со спец. сайта. 
При загрузке такой картинки, спец. сайт установит в браузере пользователя свои куки.
При повторной загрузке, спец. сайту отправятся (от пользователя) ранее созданные куки.

Но если пользователь перейдет на другой сайт, где размещается та же картинка, то спец.
сайт также получит эти самые куки, т.к. они принадлежат ему. Т.о. он распознает
пользователя и сможет отслеживать его перемещение между разными сайтами.

Обычно такие куки устанавливаются при загрузке сторонних скриптов. А используются в
основном для отслеживания страниц, посещаемых пользователем, и показа рекламы.
Современные браузеры позволяют их отключать.

Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия 
на это в соответствии с законодательством GDPR. Это относится и к тем куки, что
используются для идентификации и авторизации пользователей.

Есть два основных варианта, как сайты следуют GDPR:

1. Если сайт хочет установить куки для отслеживания только авторизованным
пользователям, то регистрационная форма должна иметь спец. флажок "принять политику
конфеденциальности" (которая рассказывает, как используются эти куки), а пользователи
должны его отметить, когда регистрируются. 

2. Если сайт хочет установить куки для отслеживания всем пользователям, то чтобы
сделать это законно, сайт обязан показывать модальное окно требующие согласия на это,
пользователям, которые зашли на сайт впервые.

Аутентификация являяется одним из наиболее частых случаев использования куки.
Сначала, при входе на сайт, сервер отсылает ответ c заголовком Set-Cookie, чтобы
установить в браузере куки со специальным id сессии. При следующем запросе браузер
посылает на сервер заголовок Cookie с этим id. Так сервер понимает, кто сделал запрос.

Аутентификация с помощью JWT (JSON Web Token) происходит так. Клиент вводит логин и
пароль. Создается сессия и он получает два токена: AccessToken и RefreshToken. Первый
имеет короткий период жизни. Второй длительный. Оба сохраняются, при этом AccessToken
обычно хранится где-то на клиенской стороне, а RefreshToken - записывается в БД. 

При последующих запросах, где необходимо быть аутентефицированным, клиент отсылает в
заголовках AccessToken. Если тот проходит верификацию то запрос проходит. Но перед тем
как отослать AccessToken, его необходимо проверить на актуальность. Если он протух, 
то его необходимо обновить через спец. подзапрос с RefreshToken'ом в заголовках.

AccessToken хранится на клиенте как раз из-за короткого передиода жизни, т.к. даже если
и попадет в чужие руки, то быстро станет неактуальным.

Существуют также и другие способы аутентификации, например OpenID. Этот способ часто
переплетен с протоколом авторизации OAuth 2.0. Говоря проще, это когда какой-то сервис
выступает в роли посредника, с помощью котор. пользователь проходит данную процедуру.
Например логинется через свой аккаунт в соц. сетях и т.п.

---------------------------------

ХРАНЕНИЕ ДАННЫХ В БРАУЗЕРЕ

Объекты localStorage и sessionStorage позволяют хранить данные в браузере.
Минимальный объем сохраняемых данных состовляет 5мб.

В localStorage данные хранятся всегда, даже после перезапуска браузера и ОС. 
Этот объект один на все вкладки и окна в рамках источника (Origin).

В sessionStorage данные хранятся только пока открыта вкладка браузера и доступны они
также только в её рамках. При этом они продолжают существовать после перезагрузки,
страницы, но не после закрытия/открытия новой. Страницы в ифреймах имеют доступ 
к sessionStorage верхней страницы. Этот объект используется нечасто.

В отличии от куки, объекты хранилища не отправляются на сервер при каждом запросе.
Кроме того, сервер не может ими манипулировать через http-заголовки.

Хранилище привязано к источнику. Т.е. разные протоколы или субдомены определяют 
разные объекты localStorage и sessionStorage, и они не могут получить доступ 
к данным друг друга.

Объекты хранилища имеют одинаковый интерфейс: 
* setItem(key, value) - сохранить пару ключ/значение;
* getItem(key) - получить данные по ключу;
* removeItem(key) - удалить данные с ключом key; 
* clear() - удалить всё;
* key(index) - получить ключ на заданной позиции; 
* length - кол-во элементов в хранилище.

Также можно получать/записывать данные, как в обычный объект: localStorage.test = 23;
Но так делать не рекоменд., потому что при такой записи не сработает событие "storage".

Объекты хранилища нельзя перебирать в обычном цикле т.к. они не итерируемы, но их 
можно использовать с циклом for in. А для получения всех ключей подойдет Object.keys.

Ключи и значения должны быть строками. Другие типы будут автоматически преобразованы.
localStorage.user = { name: 'Vasya' };  -->  выведет [object Object]

Когда в хранилище обновляются данные, то вызывается событие window.onstorage.
Оно вызывается на всех окнах, которым доступно хранилище, но только не там, 
где было инициировано обновление.

---------------------------------

РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ

Они реализованы с помощью объекта RegExp и интегрированы в методы строк.

Есть 2 синтаксиса для создания регулярных выражений.
1) Длинный: new RegExp('шаблон', 'флаг');
2) Короткий, через слэши: /шаблон/флаг  -->  это тот же RegExp

Короткий синтаксис не допускает никаких вставок переменных, типа ${...} и т.п.
Он используется когда точно известно, каким должно быть регулярное выражение. 
А длинный - когда необходимо создавать рег. выр-е динамически, "на лету".

Флаги (они влияют на поиск):
* i - поиск не зависит от регистра (нет разницы между "А" и "а");
* g - поиск ищет все совпадения в строке, а без него только первое;
* s - включает режим "dotall"; см. далее;
* u - включает полную поддержку Юникода; см. далее;
* m - многострочный режим; см. далее;
* y - режим поиска на заданной позиции в тексте; см. далее.

Символьные классы (заменяют собой какие-то символы):
* \d - цифры, от 0 до 9;
* \D - всё, кроме цифр (например буквы);
* \s - пробелы, включая символы \t и \n;
* \S - всё, кроме пробелов (цифры или буквы);
* \w - лат. буквы, цифры и символ подчёркивания;
* \W - всё, кроме букв, цифр и подчёркивания (пробел, русские буквы);
*  . - любой символ, кроме \n. 

Чтобы точка также соответствовала и \n, рег. выр-е должно иметь флаг "s":
/A.B/  -->  совпадает с "A\nB" 

Чтобы рег. выр-е могло правильно интерпритировать все символы (русские/китайские
арабские буквы, смайлики и другие сурогатные пары), оно должно иметь флаг "u".
Кроме того, этот флаг также требуется если нужно использовать класс \p{}.

В его фигурных скобках указ. спец. свойство, принадлежащее символу Юникода. Например
Letter означает букву на любом языке: /p{Letter}/u  -->  F Ц ბ (совпадение с любой)
Также это могут быть различные апострофы, символы валют, шестнадцатирич. цифры и т.д.

Символы каретки "^" и доллара "$" называются якорями. 
Каретка означает совпадение в начале, а доллар - совпадение в конце.
...
/^Mary/  -->  совпадает с "Mary had a lamb"
/snow$/  -->  совпадает с "Fleece white as show"

Оба якоря часто используют вместе чтобы проверить текст на полное совпад. с шаблоном.
Например шаблон времени \d\d:\d\d может соответств. тексту с буквами, цифрами и т.д,
тогда как ^\d\d:\d\d$ четко говорит о том, что текст должен начин. и заканч. цифрами.

Якоря в многострочном режиме означают не только начало/конец текста, но и начало/конец
каждой строки в тексте. Включается он с помощью флага "m".

Граница слова, как и якоря, также является проверкой. Она нужна чтобы находить
отдельные слова в тексте, но может работать и с цифрами. Задается через символ \b.
...
/\bJava\b/   -->  совпадает с "Hello Java", но не c "Hello, JavaSript"
/\b\d\d\b/g  -->  в строке "1 23 456 78" найдет только 23 и 78

Есть 3 вида позиций, которые являются границами слова:
1) Начало текста, если его первый символ \w.
2) Позиция внутри текста, если слева \w, а справа - не \w, или наоборот.
3) Конец текста, если его последний символ \w.

Граница слова работает только с латинским алфавитом.

Чтобы экранировать спец. символы, нужно добавить к ним обратный слэш "\".
Их перечень: [ ] \ ^ $ . | ? * + ( ).  Символьные классы - это те же спец. символы.

Также, следует помнить что обычные строки съедают обратный слэш. Поэтому его 
необходимо удваивать, если рег. выр-е берется оттуда:
...
'\d\.\d'  -->  совпадает с "d*d", где * - это любой символ
'\\d\\.\\d'  -->  совпадает с "5.5", "1.2" и т.п.

Квадратные скобки задают набор. Это означает, искать любой символ из заданных.
/[тх]оп/  -->  либо "топ", либо "хоп"

А ещё они задают диапазоны символов, например диапазон [a-z] будет соответствовать
любому символу от "a" до "z", или [0-9] - любой цифре от 0 до 9. 

Диапазонов может быть сразу несколько: 
[0-9A-Z]  -->  либо цифра от 0 до 9, либо буква от "A" до "Z"
[a-zA-Z]  -->  буквы как в верхнем, так и в нижнем регистрах (либо использ. флаг i)  

Также в кврадратных скобках могут размещаться и символьные классы:
[\s\d]  -->  или пробел, или цифра

Символьные классы это всего лишь сокращения для наборов:
* \d - это тоже самое, как если б написать [0-9];
* \w - тоже, что и [a-zA-Z0-9_] (поэтому и не ищет русских букв);
* \s - тоже, что и [\t\n\r] + несколько редких пробельных символов.

Кроме того, есть ещё и исключающие диапазоны: [^...]. Символ каретки означает что
диапазон соответствует любому символу за исключением заданных.
...
[^aey]  -->  любой символ, за исключением "а", "е", "у"
[^0-9]  -->  любой символ, за исключением диапазона цифр от 0 до 9 (тоже, что и \D)

Большинство спец. символов внутри квадратных скобок экранировать не нужно:
[^.+-()]  -->  будет искать один из символов: ^ . + - ( )

Фигурные скобки обозначают квантификатор. Он указывает на кол-во повторений и задается
вместе с каким-то символом, символьным классом, набором и т.д, например: \d{5} 
означает \d\d\d\d\d. Чтобы исключить числа длиннее, пишем: \b\d{5}\b 

Границы указываются так: \d{3,5} -->  все числа от 3 до 5 цифр.
Если записать \d{3,} то находится будут числа длинной только 3 и более цифр.

Самые востребованные квантификаторы имеют сокращения:
* "+" - один или более; тоже, что и {1,} (\d+ это все цифры в "123-45-6") 
* "?" - ноль или один; тоже, что и {0,1} (colou?r это "color" либо "colour")
* "*" - ноль или более; тоже, что и {0,} (\d0* найдет цифру и все нули за ней)

По умолчанию квантификаторы работают в жадном режиме. Например, вот что будет 
если попытаться найти все слова в кавычках, через рег. выр-е /".+"/g

Сначала квантификатор .+ будет подгребать все символы, пока не дойдет до конца
  "............................. ->
a "witch" and her "broom" is one

А когда строка закончится, будет сокращать их, пока не встретит тот остаток, 
что указан после него в шаблоне, т.е. кавычку
  "....................." <-
a "witch" and her "broom" is one

Но иногда, чтобы получить корректный результат, нужно переключится в ленивый режим.
Это делается с пом. доп. знака "?", после квантификатора: /".+?"/g

Теперь квантификатор .+? после каждой точки будет проверять текст и на остаток. 
А когда его найдет, то поиск закончится:

  "." ->
a "witch" and her "broom" is one

  ".." ->
a "witch" and her "broom" is one

При этом след. учитывать, что хорошо настроенный жадный поиск в некоторых случаях 
может работать ещё лучше чем ленивый, например: /"[^"]+"/g

Круглые скобки - это скобочная группа. Они группируют часть рег. выр-я. 
Если задать после них квантификатор или другую операцию, то это будет применяться 
ко всему содержимому внутри, а не к одному символу.
...
/go+/    -->  без скобок: go, gooo, gooooo и т.д.
/(go)+/  -->  со скобками: go, gogo, gogogo
/(\w+\.)+\w/g  -->  mail.com, user.mail.com, super.user.mail.com и т.п.

Поисковой движок запоминает содержимое каждой скобочной группы, и позволяет получить
его в результате. Например метод str.match возвращает массив, где каждый элемент
представляет детали отдельной скобочной группы из рег. выр-я.
...
let res = '<div class="my">'.match(/<(([a-z]+)\s*([^>]*))>/);
res[0];  -->  <div class="my"> (общий результат)
res[1];  -->  div class="my"   (первая скобка)
res[2];  -->  div              (первая вложенная скобка)
res[3];  -->  class="my"       (вторая вложенная)

Если рег. выр-е содержит флаг "g", то метод str.match не возвращает скобочные группы.
Результатом будет массив совпадений, но без деталей. Для того чтобы получить 
также и детали, вместо match нужно использовать matchAll.

Скобочные группы можно именовать, добавив ?<name> после открытия скобки:
...
let res = '2019-04'.match(/(?<year>[0-9]{4})-(?<month>[0-9]{2}>)/g);
let groups = res.groups;  -->  с флагом "g" группы доступны через это свойство
groups.year; groups.month;

Метод str.replace заменяет все найденные совпадения в строке, производя поиск по 
рег. выр-ю. При этом, в заменяющем шаблоне можно размещать содержимое скобок в любом
месте. Это делается через обозначение "$n", где n - номер скобочной группы.
Для именованных скобок, ссылка будет выглядеть как "$<name>".
...
'John Bull'.replace(/(\w+) (\w+)/, '$2, $1');  -->  "Bull, John"
'2019-04'.replace(/(?<year>[0-9]{4})-(?<month>[0-9]{2})/, '$<month>.$<year>');

(другие обозначения: https://learn.javascript.ru/regexp-methods)

Чтобы исключить скобочную группу из массива совпаден, нужно доб. "?:" после открытия.
Кроме того, такую группу нельзя будет использовать через $n, в строке замены.
...
let res = 'Gogogo John!'.match(/(?:go)+ (\w+)/i);
res[0];  -->  "Gogogo John"
res[1];  -->  "John"

К содержимому скобок можно обращаться и внутри самого регулярного выражения.
Делается это с помощью записи "\N", где N - номер скобочной группы.
...
`He said "She's the one!"`.match(/(['"])(.*?)\1/g);  -->  `"She's the one!"`

Сначала выражение, с пом. (['"]) находит первую кавычку и запонимает её, т.к. \1
указывает именно на эти скобки. Далее, в шаблоне, на место \1 подставляется то, 
что было запомнено ранее. Т.о. выражение как бы трансформируется в /"(.*?)"/g

Для обращения к именованным скобкам используется запись \k<name>, например: 
`He said "She's the one!"`.match(/(?<quote>['"])(.*?)\k<quote>/g);

Альтернация - это ИЛИ. Записывается она с помощью знака "|". Она напоминает квадратные
скобки, но при этом является более мощным механизмой, разделяющим не только символы, 
но и целые под-выражения. Например: /[01]\d|2[0-3]/  -->  час, от 00 до 24

В регулярных выражениях существуют опережающие и ретроспективные проверки. 
Первая задается так: X(?=Y). Это означает: найти X, при условии, что за ним следует Y.

Допустим есть строка, и в ней нужно найти число, после котор. есть знак €.
'Индейка стоит 30€'.match(/\d+(?=€)/);  -->  "30"

Возможны и более сложные варианты, например X(?=Y)(?=Z) означает, что нужно найти X 
при условии, что за ним идет и Y, и Z.

Негативная проверка задается так: X(?!Y), т.е. найти X, за которым не следует Y.

Ретроспективная проверка: (?<=Y)X. Она ищет совпадение с X при условии, что ПЕРЕД ним
есть Y: И, аналогично, негативная ретроспективная проверка: (?<!Y)X.
...
'Индейка стоит $30'.match(/(?<=\$)\d+/);  -->  "30"

Как правило, тот Y, что входит в скобки, не включается в результат.
Но если требуется захватить и его, то он должен быть обернут в доп. скобки.
...
'Индейка стоит 30€'.match(/\d+(?=(€))/);  -->  "30", "€"

Флаг "y" позволяет задать поиск на конкертной позиции в тексте. В основном он
используется для улучшения производительности. Позицию можно задать через свойство
lastIndex, объекта regexp. Оно доступно только если рег. выр-е имеет флаг "y" или "g".
...
let text = 'let value = "hello"';
let regexp = /\w+/y;

regexp.lastIndex = 3;
regexp.exec(text)  -->  null (позиция 3 не соотв. шаблону)

regexp.lastIndex = 4;
regexp.exec(text)  -->  value

При этом, если вместо "y" поставить "g", то след. запись будет верна:
...
regexp.lastIndex = 3;
regexp.exec(text)  -->  value (ищет, начиная с 3 позиции и далее)

Если рег. выр-е используется вместе с флагом "g", то свойство lastIndex всегда
возвращает позицию, после каждого найденного совпадения.
...
regexp.lastIndex;   -->  0

regexp.exec(text);  -->  let 
regexp.lastIndex;   -->  3

regexp.exec(text);  -->  value
regexp.lastIndex;   -->  9

regexp.exec(text);  -->  null (больше сопадений нет)
regexp.lastIndex;   -->  0 (сбрасывается по окончании поиска)

Если рег. выр-е имеет большое кол-во комбинаций, которые усложняют поиск, то оно может
привести к зависанию интерпритатора JS. Это называется - катастрофический возврат.

Регулярные выражения используются в следующих методах:

* str.match(regexp) - ищет совпадения в строке; regexp без флага "g", возвращает первое
совпадение, с флагом - массив всех совпадений, но без деталей; иначе null.

* str.matchAll(regexp) - возвращает перебираемый объект, где каждое совпадение - это
массив с его деталями; иначе пустой перебираемый объект; раньше вместо этого метода
использался regexp.exec, когда нужны были детали всех совпадений;

* str.split(regexp|str, limit) - разбивает строку на массив подстрок по разделителю;
* str.search(regexp) - возвращает позицию только первого совпадения; иначе -1;

* str.replace(regexp|str, str|func) - ищет и заменяет все совпадения; если первый
агрумент строка, то заменяет только первое совпадение;

* regexp.exec(str) - альтернативный вариан для str.match;
* regexp.test(str) - ищет совпадение и возвращает true/false.

Методы exec и test также необходимы, когда нужен поиск с использованием флага "y".
Одно и тоже рег. выр-е, использ. повторно в этих методах, может дать другой результат.
...
let regexp = /javascript/g;
regexp.test('javascript');  -->  true
regexp.test('javascript');  -->  false, т.к. lastIndex уже 10, а не 0

Чтобы это исправить, нужно вызывать regexp.lastIndex = 0; перед каждым поиском.

---------------------------------

АНИМАЦИИ

Для них можно использовать setInterval. При этом следует помнить, что для лучшей
произодительности эта ф-ция должна быть только одна на все анимации.

Иногда, когда CPU занят другими процессами, может возникать подтормаживание, кроме того
анимацию можно вообще отключать, когда вкладка браузера скрыта и т.д.

Чтобы исключить все эти недостатки, анимацию следует выполнять с помощью спец. ф-ции
requestAnimationFrame. Она встроена в браузер по умолчанию и позволяет вызывать
анимацию в нужный момент, когда браузер готов совершить перерисовку!

Ф-ция requestAnimationFrame напоминает setTimeout. Она также возвращает спец. id
по которому можно отменить вызов анимации. Для отмены использ. cancelAnimationFrame.
...
let requestId = requestAnimationFrame(animCb);
cancelAnimationFrame(requestId);

Колбек имеет один параметр - время с момента загрузки страницы, в миллисекундах.
Также это значение можно получить с помощью: performance.now();
...
let start = performance.now();

requestAnimationFrame(function cb(time) {
  let delta = (time - start) / 1000;  -->  0.017
  let fps = 1 / delta;                -->  58                
  start = time;
  requestAnimationFrame(fn);  -->  чтобы fn вызывалась циклично;
});                                интервал определяет сам браузер

Если в колбеке происходит какое-то изменение элементов, то оно будет сгруппировано 
с другими requestAnimationFrame и CSS-анимациями. Т.о. браузер выполнит одну
перерисовку, вместо нескольких.

Подробнее про анимации, и что означают их тайминговые ф-ции (easyIn, easyOut): 
https://learn.javascript.ru/js-animation

