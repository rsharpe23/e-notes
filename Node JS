ОСНОВЫ NODE.JS

Node.js - это среда выполнения JS-кода. Она интерпритирует JS в машинный код c помощью
интерпритатора V8 и выполняет его на компьютере без браузера. Сам V8 построен на C++
и является ядром как для браузера, так и для Node.js.

Node.js использует модульную систему для построения ф-циональности. 
Модули следует использовать только проверенные, потому что код выполняется на сервере.

Загрузка модуля происходит с помощью ф-ции require(module_name).
Чтобы экспортировать переменные или ф-ции из модуля, нужно поместить их в объект
module.exports. Сам объект module представляет ссылку на текущий модуль.

Данные, импортируемые из модуля всегда указывают на один и тот же объект.
...
const a = require('my-obj');  -->  a и b имеют одинаковую ссылку
const b = require('my-obj');  

Если в проекте есть папка, а в ней файл index.js, тогда для обращения к файлу
достаточно имени каталога:
...
home -> index.js -> module.exports = { ... }
const home = require('./home');

Объект global предоставляет доступ к глобальным переменным/ф-циям. Такие переменные
доступны в каждом модуле. К глобальным переменным можно обращаться напрямую, 
не указывая global вначале.
...
global.age = 23;  -->  module1.js
global.console.log(global.age);  -->  module2.js [либо просто console.log(age)]

Помимо global существуют также множество других объектов. Самые распространенные:
* __dirname - директория исполняемого js-файла;
* __filename - полное имя файла с директорией и расширением;
* process - различная информацию о конфигурациях, переменных окружения и т.д.

Чтобы запустить приложение нужно прописать в терминале: node file.js [param1, paramN].
Чтобы получить доступ к параметрам, внутри приложения нужно обратиться к массиву
process.argv. Этот массив подобен тому, что передается в ф-цию main из C/C++.
...
node app.js hello 23  -->  process.argv будет таким: [node_path, app_path, 'hello', 23]

Чтобы сервер автоматически перезапускался после каждого изменения в файлах, 
нужно использовать инструмент nodemon. Само же приложение должно запускаться так:
nodemon app.js

С nodemon могут быть проблемы. Например если в проекте есть локальн. БД из json-файлов, 
и backend, который их перезаписывает, то nodemon будет постоянно перезапускать сервер, 
а клиент не получать нужные ответы, в это время.

Работа с файлами осуществляется с помощью модуля fs.
...
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (error, data) => {});  -->  Считывает файл асинхронно
const content = fs.readFileSync('file.txt', 'utf8');  -->  Считывает файл синхронно

fs.writeFile('file.txt', 'content', error => {});  -->  Перезаписывает файл асинхронно
fs.writeFileSync('file.txt', 'content');  -->  Перезаписывает файл синхронно

fs.appendFile('file.txt', 'content', error => {});  -->  Дозаписывает файл асинхронно
fs.appendFileSync('file.txt', 'content');  -->  Дозаписывает файл синхронно

fs.unlink('file.txt', error => {});  -->  Удаляет файл асинхронно
fs.unlinkSync('file.txt');  -->  Удаляет файл синхронно

С файлами можно также работать и при помощи потоков.

Потоки нужны, чтобы передавать большие данные по частям. Это экономит память, 
т.к. не нужно предварительно загружать сразу все данные (большой файл БД или видео).
Часть потока (некоторое временное хранилище для куска данных) называется буфером. 

Существуют потоки чтения, записи, дуплексные (чтение и запись вместе) и преобразующие
(как дуплексные, но доп. изменяют читаемые или записываемые данные, например архивация).
...
const fs = require('fs');

const wStream = fs.createWriteStream('file.txt');
wStream.write('Привет');  -->  Первый буфер
wStream.write('мир!');  -->  Второй буфер

const rStream = fs.createReadStream('file.txt', 'utf8');
rStream.on('data', chunk => console.log(chunk));  -->  Сначала выведет 'Привет', 
                                                       а потом 'мир!'

Чтением потока управляет сам Node.js как только появляется обработчик.
Также существует принудильное чтение/запись.

Метод pipe() создает канал, который связывает потоки чтения и записи (т.е. дуплексный
поток), позволяя тем самым считатывать и сразу записывать. Каждый вызов pipe()
возвращает поток для чтения.
...
rStream.pipe(wStream)  -->  Тоже что и запись ниже
rStream.on('data', chunk => wStream.write(chunk));

Чтобы создать папку, используется метод mkdir, а чтобы удалить - rmdir: 
fs.mkdir('путь_создаваемой_папки', () => {});
fs.rmdir('путь_удаляемое_папки', () => {});

Для генерации событий используются объекты класса EventEmitter. У него есть метод on(),
который добавляет обработчик события. Все обработчики складываются в цепочку, 
а когда вызывается метод emit() они все выполняются разом.
...
const EventEmitter = require('events');

const myEvent = 'my-event';
const emitter = new EventEmitter();

emitter.on(myEvent, data => console.log(data));
emitter.on(myEvent, data => console.log(data));

emitter.emit(myEvent, 'Привет мир!');  -->  Выведет 2 раз 'Привет мир!'

Иногда полезно наследоваться от EventEmitter, тем самым добавляя своему классу ф-ционал
событий. Название EventEmitter при импорте - это общепринятая практика!

------------------------------

NODE PACKAGE MANAGER

По умолчанию вместе с Node.js устанавливается и NPM. Команда для работы с NPM: npm -v.
Для управления пакетами используется конфигурационный файл package.json. Он содержит
список установленных модулей, а также информацию о проекте. Чтобы создать этот файл,
лучше всего использовать команду: npm init.

Также, существует еще такой файл как package-lock.json. 
Он необходим для синхронизации всех версий пакетов на разных компьютерах.
Чтобы версии зависимостей были у всех одинаковые.

Чтобы легко склонировать все зависимости стороннего проекта, нужно взять packege.json 
и выполнить команду npm install. Это позволит установить сразу все модули, вместо того
чтобы устанавливать каждый по отдельности.

Минимальная конфигурация package.json:
...
{ "name": "module_name", "version": "1.0.0" }

Чтобы установить модуль нужно прописать: npm install название_модуля.
Все установленные модули хранятся локально внутри проекта в папке node_modules.

По умолчанию, при установке модуля используется флаг --save (с недавнего времени).
Чтобы утсановить сразу несколько модулей, нужно перечислить их названия через запятую.

Информация о всех установленных модулях хранится в секции dependencies, 
файла package.json:
...
{ "name": "my-app", "version": "1.0.0", dependencies: { "module": "^1.2.0" } }

Некоторые модули являются инструментами, например gulp, bower (всякие компиляторы,
транспиляторы, тестеры и т.д.). Они помогают создавать код и в прод не должны
попадать, т.к. там используется уже готовый код. 

Такие модули должны устанавливаться с флагом --save-dev (для разработки).
Модули для разработки попадают в секцию devDependencies.
...
npm install gulp --save-dev  -->  devDependencies: { "gulp": "^4.0.1" }
npm install gulp@4.1.8   -->  утсановка конкретной версии
npm install gulp@latest  -->  обновление до последней версиии

Чтобы установить модуль глобально нужно использовать флаг -g: npm install gulp -g
В этом случае модуль будет находится в том месте, куда установлен Node.js.

Чтобы удалить модуль нужно прописать: npm uninstall название_модуля.
Также можно и вручную отредактировать файл package.json, после чего ввести npm install.

Версионирование модулей определяется в формате: "major.minor.patch".
Если в модуле исправляется какой-то баг, то увеличивается на единицу число patсh.
Если в модуль добавляется какой-то ф-ционал, который совместим с предыдущей версией, 
то увеличивается minor. Если же вносятся какие-то большие изменения, которые не
совместимы с предыдущей версией, то major.

Если в версии присутствует символ каретки, то это означает что при использовании 
npm install будет установлена последняя доступная версия, начиная от указанной.
...
devDependencies: { "gulp": "^4.0.1" }  -->  Установится самая последняя версия, 
                                            начиная с 4.0.1 (например 6.1.2)

В package.json можно также определять компанды. Они размещаются в секции scripts.
Команды могут быть как произвольными, так и зарезервированными (start, test, run и т.д).
...
scripts: { "start": "node app.js", "my-command": "node app.js hello 23" }
npm start  -->  Зарезервированные команды выполняются напрямую
npm run my-command  -->  Произвольные команды выполняются через run

------------------------------

СОЗДАНИЕ СЕРВЕРА

Чтобы создать сервер с протоколом http, можно использовать встроенный модуль:
...
const http = require('http');
http.createServer(callback).listen(3000);  -->  создает сервер на порту 3000

Сервер прослушивает входящие подключения и обрабатывает их через callback.
Колбек, по сути, является главной входной точкой для приложения на node.js.
Он также принимает такие параметры как: request и response.

Параметр request хранит информацию о запросе (заголовки, метод запроса, url и т.д.), 
а через response можно делать отправку ответа.

Чтобы послать ответ нужно задать все необходимые данные и вызвать метод response.end().
...
function callback(req, res) {
  res.setHeader('Content-Type', 'text/html');  -->  добавляет в ответ заголовок
  res.setHeader('UserId', 12);  -->  добавляет пользовательский заголовок

  res.write('<h1>Hello!</h1>');  -->  пишет в поток ответа некоторый контент
  res.write('<p>Some text</p>'); -->  если нужно отправить большой ответ, то информацию 
  res.write('<a>Link</a>');    можно задавать порциями, вызывая write по нескольку раз

  res.end();  -->  говорит серверу, что заголовки и тело ответа установлены 
}                  и в итоге тот отсылается клиенту

Чтобы сделать переадресацию, нужно установить заголовок Location и нужный statusCode
...
res.setHeader('Location', 'http://new-address');
res.statusCode = 301;  -->  по умолчанию отсылается статус 200 (ПРОВЕРИТЬ!)
res.end();

Чтобы в ответ на запрос послать html-файл, его нужно предварительно считать с помощью 
метода fs.readFile(), и затем передать эти данные в response.end():
...
fs.readFile(path, function(err, data) {
  res.end(data);
});

Альтернативным вариантом является создание файлового потока для чтения и передача 
в него, через pipe, объекта response: fs.createReadStream(path).pipe(res);

Также нужно помнить, что если сервер отдает html-файл с вложенными стилями/скриптами,
то при загрузке такого файла в браузере, тот будет посылать на сервер новые запросы,
чтобы загрузить эти самые вложенности. Поэтому для такой ситуации, сервер, помимо 
html должен также знать, как отдавать css/js.

Объект request представляет собой поток, который получает данные порциями (чанками).
Чтобы вытащить из него данные нужно подписаться на его событие data. Кроме того, 
он также имеет событие end. Оно срабатывает когда все данные успешно получены.
...
let data = "";
request.on('data', chunk => data += chunk);
request.on('end', () => res.end('Данные получены!'));
...
fetch('route', { method: 'POST', body: 'My data' });

Помимо этого request является асинхронным итератором, что позволяет использовать 
цикл for await of, для работы с ним.
...
const buffer = [];
for await (const chunk of request) {
  buffer.push(chunk);
}
const data = Buffer.concat(buffer).toString();
...
const data = { name: 'Vasya', age: 85 };
fetch('route', { method: 'POST', body: JSON.stringify(data) });

------------------------------

Express



------------------------------

MongoDB

Для того чтобы работать с MongoDB, нужно установить модуль mongoose.
Он дает весь необходимый ф-ционал. Напрямую же с этой БД работать не получится.

Сначала нужно зарегистрироваться на сайте mongodb.com
После этого, в панели управления, нужно создать кластер. Тариф - Sandbox.

Далее нужно создать коллекцию. Коллекция представляет собой набор моделей.
При создании коллеции также нужно будет указать и имя БД.

Далее, во вкладке Database Access нужно создать пользователя БД.
Метод авторизации - Password.

После этого, во вкладке Clusters нужно нажать на кнопку Connect.
Метод подключения - Connect your application.

В появившемся окне копирует строку подключения, предварительно подставив 
свои данные, и переносим её приложение.

Кроме того, во вкладке Network Access нужно дать доступ всем IP-адресам.
Делается это нажатием на кнопку Allow Access From Anywhere.

Связь с БД внутри приложения (db - та самая строка подключения): 
...
mongoose.connect(db, { useNewUrlParser: true, useUnifiedTopology: true });

Работа с данными происходит через модели. Модель содержит в себе удобные методы, 
такие как: find, findById, deleteOne, get и т.д. Модель создается на основе схемы.
Схема модели - это её описание, т.е. из каких полей она состоит и т.п.

Пример создания модели (файл post.js):
...
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const postSchema = new Schema({  -->  создание схемы
  text: { type: String, required: true }  -->  поле обязательно для заполнения
  author: { type: String }
});

const Post = mongoose.model('Post', postSchema);  -->  создание модели
module.exports = Post;  -->  экспорт модели

Пример использования модели:
...
const Post = require('post');
const post = new Post({ text: "asd", author: "Vasya" });
post.save().then(...)  -->  сохраниение данных в БД  

------------------------------

РАЗНОЕ

IP-адрес - это уникальный идентификатор компьютера в сети.
Сервер - это компьютер, который хранит данные. Сервер, который хранит сайт называется
хостом. Доменное имя - это удобочитаемый псевдоним для IP-адреса.

Сетевой протокол - это набор комуникационных правил, которые принимают стороны, 
для того чтобы взаимодействовать. Протоколы бывают как http, так и tcp и т.п.

Чтобы отправить запрос и получить ответ, нужно установить некий канал связи. 
Такой канал называется "Socket". Отправка данных между двумя компьютерами через Socket,
происходит по протоколу tcp.

Данные отправляются с помощью пакетов. Пакеты напоминают буфер (как в потоках), 
в котором содержится небольшая порция передаваемой информации.

Порты позволяют идентифицировать программу, для которой приходит запрос.
Основные методы http-запроса: GET, POST, PUT, PATCH, DELETE.

Заголовок Content-Type, который задается в ответе, помогает определить браузеру 
тип получаемых данных от сервера. Это может быть обычный текст, html, json и т.д.

Если Content-Type имеет значение text/plain, но при этом передаваемые данные будут 
в виде html, то браузер не воспримет их как веб-страницу, а выведет просто
экранированный текст.

НАПИСАТЬ ОПРЕДЕЛЕНИЕ ДЛЯ localhost!

