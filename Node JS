ОСНОВЫ NODE JS

Node JS - это среда выполнения JS-кода. Она интерпритирует JS в машинный код c помощью
интерпритатора V8 и выполняет его на компьютере без браузера. Сам V8 построен на C++
и является ядром как для браузера, так и для Node JS.

Node JS использует модульную систему (CommonJS) для построения ф-циональности. 
Модули следует использовать только проверенные, потому что код выполняется на сервере.
Загрузка модуля происходит с помощью ф-ции require(module_name).

Чтобы экспортировать переменные или ф-ции из модуля, нужно поместить их в объект
module.exports. Сам объект module представляет ссылку на текущий модуль.

Данные, импортируемые из модуля всегда указывают на один и тот же объект.
...
const a = require('my-obj'); // a и b имеют одинаковую ссылку
const b = require('my-obj');  

Если в проекте есть папка, а в ней файл index.js, тогда для обращения к файлу
достаточно имени каталога. Это называется голые (bare) модули.
...
home -> index.js -> module.exports = { ... }
const home = require('./home');

В ES-модулях такая возможность не поддерживается по умолчанию. Чтобы её включить, 
нужно добавить флаг --experimental-specifier-resolution=node, при запуске приложения
(по умолчанию можно импортировать только bare-модули из node_modules).

Объект global предоставляет доступ к глобальным переменным/ф-циям. Такие переменные
доступны в каждом модуле. К глобальным переменным можно обращаться напрямую, 
не указывая global вначале.
...
global.age = 23;  -->  module1.js
global.console.log(global.age);  -->  module2.js

Помимо global существуют также множество других объектов, например:
* __dirname - директория исполняемого js-файла;
* __filename - полное имя файла с директорией и расширением;
* process - различная информацию о конфигурациях, переменных окружения и т.д.

Чтобы запустить приложение нужно прописать в терминале: node file.js [param1, paramN].
Чтобы получить доступ к параметрам, внутри приложения нужно обратиться к массиву
process.argv. Этот массив подобен тому, что передается в ф-цию main из C/C++.
...
node app.js hello 23  -->  process.argv будет: [node_path, app_path, 'hello', 23]

Чтобы сервер автоматически перезапускался после каждого изменения в файлах, нужно
использовать утилиту nodemon. Само же приложение должно запускаться так: nodemon app.js

С nodemon могут быть проблемы. Например если в проекте есть локальн. БД из json-файлов 
и backend, который их перезаписывает, то nodemon будет постоянно перезапускать 
сервер, а клиент не получать нужные ответы, в это время.

Работа с файлами осуществляется с помощью модуля fs:
...
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (error, data) => {});  -->  Считывает файл асинхронно
const content = fs.readFileSync('file.txt', 'utf8');  -->  Считывает файл синхронно

fs.writeFile('file.txt', 'content', error => {});  -->  Перезаписывает файл асинхронно
fs.writeFileSync('file.txt', 'content');  -->  Перезаписывает файл синхронно

fs.appendFile('file.txt', 'content', error => {});  -->  Дозаписывает файл асинхронно
fs.appendFileSync('file.txt', 'content');  -->  Дозаписывает файл синхронно

fs.unlink('file.txt', error => {});  -->  Удаляет файл асинхронно
fs.unlinkSync('file.txt');  -->  Удаляет файл синхронно

С файлами можно также работать и при помощи потоков.

Потоки нужны, чтобы передавать большие данные по частям. Это экономит память, 
т.к. не нужно предварительно загружать сразу все данные (большой файл БД или видео).
Часть потока (некоторое временное хранилище для куска данных) называется буфером. 

Существуют потоки чтения, записи, дуплексные (чтение и запись вместе) и преобразующие
(как дуплексные, но доп. изменяют читаемые или записываемые данные, например архивация).
...
const fs = require('fs');

const wStream = fs.createWriteStream('file.txt');
wStream.write('Привет');  -->  Первый буфер
wStream.write('мир!');  -->  Второй буфер

const rStream = fs.createReadStream('file.txt', 'utf8');
rStream.on('data', chunk => console.log(chunk));  -->  Сначала выведет 'Привет', 
                                                       а потом 'мир!'

Чтением потока управляет сам Node JS как только появляется обработчик.
Также существует принудильное чтение/запись.

Метод pipe() создает канал, который связывает потоки чтения и записи (т.е. дуплексный
поток), позволяя тем самым считатывать и сразу записывать. Каждый вызов pipe()
возвращает поток для чтения.
...
rStream.pipe(wStream)  -->  Тоже что и запись ниже
rStream.on('data', chunk => wStream.write(chunk));

Чтобы создать папку, используется метод mkdir, а чтобы удалить - rmdir: 
fs.mkdir('путь_создаваемой_папки', () => {});
fs.rmdir('путь_удаляемое_папки', () => {});

Для генерации событий используются объекты класса EventEmitter. У него есть метод on(),
который добавляет обработчик события. Все обработчики складываются в цепочку, 
а когда вызывается метод emit() они все выполняются разом.
...
const EventEmitter = require('events');

const myEvent = 'my-event';
const emitter = new EventEmitter();

emitter.on(myEvent, data => console.log(data));
emitter.on(myEvent, data => console.log(data));

emitter.emit(myEvent, 'Привет мир!');  -->  Выведет 2 раз 'Привет мир!'

Иногда полезно наследоваться от EventEmitter, тем самым добавляя своему классу ф-ционал
событий. Название EventEmitter при импорте - это общепринятая практика!

------------------------

СОЗДАНИЕ СЕРВЕРА

Чтобы создать сервер с протоколом http, можно использовать встроенный модуль:
...
const http = require('http');
http.createServer(callback).listen(3000);  -->  создает сервер на порту 3000

Сервер прослушивает входящие подключения и обрабатывает их через callback.
Колбек, по сути, является главной входной точкой для приложения на Node JS.
Он также принимает такие параметры как: request и response.

Параметр request хранит информацию о запросе (заголовки, метод запроса, url и т.д.), 
а через response можно делать отправку ответа.

Чтобы послать ответ нужно задать все необходим. данные и вызвать метод response.end().
...
function callback(req, res) {
  res.setHeader('Content-Type', 'text/html');  -->  добавляет в ответ заголовок
  res.setHeader('UserId', 12);  -->  добавляет пользовательский заголовок

  res.write('<h1>Hello!</h1>');  -->  пишет в поток ответа некоторый контент
  res.write('<p>Some text</p>'); -->  если нужно отправить большой ответ, то информацию 
  res.write('<a>Link</a>');    можно задавать порциями, вызывая write по нескольку раз

  res.end();  -->  говорит серверу, что заголовки и тело ответа установлены 
}                  и в итоге тот отсылается клиенту

Чтобы сделать переадресацию, нужно установить заголовок Location и нужный statusCode
...
res.setHeader('Location', 'http://new-address');
res.statusCode = 301;  -->  по умолчанию отсылается статус 200 (ПРОВЕРИТЬ!)
res.end();

Чтобы в ответ на запрос послать html-файл, его нужно предварительно считать с помощью 
метода fs.readFile(), и затем передать эти данные в response.end():
...
fs.readFile(path, function(err, data) {
  res.end(data);
});

Альтернативным вариантом является создание файлового потока для чтения и передача 
в него, через pipe, объекта response: fs.createReadStream(path).pipe(res);

Также нужно помнить, что если сервер отдает html-файл с вложенными стилями/скриптами,
то при загрузке такого файла в браузере, тот будет посылать на сервер новые запросы,
чтобы загрузить эти самые вложенности. Поэтому для такой ситуации, сервер, помимо 
html должен также знать, как отдавать css/js.

Объект request представляет собой поток, который получает данные порциями (чанками).
Чтобы вытащить из него данные нужно подписаться на его событие data. Кроме того, 
он также имеет событие end. Оно срабатывает когда все данные успешно получены.
...
let data = "";
request.on('data', chunk => data += chunk);
request.on('end', () => res.end('Данные получены!'));
...
fetch('route', { method: 'POST', body: 'My data' });

Помимо этого request является асинхронным итератором, что позволяет использовать 
цикл for await of, для работы с ним.
...
const buffer = [];
for await (const chunk of request) {
  buffer.push(chunk);
}
const data = Buffer.concat(buffer).toString();
...
const data = { name: 'Vasya', age: 85 };
fetch('route', { method: 'POST', body: JSON.stringify(data) });

------------------------

NODE PACKAGE MANAGER

По умолчанию вместе с Node JS устанавливается и NPM: npm -v.

Для управления пакетами используется конфигурационный файл package.json. Он содержит
список установленных модулей, а также информацию о проекте. Чтобы его создать,
лучше всего использовать команду: npm init.

Также есть еще такой файл как package-lock.json. Он необходим для синхронизации всех
версий пакетов на разных компьютерах, чтобы версии зависимостей были у всех одинаковые.

Чтобы легко склонировать все зависимости стороннего проекта, нужно взять packege.json 
и выполнить команду npm install. Это позволит установить сразу все модули, 
вместо того чтобы устанавливать каждый по отдельности. 

Если указать флаг --production, то склонируются только те зависимости, кот. определены 
в секции dependencies, а зависимости из devDependencies будут проигнорированы. 

Минимальная конфигурация package.json: { "name": "module_name", "version": "1.0.0" }

Чтобы установить модуль нужно прописать: npm install название_модуля.
Все установленные модули хранятся локально, внутри проекта, в папке node_modules.

По умолчанию, при установке модуля используется флаг --save. Чтобы утсановить 
сразу несколько модулей, нужно перечислить их названия через запятую.

Информация о всех установленных модулях хранится в секции dependencies:
{ "name": "my-app", "version": "1.0.0", dependencies: { "module": "^1.2.0" } }

Некоторые модули являются инструментами, например gulp, bower (всякие компиляторы,
транспиляторы, тестеры и т.д.). Они помогают создавать код и в прод не должны
попадать, т.к. там используется уже готовый код. 

Такие модули должны устанавливаться с флагом --save-dev (для разработки; сокращенно -D).
Модули для разработки попадают в секцию devDependencies.
...
npm install gulp --save-dev  -->  devDependencies: { "gulp": "^4.0.1" }
npm install gulp@4.1.8   -->  утсановка конкретной версии
npm install gulp@latest  -->  обновление до последней версиии

Чтобы установить модуль глобально нужно использовать флаг -g: npm install gulp -g
В этом случае модуль будет находится в том месте, куда установлен Node JS.

Модули можно устанавливать из папок и через произвольные ссылки: 
...
npm install https://github.com/username/my-module.git
npm install ./my-module

При разработке собственного модуля важно чтобы его зависимости были в секции
dependencies, иначе они не подтянутся при установке через npm.

Чтобы удалить модуль нужно прописать: npm uninstall название_модуля.
Также можно и вручную отредактировать файл package.json, после чего ввести npm install.

Версионирование модулей определяется в формате: "major.minor.patch".
Если в модуле исправляется какой-то баг, то увеличивается на единицу число patсh.
Если в модуль добавляется какой-то ф-ционал, который совместим с предыдущей версией, 
то увеличивается minor. Если же вносятся какие-то большие изменения, которые не
совместимы с предыдущей версией, то major.

Если в версии присутствует символ каретки, то это означает что при использовании 
npm install будет установлена последняя доступная версия, начиная от указанной.
...
devDependencies: { "gulp": "^4.0.1" }  -->  Установится самая последняя версия, 
                                            начиная с 4.0.1 (например 6.1.2)

Если вместо каретки используется тильда "~", то будет установлена 
указанная версия, но с последним патчем.
...
devDependencies: { "@angular/core": "~20.0.0" }  -->  может установится 20.0.5 версия

В package.json можно также определять команды. Они размещаются в секции scripts.
Команды могут быть как произвольными, так и зарезервированными (start, test, run и т.д).
...
scripts: { "start": "node app.js", "my-command": "node app.js hello 23" }
npm start  -->  зарезервированные команды выполняются напрямую
npm run my-command  -->  произвольные команды выполняются через run

Начиная с версии 5.2.0, NPM поставляется с утилитой NPX (node package exec). 
Эта утилита позволяет временно устанавливать пакеты из репозитория с их последующим
выполенением. Например это могут быть различные исполняемые файлы, CLI и другие пакеты,
требующие глобальной установки. После выполнения пакета, NPX его удаляет.
...
npx gulp // временно установит gulp-cli и выполнит команду gulp

Помимо npm-пакетов, можно запускать произвольный код, доступный по некоему адресу:
npx https://gist.github.com/zkat/4bc19503fe9e9

Если пакет уже установлен локально, в node_modules, то npx будет обращаться к нему.
При этом не нужно указывать полный путь к его исполняемому файлу.

Существует также удобная утилита - NVM (Node Version Manager), которая позволяет
устанавливать несколько разных версий Node JS и переключаться между ними при необходимости.
При переключении Node JS через NVM, глобальные модули также будут меняться. 

По умолчанию оболочка всегда подгружает системный Node JS. Чтобы вместо системного 
Node JS по умолчанию подгружался Node JS из NVM, нужно задать алиас: 
...
nvm alias default <node_version>

------------------------

ОБЗОР PACKAGE.JSON



------------------------

РАБОТА С GULP

Установка gulp-cli: npm install --global gulp-cli
Установка gulp: npm install gulp --save-dev

Gulp CLI нужен для того, чтобы была доступна команда gulp в терминале.

Gulp - это таск менеджер. Таск представляет собой ф-цию, которая принимает колбэк 
с агрументом-ошибкой и возвращает поток/промис/эмитер/дочерний_процесс/наблюдаемый_тип.

Таски должны распологаться в файле gulpfile.js, в корневом каталоге.
Этот файл автоматически загружается при запуске команды gulp.

Таски можно выносить в отдельные файлы, и подключать их через require, в основном 
gulp-файле. Также можно заменить gulpfile.js на каталог с таким же именем.
Каталог должен содержать файл index.js и файлы тасков.

Таски бывают публичными и приватными. Публичные таски можно запускать командой gulp.
Приватные запускать нельзя, они создаются для внутренного использования.

Чтобы создать публичный таск, нужно экспортировать его из gulp-файла:

 function publicTask(cb) { ... }
 function publicTask2(cb) { ... }
 function privateTask(cb) { ... }

 exports.myTask = publicTask;
 exports.default = publicTask2;

Запустить дефолтный таск: gulp
Запустить несколько тасков: gulp <task> <othertask>

Для управления тасками Gulp API предоставляет такие методы, как: series(), parallel(),
src(), dest(), watch(). Первые два позволяют объединять таски. Метод series() делает
так, чтобы таски выполнялись по порядку, а parallel() - параллельно.

 const { series } = require('gulp');

 function transpile(cb) { ... }
 function bundle(cb) { ... }

 exports.build = series(transpile, bundle);

Методы series() и parallel() можно вкладывать в друг-друга:

 exports.build = series(
   clean, 
   parallel(
     cssTranspile, 
     series(jsTranspile, jsBundle)
   ),
   publish
 );

Возвращение таском потока и промиса:

 function streamTask() {
   return src('*.js').pipe(dest('output/'));
 }

 function promiseTask() {
   // При работе с промисами можно использовать async/await
   return Promise.resolve('значение игнорируется');
 }

Если таск ничего не возвращает, то нужно вызывать колбек, чтобы сообщить о завершен.

 function myTask(cb) { 
   // Как-то преобразовываем файл **
   cb(); // чтобы выбросить ошибку, нужно передать Error
 }

Но чаще всего колбэк передают другому API:
 function myTask(cb) { fs.access('gulpfile.js', cb) }

Для работы с файлами использ. методы src() и dest(). Первый создает поток для чтения,
находит все подходящие файлы и считывает их в память. Второй метод создает поток для
записи и записывает в указанный каталог содержимое, передаваемое через канал.

Метод src() может работать в режимах: буферизации, потока и в пустом. По умолчанию
используется режим буферизации. Он загружает в память содержимое целиком. Режим потока
используется для работы с большими файлами. Содержимое передается небольшими порциями.

Методы src() и dest() могут размещаться в середине канала (конвейера):

 function myTask() {
   return src('app/*.js')
     .pipe(babel())
     .pipe(src('vendor/*.js'))  // добавление новых файлов в поток 
     .pipe(dest('output/'))     // промежуточная запись с обновлением пути
     .pipe(uglify())
     .pipe(rename({ extname: '.min.js' }))
     .pipe(dest('output/'));
 }

Метод src() принимает glob-строку/массив для определения файлов, с которыми будет
работать канал. Когда используется массив globs, эл-ты обрабатываются по порядку.

При формирования glob нужно избегать использования __dirname, __filename или
process.cwd(), т.к. они возвращают неправильные разделители.

Символы glob-строки/массива:

 * - соответсвует любому кол-ву символов в пределах одного сегмента;
 (*.js  -->  index.js, но не scripts/index.js)
 
 ** - любое кол-во символов в во всех сегментах;
 (src/**/*.js  -->  src/index.js, src/nested/index.js, src/nested/nested/index.js
 если бы не было ограничения src, то в выборку попали бы все скрипты)

 ! - исключает часть совпадений; используется в массиве, после неотрицательного glob;
 (['**/*.js', '!node_modules/**']  -->  выбирает всё и исключает файлы из node_modules;
 при исключении лучше дабавлять только /** в конце, иначе пострадает производительн.)

Сегмент - это всё, что находится между разделителями.

Плагины - это строительные блоки. Они встраиваются между src() и dest().
Они нужны чтобы как-то преобразовывать файлы **.

Метод watch() отслеживает изменения в файлах и выполняет соответсвующий таск:

 function myTask() {
   watch('src/*.css', css);
   watch('src/*.js', series(clean, javascript));
 }

Вотчер реагирует когда файл: создается, изменяется или удаляется. Но если нужны 
только некоторые события, то при вызове можно установить опцию events:

 watch('src/*.js', { events: 'add' }, cb => { cb() });

Чтобы выполнить таск сразу, после вызова watch(), нужно установить опцию 
ingoreInitial со значением false.

Если изменение файла происходит во время выполнения таска, то новый таск будет
поставлен в очередь. Чтобы отключить очередь, нужно установить опцию queue с false.

После изменения файла вотчер реагирует не сразу, а спустя 200 мс. Это сделано для того,
чтобы избежать слишком раннего запуска таска, когда множество файлов изменяются
одновременно. Чтобы изменить задержку, нужно установить опцию delay.

------------------------

РАБОТА С ROLLUP

Rollup - это мини-сборщик, который используется в основном для сборки библиотек. 
Для сборки веб-приложений лучше использовать webpack.

Установка: npm install rollup --save-dev (новую версию нужно устанавливать глобально)

После установки будет доступна команда rollup. Вызывают её обычно через npm run.
 npm run rollup:help  // scripts": { "rollup:help": "rollup --help" }  

Создать бандл через командную строку:
 rollup ./src/main.js --file ./build/bundle.js --format es

Файл конфигурации именуется так: rollup.config.js. 
Размещается он в корневой папке и вызывается след. образом: rollup --config. 

Конфиги могут также размещаться и в отдельной папке rollup. 
В этом случае вызывать их нужно так: rollup --config ./rollup/config2.js 

Пример простого конфига:

 export default [
   {
     input: './src/main.js', // на вход подаются только js-файлы
     output: {
       file: './build/bundle.js',
       format: 'es',
     }, 
   } 
 ];

Каждый обьект внутри массива определяет один процесс сборки. Если обьектов несколько,
то и бандлов на выходе тоже будет несколько. Если сборка определяется всего 
одним процессом, то массив указывать необязательно.

 export default [
   {
     input: './src/main.js',
     ouput: { file: './bundle.js', format: 'es' }
   },
   {
     input: './src/main.js',
     plugins: [ transpile() ],
     output: { file: './bundle-es5.js', format: 'cjs' }
   }
 ];

Опция watch определяет какие файлы, при изменении, запускают процесс сборки.
Эта опция требует флага --watch: rollup --config --watch

  watch: { 
    include: './src/**',
    clearScreen: false
  }

Development и Production сборку можно задать через переменную окружения NODE_ENV.
Устанавить её можно так: rollup --config --environment NODE_ENV:dev  

 output: {
   file: './build/bundle.js',
   format: 'es',
   sourcemap: process.env.NODE_ENV === 'dev' ? 'inline' : false,
 }

Популярные плагины (скачиваются отдельно):

 * rollup-plugin-terser - минификатор, удаляющий всё лишнее;

 * @rollup/plugin-replace - заменяет конфигурационные переменные в клиентском коде 
   во время сборки, например может заменить __HELLO__ на какое-нибудь слово;

 * @rollup/plugin-node-resolve - позволяет импортировать голые модули, а также 
   применять настройки из секций exports/imports, файла package.json

 * @rollup/plugin-commonjs - ковертирует CommonJS в ES-модули;

 * @rollup/plugin-babel @babel/core @babel/preset-env - транспилятор кода.

------------------------

РАБОТА С EXPRESS

Установка фреймворка: npm install express

Приложение на Express представляет из себя набор обработчиков для различных маршрутов.
Для реализации минимального приложения нужно выполнить следующие шаги:

 1) Создать объект приложения.
 2) Определить обработчики для маршрутов.
 3) Начать прослушивание.

 // Обработчики маршрутов с GET-запросами задаются через app.get()
 // Задать обработчик можно также через post(), put(), delete(), use().
 // Начало прослушивания задается через app.listen()

 const express = require('express');
 const app = express();

 app.get('/', (req, res) => {
   response.send('<h1>Hello Express</h1>');
 });

 app.get('/about', (req, res) => {
   response.send('<h1>About</h1>');
 });

 app.listen(3000);

Киллер фичей Express являются мидлвары. Их можно задать как для всех маршрутов, так и для
конкретных. Мидлвары выполняют какие-то промежуточные действия перед вызовом основного
обработчика маршрута. Создаются с пом. метода app.use();

 app.use((req, res, next) => {
   console.log('Первый мидлавар для всех маршрутов');
   next();
 });

 app.use((req, res, next) => {
   console.log('Второй мидлавар для всех маршрутов');
   next();
 });

 app.use('/about', (req, res, next) => {
   console.log('Первый мидлавар для маршрута /about');
   next();
 });

Если в мидлваре не вызвать next(), то он прервет цепочку вызовов. 
В этом случае он может сам отправить ответ.

Для отправки ответа используется метод res.send(). Он может отправлять: строку, объект,
массив или бинарные данные (объект Buffer). Отправить содержимое файла можно с пом. метода
sendFile(). Cтатус код можно отправить с пом. метода sendStatus() или status(). 

 // При отправки бинарных данных, браузер загрузит файл с "Hello Express"
 res.send(Buffer.from("Hello Express"));  

 // Здесь нужно передавать абсолютный путь к файлу
 res.sendFile(__dirname + "/index.html");

 // Отправляет сообщение вместе со статус кодом
 res.status(404).send('Ресурс не найден');

 // Отправляет json-строку. Под капотом использует send() 
 // с заголовком Content-Type: application/json

 res.json({ msg: responseText });

Чтобы указать директорию по которой будут доступны статические файлы, 
используется мидлвар express.static().

 // Статические из папки public будут доступны по ссылке http://localhost:3000
 // Обращение к конкретному файлу: http://localhost:3000/styles.css

 app.use(express.static("public"));

 // Теперь статические файлы из public будут доступны 
 // по ссылке http://localhost:3000/static
 
 app.use("/static", express.static("public"));

Шаблоны маршрутов могут содержать символы подстановок и регулярные выр-я.

 // Маршрут будет соответсвовать шаблону '/book' или '/book.html'
 app.get('/book(.html)?', (req, res) => { });

 // Маршрут будет соответсвовать всем путям, которые имеют '.html'
 app.get(/.*(\.)html$/, (req, res) => { });

Чтобы выполнить переадресацию, используется метод redirect(). Ему можно передавать 
как относительный путь, так и абсолютный, в т.ч. на другие домены. 
  
 app.use('/home', (_, res) => {
   // Если не передать статус код, то по умолчанию будет использ. 302 
   res.redirect(301, 'https://newsite.com');
 });

 app.use('/home/foo/bar', (_, res) => {
   res.redirect('/about');    -->  http://localhost:300/about

   res.redirect('about');     -->  http://localhost:300/home/foo/about
   res.redirect('./about');   -->  тоже самое
   res.redirect('../about');  -->  http://localhost:300/home/about

   res.redirect('.');         -->  http://localhost:300/home/foo 
   res.redirect('..');        -->  http://localhost:300/home
 });

Параметры строки запроса можно получить с пом. свойства query, объекта Request.
Строка запроса может содержать не только пары ключ-значение, но и массивы с объектами.
 
 app.get('/', (req) => {
   const { id, name } = req.query;         // ?id=3&name=Tom
   const { name: userNames } = req.query;  // ?name=Tom&name=Bob
   const { user } = req.query;             // ?user[id]=7&user[name]=Tom
 });

Параметры маршрута можно получить с пом. свойства params, объекта Request. 
Параметры отделяются от маршрута знаком двоеточния.

 app.get('/products/:productId', (req) => {
   const { productId } = req.params;  // products/9 или products/phone
 });

 app.get('/categories/:category/products/:product', (req) => {
   const { category, product } = req.params;  // categories/phones/products/iphone4
 });

 app.get('/book/:pageName.:pageExt', (req) => {
   const { pageName, pageExt } = req.params;  // book/storybook.php
 });

Получить данные с формы можно с пом. обработки POST-запроса. При этом, данные формы должны
быть правильно распарсены. Поэтому обработчику доп. задается парсер urlencodedParser. 

 // Опция extended со значением false в urlencoded() означает, что body будет представять 
 // из себя набор пар ключ-значение, где значение - это либо строка, либо массив
 const urlencodedParser = express.urlencoded({ extended: false });

 // Если форма присылает json, то используется jsonParser
 const jsonParser = express.json();  

 // Маршрут '/hello' соответсвует экшену формы.
 // Данные в body соответсвуют значениям из атрибутов name, инпутов формы.

 app.post('/hello', urlencodedParser, (req, res) => {
   const { userName, userAge } = req.body;
 });

Если требуется чтобы приходящие данные парсились в json во всех обработчиках, 
то парсер можно задать глобально:

 app.use(express.json());  // теперь не нужно отдельно передавать парсер в обработчики

Чтобы определить дочерние маршруты относительно одного родительского маршрута,
можно использовать объект Router.

 const productRouter = express.Router();

 productRouter.use('/create', () => { });  // products/create
 productRouter.use('/:id', () => { });     // products/4
 productRouter.use('/', () => { });        // products

 app.use('/products', productRouter)

Сгенерировать случайный id можно с пом. встроенной ф-ции crypto.randomUUID();
Для загрузки файлов на сервер можно использовать пакет - multer.

Backend-приложения обычно реализуют с пом. паттерна MVC (Модель Вид Контроллер). 

Модель представляет собой таблицу из БД и реализуется, обычно, как определенная коллекция.
Она всегда имеет только общие методы для работы с данными, например: get(), getAll(), find(),
create() и т.д. В этих методах, в основном, реализуются различные SQL-запросы.

Вместо того, чтобы вручную создавать все эти методы с SQL-запросами, можно использовать ORM.
ORM по сути предоставляет уже готовые реализации get(), getAll(), find(), create() и т.п.
для моделей. Также ORM, облегчает создание и обслуживание самой БД и ее таблиц. 

Вид (или представление) - это файл, который содержит html-код страницы. Чаще всего
представление реализуется с пом. шаблонизатора, который позволяет указывать различные шаблоны
среди статичного кода (потом они будут как-то интерпритироваться в данные), а также
передавать данные для этих шаблонов.

Контроллер обрабатывает запрос (например валидирует приходящие данные), связывает между собой
нужную модель и представление и возвращают ответ. В качестве отвеча часто возвращает 
html готовой страницы или json-данные.

При обработке запроса, часть логики, которая отвечает за работу с моделями, 
принято выносить в сервисы.

------------------------

РАБОТА С MONGODB

------------------------

РАБОТА С MONGO

Для того чтобы работать с MongoDB, нужно установить модуль mongoose.
Он дает весь необходимый ф-ционал. Напрямую же с этой БД работать не получится.

Сначала нужно зарегистрироваться на сайте mongodb.com
После этого, в панели управления, нужно создать кластер. Тариф - Sandbox.

Далее нужно создать коллекцию. Коллекция представляет собой набор моделей.
При создании коллеции также нужно будет указать и имя БД.

Далее, во вкладке Database Access нужно создать пользователя БД.
Метод авторизации - Password.

После этого, во вкладке Clusters нужно нажать на кнопку Connect.
Метод подключения - Connect your application.

В появившемся окне копирует строку подключения, предварительно подставив 
свои данные, и переносим её приложение.

Кроме того, во вкладке Network Access нужно дать доступ всем IP-адресам.
Делается это нажатием на кнопку Allow Access From Anywhere.

Связь с БД внутри приложения (db - та самая строка подключения): 
...
mongoose.connect(db, { useNewUrlParser: true, useUnifiedTopology: true });

Работа с данными происходит через модели. Модель содержит в себе удобные методы, 
такие как: find, findById, deleteOne, get и т.д. Модель создается на основе схемы.
Схема модели - это её описание, т.е. из каких полей она состоит и т.п.

Пример создания модели (файл post.js):
...
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const postSchema = new Schema({  -->  создание схемы
  text: { type: String, required: true }  -->  поле обязательно для заполнения
  author: { type: String }
});

const Post = mongoose.model('Post', postSchema);  -->  создание модели
module.exports = Post;  -->  экспорт модели

Пример использования модели:
...
const Post = require('post');
const post = new Post({ text: "asd", author: "Vasya" });
post.save().then(...)  -->  сохраниение данных в БД  

------------------------

РАЗНОЕ

IP-адрес - это идентификатор компьютера в сети интернет.
Порт - это идентификатор приложения в компьютере.

Сервер - это компьютер, который хранит данные. Сервер, который хранит сайт называется
хостом. Доменное имя - это удобочитаемый псевдоним для IP-адреса.

Сетевой протокол - это набор комуникационных правил, которые принимают стороны, 
для того чтобы взаимодействовать. Основные протоколы: http, tcp, udp.

Чтобы отправить запрос и получить ответ, нужно установить некий канал связи. 
Такой канал называется "Socket". Отправка данных между двумя компьютерами через Socket,
происходит по протоколу tcp.

Данные отправляются с помощью пакетов. Пакеты напоминают буфер (как в потоках), 
в котором содержится небольшая порция передаваемой информации.

Порты позволяют идентифицировать программу, для которой приходит запрос.
Основные методы http-запроса: GET, POST, PUT, PATCH, DELETE.

Заголовок Content-Type, который задается в ответе, помогает определить браузеру 
тип получаемых данных от сервера. Это может быть обычный текст, html, json и т.д.

Если Content-Type имеет значение text/plain, но при этом передаваемые данные будут 
в виде html, то браузер не воспримет их как веб-страницу, а выведет просто
экранированный текст.

