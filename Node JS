ОСНОВЫ NODE JS

Node JS - это среда выполнения JS-кода. Она интерпритирует JS в машинный код c помощью
интерпритатора V8 и выполняет его на компьютере без браузера. Сам V8 построен на C++
и является ядром как для браузера, так и для Node JS.

Node JS использует модульную систему (CommonJS) для построения ф-циональности. 
Модули следует использовать только проверенные, потому что код выполняется на сервере.
Загрузка модуля происходит с помощью ф-ции require(module_name).

Чтобы экспортировать переменные или ф-ции из модуля, нужно поместить их в объект
module.exports. Сам объект module представляет ссылку на текущий модуль.

Данные, импортируемые из модуля всегда указывают на один и тот же объект.
...
const a = require('my-obj'); // a и b имеют одинаковую ссылку
const b = require('my-obj');  

Если в проекте есть папка, а в ней файл index.js, тогда для обращения к файлу
достаточно имени каталога (не поддерживается в ES-модулях):
...
home -> index.js -> module.exports = { ... }
const home = require('./home');

Объект global предоставляет доступ к глобальным переменным/ф-циям. Такие переменные
доступны в каждом модуле. К глобальным переменным можно обращаться напрямую, 
не указывая global вначале.
...
global.age = 23;  -->  module1.js
global.console.log(global.age);  -->  module2.js [либо просто console.log(age)]

Помимо global существуют также множество других объектов. Самые распространенные:
* __dirname - директория исполняемого js-файла;
* __filename - полное имя файла с директорией и расширением;
* process - различная информацию о конфигурациях, переменных окружения и т.д.

Чтобы запустить приложение нужно прописать в терминале: node file.js [param1, paramN].
Чтобы получить доступ к параметрам, внутри приложения нужно обратиться к массиву
process.argv. Этот массив подобен тому, что передается в ф-цию main из C/C++.
...
node app.js hello 23  -->  process.argv будет: [node_path, app_path, 'hello', 23]

Чтобы сервер автоматически перезапускался после каждого изменения в файлах, нужно
использовать утилиту nodemon. Само же приложение должно запускаться так: nodemon app.js

С nodemon могут быть проблемы. Например если в проекте есть локальн. БД из json-файлов 
и backend, который их перезаписывает, то nodemon будет постоянно перезапускать 
сервер, а клиент не получать нужные ответы, в это время.

Работа с файлами осуществляется с помощью модуля fs:
...
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (error, data) => {});  -->  Считывает файл асинхронно
const content = fs.readFileSync('file.txt', 'utf8');  -->  Считывает файл синхронно

fs.writeFile('file.txt', 'content', error => {});  -->  Перезаписывает файл асинхронно
fs.writeFileSync('file.txt', 'content');  -->  Перезаписывает файл синхронно

fs.appendFile('file.txt', 'content', error => {});  -->  Дозаписывает файл асинхронно
fs.appendFileSync('file.txt', 'content');  -->  Дозаписывает файл синхронно

fs.unlink('file.txt', error => {});  -->  Удаляет файл асинхронно
fs.unlinkSync('file.txt');  -->  Удаляет файл синхронно

С файлами можно также работать и при помощи потоков.

Потоки нужны, чтобы передавать большие данные по частям. Это экономит память, 
т.к. не нужно предварительно загружать сразу все данные (большой файл БД или видео).
Часть потока (некоторое временное хранилище для куска данных) называется буфером. 

Существуют потоки чтения, записи, дуплексные (чтение и запись вместе) и преобразующие
(как дуплексные, но доп. изменяют читаемые или записываемые данные, например архивация).
...
const fs = require('fs');

const wStream = fs.createWriteStream('file.txt');
wStream.write('Привет');  -->  Первый буфер
wStream.write('мир!');  -->  Второй буфер

const rStream = fs.createReadStream('file.txt', 'utf8');
rStream.on('data', chunk => console.log(chunk));  -->  Сначала выведет 'Привет', 
                                                       а потом 'мир!'

Чтением потока управляет сам Node JS как только появляется обработчик.
Также существует принудильное чтение/запись.

Метод pipe() создает канал, который связывает потоки чтения и записи (т.е. дуплексный
поток), позволяя тем самым считатывать и сразу записывать. Каждый вызов pipe()
возвращает поток для чтения.
...
rStream.pipe(wStream)  -->  Тоже что и запись ниже
rStream.on('data', chunk => wStream.write(chunk));

Чтобы создать папку, используется метод mkdir, а чтобы удалить - rmdir: 
fs.mkdir('путь_создаваемой_папки', () => {});
fs.rmdir('путь_удаляемое_папки', () => {});

Для генерации событий используются объекты класса EventEmitter. У него есть метод on(),
который добавляет обработчик события. Все обработчики складываются в цепочку, 
а когда вызывается метод emit() они все выполняются разом.
...
const EventEmitter = require('events');

const myEvent = 'my-event';
const emitter = new EventEmitter();

emitter.on(myEvent, data => console.log(data));
emitter.on(myEvent, data => console.log(data));

emitter.emit(myEvent, 'Привет мир!');  -->  Выведет 2 раз 'Привет мир!'

Иногда полезно наследоваться от EventEmitter, тем самым добавляя своему классу ф-ционал
событий. Название EventEmitter при импорте - это общепринятая практика!

------------------------

СОЗДАНИЕ СЕРВЕРА

Чтобы создать сервер с протоколом http, можно использовать встроенный модуль:
...
const http = require('http');
http.createServer(callback).listen(3000);  -->  создает сервер на порту 3000

Сервер прослушивает входящие подключения и обрабатывает их через callback.
Колбек, по сути, является главной входной точкой для приложения на Node JS.
Он также принимает такие параметры как: request и response.

Параметр request хранит информацию о запросе (заголовки, метод запроса, url и т.д.), 
а через response можно делать отправку ответа.

Чтобы послать ответ нужно задать все необходим. данные и вызвать метод response.end().
...
function callback(req, res) {
  res.setHeader('Content-Type', 'text/html');  -->  добавляет в ответ заголовок
  res.setHeader('UserId', 12);  -->  добавляет пользовательский заголовок

  res.write('<h1>Hello!</h1>');  -->  пишет в поток ответа некоторый контент
  res.write('<p>Some text</p>'); -->  если нужно отправить большой ответ, то информацию 
  res.write('<a>Link</a>');    можно задавать порциями, вызывая write по нескольку раз

  res.end();  -->  говорит серверу, что заголовки и тело ответа установлены 
}                  и в итоге тот отсылается клиенту

Чтобы сделать переадресацию, нужно установить заголовок Location и нужный statusCode
...
res.setHeader('Location', 'http://new-address');
res.statusCode = 301;  -->  по умолчанию отсылается статус 200 (ПРОВЕРИТЬ!)
res.end();

Чтобы в ответ на запрос послать html-файл, его нужно предварительно считать с помощью 
метода fs.readFile(), и затем передать эти данные в response.end():
...
fs.readFile(path, function(err, data) {
  res.end(data);
});

Альтернативным вариантом является создание файлового потока для чтения и передача 
в него, через pipe, объекта response: fs.createReadStream(path).pipe(res);

Также нужно помнить, что если сервер отдает html-файл с вложенными стилями/скриптами,
то при загрузке такого файла в браузере, тот будет посылать на сервер новые запросы,
чтобы загрузить эти самые вложенности. Поэтому для такой ситуации, сервер, помимо 
html должен также знать, как отдавать css/js.

Объект request представляет собой поток, который получает данные порциями (чанками).
Чтобы вытащить из него данные нужно подписаться на его событие data. Кроме того, 
он также имеет событие end. Оно срабатывает когда все данные успешно получены.
...
let data = "";
request.on('data', chunk => data += chunk);
request.on('end', () => res.end('Данные получены!'));
...
fetch('route', { method: 'POST', body: 'My data' });

Помимо этого request является асинхронным итератором, что позволяет использовать 
цикл for await of, для работы с ним.
...
const buffer = [];
for await (const chunk of request) {
  buffer.push(chunk);
}
const data = Buffer.concat(buffer).toString();
...
const data = { name: 'Vasya', age: 85 };
fetch('route', { method: 'POST', body: JSON.stringify(data) });

------------------------

NODE PACKAGE MANAGER

По умолчанию вместе с Node JS устанавливается и NPM: npm -v.

Для управления пакетами используется конфигурационный файл package.json. Он содержит
список установленных модулей, а также информацию о проекте. Чтобы его создать,
лучше всего использовать команду: npm init.

Также есть еще такой файл как package-lock.json. Он необходим для синхронизации всех
версий пакетов на разных компьютерах, чтобы версии зависимостей были у всех одинаковые.

Чтобы легко склонировать все зависимости стороннего проекта, нужно взять packege.json 
и выполнить команду npm install. Это позволит установить сразу все модули, 
вместо того чтобы устанавливать каждый по отдельности. 

Если указать флаг --production, то склонируются только те зависимости, кот. определены 
в секции dependencies, а зависимости из devDependencies будут проигнорированы. 

Минимальная конфигурация package.json: { "name": "module_name", "version": "1.0.0" }

Чтобы установить модуль нужно прописать: npm install название_модуля.
Все установленные модули хранятся локально, внутри проекта, в папке node_modules.

По умолчанию, при установке модуля используется флаг --save. Чтобы утсановить 
сразу несколько модулей, нужно перечислить их названия через запятую.

Информация о всех установ. модулях хранится в секции dependencies:
{ "name": "my-app", "version": "1.0.0", dependencies: { "module": "^1.2.0" } }

Некоторые модули являются инструментами, например gulp, bower (всякие компиляторы,
транспиляторы, тестеры и т.д.). Они помогают создавать код и в прод не должны
попадать, т.к. там используется уже готовый код. 

Такие модули должны устанавливаться с флагом --save-dev (для разработки).
Модули для разработки попадают в секцию devDependencies.
...
npm install gulp --save-dev  -->  devDependencies: { "gulp": "^4.0.1" }
npm install gulp@4.1.8   -->  утсановка конкретной версии
npm install gulp@latest  -->  обновление до последней версиии

Чтобы установить модуль глобально нужно использовать флаг -g: npm install gulp -g
В этом случае модуль будет находится в том месте, куда установлен Node JS.

Чтобы удалить модуль нужно прописать: npm uninstall название_модуля.
Также можно и вручную отредактировать файл package.json, после чего ввести npm install.

Версионирование модулей определяется в формате: "major.minor.patch".
Если в модуле исправляется какой-то баг, то увеличивается на единицу число patсh.
Если в модуль добавляется какой-то ф-ционал, который совместим с предыдущей версией, 
то увеличивается minor. Если же вносятся какие-то большие изменения, которые не
совместимы с предыдущей версией, то major.

Если в версии присутствует символ каретки, то это означает что при использовании 
npm install будет установлена последняя доступная версия, начиная от указанной.
...
devDependencies: { "gulp": "^4.0.1" }  -->  Установится самая последняя версия, 
                                            начиная с 4.0.1 (например 6.1.2)

В package.json можно также определять команды. Они размещаются в секции scripts.
Команды могут быть как произвольными, так и зарезервированными (start, test, run и т.д).
...
scripts: { "start": "node app.js", "my-command": "node app.js hello 23" }
npm start  -->  зарезервированные команды выполняются напрямую
npm run my-command  -->  произвольные команды выполняются через run

Начиная с версии 5.2.0, NPM поставляется с утилитой NPX (node package exec).
Эта утилита позволяет временно выполнять пакеты из общего репозитория, без необходим.
их установки. Например это могут быть различные бандлеры, CLI и другие пакеты,
требующие глобальной установки. После выполнения пакета, NPX его удаляет.

npx gulp // скачает gulp-cli, выполнит команду gulp, а затем удалит его.

Помимо npm-пакетов, можно запускать произвольный код, доступный по некоему адресу:
npx https://gist.github.com/zkat/4bc19503fe9e9

------------------------

РАБОТА С GULP

Установка gulp-cli: npm install --global gulp-cli
Установка gulp: npm install gulp --save-dev

Gulp CLI нужен для того, чтобы была доступна команда gulp в терминале.

Gulp - это таск менеджер. Таск представляет собой ф-цию, которая принимает колбэк 
с агрументом-ошибкой и возвращает поток/промис/эмитер/дочерний_процесс/наблюдаемый_тип.

Таски должны распологаться в файле gulpfile.js, в корневом каталоге.
Этот файл автоматически загружается при запуске команды gulp.

Таски можно выносить в отдельные файлы, и подключать их через require, в основном 
gulp-файле. Также можно заменить gulpfile.js на каталог с таким же именем, 
(в документации указано gulpfile.js, но возможно расширение указывать не надо), 
Каталог должен содержать файл index.js и файлы тасков.

Таски бывают публичными и приватными. Публичные таски можно запускать командой gulp.
Приватные запускать нельзя, они создаются для внутренного использования.

Чтобы создать публичный таск, нужно экспортировать его из gulp-файла:

 function publicTask(cb) { ... }
 function publicTask2(cb) { ... }
 function privateTask(cb) { ... }

 exports.myTask = publicTask;
 exports.default = publicTask2;

Запустить дефолтный таск: gulp
Запустить несколько тасков: gulp <task> <othertask>

Для управления тасками Gulp API предоставляет такие методы, как: series(), parallel(),
src(), dest(), watch(). Первые два позволяют объединять таски. Метод series() делает
так, чтобы таски выполнялись по порядку, а parallel() - параллельно.

 const { series } = require('gulp');

 function transpile(cb) { ... }
 function bundle(cb) { ... }

 exports.build = series(transpile, bundle);

Методы series() и parallel() можно вкладывать в друг-друга:

 exports.build = series(
   clean, 
   parallel(
     cssTranspile, 
     series(jsTranspile, jsBundle)
   ),
   publish
 );

Возвращение таском потока и промиса:

 function streamTask() {
   return src('*.js').pipe(dest('output/'));
 }

 function promiseTask() {
   // При работе с промисами можно использовать async/await
   return Promise.resolve('значение игнорируется');
 }

Если таск ничего не возвращает, то нужно вызывать колбек, чтобы сообщить о завершен.

 function myTask(cb) { 
   // Как-то преобразовываем файл **
   cb(); // чтобы выбросить ошибку, нужно передать Error
 }

Но чаще всего колбэк передают другому API:
 function myTask(cb) { fs.access('gulpfile.js', cb) }

Для работы с файлами использ. методы src() и dest(). Первый создает поток для чтения,
находит все подходящие файлы и считывает их в память. Второй метод создает поток для
записи и записывает в указанный каталог содержимое, передаваемое через канал.

Методы src() и dest() могут размещаться в середине канала (конвейера):

 function myTask() {
   return src('app/*.js')
     .pipe(babel())
     .pipe(src('vendor/*.js'))  // добавление новых файлов в поток 
     .pipe(dest('output/'))     // промежуточная запись с обновлением пути
     .pipe(uglify())
     .pipe(rename({ extname: '.min.js' }))
     .pipe(dest('output/'));
 }

Метод src() может работать в режимах: буферизации, потока и в пустом. По умолчанию
используется режим буферизации. Он загружает в память содержимое целиком. Режим потока
используется для работы с большими файлами. Содержимое передается небольшими порциями.

Метод src() принимает glob-строку/массив для определения файлов, с которыми будет
работать канал. Когда используется массив globs, эл-ты обрабатываются по порядку.

При формирования glob нужно избегать использования __dirname, __filename или
process.cwd(), т.к. они возвращают неправильные разделители.

Символы glob-строки/массива:

 * - соответсвует любому кол-ву символов в пределах одного сегмента;
 (*.js  -->  index.js, но не scripts/index.js)
 
 ** - любое кол-во символов в во всех сегментах;
 (src/**/*.js  -->  src/index.js, src/nested/index.js, src/nested/nested/index.js
 если бы не было ограничения scripts, то в выборку попали бы все скрипты)

 ! - исключает часть совпадений; используется в массиве, после неотрицательного glob;
 (['**/*.js', '!node_modules/**']  -->  выбирает всё и исключает файлы из node_modules;
 при исключении лучше дабавлять только /** в конце, иначе пострадает производительн.)

Сегмент - это всё, что находится между разделителями.

Плагины - это строительные блоки. Они встраиваются между src() и dest().
Они нужны чтобы как-то преобразовывать файлы **.

Метод watch() отслеживает изменения в файлах и выполняет соответсвующий таск:

 function myTask() {
   watch('src/*.css', css);
   watch('src/*.js', series(clean, javascript));
 }

Вотчер реагирует когда файл: создается, изменяется или удаляется. Но если нужны 
только некоторые события, то при вызове можно установить опцию events:

 watch('src/*.js', { events: 'add' }, cb => {});

Чтобы выполнить таск сразу, после вызова watch(), нужно установить опцию 
ingoreInitial со значением false.

Если изменение файла происходит во время выполнения таска, то новый таск будет
поставлен в очередь. Чтобы отключить очередь, нужно установить опцию queue с false.

После изменения файла вотчер реагирует не сразу, а спустя 200 мс. Это сделано для того,
чтобы избежать слишком раннего запуска таска, когда множество файлов изменяются
одновременно. Чтобы изменить задержку, нужно установить опцию delay.

------------------------

РАБОТА С ROLLUP

Rollup - это мини-сборщик, который используется в основном при сборке библиотек и 
небольших проектов. Для больших проектов лучше использовать webpack.

Установка: npm install rollup --save-dev

После установки будет доступна команда rollup. Вызывают её обычно через npm run.
 npm run rollup:help  // scripts": { "rollup:help": "rollup --help" }  

Создать бандл через командную строку:
 rollup ./src/main.js --file ./build/bundle.js --format es

Файл конфигурации именуется так: rollup.config.js. 
Размещается он в корневой папке и вызывается след. образом: rollup --config. 

Конфиги могут также размещаться и в отдельной папке rollup. 
В этом случае вызывать их нужно так: rollup --config ./rollup/config2.js 

Пример простого конфига:

 export default [
   {
     input: './src/main.js',
     output: {
       file: './build/bundle.js',
       format: 'es',
     }, 
   } 
 ];

Каждый обьект внутри массива определяет один процесс сборки.
Если обьектов несколько, то и бандлов на выходе тоже будет несколько:

 export default [
   {
     input: './src/main.js',
     ouput: { file: './bundle.js', format: 'es' }
   },
   {
     input: './src/main.js',
     plugins: [ transpile() ],
     output: { file: './bundle-es5.js', format: 'cjs' }
   }
 ];

Опция watch определяет какие файлы, при изменении, запускают процесс сборки.
Эта опция требует флага --watch: rollup --config --watch

  watch: { 
    include: './src/**',
    clearScreen: false
  }

Development и Production сборку можно задать через переменную окружения NODE_ENV.
Устанавить её можно так: rollup --config --environment NODE_ENV:dev  

 output: {
   file: './build/bundle.js',
   format: 'es',
   sourcemap: process.env.NODE_ENV === 'dev' ? 'inline' : false,
 }

Популярные плагины (скачиваются отдельно):

 * rollup-plugin-terser - минификатор, удаляющий всё лишнее;

 * @rollup/plugin-replace - заменяет конфигурационные переменные в клиентском коде 
   во время сборки, например может заменить __HELLO__ на какое-нибудь слово;

 * @rollup/plugin-node-resolve - позволяет импортировать модули исходя из настроек 
   в секция exports/imports, файла package.json;

 * @rollup/plugin-commonjs - ковертирует CommonJS в ES-модули;

 * @rollup/plugin-babel @babel/core @babel/preset-env - транспилятор кода.

------------------------

РАБОТА С EXPRESS



------------------------

РАБОТА С MONGO

Для того чтобы работать с MongoDB, нужно установить модуль mongoose.
Он дает весь необходимый ф-ционал. Напрямую же с этой БД работать не получится.

Сначала нужно зарегистрироваться на сайте mongodb.com
После этого, в панели управления, нужно создать кластер. Тариф - Sandbox.

Далее нужно создать коллекцию. Коллекция представляет собой набор моделей.
При создании коллеции также нужно будет указать и имя БД.

Далее, во вкладке Database Access нужно создать пользователя БД.
Метод авторизации - Password.

После этого, во вкладке Clusters нужно нажать на кнопку Connect.
Метод подключения - Connect your application.

В появившемся окне копирует строку подключения, предварительно подставив 
свои данные, и переносим её приложение.

Кроме того, во вкладке Network Access нужно дать доступ всем IP-адресам.
Делается это нажатием на кнопку Allow Access From Anywhere.

Связь с БД внутри приложения (db - та самая строка подключения): 
...
mongoose.connect(db, { useNewUrlParser: true, useUnifiedTopology: true });

Работа с данными происходит через модели. Модель содержит в себе удобные методы, 
такие как: find, findById, deleteOne, get и т.д. Модель создается на основе схемы.
Схема модели - это её описание, т.е. из каких полей она состоит и т.п.

Пример создания модели (файл post.js):
...
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const postSchema = new Schema({  -->  создание схемы
  text: { type: String, required: true }  -->  поле обязательно для заполнения
  author: { type: String }
});

const Post = mongoose.model('Post', postSchema);  -->  создание модели
module.exports = Post;  -->  экспорт модели

Пример использования модели:
...
const Post = require('post');
const post = new Post({ text: "asd", author: "Vasya" });
post.save().then(...)  -->  сохраниение данных в БД  

------------------------

РАЗНОЕ

IP-адрес - это уникальный идентификатор компьютера в сети.
Сервер - это компьютер, который хранит данные. Сервер, который хранит сайт называется
хостом. Доменное имя - это удобочитаемый псевдоним для IP-адреса.

Сетевой протокол - это набор комуникационных правил, которые принимают стороны, 
для того чтобы взаимодействовать. Протоколы бывают как http, так и tcp и т.п.

Чтобы отправить запрос и получить ответ, нужно установить некий канал связи. 
Такой канал называется "Socket". Отправка данных между двумя компьютерами через Socket,
происходит по протоколу tcp.

Данные отправляются с помощью пакетов. Пакеты напоминают буфер (как в потоках), 
в котором содержится небольшая порция передаваемой информации.

Порты позволяют идентифицировать программу, для которой приходит запрос.
Основные методы http-запроса: GET, POST, PUT, PATCH, DELETE.

Заголовок Content-Type, который задается в ответе, помогает определить браузеру 
тип получаемых данных от сервера. Это может быть обычный текст, html, json и т.д.

Если Content-Type имеет значение text/plain, но при этом передаваемые данные будут 
в виде html, то браузер не воспримет их как веб-страницу, а выведет просто
экранированный текст.

НАПИСАТЬ ОПРЕДЕЛЕНИЕ ДЛЯ LOCALHOST !

