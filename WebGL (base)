ОСНОВЫ WEBGL

Отрисовка графики на странице происходит с помощью тега <canvas></canvas>
Канвас поддерживает 2 контекста отрисовки: 2d и webgl.

Пример отрисовки пустого окна:
...
const canvas = document.getElelemetById('my-canvas');
const gl = canvas.getContext('webgl');
gl.clearColor(0.0, 1.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

Метод clearColor() устанавливает цвет для константы COLOR_BUFFER_BIT.
Метод clear() закрашивает фон цветом COLOR_BUFFER_BIT (очищает цветовой буфер).

Чтобы нарисовать 2D-объект, нужно выполнить следующие шаги:
1) создать шейдерную программу; 
2) создать буфер вершин;
3) установить указатель на чтение из буфера;
4) отрисовать примитивы объекта;

Шейдерная программа состоит из 2х шейдеров: вершинного и фрагментного.
...
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 a_vertexPos;
  void main() {
    gl_Position = vec4(a_vertexPos, 1.0);
  }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.6, 0.6);
  }
</script>

Код шейдеров можно размещать внутри тега <script></script>, с произвольным типом.
В этом случае браузер не будет загружать его содержимое, а просто проигнирирует его.
Также, шейдеры могут определяться в отдельных файлах. Загружать их можно через fetch().

Создание шейдерной программы:
...
const program = gl.createProgram();
gl.attachShader(program, getShader(gl.VERTEX_SHADER, 'shader-vs'));
gl.attachShader(program, getShader(gl.FRAGMENT_SHADER, 'shader-fs'));
gl.linkProgram(program);

function getShader(type, elemId) {
  const shaderElem = document.getElementById(elemId);

  const shader = gl.createShader(type);
  gl.shaderSource(shader, shaderElem.text);
  gl.compileShader(shader);

  return shader;
}

Метод createProgram() создает объект программы, attachShader() прикрепляет к программе
шейдеры, а linkProgram() - связывает программу с контекстом WebGL.

После создания программы, нужно передать её на выполнение: gl.useProgram(program);

Создание буфера вершин:
...
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.5, -0.5, 0.0,
   0.0,  0.5, 0.0,
   0.5, -0.5, 0.0,
]), gl.STATIC_DRAW);

Метод createBuffer() создает некий буфер данных. Затем, с пом. метода bindBuffer()
производится привязка этого буфера к контексту WebGL.

Первый параметр bindBuffer() может принимать:
* ARRAY_BUFFER - данные вершин;
* ELEMENT_ARRAY_BUFFER - данные индексов;

Поскольку мы имеем дело с данными вершин, то выбирать нужно именно ARRAY_BUFFER.
Привязка означает, что все операции над ARRAY_BUFFER будут происходить с vertexBuffer.

Привязка нужна чтобы некоторые ф-ции WebGL имели (неявный) доступ к буферу.
Отвязать буфер можно так: gl.bindBuffer(gl.ARRAY_BUFFER, null);

Метод bufferData() наполняет буфер данными из массива. Массив должен быть типизирован.
STATIC_DRAW необходим для оптимизации. Это означает что данные не будут меняться.

В дополнении к буферу вершин можно создать буфер индексов:
...
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 2, 1]), gl.STATIC_DRAW);

Этот буфер задает порядок вершин, по которому будут рисоваться примитивы. 
Каждый индекс обозначает какую-то вершину, например 0 - это (-0.5, -0.5, 0.0).

Если буфер индексов отсутствует, то примитивы будут рисоваться по вершинам 
(в порядке размещения в vetrexBuffer), а не по индексам.

Установка указателя на чтение из буфера (этот указатель называется атрибутом):
...
const vertexPosAttrib = gl.getAttribLocation(program, 'a_vertexPos');
gl.enableVertexAttribArray(vertexPosAttrib);
gl.vertexAttribPointer(vertexPosAttrib, 3, gl.FLOAT, false, 0, 0);

Метод getAttribLocation() как бы связывает атрибут между шейдером и WebGL.
С помощью него мы получаем ссылку на a_vertexPos и присваиваем её в vertexPosAttrib.

Метод enableVertexAttribArray() включает атрибут. Обычно, вызывается перед установкой.

Метод vertexAttribPointer() устанавливает атрибут. После этого WebGL будет знать, 
как передавать данные буфера в шейдер. Метод принимает следующие параметры:

* index - индекс атрибута;
* size - кол-во элементов буфера на одну вершину;
* type - тип данных элементов буфера;
* norm - нормализация; управляет числовыми преоразованиями;
* stride - шаг сдвига к новой вершине; 0 означает size * sizeof(type);
* offset - позиция с кот. начинается обработка; 0 это начальная позиция;

Поскольку параметр size имеет значение 3, то при каждом вызове вершинного шейдера
атрибут a_vertexPos будет получать по 3 элемента из буфера. Сначала это будут эл-ты
(-0.5, -0.5, 0.0), затем (0.0, 0.5, 0.0) (указатель сдвинется на size * sizeof(type)).

Если a_vertexPos имеет тип, отличный от vec3, например vec4, то из буфера установятся
только первые 3 компоненты: x, y, z, а компонента w примет значение по умолчанию.

Перед отрисовкой примитивов нужно установить viewport (область отрисовки):
gl.viewport(offsetX, offsetY, width, height);

Если параметры offsetX и offsetY имеют нулевое значение, то отрисовка 
будет начинаться с левого нижнего угла.

Отрисовка примитивов: gl.drawArrays(gl.TRIANGLES, 0, 3);

Примитивы можно отрисовывать с пом. 2х методов: drawArrays() и drawElements().
Первый метод отрисовывает примитивы последовательно, по вершинам из буфера вершин.
Второй метод отрисовывает примитивы по индексам, когда имеется буфер индексов.

Метод drawArrays() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять объект;
* index - указывает индекс первой вершины;
* count - кол-во вершин для отрисовки;

Метод drawElements() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять объект;
* count - кол-во элементов (буфера индексов) для отрисовки;
* type - тип данных элементов (буфера индексов);
* offset - с какого индекса будет проводиться отрисовка;

Типы примитивов в WebGL:
* LINES - отдельные линии (даже если есть общие вершины);
* LINE_LOOP - соединенные линии (в замкнутый контур);
* LINE_STRIP - соединенные линии, но последняя вершина не соединяется с первой;
* TRIANGLES - отдельные треугольники;
* TRIANGLE_STRIP - соединенные треугольники;
* TRIANGLE_FAN - треугольники, у которых одна вершина общая (веер);
* PONTS - отдельные точки;

---------------------

КОНВЕЙЕР WEBGL:

1. Создается буфер вершин. По вершинам впоследствии будут составлены примитивы, 
   а из примитивов - объекты. Проводится некоторая предобработка.

2. Содержимое буфера поступает на обработку в вершинный шейдер. Шейдер производит 
   над ними некоторые трансформации, задаваемые разработчиком.

3. Происходит Primtive Assembly. Конвейер получает результат вершинного шейдера и
   сопоставляет трансформированные вершины в отдельные примитивы (треугольники, линии). 
   Далее определяется, входит ли примитив в видимое пространство. Если нет, то он
   обрезается. Видимые примитивы передаются на следующий этап конвейера.

4. Происходит растеризация. Полученные примитивы преобразов. во фрагменты (пиксели),
   которые затем будут отрисованы на экране.

5. Вызывается фрагментный шейдер (в Direct3D он называется пиксельным шейдером)
   Он наполняет примитивы цветом, т.е. окрашивает фрагменты примитивов 
   и передает их на следующие подэтапы.

5.1. Scissor Test. Здесь проверяется, находится ли фрагмент в пределах отсекающего
     прямоугольника. Если да, то он передается дальше, иначе отбрасывается 
     и больше не принимает участия в обработке.

5.2. Multisample Fragment Operations (возможно это Multisampling). 
     Здесь производится сглаживание.

5.3. Stencil Test. Фрагмент передается в буфер трафаретов (stencil buffer). В этом
     буфере дополнительно отбрасываются фрагменты, кот. не должны отображаться.
     Как правило, он используется для создания эффектов, например теней.

5.4. Depth Buffer Test. Происходит тест буфера глубины (z-buffer). Здесь сравнивается 
     z-компонента фрагмента. Если один фрагмент ближе к сцене, чем другой, 
     то он проходит тест, а иначе отбрасывается.

5.5. Blending. Здесь происходит смешивание цветов, для создания прозрачности.
5.6. Dithering. Здесь происходит смешивание цветов, для создания тонов и полутонов.

6. Фрагмент передается во Frame Buffer (превращается в пиксель на экране).

--------------------

ШЕЙДЕРЫ

Шейдеры - это программы, которые выполняются на видеокарте. Они пишутся на языке GLSL.
Чаще всего встречается 2 типа шейдеров: вершинные, фрагментные.

В самом начале, при вызове метода draw*(), данные из буфера вершин поступают в
вершинный шейдер. Количество вызовов вершинного шейдера зависит от параметра count.

Задача вершинного шейдера - обработать (трансформировать) вершины примитивов. 
Задача фрагментного шейдера - закрасить пиксели примитивов.

Вершинный шейдер вызывается один раз для каждой вершины. Фрагментный шейдер вызывается
один раз для каждого пикселя. Например, для треугольника с площадью 300 пикселей
фрагментный шейдер вызовется 300 раз, тогда как вершинный всего 3 раза.

Все действия шейдеров выполняются внутри ф-ции main().

В GLSL определены след. примитивные типы:
* void, bool, int, float - аналогичны тем, что в C++; 
* vec2, vec3, vec4 - 2х, 3х, 4х мерные векторы, с типом float для компонентов;
* ivec2, ivec3, ivec4 - теже векторы, но с типом int для компонентов;
* bvec2, bvec3, bvec4 - векторы с типом bool для компонентов;
* mat2, mat3, mat4 - матрицы с эл-тами типа float;
* sampler2d, samplerCube - семплеры для работы с текстурами; с их помощью можно
  получать различные цветовые значения текстур и передавать их в примитив.

С пом. структур можно также создавать и составные типы.

В GLSL переменные обычно объявляются с квалификаторами. Их список:
* attribute - атрибут вершины; через него в шейдер передаются данные буфера;
* const - константа, как и в других языках;
* uniform - константа со значением для всего примитива;
* varying - переменная, которая задается в вершинном шейдере и затем передается 
  во фрагментный шейдер, где может быть использована;

Атрибуты передают данные для вершин, а unifirm-переменные - для примитивов.
Например, через unifirm-переменные можно задавать матрицы, т.к. они (матрицы) 
должны быть неизменными для всех вершин. 

Для переменных типа float можно задавать точность:
* highp - число с плавающей точкой будет иметь максимальную точность;
* mediump - число со средней степенью точности;
* lowp - диапазон плавающей запятой от -2 до 2;

Точность можно задать и глобально, для всего шейдера:
...
precision mediump float;
void main() { }

Встроенные переменные вершинного шейдера:
* gl_Position - указывает на позицию вершины (выходной параметр, vec4);
* gl_PointSize - содержит размер точки (выходной параметр, float);

Встроенные переменные фрагментного шейдера:
* gl_PointCoord - позиция фрагмента внутри точки (входной параметр vec2);
* gl_FontFacing - пренадлежит ли фрагмент лицевому примитиву (входной, bool);
* gl_FragCoord - указывает на позицию фрагмента в буфере фреймов (выходной, vec4);
* gl_FragColor - указывает на цвет фрагмента (выходной, vec4);
* gl_FragData[n] - указ. на цвет фрагмента для прикреплен. цвета n (выходной, vec4);

Встроенные функции:
* dot(x, y) - возвращает скалярное произведение векторов x и y;
* cross(x, y) - возвращает векторное произведение векторов x и y;
* matrixCompMult(matX, matY) - возвращает произведение матриц x и y 
  (матрицы должны быть одной размерности); 
* normalize(x) - возвращает нормализированный вектор x;
* reflect(t, n) - возвращает проекцию вектора t вдоль вектора n;
* sin(angle) - возвращает синус угла angle;
* cos(angle) - возвращает косинус угла angle;
* pow(x, y) - возвращает x в степени y;
* max(x, y) - возвращает максимальное значение;
* min(x, y) - возвращает минимальное значение;

Пример реализации RGB-треугольника:

1) Вершинный шейдер:
...
attribute vec4 a_Pos;
attribute vec4 a_Color;
varying highp vec4 v_Color;  -->  без highp, изображения не будет;

void main() {
  gl_Position = a_Pos;  -->  это нужно понимать как некую привязку данных к вершине

  v_Color = a_Color;  -->  varying не передаются сразу во фрагментный шейдер, а только
}                          после того, как вершинный шейдер обработает все вершины

2) Фрагментный шейдер:
... 
varying highp vec4 v_Color;  -->  в переменную передаются интерполируемые значения,
                                  в завис. от того, насколько близко пиксель
void main() {                     расположен к той или иной вершине
  gl_FragColor = v_Color;
}

----------------------

РАБОТА С МАТРИЦАМИ

С пом. матриц можно трансформировать объекты, менять положение камеры и пр.
Матрица модели (Model-View Matrix) объединяет мировую матратрицу и матрицу вида.

Мировая матрица переводит объекты из локальных координат, в глобальные.
Матрица вида переводит глобальное пространство сцены, в видимое пространство камеры.

Матрица проекции (Projection Matrix) переводит трехмерные координаты объекта,
в двухмерные, для отображения на экране. Она бывает ортогональной и перспективной.

Ортогональная проекция не изменяет размеров объекта в зависимости от глубины, а
перспективная - наоборот, созд. иллюзию глубины. Дальние объекты будут казаться меньше.

Для работы с матрицами и векторами будет использоваться библиотека glMatrix-2.0.
Также есть и другие библиотеки, например: Sylvester, WebGL-mjs.

Использование матриц при создании 3D-куба:
...
const pMatrix = mat4.create();
const mvMatrix = mat4.create();

mat4.perspective(pMatrix, 1.04, canvas.width / canvas.height, 0.1, 100.0);
mat4.identity(mvMatrix);

mat4.translate(mvMatrix, mvMatrix, [0, 0, -2.0]);
mat4.rotate(mvMatrix, mvMatrix, 1.7, [0, 1, 0]);

const u_PMatrix = gl.getUniformLocation(program, 'u_PMatrix');
gl.uniformMatrix4fv(u_PMatrix, false, pMatrix);

const u_MVMatrix = gl.getUniformLocation(program, 'u_MVMatrix');
gl.uniformMatrix4fv(u_MVMatrix, false, mvMatrix);

Сначала обе матрицы нужно создать. Затем, с пом. метода perspective(), нужно установ.
матрицу проекции. Метод принимает такие параметры:

* matrix - матрица проекции;
* viewAngle - угол обзора, в радианах;
* aspectRatio - аспектное соотношение ширины к длине;
* near - самая ближняя точка (видимой области);
* far - самая дальняя точка; 

Метод identity() задаёт единичную матрицу (как бы сбрасывает значение перед трансформ).

Метод translate() задаёт перемещение. Первый параметр принимает выходную матрицу, а
второй - входную. Но так как преобразуется одна матрица, то значения совпадают.
Третий параметр - это вектор, вдоль которого происходит перемещение.

Метод rotate() задаёт вращение. Он имеет схожие параметры. Третий параметр - это 
угол поворота (в радианах), а четвёртый - ось поворота. Кроме того, вращение 
можно задавать с пом. методов rotateX(), rotateY().

Помимо перемещения и вращения есть ещё масштабирование: mat4.scale(output, input, vect);
Вектор задаёт масштаб, на который изменяется матрица input, после чего записывается 
в output. Тот же принцип преоразования матриц и в translate(), rotate().

С пом. метода getUniformLocation(), подобно атрибуту, определяется связка 
uniform-переменной между шейдером и WebGL.

Метод uniformMatrix4fv() передаёт матрицу (трансформированную) в вершинный шейдер.

Вершинный шейдер для 3D-куба:
...
attribute vec4 a_Pos;
uniform mat4 u_MVMatrix;
uniform mat4 u_PMatrix;

void main() {
  gl_Position = u_PMatrix * u_MVMatrix * a_Pos;  -->  порядок умножения важен!
}

Установка камеры происходит с пом. метода lookAt(): 
mat4.lookAt(mvMatrix, [2, 0, -2], [0, 0, 0], [0, 1, 0]);

Этот метод принимает след. параметры:
* matrix - матрица модели, кот. меняется от изменен. свойств камеры;
* eye - позиция камеры;
* center - точка, на которую направлена камера;
* up - вектор вертикальной ориентации;

Перед отрисовкой любого 3D-объекта, нужно включать глубину (тест буфера глубины), 
иначе его лицевые стороны будут прозрачными.
...
gl.enable(gl.DEPTH_TEST);

--------------------

РАЗНОЕ

Чтобы создать анимацию, нужно циклично перерисовывать сцену. 
Этап перерисовки начинается с очистки экрана (метод clearColor() и далее). 

Раньше, для перерисовки использовались таймеры или интервалы, но с недавних пор
рекомендуется использовать браузерный метод requestAnimationFrame(). 

Он делает анимации более плавными, поскольку браузер сам определяет нужный интервал 
для кадров. Также, для плавности эффекта, браузер может замедлять некоторые 
анимации, которые работают парралельно.

Обработка пользовательского ввода предполагает обычную обработку событий 
клавиатуры и мыши (как и в любом front-end приложении).

Несколько объектов на сцене...

