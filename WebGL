ОСНОВЫ WEBGL

WebGL основывается на работе пары ф-ций - вершинного и пиксельного шейдеров.
Они пишутся на языке GLSL. Вместе, эта пара называется программой.

Вершинный шейдер вычисляет расположение вершин примитивов. 
Пиксельный (фрагментный) шейдер вычисляет цвет для каждого пикселя примитива.
Шейдеры выполняются на графическом процессоре.

Есть 4 способа, чтобы передать данные на GPU:

1) Буферы и атрибуты.

    Буферы - это массивы бинарных данных, передаваемые на GPU. Обычно они содержат
    расположения вершин, их цвета, нормали, координаты текстур и т.д.

    Атрибуты определяют как данные из буфера будут передаваться на GPU, например 
    в них можно указать откуда брать расположения вершин, какой тип данных будет
    использоваться, индекс начальной вершины, какое кол-во байт нужно 
    считать чтобы перейти к следующей вершине и т.д.

2) Uniform-переменные.

    Это глобальные переменные, которые устанавливаются перед выполнением 
    программы шейдера (чем отличаются от атрибутов???).

3) Текстуры.

    Это массивы данных, представляющие собой картинки. 
    В них также можно помещать и что-то отличное от набора цветов.

4) Varying-переменные.

    Они позволяют передавать данные из вершинного шейдера в пиксельный.
    Пиксельный шейдер получает интерполированные значения вершинного шейдера.

Ниже представлен пример использования WebGL:

1) Задаём вершинный шейдер. Код нужно разместить внутри тега 
<script id="vertex-shader-2d" type="notjs"></script>
...
attribute vec4 a_position;  -->  атрибут вершины, занимающий 4 эл-та в буфере

void main() {
    gl_Position = a_position;  -->  gl_Position - спец. переменная вершинного шейдера,
}                                   отвечающая за установку расположения

При каждом вызове шейдера в a_position передаётся новая вершина из буфера. 
Координаты вершин всегда находятся в диапазоне от -1 до 1.

2) Задаём пиксельный шейдер. Код нужно разместить внутри тега
<script id="fragment-shader-2d" type="notjs"></script>
...
precision mediump float;  -->  точность шейдера; по умолчанию она не задана, 
                               поэтому нужно явно это сделать; mediump означает 
void main() {                  среднюю точность (подходит для большинства случаев)

    gl_FragColor = vec4(1, 0, 0, 1);  -->  gl_FragColor - спец. переменная пиксельного
}                                          шейдера, отвечающая за установку цвета

Цвета, подобно вершинам, принимают значения в диапазоне от 0 до 1, но т.к. канвас
содержит 8 бит на канал, то итоговые значения будут: 255, 0, 0, 255

3) Настроим WebGL для рендеринга:

// Получаем контекс отрисовки
const canvas = document.querySelector("#canvas");
const gl = canvas.getContext("webgl");

// Создаем вершинный шейдер
const vShaderSrc = document.querySelector("#vertex-shader-2d").text;
const vShader = createShader(gl, gl.VERTEX_SHADER, vShaderSrc);

// Создаем пиксельный шейдер
const fShaderSrc = document.querySelector("#fragment-shader-2d").text;
const fShader = createShader(gl, gl.FRAGMENT_SHADER, fShaderSrc);

function createShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) return shader;

  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

// Связываем вершинный и пиксельный шейдеры (создаем программу)
const program = createProgram(gl, vShader, fShader);

function createProgram(gl, vShader, fShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);

  const success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) return program;

  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}

// Выполняем инициализацию данных
const posAttribute = gl.getAttribLocation(program, "a_position");
const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  0, 0,    -->  первая вершина
  0, 0.5,  -->  вторая 
  0.7, 0,
]), gl.STATIC_DRAW);

С пом. getAttribLocation(), получаем ссылку на атрибут программы a_position.
С пом. createBuffer(), создаем буфер вершин, от которого атрибут будет получать данные.

Метод bindBuffer() привязывает буфер к точке связи. Точка связи нужна чтобы привязать
ресурс к WebGL. После привязки, к ресурсу смогут обращаться другие ф-ции.

Метод bufferData() наполняет буфер данными. Обращение к буферу идет через точку связи.
WebGL требует типизированные данные, поэтому вершины задаются через Float32Array.

При наполнении буфера, данные копируются (переносятся) на видеокарту.

Последний аргумент указывает, как WebGL должен использовать данные. Это необходимо 
для оптимизации. STATIC_DRAW говорит о том, что данные не будут изменяться.

4) Переходим к рендерингу:

gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.clearColor(0, 0, 0, 0);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.useProgram(program);
gl.enableVertexAttribArray(posAttribute);
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.vertexAttribPointer(posAttribute, 2, gl.FLOAT, false, 0, 0);
gl.drawArrays(gl.TRIANGLES, 0, 3);

Метод viewport() переводит диапазон вершин от -1 до 1 к размерам канваса, т.е. 1 
по горизонтали будет соответствовать canvas.width, а по вертикали - canvas.height.

Метод clear() очищает канвас тем цветом, что задан в clearColor().
Метод useProgram() указывает WebGL, какую шейдерную программу нужно выполнить.

Метод enableVertexAttribArray() включает атрибут, а метод vertexAttribPointer() 
задает конфигурацию, определяющую, как данные из буфера должны извлекаться в атрибут.

Аргументы vertexAttribPointer():
1) Собственно атрибут.
2) Кол-во элементов буфера на одну вершину (size).
3) Тип данных элементов буфера.
4) Определяет, нужно ли нормализовать данные.
5) Ноль означает, что новая вершина задается сдвигом size * sizeof(type).
6) Ноль означает, что начинать надо с начала буфера. 

Еще один вызов bindBuffer() может говорить о том, что привязка используется только той
ф-цией что идет ниже, а после очищается, или что-то вроде этого (уточнить)...

Стоит также учесть, что при вызове vertexAttribPointer() параметру size было задано 2,
а атрибут a_position в шейдере имет тип vec4. Это означает, что свойства x и y 
будут заданы из буфера, а z и w примут значения по умолчанию.

В методе drawArrays() первый аргумент задает примитив, который будут создавать
вершины. Последний аргумент указывает сколько раз нужно выполнить вершинный шейдер,
т.е. 3 раза. При первом выполнении a_position получит из буфера элементы (0, 0), 
При втором - элементы (0, 0.5). А при третьем - (0.7, 0).

Теперь рассмотрим работу uniform-переменных.

Обычно шейдеры содержат всего несколько атрибутов и множество uniform-переменных
Получить ссылку на переменную можно примерно также, как и на атрибут. 
А задать значение - через методы типа uniform*().
...
const uniformVariable = gl.getUniformLocation(program, "u_variable");
gl.uniform2f(uniformVariable, 23, 32);  -->  тип vec2

------------------------

КАК РАБОТАЕТ WEBGL



------------------------

РАЗНОЕ

Чтобы не захламлять проект лишним кодом, можно воспользоваться утилитой webgl-utils.js
которая содержит множество полезных ф-ций для компиляции и компоновки шейдеров и др.

Если изображение не выводится на экран, и есть предупреждение типа "Drawing to a
destination rect smaller than the viewport rect", то нужно перед вызовом метода
viewport() добавить строчку webglUtils.resizeCanvasToDisplaySize(gl.canvas);

Канвас имеет два размера. Один размер - это кол-во пикселей, а второй - размер на 
HTML-странице (см. Изменение размера Canvas в WebGL).

Пиксельные координаты и экранные координаты - это, вероятно, одно и тоже.

Код шейдеров может размещаться либо внутри тега <script type="notjs"></script>, 
либо внутри шаблонной строки: const src = ``; Если код размещен внутри тега, то тегу
нужно указать любой, произвольный тип, например "notjs". В этом случае браузер не 
будет загружать его содержимое, а просто проигнирирует его.

Растеризация - это отрисовка объекта пикселями.

