ОСНОВЫ WEBGL

Отрисовка графики на странице происходит с помощью тега <canvas></canvas>
Канвас поддерживает 2 контекста отрисовки: 2d и webgl.

Пример отрисовки пустого окна:
...
const canvas = document.getElelemetById('my-canvas');
const gl = canvas.getContext('webgl');
gl.clearColor(0.0, 1.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

Метод clearColor() устанавливает цвет для константы COLOR_BUFFER_BIT.
Метод clear() закрашивает фон цветом COLOR_BUFFER_BIT (очищает цветовой буфер)

Чтобы нарисовать 2D-объект, нужно выполнить следующие шаги:
1) создать шейдерную программу; 
2) создать буфер вершин;
3) установить указатель на чтение из буфера;
4) отрисовать примитивы объекта;

Шейдерная программа состоит из 2х шейдеров: вершинного и фрагментного.
...
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 a_VertPos;
  void main() {
    gl_Position = vec4(a_VertPos, 1.0);
  }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.6, 0.6);
  }
</script>

Код шейдеров можно размещать внутри тега <script></script>, с произвольным типом.
В этом случае браузер не будет загружать его содержимое, а просто проигнирирует его.
Также, шейдеры могут определяться в отдельных файлах. Загружать их можно через fetch().

Создание шейдерной программы:
...
const program = gl.createProgram();
gl.attachShader(program, getShader(gl.VERTEX_SHADER, 'shader-vs'));
gl.attachShader(program, getShader(gl.FRAGMENT_SHADER, 'shader-fs'));
gl.linkProgram(program);

function getShader(type, elemId) {
  const shaderElem = document.getElementById(elemId);

  const shader = gl.createShader(type);
  gl.shaderSource(shader, shaderElem.text);
  gl.compileShader(shader);

  return shader;
}

Метод createProgram() создает объект программы, attachShader() прикрепляет к программе
шейдеры, а linkProgram() - связывает программу с контекстом WebGL.

После создания программы, нужно передать её на выполнение: gl.useProgram(program);

Создание буфера вершин:
...
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.5, -0.5, 0.0,
   0.0,  0.5, 0.0,
   0.5, -0.5, 0.0,
]), gl.STATIC_DRAW);

Метод createBuffer() создает некий буфер данных. Затем, с пом. метода bindBuffer()
производится привязка этого буфера к контексту WebGL.

Первый параметр bindBuffer() может принимать:
* ARRAY_BUFFER - данные вершин;
* ELEMENT_ARRAY_BUFFER - данные индексов;

Поскольку мы имеем дело с данными вершин, то выбирать нужно именно ARRAY_BUFFER.
Привязка означает, что все операции над ARRAY_BUFFER будут происходить с vertexBuffer.

Привязка нужна чтобы некоторые методы WebGL имели (неявный) доступ к буферу.
Отвязать буфер можно так: gl.bindBuffer(gl.ARRAY_BUFFER, null);

Метод bufferData() наполняет буфер данными из массива. Массив должен быть типизирован.
STATIC_DRAW необходим для оптимизации. Это означает что данные не будут меняться.

В дополнении к буферу вершин можно создать буфер индексов:
...
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 2, 1]), gl.STATIC_DRAW);

Этот буфер задает порядок вершин, по которому будут рисоваться примитивы. 
Каждый индекс обозначает какую-то вершину, например 0 - это [-0.5, -0.5, 0.0].

Если буфер индексов отсутствует, то примитивы будут рисоваться по вершинам 
(в порядке размещения в vetrexBuffer), а не по индексам.

Установка указателя на чтение из буфера (этот указатель называется атрибутом):
...
const vertPosAttr = gl.getAttribLocation(program, 'a_VertPos');
gl.enableVertexAttribArray(vertPosAttr);
gl.vertexAttribPointer(vertPosAttr, 3, gl.FLOAT, false, 0, 0);

Метод getAttribLocation() как бы связывает атрибут между вершинным шейдером и WebGL.
С помощью него мы получаем ссылку на a_VertPos и присваиваем её в vertPosAttr.

Атрибуты в вершинном шейдере по умолчанию отключены. Чтобы использовать атрибут, 
необходимо сначала включить его с пом. метода enableVertexAttribArray(). 
Обычно он вызывается вместе с vertexAttribPointer()

Метод vertexAttribPointer() устанавливает атрибут. После этого WebGL будет знать, 
как передавать данные буфера в шейдер. Метод принимает следующие параметры:

* index - индекс атрибута;
* size - кол-во элементов буфера на одну вершину;
* type - тип данных элементов буфера;
* norm - нормализация; управляет числовыми преоразованиями;
* stride - шаг сдвига к новой вершине; 0 означает size * sizeof(type);
* offset - позиция с кот. начинается обработка; 0 это начальная позиция;

Поскольку параметр size имеет значение 3, то при каждом вызове вершинного шейдера
атрибут a_VertPos будет получать по 3 элемента из буфера. Сначала это будут элементы
[-0.5, -0.5, 0.0], затем [0.0, 0.5, 0.0] (указатель сдвинется на size * sizeof(type)).

Если a_VertPos имеет тип, отличный от vec3, например vec4, то из буфера установятся
только первые 3 компоненты: x, y, z; а компонента w примет значение по умолчанию.

Перед отрисовкой примитивов нужно установить viewport (область отрисовки):
gl.viewport(offsetX, offsetY, width, height);

Область отрисовки нужна чтобы преобразовать диапазон вершин, который всегда находится 
в пределах от -1 до 1, к размерам канваса. Т.е. 1 по горизонтали будет соответствовать
значению width, а по вертикали - значению height.

Если параметры offsetX и offsetY имеют нулевое значение, то отрисовка 
будет начинаться с левого нижнего угла.

Отрисовка примитивов: gl.drawArrays(gl.TRIANGLES, 0, 3);

Примитивы можно отрисовывать с пом. 2х методов: drawArrays() и drawElements().
Первый метод отрисовывает примитивы последовательно, по вершинам из буфера вершин.
Второй метод отрисовывает примитивы по индексам, когда имеется буфер индексов.

Метод drawArrays() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять объект;
* index - указывает индекс первой вершины;
* count - кол-во вершин для отрисовки;

Метод drawElements() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять объект;
* count - кол-во элементов (буфера индексов) для отрисовки;
* type - тип данных элементов (буфера индексов);
* offset - с какого индекса будет проводиться отрисовка;

Типы примитивов в WebGL:
* LINES - отдельные линии (даже если есть общие вершины);
* LINE_LOOP - соединенные линии (в замкнутый контур);
* LINE_STRIP - соединенные линии, но последняя вершина не соединяется с первой;
* TRIANGLES - отдельные треугольники;
* TRIANGLE_STRIP - соединенные треугольники;
* TRIANGLE_FAN - треугольники, у которых одна вершина общая (веер);
* PONTS - отдельные точки;

---------------------

КОНВЕЙЕР WEBGL:

1. Создается буфер вершин. По вершинам впоследствии будут составлены примитивы, 
   а из примитивов - объекты. Проводится некоторая предобработка.

2. Содержимое буфера поступает на обработку в вершинный шейдер. Шейдер производит 
   над ними некоторые трансформации, задаваемые разработчиком.

3. Происходит Primtive Assembly. Конвейер получает результат вершинного шейдера и
   сопоставляет трансформированные вершины в отдельные примитивы (треугольники, линии). 
   Далее определяется, входит ли примитив в видимое пространство. Если нет, то он
   обрезается. Видимые примитивы передаются на следующий этап конвейера.

4. Происходит растеризация. Полученные примитивы преобразов. во фрагменты (пиксели),
   которые затем будут отрисованы на экране.

5. Вызывается фрагментный шейдер (в Direct3D он называется пиксельным шейдером)
   Он наполняет примитивы цветом, т.е. окрашивает фрагменты примитивов 
   и передает их на следующие подэтапы.

5.1. Scissor Test. Здесь проверяется, находится ли фрагмент в пределах отсекающего
     прямоугольника. Если да, то он передается дальше, иначе отбрасывается 
     и больше не принимает участия в обработке.

5.2. Multisample Fragment Operations (возможно это Multisampling). 
     Здесь производится сглаживание.

5.3. Stencil Test. Фрагмент передается в буфер трафаретов (stencil buffer). В этом
     буфере дополнительно отбрасываются фрагменты, кот. не должны отображаться.
     Как правило, он используется для создания эффектов, например теней.

5.4. Depth Buffer Test. Происходит тест буфера глубины (z-buffer). Здесь сравнивается 
     z-компонента фрагмента. Если один фрагмент ближе к сцене, чем другой, 
     то он проходит тест, а иначе отбрасывается.

5.5. Blending. Здесь происходит смешивание цветов, для создания прозрачности.
5.6. Dithering. Здесь происходит смешивание цветов, для создания тонов и полутонов.

6. Фрагмент передается во Frame Buffer (превращается в пиксель на экране).

--------------------

ШЕЙДЕРЫ

Шейдеры - это программы, которые выполняются на видеокарте. Они пишутся на языке GLSL.
Чаще всего встречается 2 типа шейдеров: вершинные, фрагментные.

В самом начале, при вызове метода draw*(), данные из буфера вершин поступают в
вершинный шейдер. Количество вызовов вершинного шейдера зависит от параметра count.

Задача вершинного шейдера - обработать (трансформировать) вершины примитивов. 
Задача фрагментного шейдера - закрасить пиксели примитивов.

Вершинный шейдер вызывается один раз для каждой вершины. Фрагментный шейдер вызывается
один раз для каждого пикселя. Например, для треугольника с площадью 300 пикселей
фрагментный шейдер вызовется 300 раз, тогда как вершинный всего 3 раза.

Все действия шейдеров выполняются внутри ф-ции main().

В GLSL определены след. примитивные типы:
* void, bool, int, float - аналогичны тем, что в C++; 
* vec2, vec3, vec4 - 2х, 3х, 4х мерные векторы, с типом float для компонентов;
* ivec2, ivec3, ivec4 - теже векторы, но с типом int для компонентов;
* bvec2, bvec3, bvec4 - векторы с типом bool для компонентов;
* mat2, mat3, mat4 - матрицы с эл-тами типа float;
* sampler2D, samplerCube - типы данных текстур (семплеры);

С помощью структур можно создавать составные типы.

В GLSL переменные обычно объявляются с квалификаторами:
* const - обычная константа;
* attribute - значение для отдельной вершини;
* uniform - значение, сразу для всех вершин;
* varying - значение, кот. задается в вершинном шейдере и затем передается 
  во фрагментный шейдер, где может быть использовано;

Атрибуты задают данные для вершин, а unifirm-переменные - для объектов.
Например, через unifirm-переменные можно задавать матрицы, т.к. они должны иметь 
одни и те же значения для всех вершин. 

Для переменных типа float можно задавать точность:
* highp - число с плавающей точкой будет иметь максимальную точность;
* mediump - число со средней степенью точности;
* lowp - диапазон плавающей запятой от -2 до 2;

Точность можно задать и глобально, для всего шейдера:
...
precision mediump float;
void main() { }

Встроенные переменные вершинного шейдера:
* gl_Position - указывает на позицию вершины (выходной параметр, vec4);
* gl_PointSize - содержит размер точки (выходной параметр, float);

Встроенные переменные фрагментного шейдера:
* gl_PointCoord - позиция фрагмента внутри точки (входной параметр vec2);
* gl_FontFacing - пренадлежит ли фрагмент лицевому примитиву (входной, bool);
* gl_FragCoord - указывает на позицию фрагмента в буфере фреймов (выходной, vec4);
* gl_FragColor - указывает на цвет фрагмента (выходной, vec4);
* gl_FragData[n] - указ. на цвет фрагмента для прикреплен. цвета n (выходной, vec4);

Встроенные функции:
* dot(x, y) - возвращает скалярное произведение векторов x и y;
* cross(x, y) - возвращает векторное произведение векторов x и y;
* matrixCompMult(matX, matY) - возвращает произведение матриц x и y 
  (матрицы должны быть одной размерности); 
* normalize(x) - возвращает нормализированный вектор x;
* reflect(t, n) - возвращает проекцию вектора t вдоль вектора n;
* sin(angle) - возвращает синус угла angle;
* cos(angle) - возвращает косинус угла angle;
* pow(x, y) - возвращает x в степени y;
* max(x, y) - возвращает максимальное значение;
* min(x, y) - возвращает минимальное значение;

Пример реализации RGB-треугольника:

1) Вершинный шейдер:
...
attribute vec4 a_Pos;
attribute vec4 a_Color;
varying highp vec4 v_Color;  -->  без highp, изображения не будет;

void main() {
  gl_Position = a_Pos;  -->  это нужно понимать как некую привязку данных к вершине

  v_Color = a_Color;  -->  varying не передаются сразу во фрагментный шейдер, а только
}                          после того, как вершинный шейдер обработает все вершины

2) Фрагментный шейдер:
... 
varying highp vec4 v_Color;  -->  в переменную передаются интерполируемые значения,
                                  в завис. от того, насколько близко пиксель
void main() {                     расположен к той или иной вершине
  gl_FragColor = v_Color;
}

----------------------

РАБОТА С МАТРИЦАМИ

С помощью матриц можно трансформировать объекты, менять положение камеры и пр.

Матрица ModelView объединяет мировую матрицу и матрицу вида. Задает трансформацию
(положение, ориентацию и масштабирование) объекта на сцене относительно камеры.

Мировая матрица (или матрица модели) объединяет матрицы: перемещения, вращения и
масштабирования. Переводит объекты из локальных координат, в глобальные.

Матрица вида переворачивает мировое пространство относительно камеры. 
Является обратной матрице модели камеры.

Если смотреть на мир со стороны, то можно сказать что движется камера. Но если смотреть
на него глазами камеры, то двигаться будут окружающие объекты (в противоположном
направлении и ориентации). Следовательно, чтобы преобразовать объекты для 
просмотра глазами камеры, используется матрица вида.

Матрица камеры - это её матрица модели, но без масштабирования (т.е. матрица поворота
умноженная на матрицу перемещения). Задает положение и ориентацию камеры на сцене.

Матрица проекции (Projection Matrix) переводит трехмерные координаты объекта,
в двухмерные, для отображения на экране. Она бывает ортогональной и перспективной.

Ортогональная проекция не изменяет размеров объекта в зависимости от глубины, а
перспективная - наоборот, созд. иллюзию глубины. Дальние объекты будут казаться меньше.

Для работы с матрицами и векторами будет использоваться библиотека glMatrix-2.0.
Также есть и другие библиотеки, например: Sylvester, WebGL-mjs.

Использование матриц для создания 3D-куба:
...
const pMatrix = mat4.create();
const mvMatrix = mat4.create();

mat4.perspective(pMatrix, 1.04, canvas.width / canvas.height, 0.1, 100.0);
mat4.identity(mvMatrix);

mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -2.0]);
mat4.rotate(mvMatrix, mvMatrix, 1.7, [0, 1, 0]);

const u_PMatrix = gl.getUniformLocation(program, 'u_PMatrix');
gl.uniformMatrix4fv(u_PMatrix, false, pMatrix);

const u_MVMatrix = gl.getUniformLocation(program, 'u_MVMatrix');
gl.uniformMatrix4fv(u_MVMatrix, false, mvMatrix);

Сначала обе матрицы нужно создать. Затем, с пом. метода perspective(), нужно установ.
матрицу проекции. Метод принимает такие параметры:

* matrix - матрица проекции;
* fieldOfView - угол обзора, в радианах;
* aspect - аспектное соотношение ширины к длине;
* near - самая ближняя точка (видимой области);
* far - самая дальняя точка; 

Метод identity() задаёт единичную матрицу (как бы сбрасывает её перед трансформацией).

Метод translate() задаёт перемещение. Первый параметр принимает выходную матрицу, а
второй - входную. Но так как преобразуется одна матрица, то значения совпадают.
Третий параметр - это вектор, вдоль которого происходит перемещение.

Метод rotate() задаёт вращение. Он имеет схожие параметры. Третий параметр - это 
угол поворота (в радианах), а четвёртый - ось поворота. Кроме того, вращение 
можно задавать с пом. методов rotateX(), rotateY().

Помимо перемещения и вращения есть ещё масштабирование: mat4.scale(output, input, vect);
Вектор задаёт масштаб, на который изменяется матрица input, после чего записывается 
в output. Тот же принцип преоразования матриц и в translate(), rotate().

С пом. метода getUniformLocation(), подобно атрибуту, определяется связка 
uniform-переменной между шейдером и WebGL.

Метод uniformMatrix4fv() передаёт преобразованную матрицу в вершинный шейдер.

Вершинный шейдер для 3D-куба:
...
attribute vec4 a_Pos;
uniform mat4 u_MVMatrix;
uniform mat4 u_PMatrix;

void main() {
  gl_Position = u_PMatrix * u_MVMatrix * a_Pos;  -->  порядок умножения важен!
}

Установка камеры происходит с пом. метода lookAt(): 
mat4.lookAt(mvMatrix, [2, 0, -2], [0, 0, 0], [0, 1, 0]);

Этот метод принимает след. параметры:
* matrix - матрица модели, кот. меняется от изменен. свойств камеры;
* eye - позиция камеры;
* center - точка, на которую направлена камера;
* up - вектор вертикальной ориентации;

Перед отрисовкой 3D-объекта, нужно включать тест (буфера) глубины, иначе лицевые
стороны объекта будут прозрачными. Также, в методе clear(), нужно задавать 
очистку буфера глубины (хотя без неё тоже всё будет работать).
...
gl.enable(gl.DEPTH_TEST);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 

--------------------

ТЕКСТУРИРОВАНИЕ

Текстурирование - это процесс наложения текстуры (картинки) на объект сцены.
Перед началом работы, желательно заранее подгрузить все текстуры.

Пример текстурирования 2D-объекта:
...
const texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, texture);

const u_Sampler = gl.getUniformLocation(program, 'u_Sampler');
gl.uniform1i(u_Sampler, 0);

gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

Сначала, с пом. методов createTexture() и bindTexture() создаётся объект текстуры и
устанавливается его связка с контекстом WebGL. После этого, к texture смогут 
обращаться методы WebGL, через свойство TEXTURE_2D.

Дальше, с пом. методов getUniformLocation() и uniform1i() определяется связка для
текстурного семплера, и передается базовое значение во фрагментный шейдер.

Семплер позволяет брать тексели из текстуры и совмещать их с пикселями объекта 
на экране. Тексель - это пиксель на текстуре.

Метод pixelStorei() указывает texImage2D() на правильное позиционирование текстуры.
Дело в том, что у объекта img система координа направлена сверху вниз. А параметр
UNPACK_FLIP_Y_WEBGL указывает, что изображение надо перевернуть.

Метод texImage2D() загружает текстуру на GPU. Он принимает след. параметры:
* target - целевой объект текстуры;
* level - уровень множественного отображения текстуры;
* internalformat - внутренний формат; RGBA говорит о том, что каждый тексель должен
  иметь цветовой канал для красного, зеленого и синего цвета, а также альфа-канал. 
* format - формат; в WebGL должен иметь тоже значение, что и в internalformat.
* type - тип данных, который указывает сколько байт выделить на один канал;
* elem - элемент, содержащий картинку для текстуры;

Форматы, помимо RGBA, могут быть такими: RGB, LUMINANCE и LUMINANCE_ALPHA. 
Формат LUMINANCE имеет только альфа-канал, а LUMINANCE_ALPHA кроме альфа-канала 
имеет ещё и канал яркости (т.е. при них, изображение будет похоже на черно-белое).

Для типа данных type иногда могут задаваться такие значения: UNSIGNED_SHORT_4_4_4_4,
UNSIGNED_SHORT_5_6_5 и т.п. Первый означает, что у формата RGBA каждый канал будет 
по 4 байта. Второй означает, что у формата RGB, красный и синий каналы будут 
по 5 байт, а зеленый - 6 байт.

Метод texParameteri() задает параметры текстурирования. Первый вызов устанавливает
значение для TEXTURE_MAG_FILTER, с пом. которого определяется рендеринг текстуры, 
когда она меньше объекта (по размеру). Второй вызов, с TEXTURE_MIN_FILTER, 
наоборот, определяет рендеринг текстуры, когда она больше объекта.

Этот метод принимает след. параметры:
* target - объект текстуры; может быть TEXTURE_2D или TEXTURE_CUBE_MAP;
* pname - устанавливаемый фильтр; может быть TEXTURE_MAG_FILTER, 
  TEXTURE_MIN_FILTER, TEXTURE_WRAP_S, и TEXTURE_WRAP_T;
* param - значение для фильтра;

Значения текстурных фильтров:

* NEAREST - установливается для TEXTURE_MAG_FILTER и TEXTURE_MIN_FILTER; 
  позволяет семплеру взять из текстуры цвет того текселя, центр которого находится 
  ближе всего к точке, с которой семплер берет цветовые значения;

* LINEAR - устанавливается для тех же фильтров; возвращает средневзвешанное значение
  соседних четырех пикселей, центры которых ближе всего к точке, с кот. семплер берет
  цветовые значения; работает медленнее NEAREST, но дает более качествен. результат;

Помимо самого текстурирования, нужно ещё определить текстурные координаты:
...
const texCoordsBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texCoordsBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  0.0, 0.0,
  0.0, 1.0,
  1.0, 1.0,
  1.0, 0.0,
]), gl.STATIC_DRAW);

Координаты 2D-текстуры описываются двумя компонентами: S и T. Координаты задаются в
диапазоне от 0.0 до 1.0. Каждая координата соответсвует определенной вершине полигона.

 [0.0, 1.0]      [1.0, 1.0]       [-0.5, 0.5]        [0.5, 0.5]
     @---------------$                  @---------------$
     |               |                  |               |
     |               |                  |               |
   T |   Текстура    |                Y |    Полигон    |
     |               |                  |               |
     |               |                  |               |
     #---------------&                  #---------------&
 [0.0, 0.0]   S   [1.0, 0.0]      [-0.5, -0.5]   X   [0.5, -0.5]

Также нужно задать дополнительные настройки:
...
const a_TexCoords = gl.getAttribLocation(program, 'a_TexCoords');
gl.enableVertexAttrubArray(a_TexCoords);
gl.vertexAttribPointer(a_TexCoords, 2, gl.FLOAT, false, 0, 0);

gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);

С пом. методов activeTexture() и bindTexture() делаем активной текстуру TEXTURE0 
и связываем её. WebGL поддерживает работу с несколькими текстурами одновременно, 
а использование TEXTURE0 отсылает нас к первой текстуре. 

Вершинный шейдер:
...
attribute vec4 a_Pos;
attribute vec2 a_TexCoords;
varying vec2 v_TexCoords;

void main() {
  gl_Position = a_Pos;
  v_TexCoords = a_TexCoords;
}

Фрагментный шейдер:
...
precision hight float; 
uniform sampler2D u_Sampler;
varying vec2 v_TexCoords;  -->  интерполир. значение, в диапазоне от 0.0 до 1.0
                                в завис. от близости пикселя к текстурной координате
void main() {
  gl_FragColor = texture2D(u_Sampler, v_TexCoords);  -->  здесь просто берётся тексель 
}                                                         по координате

Mip-текстурирование - способ, при кот. используется нескольких копий одной текстуры, 
с разными детализациями. Это позволяет менять качество отображения, когда объект
приближается или отдаляется. Исполуется только для TEXTURE_MIN_FILTER.

Значения фильтра, при mip-текстурировании:

* NEAREST_MIPMAP_NEAREST - фильтр использ. одну копию текстуры, наиболее подходящую 
  по размерам; семплер берёт тексели по алгоритму NEAREST;

* LINEAR_MIPMAP_NEAREST - фильтр использ. одну копию текстуры, но семплер 
  берёт тексели по алгоритму LINEAR;

* NEAREST_MIPMAP_LINEAR - фильтр использ. две копии текстуры; семплер работает по
  алгоритму NEAREST; цвет пикселя - это средневзвешенное значение 
  текселей, выбранных сразу из 2х текстур.

* LINEAR_MIPMAP_LINEAR - тоже самое, но семплер работает по алгоритму LINEAR;
  наиболее медленный способ, но с наилучшим качеством.

Помимо этого, нужно ещё сгенерировать мипмапы (т.е. копии текстуры):
gl.generateMipmap(gl.TEXTURE_2D);  -->  должен вызываться после texImage2D();

Также, нужно помнить, что изображения, при mip-текстурировании, должны иметь 
размеры, равные степени двойки: 16px, 32px и т.д.

Texture wrapping - ещё один способ текстурирования, при котором семплер работает 
с текстурными координатами, находящимися вне диапазона от 0.0 до 1.0.

Для его использования нужно установить фильтры TEXTURE_WRAP_S и TEXTURE_WRAP_T.
Они отвечают за рендеринг текстуры вдоль осей S и T.

Значения этих фильтров:
* CLAMP_TO_EDGE - координаты, которые меньше 0 и больше 1, сжимаются до 0:1;
* REPEAT - повторение текстуры, если её координаты вне диапазона 0:1;
* MIRRORED_REPEAD - повторение текстуры с зеркальным отражением;

Текстурные коодринаты теперь могут иметь такой вид:
...
const texCoords = [
  0.0, 0.0,
  0.0, 2.0,
  2.0, 2.0,
  2.0, 0.0,
];

Текстурирование 3D-объекта выполняется также, как и для 2D. Только нужно учитывать, 
что в этом случае у сторон объекта не должно быть общих вершин. Каждая вершина должна
представять только одну сторону, т.е. для куба понадобится 24 вершины и столько же
текстурных координат, а не 8, как было в примерах ранее (иначе текстуры поплывут).

--------------------

ОСВЕЩЕНИЕ

Чтобы создать освещение, нужно реализовать его тип и задать объектам материал. 
Основная работа по освещению выполняется в шейдерах.

Освещение бывает 3х типов:
* Ambient light - фоновое освещение, отраженный свет;
* Directional light - направленное освещение, солнечный свет;
* Point light - точечное освещение, свет лампы;

Фоновое освещение (в модели отражения Фонга) - это сумма фонового, диффузного и
зеркального отражений. Материал - это совокупность параметров, задающих цвет объекта.

При реализации освещения необходимо, чтобы каждая вершина имела вектор нормали.
Для этого создается буфер нормалей. Перед использованием нормалей, их нужно
дополнительно нормализовать с помощью метода normalize().

При реализации освещения нужно также выбрать подходящую модель отражения и затенения.
Модель отражения - это способ взаимодействия света и материала для получения цвета
поверхности. Модель затенения - это тип интерполяции, позволяющий получить 
конечное значение цвета, в зависимости от освещения.

Пример реализации освещения (модель отражения Фонга):
...
const normalBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  // лицевая сторона
  0.0, 0.0, 1.0,
  0.0, 0.0, 1.0,
  0.0, 0.0, 1.0,
  0.0, 0.0, 1.0,
  // задняя сторона.
  0.0, 0.0, -1.0,
  0.0, 0.0, -1.0,
  0.0, 0.0, -1.0,
  0.0, 0.0, -1.0,
  ...
]), gl.STATIC_DRAW);

gl.uniform3fv(u_LightPos, [0.0, 10.0, 5.0]);

gl.uniform3fv(u_AmbientLightColor, [0.1, 0.1, 0.1]);
gl.uniform3fv(u_DiffuseLightColor, [0.7, 0.7, 0.7]);
gl.uniform3fv(u_SpecularLightColor, [1.0, 1.0, 1.0]);

gl.uniform3fv(u_AmbientMaterialColor, [0.0, 1.0, 0.0]);
gl.uniform3fv(u_DiffuseMaterialColor, [0.7, 0.7, 0.7]);
gl.uniform3fv(u_SpecularMaterialColor, [1.0, 1.0, 1.0]);

const nMatrix = mat3.create();
mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, 5.0])
mat4.rotateY(mvMatrix, mvMatrix, 45);
mat3.normalFromMat4(nMatrix, mvMatrix);

Реализация почти та же, что и для обычного 3D-объекта. Только дополнительно нужно
создать буфер нормалей, передать в шейдер значения для uniform-переменных освещения 
и материала, создать матрицу нормалей и установить её с пом. метода normalFromMat4().
После чего, идут обычные действия по передачи преобраз. матриц и отрисовки примитивов.

Вершинный шейдер:
...
attribute vec3 a_Pos;
attribute vec3 a_Normal;

uniform mat4 u_MVMatrix;
uniform mat4 u_PMatrix;
uniform mat3 u_NMatrix;

uniform vec3 u_LightPos;

uniform vec3 u_AmbientLightColor;
uniform vec3 u_DiffuseLightColor;
uniform vec3 u_SpeculaLightrColor;

uniform vec3 u_AmbientMaterialColor;
uniform vec3 u_DiffuseMaterialColor;
uniform vec3 u_SpecularMaterialColor;

const float c_Shininess = 16.0;
varying mediump vec4 v_Color;

vec3 getTransformedPos();
vec4 getColor(float, float);

void main() {
  gl_Position = a_Pos;  

  vec3 tPos = getTransformedPos();
  vec3 tNormal = normalize(u_NMatrix * a_Normal);

  vec3 lightDir = normalize(u_LightPos - tPos);
  vec3 reflDir = normalize(reflect(-lightDir, tNormal));
  vec3 viewDir = -normalize(tPos);  

  float diffuseDot = max(dot(tNormal, lightDir), 0.0);

  float specularDot = max(dot(reflDir, viewDir), 0.0);
  specularDot = pow(specularDot, c_Shininess);

  v_Color = getColor(diffuseDot, specularDot);
}

vec3 getTransformedPos() {
  vec4 pos = u_MVMatrix * a_Pos;
  return pos.xyz / pos.w;
}

vec4 getColor(float diffuseDot, float specularDot) {
  vec3 ambientRefl = u_AmbientMaterialColor * u_AmbientLightColor;
  vec3 diffuseRefl = u_DiffuseMaterialColor * u_DiffuseLightColor * diffuseDot;
  vec3 specularRefl = u_SpecularMaterialColor * u_SpecularLightColor * specularDot;
  return vec4(ambientRefl + diffuseRefl + specularRefl, 1.0);
}

Сначала мы преобразовываем позицию вершины и нормаль. Это необходимо, чтобы правильно
рассчитать отражения, посколько на входе вершина и нормаль ещё не преобразованы 
через матрицы (вращения, перемещения, и т.п.).

Далее получаем вектор направления света и вычисляем все отражения.

Фоновое отражение (ambient reflection) вычисляется по формуле: I = Ka * Ia, 
где Ka - это материал, Ia - цвет фонового отражения.

Диффузное отражение (diffuse reflection) вычисляется так: I = Kd * Id * max(cos θ, 0).
Kd и Id - материал и цвет диффузного отражения, cos θ - угол между нормалью (N) и
направлением света (L). Ф-ция max() отсекает отрицательные значения. В шейдере, 
cos θ представлен как скалярное произведение: dot(tNormal, lightDir);

Зеркальное отражение (specular reflection): I = Ks * Is * max(cos θ, 0) ^ a.
Ks и Is - материал и цвет зеркального отражения, cos θ - угол между направлением
взгляда (V) и отраженным лучом (R). В шейдере cos θ представлен, как скалярное
произведение R и V. Степень "a" указывает на блеск материала. 

Отраженный луч - это вектор, перпендикулярный направлению света. Он вычисляется так: 
R = 2(L * N) * N - L. В шейдере это вычисление делается через ф-цию reflect().
Переменная lightDir с знаком минус из-за зеркального отражения.

И в конце, ф-ция getColor() выполняет суммирование всех отражений и возвращает
итоговый цвет вершины, который затем передается во фграгментный шейдер.

Фрагментный шейдер:
...
varying mediump vec4 v_Color;

void main() {
  gl_FragColor = v_Color;
}

--------------------

РАЗНОЕ

Раньше, для перерисовки сцен использовались таймеры или интервалы, но с недавних пор
рекомендуется использовать браузерный метод requestAnimationFrame(). 

Он делает анимации более плавными, поскольку браузер сам определяет нужный интервал 
для кадров. Также, для плавности эффекта, браузер может замедлять некоторые 
анимации, которые работают парралельно.

Обработка пользовательского ввода предполагает обычную обработку событий 
клавиатуры и мыши (как и в любом front-end приложении).

Каждый объект на сцене должен состоять из собствтенного набора вершин, индексов,
текстурных координат и т.п. Каждый набор должен отрисовываться отдельно.

