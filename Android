СТРУКТУРА ПРОЕКТА

Проект для Android состоит из модулей. Каждый модуль имеет три папки:
* minifests - хранит файл манифеста AndroidManifest.xml;
* java - хранит файлы с исходным кодом проекта, активити т.п.;
* res - хранит файлы ресурсов.

Папка res также имеет подпапки:
* drawable - для различных изображений;
* layout - для xml-файлов с разметкой активити;
* mipmap - для иконок приложения, при разных разрешениях экрана;
* values - для xml-файлов с данными: цвета, языковые переводы, темы и т.п.

Другие подпапки res:
* animator - для xml-файлов, определяющих анимацию свойств;
* anim - для xml-файлов, определяющих tween-анимации;
* color - для xml-файлов, опредеяющих список цветов;
* menu - для xml-файлов, определяющих меню приложения;
* raw - для различных файлов, которые сохраняются в исходном виде;
* xml - для произвольных xml-файлов;
* font - для файлов шрифтов, либо xml, в которых есть элементы <font-family>.

--------------------------------------

ГРАФИЧЕСКИЙ ИНТЕРФЕЙС

Графический интерфейс можно строить как с помощью обычных классов, так и через xml-
разметку. Но обычно весь визуал выносят в xml-файл.

Графический интерфейс состоит из контейнеров и элементов. Контейнеры упорядочивают
элементы. Контейнеры это классы-наследники от ViewGroup, а элементы - от View.

Контейнеры по сути это теже элементы. Их классы обычно заканчиваются на Layout:
ConstraintLayout, GridLayout, LinearLayout и т.д.

При создании элементов через классы, в их конструкторы необходимо передавать контекст.
Контекст - это то активити, в котором они будут отображаться.

Для установки созданного элемента нужно вызвать метод setContentView и передать в него
объект этого самого элемента. Также этот метод может принимать id xmp-файла. 
А вызываться он должен из активити, из метода onCreate.
...
setContentView(new TextView(this));
setContentView(R.layout.activity_main);

Чтобы добавить элемент в контейнер нужно воспользоваться методом addView, но перед этим
элементу нужно задать параметры (размер, позиционирование и др.). Задать параметры
можно с помощью метода setLayoutParams.
...
var textView = new TextView(this);
// Тоже самое, что и установка атрибутов в xml
textView.setLayoutParams(new ConstraintLayout.LayoutParams(...));

var layout = new ConstraintLayout(this);
layout.addView(textView);

setContentView(layout);  -->  Установка контейнера с набором элементов

Разметка в xml должна начинаться с корневого элемента, обычно это какой-то контейнер.
В корневом элементе необходимо определять пространства имен. Каждое пространство имен
добавляет какую-то функциональность в приложение, например атрибуты элементов и т.д.

Пространство имен объявляется так: xmlns:префикс="ссылка_на_ресурс".
...
<ConstraintLayout xmlns:android="http://">  -->  Префикс android - это ссылка на 
  <TextView android:text="Hello!" />             загружаемый ресурс. Обращаясь к нему,
</ConstraintLayout>                              мы как бы обращаемся к тому ресурсу

Три наиболее распространенных пространства имен:
1) android - содержит основные атрибуты платформы Android для управления свойствами
элементов (текст, размер, позиционирование и т.д.)
2) app - содержит пользовательские атрибуты, или атрибуты подключаемых библиотек;
3) tools - применяется для работы с элементами в режиме дизайнера из Android Studio.

Id элемента задается так: android:id="@+id/my_name". Знак + означает, что это новый
ресурс и он должен добавиться в класс R.java, если его там еще нет.

Чтобы получить элемент по id из кода, нужно использовать метод findViewById.
TextView textView = (TextView) findViewById(R.id.my_name);

Типы измерений в Android-приложении:
* px - пиксели, не рекомендуется использовать, т.к. устройства имеют разную плотность
пикселей на дюйм;
* dp - абстрактные пиксели, задают примерно одинаковые размеры, рекомендуется
использовать именно их;
* sp - независимые от масштаба пиксели, допускают настройку размеров, рекомендуется
использовать для работы со шрифтами;
* pt - 1/72 дюйма, базируются на физических размерах экрана;
* mm - миллиметры;
* in - дюймы.

Для перевода размеров из одного измерения в другое, нужно использовать метод
TypedValue.applyDimension.

Для организации элементов внутри контейнера необходимо использовать атрибуты
начинающиеся с префикста layout_*, например layout_width/heigth и т.д. 
Они могут принимать следующие значения:
...
* match_parent - растяжение по всей ширине/высоте, не рекомендуется использовать в
элементах, которые находятся внутри ConstraintLayout (вместо этого подойдет 0dp);
* match_constraint - тоже, что и match_parent но для ConstraintLayout;
* wrap_content - растяжение по содержимому;
* точные размеры.

Другие атрибуты организации элементов:
* min/maxWidth - минимальная и максимальная ширина;
* min/maxHeight - минимальная и максимальная высота;
* padding/paddingLeft/Right/Top/Bottom - внутренние отступы;
* layout_marginLeft и т.д. - внешние отступы (общего margin сразу для всех сторон нет!).

При установке отступов через классы, их значения будут задаваться в обычных пикселях.
В этом случае может потребоваться дополнительное преобразование в dp и т.п.

Для выравнивания элементов внутри контейнера ConstraintLayout, необходимо использовать
привязки. Они находятся в пространстве имен app и определяются следующим образом: 
...
* layout_constraintLeft_toLeftOf - левая граница элемента выравнивается по левой
границе другого элемента;
* layout_constraintRight_toLeftOf - правая граница элемента выравнивается по левой
границе другого элемента;
* layout_constraintBaseline_toBaselineOf - базовая линия элемента выравнивается по
базовой линии другого элемента.

Подобным образом реализуются и остальные варианты привязок.

Чтобы установить привязку, нужно атрибуту layout_constraint* передать id элемента,
относительно которого необходимо выравниваться, либо передать значение parent,
указывающее что привязка будет относительно родительского контейнера.
...
<TextView 
  app:layout_constraintLeft_toRightOf="@+id/button"
  app:layout_constraintTop_toTopOf="parent"
/>

В примере выше левая граница TextView располагается по правой границе кнопки, а верхняя
граница располагается по верхней границе контейнера.

Чтобы расположить элемент в центре по одной из оси, нужно указать сразу две привязки.
По горизонтали: layout_constraintLeft_toLeftOf и layout_constraintRight_toRightOf.

Если елемент расположен по центру, ему можно задавать сдвиг (значение от 0 до 1):
layout_constraintHorizontal_bias="0.2"  -->  На 20%, начиная от заданного края

Другие атрибуты для элементов внутри ConstraintLayout:
* layout_constraintWidth_min/max - минимальная/максимальная ширина;
* layout_constraintHeight_min/max - минимальная/максимальная высота;
* layout_constraintWidth/Height_percent - ширина/высота в процентах (значен. от 0 до 1);
* layout_constraintWidth/Height_default - требуется устанавл. для работы с процентами;
* layout_constraintDimensionRatio - соотношение размеров, задается как width:height
(например 1:0.5 говорит что ширина в 2 раза больше высоты);
* layout_constraintHorizontal_chainStyle - растягивает элементы, подобно тому как это
делается во flexbox через space-between, space-around и т.д.

Применение некоторых атрибутов требует соблюдения дополнительных условий. 
Так например, если у элемента есть атрибуты типа layout_constraintWidth/Height_percent
или layout_constraintDimensionRatio, то у него также должен быть хотябы один из
атрибутов layout_width/height со значением 0dp или match_constraint.

Другие контейнеры:
* LinearLayout - контейнер, который упорядочивает все элементы в одном направлении: 
по горизонтали или по вертикали; 
* RelativeLayout - контейнер, необходимый для упрощенного построения элементов
относительно друг-друга;
* TableLayout - контейнер, который упорядочивает элементы в виде таблицы; чтобы задать
строку нужно использовать элемент TableRow (он наследник LinearLayout), а столбцы
определяются автоматически, по кол-ву элементов внутри него.
* FrameLayout - контейнер для отображения одного элемента; если разместить в нем
несколько элементов, то они будут наклываться друг на друга;
* GridLayout - контейнер, который упрядочивает элементы в виде сетку; каждый элемен это
отдельная колонка; колонки можно растягивать;
* ScrollView - контейнер, позволяющий прокручивать содержимое; как и FrameLayout может
вмещать только один элемент; если требуется отображать много элементов, то их нужно
будет сперва обернуть во внутренний контейнер.

Некоторые из контейнеров дают возможность своим элементам использовать такие атрибуты:
* layout_gravity - позволяет упрощенно выравнивать элементы по разным сторонам;
* layout_weight - задает вес элемента, на основе которого определятся занимаемое
пространство в контейнере, относительно других элементов.

Файл с xml-разметкой может включать в себя также и другие файлы разметки. 
Это делается с помощью элемента include.
...
<ConstraintLayout>  -->  Разметка одного файла
  <include layout="@layout/inner_panel" />  -->  Подключает какой-то другой файл
</ConstraintLayout>                              с названием inner_panel.xml

Существует также еще один атрибут для выравнивания - gravity. В отличии от
layout_gravity, он выравнивает внутреннее содержимое элемента, а не сам элемент:
...
<TextView 
  android:gravity="bottom"  -->  Выравнивает текст по низу, внутри квадрата 200х100.
  android:layout_width="200dp"   Еще можно делать комбинации bottom|right и т.п.
  android:layout_height="100dp" 
/>                               

Элементы управления:
* TextView - отображает текст; высота текста задается в sp; чтобы выделить все ссылки в
тексте, нужно добавить атрибут autoLink; ссылки могут быть как web, email, phone и т.д.
* EditText - редактируемый текст; атрибут hint задает подсказку ввода (placeholder);
атрибут inputType задает клавиатуру ввода (текстовая, числовая, для паролей и т.д).
* Button - кнопка; атрибут onClick задает обработчик клика;
* Checkbox - флажок; атрибут onClick задает обработчик клика;
* ToggleButton - кнопка, работающая подобно флажку; имеет атрибуты textOn и textOff, 
в которых задается текст при отмеченном/неотмеченном состояниях; 
* RadioButton - переключатель; используется только внутри контейнера RadioGroup; 
у этого контейнера может определяться общий слушатель событий всех переключателей;
* DatePicker - виджет календаря; позволяет выбрать дату;
* TimePicker - виджет часов; позволяет выбрать время;
* SeekBar - ползунок; имеет атрибуты: min, max, progress; они задают минимальное
максимальное значение шкалы, и текущее значение соответсвенно. 

Чтобы в элементе задать обработчик события, необходимо установить специальный атрибут
соответсвующий тиму событию, например onClick и т.д. Значение атрибута должно сомпадать
с названием публичного метода в активити. Сигнатура метода: void handlerName(View).
...
<Button onClick="sendMessage" />  -->  activity_main.xml

class MainActivity {
  public void sendMessage(View view) { }
}

Кроме того, обработчик события можно задавать сразу из кода:
...
Button btn = findViewById(R.id.myBtn);
btn.setOnClickListener(v -> { });

Для создания простых уведомлений используется класс Toast. Уведомление Toast затухает
по истечению заданного времени. Его можно размещать где угодно, а не только снизу.
Кроме того, можно менять его внешний вид с помощью собственной xml-разметки.
...
Toast toast = Toast.makeText(this, "Hello!", Toast.LENGTH_LONG);
toast.show();  -->  Показать уведомление на 3.5 сек.

Подобно Toast, выводить уведомления можно и с помощью элемента Snackbar. В отличии от
Toast, уведомление выводится на всю ширину экрана, в нижней части. Позиционирование
изменить нельзя, но зато можно определить кнопку внутри, с обработчиком клика.

--------------------------------------

РЕСУРСЫ

Ресуры располагаются в папке res. Когда происходит компиляцая проекта, они добавляются
в специальный файл R.jar. В этом файле есть класс R.java, в который подтягиваются все
значения, ранее заданные в различных xml-файлах. Например если задать строку my_app в
файле strings.xml, то в R.java будет создан вложенный класс string с полем my_app.

К ресурсам можно обращаться как из java-кода, так и из xml-разметки. 
Ссылка на ресурс в xml-файле выглядит так: @[имя_пакета:]тип_ресурса/имя_ресурса
...
<resources>  -->  Ресурсы должны находиться в теге <resources>
  <string name="app_name">My App</string>  -->  Задается строковый ресурс
</resources>
...
R.string.app_name  -->  Обращение из java-кода
<TextView android:text="@string/app_name" />  -->  Обращение из xml-разметки

Для получения ресурсов в активити можно использовать метод getResources. Кроме того,
некоторые элементы позволяют напрямую устанавливать значения по идентификатору ресурса.
...
textView.setText(R.string.app_name);  -->  Установится значение "My App"

Строковые ресурсы могут содержать форматированное значение:
...
<string name="message">Hello %1$s with id: %2$d</string>
getResources().getString(R.string.message, "user", 23);  -->  Hello user with id: 23

Для строковых ресурсов во множественных числах, нужно использовать plurals.
...
<plurals name="flowers">
  <item quantity="one">%d цветок</item>
  <item quantity="few">%d цветка</item>
  <item quantity="many">%d цветков</item>
</plurals>

Resources res = getResources();
res.getQuantityString(R.plurals.flowers, 1, 1);    -->  1 цветок
res.getQuantityString(R.plurals.flowers, 10, 10);  -->  10 цветков

У метода getQuantityString второй параметр это значение, на основе которого будет
подобран подходящий item, а третий параметр - значение которое будет подставлено в %d.

Пример строкового массива:
...
<string-array name="languages">
  <item>JavaScript</item>
  <item>С++</item>
</string-array>

Пример ресурса цвета: <color name="white">fff</color>
Пример ресурса размера: <dimen name="size_lg">10dp</dimen>

Таблица всех типов ресурсов: https://metanit.com/java/android/2.4.php

--------------------------------------

АКТИВИТИ

Это экраны приложения. Они управляются системой в виде стэка, который называется back
stack. При запуске нового активити оно помещается поверх этого стэка, а когда завершает
свою работу, то удаляется оттуда. После этого возобновляется предыдущее активити.

Обработчики событий активити:
* onCreate - здесь происходит первоначальная настройка активити; этот метод получает
объект Bundle в котором хранится предыдущее состояние активити;
* onStart - здесь активити подготавливается к выводу на экран; не переопределяется;
* onResume - вызывается когда активити получает фокус;
* onPause - вызывается когда активити теряет фокус, например при переходе к другому
активити; здесь можно освобождать ресурсы, приостанавливать аудио, видео и т.д;
* onStop - вызвается когда активити становится невидимым, но ещё сохраняется в памяти;
здесь также можно освобождать ресурсы, отправлять запросы в БД и т.д;
* onRestart - вызывается при возобновлении активити из состояния stopped;
* onDestroy - вызывается когда активити завершает свою работу.

При изменении ориентации экрана система завершает работу активити и создает его заново,
вызывая метод onCreate. Также активити завершается при вызове метода finish.

Каждое приложение содержит файл манифеста AndroidManifest.xml. В нем содержится вся
основная информация: название приложения, версия SDK, иконки, регистрируются все
используемые классы активити, сервисы и т.д.

Корневым элементом является manifest. По умолчанию он имеет атрибут package, в котором
определяется основной пакет приложения, а также ряд других из пространства имен android,
например versionName и versionCode. Они помогают определить, нужно ли пользователю
устанавливать обновление.

Далее идет элемент application. В нем определяются настройки приложения. Он также 
имеет атрибуты из пространства имен android:
...
* allowBackup - указывает, будет ли создаваться бэкап для приложения;
* icon - устанавливает иконку приложения;
* roundIcon - устанавливает круглую иконку приложения;
* label - название приложение, под которым оно будет отображаться на устройстве;
* supportsRtl - могут ли использоваться специальные API для правостороннего текста;
* theme - устанавливает тему приложения;

Внутри application содержатся элементы activity. Они определяют все используемые
активити в приложении. У activity также есть внутренний элемент intent-filter, а тот 
в свою очередь содержит такие элементы как action и category.

Элемент intent-filter, с помощью своих внутренних элементов, указывает как будет
использоваться заданное активити.
...
<activity android:name=".MainActivity">
  <intent-filter>
    <action android:name="...action.MAIN" />  -->  MainActivity будет входной точкой
                                                   приложения, без данных извне

    <category android:name="...category.LAUNCHER" />  -->  MainActivity будет стартовым
  </intent-filter>                                         экраном при запуске
</activity>

Элемент uses-sdk позволяет управлять версией Android SDK.

Элемент uses-permission необходим для установки разрешений (на использование камеры,
списка контактов и т.д; про контакты подребнее написано в главе о провайдерах контента).

Поддержка разных разрешений определяется элементом supports-screen. В его атрибутах
указывается на каких разрешениях может работать приложение.

Чтобы запретить изменение ориентации для активити, нужно в его элементе установить
атрибут screenOrientation со значением "portrait" либо "landscape".

Для перехода к другому активити необходимо создать интент, и передать его в метод
startActivity. Интент - это класс, необходимый для взаимодействия между собой разных
активити, передачи данных и т.п.
...
var intent = new Intent(this, SecondActivity.class);
startActivity(intent);

Чтобы передать данные в другое активити, нужно использовать метод интента putExtra. 
В него можно положить только данные примитивных типов, их массивы либо объект
интерфейса Serializable.

Получить переданные данные можно так:
...
Bundle args = getIntent().getExtras();
String myStr = args.get("key").toString();  -->  Какое-то значение, переданное через
                                                 putExtra по ключу "key"

Для лучшей оптизимации под Android, вместо Serializable можно использовать Parcelable.

Если требуется запустить новое активити и получить от него какой-то результат, то
вместо метода startActivity нужно использовать Activity Result API. Принцип его работы:
...
1) Регистрируется лаунчер интента с помощью метода registerForActivityResult.
2) Лаунчер имеет метод launch, который запускает новое активити.
3) В новом активити выполняется какая-то работа и вызывается метод setResult с нужным
результатом. Результат передается в колбек, указанный ранее при вызове метода
registerForActivityResult.
4) Обрабатывается полученный результат.

При использовании класса Intent без флагов, метод startActivity всегда будет создавать
новое активити в стэке. Флаги позволяют манипулирвать стэком, обращаться к уже
существующим в нем активити и т.д.
...
var intent = new Intent(this, MainActivity.class);
intent.addFlags(INTENT.FLAG_ACTIVITY_REORDER_TO_FRONT);
startActivity(intent)  -->  Вместо создания нового активити будет обычное  
                            перемещение, к уже созданному ранее
Все intent-флаги:
* FLAG_ACTIVITY_REORDER_TO_FRONT - перемещает активити, к которой осуществляется
переход на вершину стека, если оно уже там есть;
* FLAG_ACTIVITY_CLEAR_TOP - очищает все activity кроме того, которое запускается;
* FLAG_ACTIVITY_SINGLE_TOP - активити может существовать в стеке только в единич. виде;
* FLAG_ACTIVITY_NO_HISTORY - позволит не сохранять в стеке запускаемое активити.

--------------------------------------

РАБОТА С КАРТИНКАМИ

Чтобы обратиться к картинке из java-кода, нужно вызвать: R.drawable.имя_файла.
В xml-разметке: @drawable/имя_файла. А чтобы отобразить картинку, используется элемент
ImageView с атрибутом src.

Для получения ресурса картинки используется метод ResourcesCompat.getDrawable.

Изображение не обазятельно размещать в drawable. Оно также может хранится в папке
assets. Но в этом случае его придется считывать из потока.

--------------------------------------

СПИСКИ И АДАПТЕРЫ

Списки - это виджеты, которые предоставляют визуальное отображение коллеций данных. 
Из них самым распространенным является элемент ListView. 

Связь между данными и их отображением обеспечивает класс ArrayAdapter. Кроме того он
позволяет манипулировать коллекциями: добавлять/удалять элементы и т.п. 

При изменении коллеции через ArrayAdapter нужно обязательно выполнить синхронизацию,
иначе она не перерисуется. Делается это с помощью метода notifyDataSetChanged.

Элемент ListView имеет атрибут entries в который можно передать название ресурса, 
где хранятся данные в виде string-array. Для установки множественного выбора
используется атрибут choiceMode со значением multipleChoice.
...
<string-array name="my_list">  -->  Ресурс из xml-файла в res/values
  <item>First value</item>
  <item>Second value</item>
</string-array>

<ListView android:entries="@array/my_list" />  -->  Связываем элемент с ресурсом

При создании адаптера, в него необходимо передавать xml-файл с разметкой одного
элемента списка. В Android SDK по умолчанию уже имеются такие файлы. Обратиться к ним
из java можно так: android.R.layout.simple_list_item_multiple_choice, либо
android.R.layout.simple_list_item_1

Для сложных списков необходимо создавать кастомный адаптер. Обычно это делается на
основе всё того же ArrayAdapter. При этом стоит помнить про оптимизацию отображения
элементов, например с помощью пула объектов и т.п.

Если активити в основном предназначено для вывода списка, то для удобной работы с ним
можно унаследоваться от класса ListActivity.

Для работы с выпадающими списками используется элемент Spinner.
Для отображения данных в виде таблицы используется элемент GridView.

Элемент RecyclerView предназначен для оптимизации работы со списками. Он имеет лучшую
производительность; может выводить элементы не только списоком, но и таблицей и т.д.
Однако событие выбора в RecyclerView необходимо реализовывать самому.

--------------------------------------

СТИЛИ И ТЕМЫ

Стили определяются в файле styles.xml в папке res/values. Задаются они с помощью
элемента style. Через атрибут parent можно унаследовать родительские стили. Внутри
указываются элементы item, которые хранят все необходимые свойства.
...
<style name="my_style">
  <item name="android:layout_width">0dp</item>  -->  Элемент, который принимает стиль
  <item name="android:textColor">#3f51b5</item>      переносит на себя заданные
  <item name="android:textSize">28sp</item>          в item'ах свойсва
</style>

<TextView style="@style/my_style" />  -->  Теперь размер текста будет 28sp и т.д.

Тема как и стиль определяется с помощью элемента style. Она задает стили для всего
приложения в целом (или активити), а не для отдельных элементов. Тема задается в
элементе application, который внутри файла манифеста.
...
<application android:theme="@style/my_theme">  -->  Тема устанавливается глобально, 
                                                    для всего приложения
  <activity  -->  Тема только для активити
    android:name="MyActivity" 
    android:theme="@style/my_theme2
  ></activity>
</application>

<style name="my_theme">
  <item name="colorPrimary">@color/red_500</item>  -->  Семантическое имя colorPrimary 
                                                        ссылается на стиль red_500

  <item name="android:textSize">28sp</item>  -->  Все элементы, использующие данную
</style>                                          тему будут иметь размер текста в 28sp

<ConstraintLayout android:theme="@style/my_theme3">  -->  Контейнер также может иметь
</ConstraintLayout>                                       собственную тему

--------------------------------------

МЕНЮ

Меню определяется в xml-файле, в каталоге res/menu, с помощью элемента menu. 
Оно состоит из внутренних элементов item и group. Внутри item можно задавать подменю.

Элемент item представляет объект MenuItem. Он включает в себя android-атрибуты:
* id - идентификатор элемента меню;
* icon - ссылка на ресурс картинки, которая содержит изображение элемента;
* title - ссылка на ресурс строки, которая содержит заголовок элемента;
* orderInCategory - порядок элемента в меню.

Чтобы отобразить меню, нужно в активити переопределить метод onCreateOptionsMenu и 
в нём вызвать: getMenuInflater().inflate(R.menu.my_menu, menuObj); где menuObj - это
параметр, наполняемый данными из xml-файла "my_menu".

Меню можно также создать и програмным способом. Для добавления нового пункта в этом
случае, нужно вызывать метод add в объекте menuObj.

Чтобы обработать нажатия в меню, нужно переопределить метод onOptionsItemSelected.

Элемент group группирует item'ы. Группа может состоять из флажков или радиокнопок.

--------------------------------------

ФРАГМЕНТЫ

Это часть визуального интерфейса, которая может переиспользоваться в различных местах
приложения. У фрагмента может быть соственный файл разметки. Он существует в контексте
активити и имеет свой жизненный цикл. Их удобно использовать на больших экранах.

Фрагмент определяется классом, который наследуется от Fragment. Задать разметку можно
либо в конструкторе, либо из метода onCreateView с помощью инфлатера.
...
class ContentFragment extends Fragment {
  public ContentFragment() {
    super(R.layout.fragment_content);  -->  Так задается xml-разметка, 
  }                                         вместо вызова setContentView
}

Чтобы вставить фрагмент в активити, нужно в разметке активити определить контейнер
FragmentContainerView с атрибутом name, где указывается класс фрагмента.
...
<FragmentContainerView 
  android:id="@+id/fragment_container_view"
  android:name="com.myapp.ContentFragment" 
/>

Чтобы задать логику, нужно переопределить метод onViewCreated.

Чтобы установить фрагмент из java-кода, нужно из активити выполнить такую связку: 
(в этом случае для FragmentContainerView не нужно указывать атрибут name)
...
getSupportFragmentManager().beginTransaction()
  .add(R.id.fragment_container_view, new ContentFragment()).commit();

В одном активити может быть несколько фрагментов, нупример на большом экране одним
фрагментом можно сделать боковое меню, а другим контентную часть. 

Взаимодействие между фрагментами можно реализовать путем доступа к их общему активити.
Его можно получить переопределив метод onAttach. Там оно представлено в виде параметра
context. А уже в самом активити находим контейнеры фрагментов и ими манипулируем.

Передать данные из активити во фрагмент можно через класс Bundle. См. Диалоговые окна!

--------------------------------------

МНОГОПОТОЧНОСТЬ

Если попробовать изменить UI из вспомогательного потока, то получится исключение, т.к.
это можно делать только в основном потоке. Чтобы этого избежать, нужно использовать
метод post или postDelayed класса View.
...
public void run() {  -->  Вызывается где-то в активити
  String value = calcValue();
  textView.post(() -> textView.setText(value));
}

Работа с многопоточностью из активити может привести к ошибкам. Это из-за того что при
изменении ориентации, активити пересоздаются заново и соответсвенно нарушает работу
потоков, которые теряют свои состояния.

Исправить это поможет класс ViewModel. Он позволяет автоматически сохранять состояния.

Состояния во ViewModel определяются типом MutableLiveData. Это обобщенный класс,
который выступает оберткой над каким-то другим типом. Его особенностью является то, 
что он имеет метод observer, позволяющий отслеживать изменения, сделанные из разных
потоков, во внешнем коде.

Задействовать ViewModel в активити можно через ViewModelProvider.

Также для реализации многопоточности можно использовать библиотеку ThreadPoster.

--------------------------------------

WEBVIEW И РАБОТА С СЕТЬЮ

WebView - это элемент для рендеринга html-кода, основанный на движке WebKit. 
Его можно использовать внутри приложения как встраиваемый браузер. Но JavaScript, 
по умолчанию, в нём отключен.
...
<WebView android:id="@+id/web_browser" />

Для получения доступа к интернету, нужно указать в файле манифеста такое разрешение:
<uses-permission android:name="android.permission.INTERNET" />

Чтобы загрузить страницу нужно воспользоваться методом loadUrl.
...
WebView browser = findViewById(R.id.web_browser);
browser.loadUrl("https://");

Чтобы отобразить html-код нужно использовать метод loadData.
browser.loadData("<html><body><h1>Hello World!</h1></body></html>");

Для загрузки данных по сети необходимо использовать класс HttpsURLConnection. 
Это напоминает использование CURL на backend'е.
...
var url = new URL("https://");

var connection = (HttpsURLConnection) url.openConnection();
connection.setRequestMethod("GET");
connection.setReadTimeout(10000);  -->  Таймаут перед выполнением 10 сек.
connection.connect();

var reader = new InputStreamReader(connection.getInputStream());
while (reader.readLine() != null) { }

--------------------------------------

РАБОТА С МУЛЬТИМЕДИА

Для работы с видео используется элемент VideoView. Видео обычно хранятся в каталоге 
res/raw, но можно также воспроизводить файлы и из интернета. Для управления видео,
используются методы: start, pause, resume, stopPlayback.

Чтобы добавить к видео стандартные инструменты управления, необходимо использовать
класс MediaController. C ним методы управления не нужны (start, pause и т.д).

Для воспроизведения аудио используется класс MediaPlayer. Но в работе с ним есть один
нюанс. При выходе из приложения, когда уничтожается активити, MediaPlayer всё равно
продолжит работу. Если вернутся к приложению, активити будет создано заново, но
элементы управления уже не смогут управлять воспроизведением. Чтобы это исправить,
нужно переопределить метод onDestroy и завершить в нем роботу MediaPlayer. Кроме этого
для плеера должен быть задан обработчик OnCompletionListener, в котором также должно
завершаться воспроизведение.
...
mediaPlayer = new MediaPlayer.create(this, R.raw.music_file);
mediaPlayer.setOnCompletionListener(mediaPlayer -> stopPlay());

public void onDestroy() { stopPlay(); }

public void stopPlay() {
  mediaPlayer.stop();
  mediaPlayer.prepare();
  mediaPlayer.seekTo(0);
}

Для управления громкостью используется класс AudioManager. А индикатором громкости в
разметке может быть элемент SeekBar.

--------------------------------------

СОСТОЯНИЯ И ДАННЫЕ ПРИЛОЖЕНИЯ

Чтобы сохранить какое-то состояние приложения и подзнее восстановить его, можно
воспользоваться методами onSaveInstanceState и onRestoreInstanceState соответсвенно.
...
protected void onSaveInstanceState(Bundle state) {
  state.putString(key, value);
  super.onSaveInstanceState(state);
}

protected void onRestoreInstanceState(Bundle state) {
  super.onRestoreInstanceState(state);
  var value = state.getString(key);
}

Метод onRestoreInstanceState вызывается после создания активити, а метод
onRestoreInstanceState - перед завершением работы.

Для сохранения состояний разных типов, а также для их получения, имеются соответсвующие
методы: put/get, putInt/getInt, putDouble/getDouble и т.д.

Если нужно хранить какие-то небольшие данные вне сессии приложения, можно использовать
SharedPreferences. Данные из SharedPreferences хранятся в xml-файлах в незашифрованном
виде, в локальном хранилище. Они невидимы и не доступны для простых пользователей.

Однако их можно удалить через панель управления приложением, в настройках ОС. 
Данные из SharedPreferences обрабатываются по принципу ключ-значение.

Для изменения данных используется класс SharedPreferences.Editor. Чтобы подтвертить
изменение необходимо вызвать метод commit или apply. Последний отличается тем, что
перед сохранением данных в файл, сначала сохраняет их во временной памяти.
...
SharedPreferences settings = getSharedPreferences(FILE_NAME, MODE_PRIVATE);

SharedPreferences.Editor editor = settings.edit();
editor.putString(key, value);
editor.apply();

String value = settings.getString(key);

Для упрощенной работы с группой настроек можно использовать специальный фрагмент
PreferenceFragmentCompat. Группа должна задаваться в отдельном xml-файле.

--------------------------------------

СЕРВИСЫ

Сервисы - это в каком-то смысле сопрограммы, которые могут работать без участия
пользователя. Для них не нужен визуальный интерфейс. Все сервисы наследуются от Service.

Методы жизненного цикла:
* onCreate - вызывается при создании сервиса;
* onStartCommand - вызывается при запуске сервиса;
* onBind - вызывается при использовании метода bindService;
* onDestroy - вызывается при завершении работы сервиса.

Для запуска/остановки сервиса из активити используется Intent:
...
var intent = new Intent(this, MyService);
startService(intent);  -->  Вызовется onStartCommand
stopService(intent);   -->  Вызовется onDestroy

Сервисы также как и активити необходимо регистрировать в файле манифеста. 
При регистрации, сервис принимает ряд атрибутов. В примере указаны только некоторые.
...
<application>
  <service 
    android:name=".MyService"  -->  Указывает класс сервиса
    android:enabled="true"     -->  Может ли сервис создаваться системой (true по умол.)
    android:exported="true"    -->  Можно ли другим приложениям обращаться к сервису
  ></service>
</application>

Если для работы сервиса требуются некоторые разрешения, то их можно указать в атрибуте
permissin. Кроме того сервис может запускаться в отдельном процессе.

Сервисы имеют один недостаток. Их работа останавливается при закрытии приложения. 
Таким образом они не завершают выполнение задач в фоновом режиме. Вместо сервисов можно
использовать WorkManager. Он, в отличии от них, продолжает работу до завершения всех
задач и является более современной альтернативой.

--------------------------------------

ДИАЛОГОВЫЕ ОКНА

Диалоговые окна создаются на основе связки из DialogFragment и AlertDialog.
...
class MyDialogFragment extends DialogFragment {
  public Dialog onCreateDialog(Bundle state) {
    var builder = new AlertDialog.Builder(getActivity());
    return builder.setTitle("Title").setMessage("Message").create();
  }
}

var dialog = new MyDialogFragment();
dialog.show(getSupportFragmentManager(), "tag");

Для такого окна можно установить: заголовок, сообщение, иконку, кнопки 
подтвержения/нейтральную/отмены, разметку интерфейса. При этом кнопки и заголовок с
иконкой в разметку не входят.

Передача данных из активити в окно, как и в любой другой фрагмент, осуществляется 
с помощью объекта Bundle.
...
var args = new Bundle();
args.putString("key", "value");

dialog.setArguments(args);
dialog.show(...);

Получить данные внутри окна можно с помощью метода getArguments.
String value = getArguments().getString("key");

--------------------------------------

ПРОВАЙДЕРЫ КОНТЕНТА

Они необходимы для доступа к контенту пользователя на девайсе, например это могут быть
контакты, фотки, отметки о звонках и т.д.

Встроенные провайдеры андроид:
* AlarmClock - управление будильником;
* Browser - история браузера и закладки;
* CalendarContact - календарь и информация о событиях;
* CallLog - информация о звонках;
* ContactsContact - контакты;
* MediaStore - медиа-файлы;
* SearchRecentSuggestions - подсказки по поиску;
* Settings - системные настройки;
* UserDictionary - словарь слов, использующиеся для быстрого набора;
* VoicemailContract - записи голосовой почты;

Для работы с провайдером контента используется метод getContentResolver. Он возвращает
объект, с помощью которого можно выполнять запросы в БД. Обычно весь контент
пользователя харнится в базе SQLite.

Рассмотрим пример работы с контактами. При работе с контактами можно получать 
и изменять их список. Чтобы обратиться к базе контактов, используется константа:
ContactsContract.Contacts.CONTENT_URI. Также для доступа к ним надо установить
разрешение: android.permission.READ_CONTACTS.
...
ContentResolver cResolver = getContentResolver();
Cursor cursor = cResolver.query(ContactsContract.Contacts.CONTENT_URI, ...);
while (cursor.moveToNext()) { ... }

Начиная с 23 версии андроид, получить разрешения для работы с провайдерами контента
можно только непосредсвенно перед работой с ними. Раньше, достаточно было установить
нужное разрешение в файле манифеста.

Чтобы установить разрешение из активити, нужно вызвать специальное диалоговое окно:
ActivityCompat.requestPermissions(this, new String[]
  { MANIFEST.permission.READ_CONTACTS }, REQUEST_CODE_READ_CONTACTS);

Проверить наличие того или иного разрешения в активити можно так:
...
int hasPermission = ContextCompat.checkSelfPermission(this,
  MANIFEST.permission.READ_CONTACTS);
if (hasPermission == PackageManager.PERMISSION_GRANTED) { ... }

Чтобы обработать выбор из диалового окна, нужно переопределить метод
onRequestPermissionsResult. Если приложение получает разрешение, то этот метод больше
не будет вызываться для него (того разрешения).

Чтобы изменять контакты нужно получить разрешение: android.permission.WRITE_CONTACTS.
Для записи новых контактов в базу используется метод insert класса ContentResolver.
Данные нужно записывать в две таблицы "raw contacts" и "data".
...
ContactResolver cResolver = getContentResolver();
var cValues = new ContactValues();

// Здесь устанавливается название и тип контакта
cValues.put(ContactsContract.RawContacts.ACCOUNT_NAME, value);
cValues.put(ContactsContract.RawContacts.ACCOUNT_TYPE, value);

Uri newUri = cResolver.insert(ContactsContract.RawContacts.CONTENT_URI, cValues);

cValues.clear();
cValues.put(ContactsContract.Data.RAW_CONTACT_ID, ContentUris.parseId(newUri));
cValues.put(ContactsContract.Data.MIMETYPE,
  ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE);
cValues.put(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME, value);

cResolver.insert(ContactsContract.Data.CONTENT_URI, cValues);

С помощью кастомных провайдеров контента можно делать публичные API, для доступа из
сторонних приложений к данным своего приложения. По сути все провайдеры - это
высокоуровневые обертки для работы с БД, по принципу CRUD.

Все провайдеры, как встроенные, так и кастомные имеют всегда одинаковый интерфейс. 
Для создания своего провайдера нужно проделать правильную последовательность, класс
провайдера должен реализовывать определенный интерфейс и т.д.

Чтобы зарегистрировать кастомный провайдер, нужно в файле манифеста довавить:
...
<provider 
  android:authorities="com.example.myprovider"  -->  Название провайдера
  android:name="com.example.myapp.AppProvider"  -->  Название класса провайдера
  android:exported="false"                           с учетом его пакета
/>

Чтобы провайдер мог работать асинхронно, активити/фрагмент в котором он используется
должен реализовывать интерфейс LoaderManager.LoaderCallbacks<Cursor>. 
(но возможно это не точное определение...)

--------------------------------------

РАЗНОЕ

Важно помнить, что Gradle должен поддерживать выбранную версию JDK, иначе будут ошибки
типа: "Unsupported class file major version".

Чтобы программно сгенерировать id для элемента, можно воспользоваться методом
generateViewId из класса View.

Чтобы вывести сообщение на консоль в Logcat используется метод Log.d. В этот метод
передается специальный тег, который позволяет удобно отслеживать сообщения среди других.

С помощью класса LayoutInflater можно создавать объекты View на основе файлов с 
xml-разметкой.

Если некоторая разметка доступна только для одного режима отображения, например для
портретного, тогда её xml-файлы могут находится в отдельной папке layout-port.

Локальный URI в андроиде начинается с префикса "android.resource://", после чего
указывается название пакета и название файла.

Для работы с файлами, в классе Context определены базовые методы: openFileInput,
openFileOutput, getDir и т.д. Все файлы, которые создаются и редактируются приложением,
хранятся в каталоге /data/data/название_пакета/files (на девайсе). По умолчанию такие
файлы доступны только самому приложению. Однако файлы можно также записывать/считывать
из внешнего (общего) хранилища: storage/self/primary/Android/data/название_пакета/files.

В андроиде имеется встроенная поддержка SQLite. При работе с БД попадаются классы с
названием Cursor. Синонимом этого названия могло бы быть слово Query, т.к. они хранят
результат SQL-запроса. Имя идентификат. должно начинаться с нижнего подчеркивания: _id.

Если в SQL-выборке присутствует зна "?", то это означает что вместо него будет
подставлено какое-то значение.

При работе с различного рода файлами, будь то: БД, SharedPreferences, чтение/запись
произвольных файлов и т.д. может использоваться константа MODE_PRIVATE. Она определяет
приватный режим доступа. Такие файлы/данные не будут доступны в других активити, либо
не будут доступны для внешнего хранилища.

Чтобы реализовать в приложении систему перелистывания страниц, можно использовать
элемент ViewPager2. Для создания эффекта страниц он использует фрагменты. Чтобы
добавить страницам вкладки, применяется элемент TabLayout и класс TabLayoutMediator,
связывающий TabLayout с ViewPager2.

Tween-анимация - это анимация различных свойств объекта, при которой система сама
расчитывает промежуточные значения с помощью интерполяции. Свойства анимации задаются 
в xml-файле, из папки anim. Это может быть: перемещение, вращение, затухание и т.д.

Для работы с JSON можно использовать библиотеку Gson.

Для работы с XML используется класс XMLPullParser. Он помогает парсить файл поэтапно.
Когда парсер обнаруживает тег, то генерирует одно из событий: START_TAG, TEXT, END_TAG
или END_DOCUMENT. Для перехода к следующему тегу используется метод next. 
Обычно, весь этот процесс выполняется через цикл.

