БАЗОВЫЙ SVELTE

Компонент в Svelte - это переиспользуемый блок кода, который инкапсулируют в себе HTML, 
CSS и JavaScript в одном .svelte файле.

----------

Файл MyComponent.svelte

 <script>
   let name = 'Svelte'
 </script>

 <h1>Hello {name}</h1>

 <style>
   p { color: green; }
 </style>

Файл App.svelte

 <script>
   import MyComponent from './MyComponent.svelte';
 </script>

 <p>This is a paragraph.</p>
 <MyComponent />

----------

В фигурных скобках может располагаться любой JS-код: 
 
 <h1>Hello {name.toUpperCase()}</h1>

Фигурные скобки можно также использовать и внутри атрибутов:

 <img src={src} alt="{name} dances" />

Если имя переменной соответсвует названию атрибута, то можно использовать 
сокращенный синтаксис:

 <img {src} alt="{name} dances" />

Svelte требует, чтобы HTML-разметка компонентов соответствовала стандарту a11y. 
Поэтому отсуствие на некоторых элементах атрибутов типа aria, alt и т.п. 
будет приводит к предупреждениям.

Стили компонента по умолчанию являются локальными (т.е. scoped)
Названия компонентов должны быть в PascalCase чтобы отличать их от HTML-элементов.

Чтобы вывести строку в чистом виде, без экранирования спецсимволом, 
нужно использовать специальный тег @html

 <p>{@html myStr}</p>

Чтобы объявить реактивную переменную (состояние) нужно использовать руну $state. 
Реактивная переменная отличается от обычной тем, что ее изменение приводит к изменению DOM.

 <script>
	let count = $state(0);
	const increment = () => count++;
 </script>

 <button onclick={increment}>Count: {count}</button>

Реактивность в Svelte является глубокой. Это означает, что изменение элементов массива 
или свойств объекта (т.е. мутации), также приведет к изменению DOM.

Если требуется сделать состояние, которое зависит от другого состояния, 
нужно использовать руну $derived (напоминает computed из Vue): 

 let numbers = $state([1, 2, 3, 4]);

 // Если изменится numbers, то изменится и total
 let total = $derived(numbers.reduce((t, n) => t + n, 0));

Чтобы вывести на консоль реактивное состояние, нужно перевести его в нереактивный снимок 
или использовать руну $inspect. Иначе будет предупреждение.

 console.log($state.snapshot(numbers)); 

 // Один раз вызываем и все последующие измениния в numbers 
 // будут автоматически выводиться в консоль
 $inpect(numbers);  

Если требуется отлеживать изменение реактивного состояния, то нужно использовать руну
$effect (напоминает watch из Vue). Если передаваемый колбек возвращает замыкание, то оно
вызовется при уничножении компонента. Если эффект используется в компоненте без реактивных
состояний, то его колбек вызовется только один раз, при монтировании. 

 let elapsed = $state(0);
 let interval = $state(1000); 

 $effect(() => {
   // Изменение любого из реактивных состояний приведет к вызову колбека
   // Эффекты не запускаются при server-side рендеринге.
 });

Чтобы сделать реактивное состояние общим для нескольких компонентов, его можно вынести в
отдельный файл. Но обычные js-файлы не могут использовать руны. Поэтому такие файлы должны
называться как .svelte.js

----------

Файл shared.svelte.js

 export const counter = $state({ count: 0 });

----------

Чтобы определить пропсы, нужно использовать руну $props
 
 let { age, desc = 'A student' } = $props();
 <User age={19} />  -->  age=19, desc="A student"

Для установки или получения пропсов можно использовать оператор spread

 const info = { age: 23, desc: 'hello' };
 <User {...info} />

 let { age, ...rest } = $props();

Условие if/else внутри HTML-разметки объявляется так:

 {#if count > 10}
   <p>{count} is greater than 10</p>
 {:else if count < 5}
   <p>{count} is less than 5</p>
 {:else}
   <p>{count} is between 5 and 10</p>
 {/if}

Цикл each объявляется так: (idx необязателен)

 {#each colors as color, idx}
   <button aria-label={color}>{idx + 1}</button>
 {/each}

Но для правильной переотрисовки элементов нужно использовать keyed each.
В качестве ключа лучше использовать строку или число.

 {#each things as thing (thing.id)}
   <Thing name={thing.name}/>
 {/each}

Svelte позволяет удобно обрабатывать промисы прямо в HTML-разметке (если нужно просто
дождаться результата, то блоки :then и :catch можно не использовать):

 {#await promise}
   <p>...rolling</p>
 {:then number}
   <p>you rolled a {number}!</p>
 {:catch error}
   <p style="color: red">{error.message}</p>
 {/await}

Чтобы назначить обработчик события используется атрибут on<eventname> (как в обычном JS)

 <div onpointermove={onpointermove}>
   The pointer is at {myState.x} x {myState.y}
 </div>

Или сокращенно (если название обработчика соответсвует названию атрибута):

 <div {onpointermove}>
   The pointer is at {myState.x} - {myState.y}
 </div>

Обработчик события можно определить инлайн:

 <div 
   onpointermove={(event) => {
     myState.x = event.clientX;
     myState.y = event.clientY;
   }}
 >
   The pointer is at {myState.x} - {myState.y}
 </div>

Чтобы событие перехватывалось на фазе погружения, а не всплытия, нужно дописать 
к его названию слово "capture"

 <input onkeydowncapture={(e) => alert(`<input> ${e.key}`)} />

Для компонентов события задаются как обычные пропсы.

Двухсторонняя привязка (two-way binding) реализуется через директиву bind:
В примере ниже, изменение name обновит value, и наоборот, изменение value обновит name.

 let name = $state('hello');
 <input bind:value={name}>

В input[type=number|range], value будет автоматически преобразовываться в число. 
(по умолчанию value в input всегда строка, даже для [type=number|range])

 let num = $state(1);
 <input type="number" value={num}>

Для чекбоксов, используется привязка к свойству checked, а не value:

 <input type="checkbox" bind:checked={yes}>

Для привязки группы чекбоксов или радиокнопок используется bind:value вместе bind:group
В случае с чекбоксами, в bind:group передается массив (поскольку выбранных чекбоксов может
быть несколько), а в bind:group для радиокнопок - обычно число или строка.

 <input type="checkbox" name="flavours" value={flavour} bind:group={flavours}>
 <input type="checkbox" name="flavours" value={flavour} bind:group={flavours}>

Двухсторонняя привязка для списка реализуется так:

 <select bind:value={flavour}>...</select>
 <select multiple bind:value={flavours}>...</select>

В случаях, когда название стейта совпадает с названием атрибута привязки, 
можно также использовать сокращенный синтаксис.

 <textarea bind:value></textarea>  -->  <textarea bind:value={value}></textarea>

Способы задать классы для HTML-элемента:

 // Через js-выражение
 <div class="card {flipped ? 'flipped' : ''}"></div>

 // Через объектный литерал
 <div class={{ cool, lame: !cool }}></div>

 // Через массив
 <div class={[ "card", { flipped }, large && 'scale-200']}></div>

 // Через директиву class:
 <div class:cool={cool} class:lame={!cool}></div>  
 <div class:cool class:lame={!cool}></div>  (сокращенный вариает)

Способы задать стили для HTML-элемента:

 // Через js-выражение
 <div style="color: { isBlue ? 'blue' : 'red' }; font-size: 1rem"></div>

 // Через директиву style:
 <div style:color={ isBlue ? 'blue' : 'red' } style:--bg-color="white"></div>

Если требуется переопределить стили дочернего компонента из родительского, то можно
использовать CSS-модификатор :global. Но такой подходт не рекомендуется использовать часто,
т.к. он нарушает инкапсуляцию стилей. Вместо этого, в дочерний компонент лучше передать 
CSS-переменную, либо обернуть дочерний компонент в тег svelte-css-wrapper

 // Теперь --color будет доступен в CSS у ChildComponent
 <ChildComponent --color="green" />

 // display: contents; не даст затронуть стили родительского компонента
 <svelte-css-wrapper style="display: contents; --color: red;">
   <ChildComponent />
 </svelte-css-wrapper>

Чтобы задать хуки жизненного цикла для HTML-элементов, используются экшены (директивы из Vue).
С их помощью можно удобно реализовать пользовательские события и низкоуровневую логику для
элементов. Чтобы установить экшен на элементе, нужно использовать директиву use:

----------

Файл actions.svelte.js

 export function trapFocus(node) {
   // Какая-то логика фокуса для node (в данном случае c <div class="menu">)

   $effect(() => {
     // Эффект сработает, когда node будет смонтирован в DOM

     return () => {
       // Замыкание сработает, когда node будет размонтирован из DOM
     };
   })
 };
 
Файл App.svelte

 <script>
   import { trapFocus } from './actions.svelte.js'
 </script>

 <div class="menu" use:trapFocus></div>

----------

Экшены могут принимать параметры, но они должны быть в виде ф-ций, иначе эффект 
не сможет отлеживать их реактивность.

 export function trapFocus(node, fn) { }

 // Если передать просто myState, то $effect не будет реагировать на его изменение 
 <div class="menu" use:trapFocus={() => myState}></div>

Для работы с анимационными переходами используется директива transition: в которую передается
одна из transition-функций. Transition-функции, на основе своих внутренних данных, 
генерируют CSS-анимацию (0% {opacity: 0} 40% {opacity: 0.2} 100 {opacity: 1})

 import { fade } from 'svelte/transition';
 <p transition:fade>Hello World</p>

Transition-функция может также принимать параметры:

 import { fly } from 'svelte/transition';
 <p transition:fly={{ y: 200, duration: 2000 }}>Hello World</p>

Вместо transition: можно использовать директивы in: и out:

 <p in:fly={{ y: 200, duration: 2000 }} out:fade>Hello World</p>

Кроме встроенных transition-функций есть возможность создавать и пользовательские. 
Они должны принимать 2 пар-ра - node и opts, и возвращают transition-объект 
со следующими свойствами:

 delay - миллисекунды перед началом анимации;
 duration - длина анимации в миллисекундах;
 easing - ф-ция смягчения анимации;
 css - ф-ция для изменения CSS-свойств;
 tick - ф-ция для изменения свойств node (textContent и пр.).

----------

 <script>
   import { elasticOut } from 'svelte/easing';

   const spin = (node, { duration }) => {
     return {
       duration,
       css: (t, u) => {                  // t изменяется от 0 до 1, а u = 1 - t 
	     const eased = elasticOut(t);
	     return `
		   transform: scale(${eased}) rotate(${eased * 1080}deg);
		   color: hsl(
		     ${Math.trunc(t * 360)},
		     ${Math.min(100, 1000 * u)}%,
		     ${Math.min(50, 500 * u)}%
		   );
         `;
       }
     };
   };
 </script>

 <div transition:spin></div>

----------

Можно отслеживать этапы анимации, подписавшись на анимационные события:

 <MyComponent
	transition:fly={{ y: 200, duration: 2000 }}
	onintrostart={() => status = 'intro started'}
	onoutrostart={() => status = 'outro started'}
	onintroend={() => status = 'intro ended'}
	onoutroend={() => status = 'outro ended'}
 />

По умолчанию, анимационные переходы выполняются только когда их HTML-элементы добавляются 
в DOM или удаляется из него. Но если элементы отображаются через условие, то переходов 
не будет. Чтобы изменить такое поведение, нужно сделать переходы глобальными.

 // Теперь, при соблюдении условия, переходы будут выполнятся
 {#if showItems}
   <div transition:slide|global></div>
   <div transition:slide|global></div>
 {/if}

Если требуется, чтобы анимация проигрывалась при изменении реактивного состояния, 
то нужно использовать key-блоки.

 {#key myState}
	<p in:typewriter={{ speed: 10 }}></p>
 {/key}

=========================

ПРОДВИНУТЫЙ SVELTE

Если состояние обновляется часто или если не нужно делать его глубоко реактивным, 
то вместо $state можно использовать $state.raw

Реактивными могут быть не только переменные, но и свойства класса. Использование классов
особенно полезно когда нужна валидация данных (например через аксессоры).

 class Box {
   #width = $state(0);
   #height = $state(0);
   area = $derived(this.#width * this.#height);
   uid = 10432675; 

   constructor(width, height) {
	 this.#width = width;
     this.#height = height;
   }

   get width() { return this.#width; }
   set width(value) {
     this.#width = Math.max(0, Math.min(MAX_SIZE, value));
   }
 }

Svelte имеет встроенные реактивные классы: Map, Set, Date, URL и URLSearchParams. 

 import { SvelteDate } from 'svelte/reactivity';
 let date = new SvelteDate();

До появления рун, общие состояния для нескольких компонентом создавались через сторы. 
Хотя в Svelte 5 это больше не основной способ, сторы по прежнему можно встретить.
Стор напоминает объект Observable из RxJS. (тоже есть метод subscribe и т.п.)

----------

Файл shared.js

 import { writable } from 'svelte/store';

 // Значение writable-стора можно менять
 export const count = writable(0); 

Файл Counter.svelte

 <script>
   import { count } from './shared.js';

   const click = () => {
	 count.update((n) => n + 1);

	 // Или так: (get импортируется из 'svelte/store')
     // const value = get(count);
     // count.set(value + 1)	
   };
 </script>

 // Для обращения к значению стора в шаблоне, используется префикс $
 <button onclick={click}>clicks: {$count}</button>
 <button onclick={() => $count++}>clicks: {$count}</button>

----------

Сниппеты позволяют переиспользовать HTML-шаблоны внутри компонента. Все, что находится 
внутри снипета, не участвует в рендеринге. Чтобы отрендерить снипет, нужно 
использовать специальный тег @render

 // Снипет может принимать сколь угодно параметров
 {#snippet monkey(emoji, descr)}
   <tr>
	 <td>{emoji}</td>
	 <td>{description}</td>
   </tr>
 {/snippet} 

 <table>
   <thead>
     <tr>
	   <th>emoji</th>
	   <th>description</th>
	 <tr>
   </thead>
   <tbody>
     {@render monkey('smile', 'see no evil')}
   </tbody>
 </table>

Сниппеты можно передавать дочерним компонентам через пропсы:

----------

Файл App.svelte

 {#snippet header()} ... {/snippet} 
 {#snippet row(d)} ... {/snippet} 

 <FilteredList data={colors} {header} {row} />

Файл FilteredList.svelte

 <script>
   let { data, header, row } = $props();
 </script>

 <div class="header">
	{@render header()}
 </div>

 <div class="content">
   {#each data as item}
	 {@render row(item)}
   {/each}
 </div>

----------

Снипеты, объявленные внутри компонента, автоматически становятся его пропсами:

 <FilteredList data={colors}>
   {#snippet header()} ... {/snippet} 
   {#snippet row(d)} ... {/snippet} 
 </FilteredList>

Кроме этого, любой HTML внутри тега также превращается в специальный снипет children.

 <FilteredList data={colors}>
   <header> ... </header>
   {#snippet row(d)} ... {/snippet} 
 </FilteredList>

 ...

 let { data, children, row } = $props();
 <div class="header">
	{@render children()}  // <header></header>
 </div>

Tweened values...

