БАЗОВЫЙ SVELTE

Компонент в Svelte - это переиспользуемый блок кода, который инкапсулируют в себе HTML, 
CSS и JavaScript в одном .svelte файле.

-------------

Файл MyComponent.svelte

 <script>
   let name = 'Svelte'
 </script>

 <h1>Hello {name}</h1>

 <style>
   p { color: green; }
 </style>

-------------

Файл App.svelte

 <script>
   import MyComponent from './MyComponent.svelte';
 </script>

 <p>This is a paragraph.</p>
 <MyComponent />

-------------

В фигурных скобках может располагаться любой JS-код: 
 
 <h1>Hello {name.toUpperCase()}</h1>

Фигурные скобки можно также использовать и внутри атрибутов:

 <img src={src} alt="{name} dances" />

Если имя переменной соответсвует названию атрибута, то можно использовать 
сокращенный синтаксис:

 <img {src} alt="{name} dances" />

Svelte требует, чтобы HTML-разметка компонентов соответствовала стандарту a11y. 
Поэтому отсуствие на некоторых элементах атрибутов типа aria, alt и т.п. 
будет приводит к предупреждениям.

Стили компонента по умолчанию являются локальными (т.е. scoped)
Названия компонентов должны быть в PascalCase чтобы отличать их от HTML-элементов.

Чтобы вывести строку в чистом виде, без экранирования спецсимволом, 
нужно использовать специальный тег @html

 <p>{@html myStr}</p>

Чтобы объявить реактивную переменную (состояние) нужно использовать руну $state. 
Реактивная переменная отличается от обычной тем, что ее изменение приводит к изменению DOM.

 <script>
	let count = $state(0);
	const increment = () => count++;
 </script>

 <button onclick={increment}>Count: {count}</button>

Реактивность в Svelte является глубокой. Это означает, что изменение элементов массива 
или свойств объекта (т.е. мутации), также приведет к изменению DOM.

Если требуется сделать состояние, которое зависит от другого состояния, 
нужно использовать руну $derived (напоминает computed из Vue): 

 let numbers = $state([1, 2, 3, 4]);

 // Если изменится numbers, то изменится и total
 let total = $derived(numbers.reduce((t, n) => t + n, 0));

Чтобы вывести на консоль реактивное состояние, нужно перевести его в нереактивный снимок 
или использовать руну $inspect. Иначе будет предупреждение.

 console.log($state.snapshot(numbers)); 

 // Один раз вызываем и все последующие измениния в numbers 
 // будут автоматически выводиться в консоль
 $inpect(numbers);  

Если требуется отлеживать изменение реактивного состояния, то нужно использовать руну
$effect, в которую передается колбек. Если колбек возвращает замыкание, то оно вызовется при
уничножении компонента. Если эффект используется в компоненте без реактивных состояний, 
то его колбек вызовется только один раз, при монтировании. 

 let elapsed = $state(0);
 let interval = $state(1000); 

 $effect(() => {
   // Изменение любого из реактивных состояний приведет к вызову колбека
   // Эффекты не запускаются при server-side рендеринге.
 });

Чтобы сделать реактивное состояние общим для нескольких компонентов, его можно вынести в
отдельный файл. Но обычные js-файлы не могут использовать руны. Поэтому такие файлы должны
называться как .svelte.js

-------------

Файл shared.svelte.js

 export const counter = $state({ count: 0 });

-------------

Чтобы определить пропсы, нужно использовать руну $props
 
 let { age, desc = 'A student' } = $props();
 <User age={19} />  -->  age=19, desc="A student"

Для установки или получения пропсов можно использовать оператор spread

 const info = { age: 23, desc: 'hello' };
 <User {...info} />

 let { age, ...rest } = $props();

Условие if/else внутри HTML-разметки объявляется так:

 {#if count > 10}
   <p>{count} is greater than 10</p>
 {:else if count < 5}
   <p>{count} is less than 5</p>
 {:else}
   <p>{count} is between 5 and 10</p>
 {/if}

Цикл each объявляется так (idx необязателен):

 {#each colors as color, idx}
   <button aria-label={color}>{idx + 1}</button>
 {/each}

Но для правильной переотрисовки элементов нужно использовать keyed each.
В качестве ключа лучше использовать строку или число.

 {#each things as thing (thing.id)}
   <Thing name={thing.name}/>
 {/each}

Svelte позволяет удобно обрабатывать промисы прямо в HTML-разметке (если нужно просто
дождаться результата, то блоки :then и :catch можно не использовать):

 {#await promise}
   <p>...rolling</p>
 {:then number}
   <p>you rolled a {number}!</p>
 {:catch error}
   <p style="color: red">{error.message}</p>
 {/await}

Чтобы назначить обработчик события используется атрибут on<event> (как в обычном JS)

 <div onpointermove={onpointermove}>
   The pointer is at {myState.x} x {myState.y}
 </div>

Или сокращенно (если название обработчика соответсвует названию атрибута):

 <div {onpointermove}>
   The pointer is at {myState.x} - {myState.y}
 </div>

Обработчик события можно определить инлайн:

 <div 
   onpointermove={(event) => {
     myState.x = event.clientX;
     myState.y = event.clientY;
   }}
 >
   The pointer is at {myState.x} - {myState.y}
 </div>

Чтобы событие перехватывалось на фазе погружения, а не всплытия, нужно дописать 
к его названию слово "capture"

 <input onkeydowncapture={(e) => alert(`<input> ${e.key}`)} />

Для компонентов события задаются как обычные пропсы.

Bindings...

