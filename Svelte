БАЗОВЫЙ SVELTE

Svelte - это компонентный фреймворк, предназначенный для реализации только UI приложения.
Компонент в Svelte - это переиспользуемый блок кода, который инкапсулируют HTML, 
CSS и JavaScript в одном .svelte файле.

	Файл MyComponent.svelte

	 <script>
	   let name = 'Svelte'
	 </script>

	 <h1>Hello {name}</h1>

	 <style>
	   p { color: green; }
	 </style>

	Файл App.svelte

	 <script>
	   import MyComponent from './MyComponent.svelte';
	 </script>

	 <p>This is a paragraph.</p>
	 <MyComponent />

В фигурных скобках может располагаться любой JS-код: 
 
	 <h1>Hello {name.toUpperCase()}</h1>

Фигурные скобки можно также использовать и внутри атрибутов:

	 <img src={src} alt="{name} dances" />

Если имя переменной соответсвует названию атрибута, то можно использовать 
сокращенный синтаксис:

	 <img {src} alt="{name} dances" />

Svelte требует, чтобы HTML-разметка компонентов соответствовала стандарту a11y. 
Поэтому отсуствие на некоторых элементах атрибутов типа aria, alt и т.п. 
будет приводит к предупреждениям.

Стили компонента по умолчанию являются локальными (т.е. scoped)
Названия компонентов должны быть в PascalCase чтобы отличать их от HTML-тегов.
Код в теге <script> выполняется при инициализации каждого экземпляра компонента.

Чтобы вывести строку в чистом виде, без экранирования спецсимволом, 
нужно использовать специальный тег @html

	 <p>{@html myStr}</p>

Чтобы объявить реактивную переменную (состояние) нужно использовать руну $state. 
Реактивная переменная отличается от обычной тем, что ее изменение приводит к изменению DOM.
(для типизации переменных можно использовать обычный JS-doc)

	 <script>
		let count = $state(0);
		const increment = () => count++;
	 </script>

	 <button onclick={increment}>Count: {count}</button>

Реактивность в Svelte является глубокой. Это означает, что изменение элементов массива 
или свойств объекта (т.е. мутации), также приведет к изменению DOM.

Если требуется сделать состояние, которое зависит от другого состояния, 
нужно использовать руну $derived (как computed из Vue): 

	 let numbers = $state([1, 2, 3, 4]);

	 // Если изменится numbers, то изменится и total
	 let total = $derived(numbers.reduce((t, n) => t + n, 0));

Чтобы вывести на консоль реактивное состояние, нужно перевести его в нереактивный снимок 
или использовать руну $inspect. Иначе будет предупреждение.

	 console.log($state.snapshot(numbers)); 

	 // Один раз вызываем и все последующие измениния в numbers 
	 // будут автоматически выводиться в консоль
	 $inpect(numbers);  

Если требуется отлеживать изменение реактивного состояния, то нужно использовать руну
$effect (как watch из Vue). Если передаваемый колбек возвращает замыкание, то оно вызовется
при уничножении компонента. Если эффект используется в компоненте без реактивных состояний,
то его колбек вызовется только один раз, при монтировании. 

	 let elapsed = $state(0);
	 let interval = $state(1000); 

	 $effect(() => {
	   // Изменение любого из реактивных состояний приведет к вызову колбека
	   // Эффекты не запускаются при server-side рендеринге.
	 });

Чтобы сделать реактивное состояние общим для нескольких компонентов, его можно вынести в
отдельный файл. Но обычные js-файлы не могут использовать руны. Поэтому такие файлы 
должны называться как .svelte.js

	Файл shared.svelte.js

	 export const counter = $state({ count: 0 });

Чтобы определить пропсы, нужно использовать руну $props
 
	 let { age, desc = 'A student' } = $props();
	 <User age={19} />  -->  age=19, desc="A student"

Для установки или получения пропсов можно использовать оператор spread

	 const info = { age: 23, desc: 'hello' };
	 <User {...info} />

	 let { age, ...rest } = $props();

Условие if/else внутри HTML-разметки объявляется так:

	 {#if count > 10}
	   <p>{count} is greater than 10</p>
	 {:else if count < 5}
	   <p>{count} is less than 5</p>
	 {:else}
	   <p>{count} is between 5 and 10</p>
	 {/if}

Цикл each объявляется так: (idx необязателен)

	 {#each colors as color, idx}
	   <button aria-label={color}>{idx + 1}</button>
	 {/each}

Но для правильной переотрисовки элементов нужно использовать keyed each.
В качестве ключа лучше использовать строку или число.

	 {#each things as thing (thing.id)}
	   <Thing name={thing.name}/>
	 {/each}

Svelte позволяет удобно обрабатывать промисы прямо в HTML-разметке (если нужно просто
дождаться результата, то блоки :then и :catch можно не использовать):

	 {#await promise}
	   <p>...rolling</p>
	 {:then number}
	   <p>you rolled a {number}!</p>
	 {:catch error}
	   <p style="color: red">{error.message}</p>
	 {/await}

Чтобы назначить обработчик события используется атрибут on<eventname> (как в обычном JS)

	 <div onpointermove={onpointermove}>
	   The pointer is at {myState.x} x {myState.y}
	 </div>

Или сокращенно (если название обработчика соответсвует названию атрибута):

	 <div {onpointermove}>
	   The pointer is at {myState.x} - {myState.y}
	 </div>

Обработчик события можно определить инлайн:

	 <div 
	   onpointermove={(event) => {
		 myState.x = event.clientX;
		 myState.y = event.clientY;
	   }}
	 >
	   The pointer is at {myState.x} - {myState.y}
	 </div>

Чтобы событие перехватывалось на фазе погружения, а не всплытия, нужно дописать 
к его названию слово "capture"

	 <input onkeydowncapture={(e) => alert(`<input> ${e.key}`)} />

Для компонентов события задаются как обычные пропсы.

Двухсторонняя привязка (two-way binding) реализуется через директиву bind:
В примере ниже, изменение name обновит value, и наоборот, изменение value обновит name.

	 let name = $state('hello');
	 <input bind:value={name}>

В input[type=number|range], value будет автоматически преобразовываться в число. 
(по умолчанию value в input всегда строка, даже для [type=number|range])

	 let num = $state(1);
	 <input type="number" value={num}>

Для чекбоксов, используется привязка к свойству checked, а не value:

	 <input type="checkbox" bind:checked={yes}>

Для привязки группы чекбоксов или радиокнопок используется bind:value вместе bind:group
В случае с чекбоксами, в bind:group передается массив (поскольку выбранных чекбоксов может
быть несколько), а в bind:group для радиокнопок - обычно число или строка.

	 <input type="checkbox" name="flavours" value={flavour} bind:group={flavours}>
	 <input type="checkbox" name="flavours" value={flavour} bind:group={flavours}>

Двухсторонняя привязка для списка реализуется так:

	 <select bind:value={flavour}>...</select>
	 <select multiple bind:value={flavours}>...</select>

В случаях, когда название стейта совпадает с названием атрибута привязки, 
можно также использовать сокращенный синтаксис.

	 <textarea bind:value></textarea>  -->  <textarea bind:value={value}></textarea>

Способы задать классы для элемента:

	 // Через js-выражение
	 <div class="card {flipped ? 'flipped' : ''}"></div>

	 // Через объектный литерал
	 <div class={{ cool, lame: !cool }}></div>

	 // Через массив
	 <div class={[ "card", { flipped }, large && 'scale-200']}></div>

	 // Через директиву class:
	 <div class:cool={cool} class:lame={!cool}></div>  
	 <div class:cool class:lame={!cool}></div>  (сокращенный вариает)

Способы задать стили для элемента:

 // Через js-выражение
 <div style="color: { isBlue ? 'blue' : 'red' }; font-size: 1rem"></div>

 // Через директиву style:
 <div style:color={ isBlue ? 'blue' : 'red' } style:--bg-color="white"></div>

Если требуется переопределить стили дочернего компонента из родительского, то можно
использовать CSS-модификатор :global. Но такой подходт не рекомендуется использовать часто,
т.к. он нарушает инкапсуляцию стилей. Вместо этого, в дочерний компонент лучше передать 
CSS-переменную, либо обернуть дочерний компонент в тег svelte-css-wrapper

	 // Теперь --color будет доступен в CSS у ChildComponent
	 <ChildComponent --color="green" />

	 // display: contents; не даст затронуть стили родительского компонента
	 <svelte-css-wrapper style="display: contents; --color: red;">
	   <ChildComponent />
	 </svelte-css-wrapper>

Чтобы задать хуки жизненного цикла для DOM-элементов, используются экшены (директивы из Vue).
С их помощью можно удобно реализовать пользовательские события и низкоуровневую логику для
элементов. Чтобы установить экшен на элементе, нужно использовать директиву use:

	Файл actions.svelte.js

	 export function trapFocus(node) {
	   // Какая-то логика фокуса для node (в данном случае c <div class="menu">)

	   $effect(() => {
		 // Эффект сработает, когда node будет смонтирован в DOM

		 return () => {
		   // Замыкание сработает, когда node будет размонтирован из DOM
		 };
	   })
	 };
	 
	Файл App.svelte

	 <script>
	   import { trapFocus } from './actions.svelte.js'
	 </script>

	 <div class="menu" use:trapFocus></div>

Экшены могут принимать параметры, но они должны быть в виде ф-ций, иначе эффект 
не сможет отлеживать их реактивность.

	 export function trapFocus(node, fn) { }

	 // Если передать просто myState, то $effect не будет реагировать на его изменение 
	 <div class="menu" use:trapFocus={() => myState}></div>

Для работы с анимационными переходами используется директива transition: в которую передается
одна из transition-функций. Transition-функции, на основе своих внутренних данных, 
генерируют CSS-анимацию (0% {opacity: 0} 40% {opacity: 0.2} 100 {opacity: 1})

	 import { fade } from 'svelte/transition';
	 <p transition:fade>Hello World</p>

Transition-функция может также принимать параметры:

	 import { fly } from 'svelte/transition';
	 <p transition:fly={{ y: 200, duration: 2000 }}>Hello World</p>

Вместо transition: можно использовать директивы in: и out:

	 <p in:fly={{ y: 200, duration: 2000 }} out:fade>Hello World</p>

Кроме встроенных transition-функций есть возможность создавать и пользовательские. 
Они должны принимать 2 пар-ра - node и opts, и возвращают transition-объект 
со следующими свойствами:

 * delay - миллисекунды перед началом анимации;
 * duration - длина анимации в миллисекундах;
 * easing - ф-ция смягчения анимации;
 * css - ф-ция для изменения CSS-свойств;
 * tick - ф-ция для изменения свойств node (textContent и пр.).

	 <script>
	   import { elasticOut } from 'svelte/easing';

	   const spin = (node, { duration }) => {
		 return {
		   duration,
		   css: (t, u) => {                  // t изменяется от 0 до 1, а u = 1 - t 
			 const eased = elasticOut(t);
			 return `
			   transform: scale(${eased}) rotate(${eased * 1080}deg);
			   color: hsl(
				 ${Math.trunc(t * 360)},
				 ${Math.min(100, 1000 * u)}%,
				 ${Math.min(50, 500 * u)}%
			   );
		     `;
		   }
		 };
	   };
	 </script>

	 <div transition:spin></div>

Можно отслеживать этапы анимации, подписавшись на анимационные события:

	 <MyComponent
		transition:fly={{ y: 200, duration: 2000 }}
		onintrostart={() => status = 'intro started'}
		onoutrostart={() => status = 'outro started'}
		onintroend={() => status = 'intro ended'}
		onoutroend={() => status = 'outro ended'}
	 />

По умолчанию, анимационные переходы выполняются только когда их элементы добавляются 
в DOM или удаляется из него. Но если элементы отображаются через условие, то переходов 
не будет. Чтобы изменить такое поведение, нужно сделать переходы глобальными.

	 // Теперь, при соблюдении условия, переходы будут выполнятся
	 {#if showItems}
	   <div transition:slide|global></div>
	   <div transition:slide|global></div>
	 {/if}

Если требуется, чтобы анимация проигрывалась при изменении реактивного состояния, 
то нужно использовать key-блоки.

	 {#key myState}
		<p in:typewriter={{ speed: 10 }}></p>
	 {/key}

-----------------------

ПРОДВИНУТЫЙ SVELTE

Если состояние обновляется часто или если не нужно делать его глубоко реактивным, 
то вместо $state можно использовать $state.raw

Реактивными могут быть не только переменные, но и свойства класса. Использование классов
особенно полезно когда нужна валидация данных (например через аксессоры).

	 class Box {
	   #width = $state(0);
	   #height = $state(0);
	   area = $derived(this.#width * this.#height);
	   uid = 10432675; 

	   constructor(width, height) {
		 this.#width = width;
		 this.#height = height;
	   }

	   get width() { return this.#width; }
	   set width(value) {
		 this.#width = Math.max(0, Math.min(MAX_SIZE, value));
	   }
	 }

Svelte имеет встроенные реактивные классы: Map, Set, Date, URL и URLSearchParams. 

	 import { SvelteDate } from 'svelte/reactivity';
	 let date = new SvelteDate();

До появления рун, общие состояния для нескольких компонентом создавались через сторы. 
Хотя в Svelte 5 это больше не основной способ, сторы по прежнему можно встретить.
Стор напоминает объект Observable из RxJS. (тоже есть метод subscribe и т.п.)

	Файл shared.js

	 import { writable } from 'svelte/store';

	 // Значение writable-стора можно менять
	 export const count = writable(0); 

	Файл Counter.svelte

	 <script>
	   import { count } from './shared.js';

	   const click = () => {
		 count.update((n) => n + 1);

		 // Или так: (get импортируется из 'svelte/store')
		 // const value = get(count);
		 // count.set(value + 1)	
	   };
	 </script>

	 // Для обращения к значению стора в шаблоне, используется префикс $
	 <button onclick={click}>clicks: {$count}</button>
	 <button onclick={() => $count++}>clicks: {$count}</button>

Сниппеты позволяют переиспользовать HTML-шаблоны внутри компонента. Все, что находится 
внутри снипета, не участвует в рендеринге. Чтобы отрендерить снипет, нужно 
использовать специальный тег @render

	 // Снипет может принимать сколь угодно параметров
	 {#snippet monkey(emoji, descr)}
	   <tr>
		 <td>{emoji}</td>
		 <td>{description}</td>
	   </tr>
	 {/snippet} 

	 <table>
	   <thead>
		 <tr>
		   <th>emoji</th>
		   <th>description</th>
		 <tr>
	   </thead>
	   <tbody>
		 {@render monkey('smile', 'see no evil')}
	   </tbody>
	 </table>

Сниппеты можно передавать дочерним компонентам через пропсы:

	Файл App.svelte

	 {#snippet header()} ... {/snippet} 
	 {#snippet row(d)} ... {/snippet} 

	 <FilteredList data={colors} {header} {row} />

	Файл FilteredList.svelte

	 <script>
	   let { data, header, row } = $props();
	 </script>

	 <div class="header">
		{@render header()}
	 </div>

	 <div class="content">
	   {#each data as item}
		 {@render row(item)}
	   {/each}
	 </div>

Снипеты, объявленные внутри компонента, автоматически становятся его пропсами:

	 <FilteredList data={colors}>
	   {#snippet header()} ... {/snippet} 
	   {#snippet row(d)} ... {/snippet} 
	 </FilteredList>

Кроме этого, любой HTML внутри тега превращается в специальный снипет children.

	 <FilteredList data={colors}>
	   <header> ... </header>
	   {#snippet row(d)} ... {/snippet} 
	 </FilteredList>

	 ...

	 let { data, children, row } = $props();
	 <div class="header">
		{@render children()}  // <header></header>
	 </div>

Чтобы реализовать плавное изменение числа (от 0 до 1), можно использовать встроенный класс
Tween. Объект Tween имеет два свойства - current и target. Изменяя target, current будет
плавно нагонять его. Плавность можно задать через easing-функцию. Также можно задать 
задержку и прочие анимационные настройки (передаются в конструктор, как опции).

Еще есть класс Spring, который также позволяет плавно менять значения. Но он может менять 
не только числа, но и объекты (например координаты). Этот класс, помимо current и target,
имеет 2 доп. свойства - stiffness и damping. Они задают жесткость и демфирование анимации.

Элемент с атрибутом contenteditable поддерживает привязку свойств innerHTML и textContent

	 <div bind:innerHTML={myContent} contenteditable></div>

Привязку можно сделать и для свойств у элементов <autio> и <video>

	 <audio {src} bind:currentTime={time} bind:duration bind:paused></audio>
	 <button class="play" onclick={() => paused = !paused}></button>

У любых блочных элементов доступна также привязка свойств: clientWidth, clientHeight,
offsetWidth и offsetHeight. При изменении их значений, Svelte будет обновлять привязанные
состояния, используя ResizeObserver.

	 <div bind:clientWidth={w} bind:clientHeight={h}>
	   <span class="size">{w} x {h}px</span>
	 </div>

Чтобы сделать привязку к DOM-элементу, используется директива bind:this. Но следует помнить,
что привязанная переменная получит значение только после монтирования компонента.

	 <script>
	   import { paint } from './gradient.js';

	   let canvas;

	   $effect(() => {
		 // Здесь можно обратиться к canvas	
	   });
	 </script>

	 <canvas bind:this={canvas} width={32} height={32}></canvas>

Помимо привязки к свойствам DOM-элементов, можно также выполнять привязку к пропсам
компонентов. Для этого нужные пропсы нужно определять с руной $bindable.

	Файл Keypad.svelte

	 let { value = $bindable(''), onsubmit } = $props();

	Файл App.svelte

	 <Keypad bind:value={pin} {onsubmit} />

Чтобы сделать привязку к экземпляру компонента, также используется bind:this. В этом случае
привязанный компонент должен экспортировать часть своего API, чтобы к нему можно было
обращаться из внешнего кода.

	Файл Canvas.svelte

	 let canvas = $state();
	 let context = $state();
	 
	 export const clear () => {
	   context.clearRect(0, 0, canvas.width, canvas.height);
	 };  

	Файл App.svelte

	 <script>
	   let canvas;
	   ...
	 </script>

	 <Canvas bind:this={canvas} />
	 <button onclick={() => canvas.clear()}>Clear</button>

Svelte поддерживает отложенные анимационные переходы. Это достигается за счет использования
функции crossfade, которая возвращает 2 transition-функции receive и send. Первая
используется с директивой in:, а вторая - с out:. Они принимают объект с ключом, который
указывает на новое переходное место. Как только элемент становится неактивен, то он 
плавно переходит на новую позицию. Например из одного списка в другой. 
См. https://svelte.dev/tutorial/svelte/deferred-transitions

В примере, по ссылке выше, анимируются только те элементы, которые непосредсвенно переходят
из списка в список. При этом остальные элементы в списках резко сдвигаются и раздвигаются, 
без анимации. Чтобы они также плавно сдвигались и раздвигались, к ним, помимо 
in:receive и out:send, нужно дополнительно добавить директиву animate.
См. https://svelte.dev/tutorial/svelte/animations

Чтобы пробросить данные из родительского компонента в глубоко вложенные компоненты, 
можно использовать context API. (как provide/inject из Vue).

	Файл Canvas.svelte

	 import { setContext } from 'svelte';

	 let items = new SvelteSet();
	 setContext('canvas', { addItem });   // может пробрасываться всё что угодно, 
                                          // а не только объекты
	 function addItem(fn) {          
	   $effect(() => {
		 items.add(fn);
		 return () => items.delete(fn);
	   });
	 }

	Файл Square.svelte

	 import { getContext } from 'svelte';
	 getContext('canvas').addItem(() => { ... });

	Файл App.svelte

	 <Canvas>
	   {#each Array(12) as _, c}
		 {#each Array(22) as _, r}
		   <Square 
			 x={180 + c * 40 + jitter(r * 2)} 
		     y={180 + r * 40 + jitter(r * 2)}
		     rotate={jitter(r * 0.05)}
		   />
		 {/each}
	   {/each}
	 </Canvas>

Методы setContext() и getContext() должны вызываться при инициализации компонентов. 
В качестве ключей могут задаваться не только строки.

Чтобы задать обработчики событий на объекте window, используется тег <svelte:window>
Также, с пом. этого тега можно задать привязки для свойств window. Привязать можно только
следующие свойства: innerWidth, innerHeight, outerWidth, outerHeight, scrollX, scrollY 
и online - алиас для window.navigator.onLine

	 <svelte:window {onkeydown} />
	 <svelte:window bind:scrollY={y} />

Специальный тег <svelte:document> позволяет прослушивать события объекта document.
Cледует избегать прослушивания событий mouseenter и mouseleave на document, посколько
большинство событий не вызываются на тем. Вместо этого нужно использовать <svelte:body>

	 <svelte:document {onselectionchange} />

Специальный тег <svelte:body> позволяет прослушивать события объекта document.body:

	 <svelte:body
	   onmouseenter={() => hereKitty = true}
	   onmouseleave={() => hereKitty = false}
	 />

Специальный тег <svelte:head> позволяет вставлять в элемент <head> различные метатеги 
<title> и прочее, что необходимо для SEO:

Специальный тег <svelte:element> позволяет задать условный элемент, содержимое которого 
будет рендериться в зависимости от переданного falsy-значения в this (используются 
вместо большого кол-ва {#if} блоков) 

	 <svelte:element this={isActive}>
	   I'm a <code>{selected}</code> element
	 </svelte:element>

Специальный тег <svelte:boundary> позволяет перехватывать ошибки, возникающие в его дочерних
компонентах. Чтобы заменить компонент с багом на пользовательский шаблон, нужно также
определить внутри сниппет с названием failed.

	 <svelte:boundary>      // тегу можно задать слушатель onerror
	   <FlakyComponent />   // компонент выбрасывает ошибку

	   {#snippet failed(error, reset)}
		 <p>Oops! {error.message}</p>
		 <button onclick={reset}>Reset</button>
	   {/snippet}
	 </svelte:boundary>

В компоненте, кроме обычного тега <script>, можно также объявить тег <script module>.
Все, что находится внутри такого модуля, выполняется единожды (как в ES-модулях). 
Из <script module> можно экспортировать доп. функционал компонента.

	Файл AudioPlayer.svelte

	 <script module>
	   let current;    // текущий плеер

	   export const pauseAll = () => {    // Экспорт по умолчанию зарезервирован 
		 current?.pause();                // за самим компонентом
	   };
	 </script>

	 <script>
	   let { src } = $props();

	   const play = (e) => {
		 const audio = e.currentTarget;
		 if (audio !== current) {
		   current?.pause();
		   current = audio;
		 }
	   };
	 </script>
	 
	 <audio {src} onplay={play}></audio>

	Файл App.svelte

	 <script>
	   import AudioPlayer, { pauseAll } from './AudioPlayer.svelte';
	   import { tracks } from './tracks.js';
	 </script>

	 <div class="container">
	   {#each tracks as track}
		 <AudioPlayer {...track} />
	   {/each}

	   <button onclick={pauseAll}>Pause</button>
	 </div>

-----------------------

БАЗОВЫЙ SVELTEKIT

SvelteKit - это метафреймворк, предназначенный для реализации полноценного production
приложения. Он решает такие задачи, как: маршрутизация, SSR, data fetching, service workers,
интеграцию с TS, prerendering, SPA, library packaging, production builds, дейплой и др.

По умолчанию, SvelteKit приложение является server-rendered.
В качестве сборщика используется Vite.

SvelteKit использует маршрутизацию на основе файловой системы. Это означает, что маршруты
определяются через каталоги. Корневой папкой маршрутов является src/routes. 
Страница маршрута задается в файле +page.svelte.

	 src/
	   routes/

		 about/
		   +page.svelte   // соответсвует маршруту "/about"

		 +page.svelte     // соответсвует маршруту "/"
     
Несмотря на то, что приложение рендерится на стороне сервера, переход на страницу и обратно
осуществляется без перезагрузки в браузере.

Макет страницы следует помещать в файл +layout.svelte. Он автоматически применяется к тому
маршруту, в папке которого находится, а также ко всем дочерним маршрутам.

	 about/
	   +page.svelte

	 +layout.svelte   // применится и к +page.svelte, и к about/+page.svelte
	 +page.svelte

Чтобы создать маршрут с динамическим параметром, нужно использовать папку 
с квадратными скобками (что означает маршрут, разделенных символом "x" - [bar]x[baz] ?). 

	 blog/
	   [slug]/            // будет соответствовать любому параметру для /blog
		 +page.svelte     // т.е. "/blog/one", "/blog/hello", "/blog/asdsa" и т.п.

Для загрузки данных с сервера используется функция load, которая определяется в файле
+page.server.js. Чтобы получить данные в компоненте страницы, нужно использовать проп "data".
(проп "data" является не глубоко реактивным)

	Файл src/routes/blog/+page.server.js

	 import { posts } from './data.js';

	 export const load = () => {
	   return {
		 summaries: posts.map((post) => ({
		   slug: post.slug,
		   title: post.title
		 }))
	   };
	 };

	Файл src/routes/blog/+page.svelte

	 <script>
	   let { data } = $props();
	 </script>

	 <h1>blog</h1>

	 <ul>
	   {#each data.summaries as { slug, title }}
		 <li><a href="/blog/{slug}">{title}</a></li>
	   {/each}
	 </ul>

Подобно тому, как +layout.svelte создают общую разметку для всех дочерних маршрутов,
+layout.server.js загружает общие данные для всех дочерних маршрутов, избавляя от
необходимости повторять каждый раз +page.server.js

Чтобы установить заголовки ответа от сервера, используется ф-ция setHeaders()
Но с помощью нее нельзя установить заголовок Set-Cookie.

	 export const = load({ setHeaders }) => {
	   setHeaders({ 'Content-Type': 'text/plain' });
	 };

Для установки/получения куков, используется объект coockies.

	 export const load = ({ cookies }) => {
	   const visited = cookies.get('visited');

	   // Рекомендуется самостоятельно задавать путь при установке куков, 
	   // поскольку браузеры по умолчанию устанавливают куки 
	   // в родительский каталог текущего пути 
	   cookies.set('visited', 'true', { path: '/' });

	   return { visited: visited === 'true' };
	 };

В SvelteKit, все переиспользуемые модули следует хранить в папке src/lib, 
т.к. для доступа к ней есть удобный алиас - $lib.

Для отправки данных на сервер можно использовать обычные HTML-формы. Но чтобы обработать
данные на сервере, нужно в файле +page.server.js объявить объект actions, методы которого
должны соответствовать action-формам на странице (т.е. формам с атрибутом action). 
Если форма задана без экшена, то ее обрабатывает метод default.

	Файл src/routes/+page.svelte

	 <form method="POST" action="?/create">
	   <input type="text" name="a">
	 </form>

	 <form method="POST" action="?/delete">
	   <input type="text" name="b">
	 </form>

	Файл src/routes/+page.server.js

	 export const actions = {
	   create: async ({ cookies, request }) => {
	     ...
	   },

	   delete: async ({ cookies, request }) => {
		 ...
	   },
	 };

Чтобы провалидировать данные на сервере, предлагается просто использовать обычные условия 
и выбрасывать ошибки при некорретных проверках. Но чтобы вернуть клиенту отрицательный ответ,
нужно из actions-метода вернуть результат вызова fail(), куда передается статус код ошибки
и вспомогательные данные (description, error). Если из actions-метода вернуть другое значение
(например строку), то оно будет расцениваться как положительный ответ. 

Чтобы получить такой ответ, нужно использовать проп "form", который получает 
значение только после отправки формы.

	Файл src/lib/server/database.js

	 export const createTodo = (userId, description) => {
	   if (description === '') {
		 throw new Error('todo must have a description');
	   }
	   ...
	 }; 

	Файл src/routes/+page.server.js

	 import { fail } from '@sveltejs/kit';
	 import * as db from '$lib/server/database.js';

	 export const actions = {
	   create: async = ({ coockies, request }) => {
		 const data = await request.formData();
		 try {
		   db.createTodo(cookies.get('userid'), data.get('description'));
		 } catch (error) {
		   return fail(422, {
		     description: data.get('description'),
		     error: error.message
		   });
		 }
	   }
	 };
	 
	Файл src/routes/+page.svelte

	 <script>
	   let { data, form } = $props();
	 </script>

	 {#if form?.error}
	   <p class="error">{form.error}</p>
	 {/if}

	 <form method="POST" action="?/create">
	   <input name="description" value={form?.description ?? ''} required>
	 </form>

Чтобы улучшить интерактивность форм, можно добавить им директиву use:enhance. 
Эта директива позволит формам самостоятельно перерисовываться при получении ответа, 
а также валидироваться, отображать ошибки и пр.

Если use:enhance установить с колбеком, то можно эмулировать дополнительное поведение,
например ожидание, при медленном интернете. Пример можно посмотреть здесь: 
https://svelte.dev/tutorial/kit/customizing-use-enhance

Кроме маршрутных страниц, можно также создавать маршрутные API, которые хранятся в файлах
+server.js. Эти файлы должны экспортировать ф-ции GET, PUT, POST, PATCH, DELETE 
(обработчики запросов) соответсвующие HTTP-методам. 

Обработчики запросов должны возвращать объект Response.

	Файл src/routes/roll/+server.js

	 export function GET() {
	   const number = Math.floor(Math.random() * 6) + 1;

	   // JSON можно вернуть и так: json(number);
	   return new Response(number, {
		 headers: { 'Content-Type': 'application/json' }
	   });
	 }

	Файл src/routes/+page.svelte

	 <script>
	   /** @type {number} */
	   let number = $state();

	   async function roll() {
		 const response = await fetch('/roll');
		 const res = await response.json();
		 console.log(res);
	   }
	 </script>

	 <button onclick={roll}>Roll the dice</button>

Обработчики, требующие маршрутного параметра, могут также размещаться в папках c квадратным
скобками. Например удаления и обновление пунктов todo-списка можно реализовать в файле 
src/routes/todo/[id]/+server.js

	 import * as database from '$lib/server/database.js';

	 export async function PUT({ params, request, cookies }) {
	   const { done } = await request.json();
	   const userid = cookies.get('userid');
	   await database.toggleTodo({ userid, id: params.id, done });

       // Когда не нужно возвращать актуальные данные, 
       // можно возвращать пустой Response со статусом 204

	   return new Response(null, { status: 204 });
	 }

	 export async function DELETE({ params, cookies }) {
	   const userid = cookies.get('userid');
	   await database.deleteTodo({ userid, id: params.id });
	   return new Response(null, { status: 204 });
	 }

SvelteKit имеет специальный модуль state, который предоставляет следующие состояния
приложения: page, navigation и updated. 

Состояние page хранит информацию:
 * url - объект URL текущей страницы;
 * params - параметры текущей страницы;
 * route - объект со свойством id, относящимся к текущему маршруту;
 * status - статус код текущей страницы;
 * error - объект ошибки текущей страницы;
 * data - данные для текущей страницы, объединенные из всех load ф-ций;
 * form - данные, возвращаемые из form action;

Состояние navigation хранит информацию:
 * from и to - объекты со свойствами params, route, url;
 * type - тип навигации (link - клик по ссылке, goto - программная навигация и пр.);

	 <script>
	   import { page, navigating } from '$app/state';
	 </script>	
		 
	 <nav>
	   <a href="/" aria-current={page.url.pathname === '/'}>home</a>
	   <a href="/about" aria-current={page.url.pathname === '/about'}>about</a>
	 </nav>

	 {#if navigating.to}
	   Navigating to {navigating.to.url.pathname}
	 {/if}

Состояние updated сообщает, была ли развернута новая версия приложения на проде.

Errors and redirects...

