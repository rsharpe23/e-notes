БАЗОВЫЙ SVELTE

Компонент в Svelte - это переиспользуемый блок кода, который инкапсулируют HTML, 
CSS и JavaScript в одном .svelte файле.

	Файл MyComponent.svelte

	 <script>
	   let name = 'Svelte'
	 </script>

	 <h1>Hello {name}</h1>

	 <style>
	   p { color: green; }
	 </style>

	Файл App.svelte

	 <script>
	   import MyComponent from './MyComponent.svelte';
	 </script>

	 <p>This is a paragraph.</p>
	 <MyComponent />

В фигурных скобках может располагаться любой JS-код: 
 
	 <h1>Hello {name.toUpperCase()}</h1>

Фигурные скобки можно также использовать и внутри атрибутов:

	 <img src={src} alt="{name} dances" />

Если имя переменной соответсвует названию атрибута, то можно использовать 
сокращенный синтаксис:

	 <img {src} alt="{name} dances" />

Svelte требует, чтобы HTML-разметка компонентов соответствовала стандарту a11y. 
Поэтому отсуствие на некоторых элементах атрибутов типа aria, alt и т.п. 
будет приводит к предупреждениям.

Стили компонента по умолчанию являются локальными (т.е. scoped)
Названия компонентов должны быть в PascalCase чтобы отличать их от HTML-тегов.
Код в теге <script> выполняется при инициализации каждого экземпляра компонента.

Чтобы вывести строку в чистом виде, без экранирования спецсимволом, 
нужно использовать специальный тег @html

	 <p>{@html myStr}</p>

Чтобы объявить реактивную переменную (состояние) нужно использовать руну $state. 
Реактивная переменная отличается от обычной тем, что ее изменение приводит к изменению DOM.

	 <script>
		let count = $state(0);
		const increment = () => count++;
	 </script>

	 <button onclick={increment}>Count: {count}</button>

Реактивность в Svelte является глубокой. Это означает, что изменение элементов массива 
или свойств объекта (т.е. мутации), также приведет к изменению DOM.

Если требуется сделать состояние, которое зависит от другого состояния, 
нужно использовать руну $derived (как computed из Vue): 

	 let numbers = $state([1, 2, 3, 4]);

	 // Если изменится numbers, то изменится и total
	 let total = $derived(numbers.reduce((t, n) => t + n, 0));

Чтобы вывести на консоль реактивное состояние, нужно перевести его в нереактивный снимок 
или использовать руну $inspect. Иначе будет предупреждение.

	 console.log($state.snapshot(numbers)); 

	 // Один раз вызываем и все последующие измениния в numbers 
	 // будут автоматически выводиться в консоль
	 $inpect(numbers);  

Если требуется отлеживать изменение реактивного состояния, то нужно использовать руну
$effect (как watch из Vue). Если передаваемый колбек возвращает замыкание, то оно вызовется
при уничножении компонента. Если эффект используется в компоненте без реактивных состояний,
то его колбек вызовется только один раз, при монтировании. 

	 let elapsed = $state(0);
	 let interval = $state(1000); 

	 $effect(() => {
	   // Изменение любого из реактивных состояний приведет к вызову колбека
	   // Эффекты не запускаются при server-side рендеринге.
	 });

Чтобы сделать реактивное состояние общим для нескольких компонентов, его можно вынести в
отдельный файл. Но обычные js-файлы не могут использовать руны. Поэтому такие файлы 
должны называться как .svelte.js

	Файл shared.svelte.js

	 export const counter = $state({ count: 0 });

Чтобы определить пропсы, нужно использовать руну $props
 
	 let { age, desc = 'A student' } = $props();
	 <User age={19} />  -->  age=19, desc="A student"

Для установки или получения пропсов можно использовать оператор spread

	 const info = { age: 23, desc: 'hello' };
	 <User {...info} />

	 let { age, ...rest } = $props();

Условие if/else внутри HTML-разметки объявляется так:

	 {#if count > 10}
	   <p>{count} is greater than 10</p>
	 {:else if count < 5}
	   <p>{count} is less than 5</p>
	 {:else}
	   <p>{count} is between 5 and 10</p>
	 {/if}

Цикл each объявляется так: (idx необязателен)

	 {#each colors as color, idx}
	   <button aria-label={color}>{idx + 1}</button>
	 {/each}

Но для правильной переотрисовки элементов нужно использовать keyed each.
В качестве ключа лучше использовать строку или число.

	 {#each things as thing (thing.id)}
	   <Thing name={thing.name}/>
	 {/each}

Svelte позволяет удобно обрабатывать промисы прямо в HTML-разметке (если нужно просто
дождаться результата, то блоки :then и :catch можно не использовать):

	 {#await promise}
	   <p>...rolling</p>
	 {:then number}
	   <p>you rolled a {number}!</p>
	 {:catch error}
	   <p style="color: red">{error.message}</p>
	 {/await}

Чтобы назначить обработчик события используется атрибут on<eventname> (как в обычном JS)

	 <div onpointermove={onpointermove}>
	   The pointer is at {myState.x} x {myState.y}
	 </div>

Или сокращенно (если название обработчика соответсвует названию атрибута):

	 <div {onpointermove}>
	   The pointer is at {myState.x} - {myState.y}
	 </div>

Обработчик события можно определить инлайн:

	 <div 
	   onpointermove={(event) => {
		 myState.x = event.clientX;
		 myState.y = event.clientY;
	   }}
	 >
	   The pointer is at {myState.x} - {myState.y}
	 </div>

Чтобы событие перехватывалось на фазе погружения, а не всплытия, нужно дописать 
к его названию слово "capture"

	 <input onkeydowncapture={(e) => alert(`<input> ${e.key}`)} />

Для компонентов события задаются как обычные пропсы.

Двухсторонняя привязка (two-way binding) реализуется через директиву bind:
В примере ниже, изменение name обновит value, и наоборот, изменение value обновит name.

	 let name = $state('hello');
	 <input bind:value={name}>

В input[type=number|range], value будет автоматически преобразовываться в число. 
(по умолчанию value в input всегда строка, даже для [type=number|range])

	 let num = $state(1);
	 <input type="number" value={num}>

Для чекбоксов, используется привязка к свойству checked, а не value:

	 <input type="checkbox" bind:checked={yes}>

Для привязки группы чекбоксов или радиокнопок используется bind:value вместе bind:group
В случае с чекбоксами, в bind:group передается массив (поскольку выбранных чекбоксов может
быть несколько), а в bind:group для радиокнопок - обычно число или строка.

	 <input type="checkbox" name="flavours" value={flavour} bind:group={flavours}>
	 <input type="checkbox" name="flavours" value={flavour} bind:group={flavours}>

Двухсторонняя привязка для списка реализуется так:

	 <select bind:value={flavour}>...</select>
	 <select multiple bind:value={flavours}>...</select>

В случаях, когда название стейта совпадает с названием атрибута привязки, 
можно также использовать сокращенный синтаксис.

	 <textarea bind:value></textarea>  -->  <textarea bind:value={value}></textarea>

Способы задать классы для элемента:

	 // Через js-выражение
	 <div class="card {flipped ? 'flipped' : ''}"></div>

	 // Через объектный литерал
	 <div class={{ cool, lame: !cool }}></div>

	 // Через массив
	 <div class={[ "card", { flipped }, large && 'scale-200']}></div>

	 // Через директиву class:
	 <div class:cool={cool} class:lame={!cool}></div>  
	 <div class:cool class:lame={!cool}></div>  (сокращенный вариает)

Способы задать стили для элемента:

 // Через js-выражение
 <div style="color: { isBlue ? 'blue' : 'red' }; font-size: 1rem"></div>

 // Через директиву style:
 <div style:color={ isBlue ? 'blue' : 'red' } style:--bg-color="white"></div>

Если требуется переопределить стили дочернего компонента из родительского, то можно
использовать CSS-модификатор :global. Но такой подходт не рекомендуется использовать часто,
т.к. он нарушает инкапсуляцию стилей. Вместо этого, в дочерний компонент лучше передать 
CSS-переменную, либо обернуть дочерний компонент в тег svelte-css-wrapper

	 // Теперь --color будет доступен в CSS у ChildComponent
	 <ChildComponent --color="green" />

	 // display: contents; не даст затронуть стили родительского компонента
	 <svelte-css-wrapper style="display: contents; --color: red;">
	   <ChildComponent />
	 </svelte-css-wrapper>

Чтобы задать хуки жизненного цикла для DOM-элементов, используются экшены (директивы из Vue).
С их помощью можно удобно реализовать пользовательские события и низкоуровневую логику для
элементов. Чтобы установить экшен на элементе, нужно использовать директиву use:

	Файл actions.svelte.js

	 export function trapFocus(node) {
	   // Какая-то логика фокуса для node (в данном случае c <div class="menu">)

	   $effect(() => {
		 // Эффект сработает, когда node будет смонтирован в DOM

		 return () => {
		   // Замыкание сработает, когда node будет размонтирован из DOM
		 };
	   })
	 };
	 
	Файл App.svelte

	 <script>
	   import { trapFocus } from './actions.svelte.js'
	 </script>

	 <div class="menu" use:trapFocus></div>

Экшены могут принимать параметры, но они должны быть в виде ф-ций, иначе эффект 
не сможет отлеживать их реактивность.

	 export function trapFocus(node, fn) { }

	 // Если передать просто myState, то $effect не будет реагировать на его изменение 
	 <div class="menu" use:trapFocus={() => myState}></div>

Для работы с анимационными переходами используется директива transition: в которую передается
одна из transition-функций. Transition-функции, на основе своих внутренних данных, 
генерируют CSS-анимацию (0% {opacity: 0} 40% {opacity: 0.2} 100 {opacity: 1})

	 import { fade } from 'svelte/transition';
	 <p transition:fade>Hello World</p>

Transition-функция может также принимать параметры:

	 import { fly } from 'svelte/transition';
	 <p transition:fly={{ y: 200, duration: 2000 }}>Hello World</p>

Вместо transition: можно использовать директивы in: и out:

	 <p in:fly={{ y: 200, duration: 2000 }} out:fade>Hello World</p>

Кроме встроенных transition-функций есть возможность создавать и пользовательские. 
Они должны принимать 2 пар-ра - node и opts, и возвращают transition-объект 
со следующими свойствами:

 * delay - миллисекунды перед началом анимации;
 * duration - длина анимации в миллисекундах;
 * easing - ф-ция смягчения анимации;
 * css - ф-ция для изменения CSS-свойств;
 * tick - ф-ция для изменения свойств node (textContent и пр.).

	 <script>
	   import { elasticOut } from 'svelte/easing';

	   const spin = (node, { duration }) => {
		 return {
		   duration,
		   css: (t, u) => {                  // t изменяется от 0 до 1, а u = 1 - t 
			 const eased = elasticOut(t);
			 return `
			   transform: scale(${eased}) rotate(${eased * 1080}deg);
			   color: hsl(
				 ${Math.trunc(t * 360)},
				 ${Math.min(100, 1000 * u)}%,
				 ${Math.min(50, 500 * u)}%
			   );
		     `;
		   }
		 };
	   };
	 </script>

	 <div transition:spin></div>

Можно отслеживать этапы анимации, подписавшись на анимационные события:

	 <MyComponent
		transition:fly={{ y: 200, duration: 2000 }}
		onintrostart={() => status = 'intro started'}
		onoutrostart={() => status = 'outro started'}
		onintroend={() => status = 'intro ended'}
		onoutroend={() => status = 'outro ended'}
	 />

По умолчанию, анимационные переходы выполняются только когда их элементы добавляются 
в DOM или удаляется из него. Но если элементы отображаются через условие, то переходов 
не будет. Чтобы изменить такое поведение, нужно сделать переходы глобальными.

	 // Теперь, при соблюдении условия, переходы будут выполнятся
	 {#if showItems}
	   <div transition:slide|global></div>
	   <div transition:slide|global></div>
	 {/if}

Если требуется, чтобы анимация проигрывалась при изменении реактивного состояния, 
то нужно использовать key-блоки.

	 {#key myState}
		<p in:typewriter={{ speed: 10 }}></p>
	 {/key}

-----------------------

ПРОДВИНУТЫЙ SVELTE

Если состояние обновляется часто или если не нужно делать его глубоко реактивным, 
то вместо $state можно использовать $state.raw

Реактивными могут быть не только переменные, но и свойства класса. Использование классов
особенно полезно когда нужна валидация данных (например через аксессоры).

	 class Box {
	   #width = $state(0);
	   #height = $state(0);
	   area = $derived(this.#width * this.#height);
	   uid = 10432675; 

	   constructor(width, height) {
		 this.#width = width;
		 this.#height = height;
	   }

	   get width() { return this.#width; }
	   set width(value) {
		 this.#width = Math.max(0, Math.min(MAX_SIZE, value));
	   }
	 }

Svelte имеет встроенные реактивные классы: Map, Set, Date, URL и URLSearchParams. 

	 import { SvelteDate } from 'svelte/reactivity';
	 let date = new SvelteDate();

До появления рун, общие состояния для нескольких компонентом создавались через сторы. 
Хотя в Svelte 5 это больше не основной способ, сторы по прежнему можно встретить.
Стор напоминает объект Observable из RxJS. (тоже есть метод subscribe и т.п.)

	Файл shared.js

	 import { writable } from 'svelte/store';

	 // Значение writable-стора можно менять
	 export const count = writable(0); 

	Файл Counter.svelte

	 <script>
	   import { count } from './shared.js';

	   const click = () => {
		 count.update((n) => n + 1);

		 // Или так: (get импортируется из 'svelte/store')
		 // const value = get(count);
		 // count.set(value + 1)	
	   };
	 </script>

	 // Для обращения к значению стора в шаблоне, используется префикс $
	 <button onclick={click}>clicks: {$count}</button>
	 <button onclick={() => $count++}>clicks: {$count}</button>

Сниппеты позволяют переиспользовать HTML-шаблоны внутри компонента. Все, что находится 
внутри снипета, не участвует в рендеринге. Чтобы отрендерить снипет, нужно 
использовать специальный тег @render

	 // Снипет может принимать сколь угодно параметров
	 {#snippet monkey(emoji, descr)}
	   <tr>
		 <td>{emoji}</td>
		 <td>{description}</td>
	   </tr>
	 {/snippet} 

	 <table>
	   <thead>
		 <tr>
		   <th>emoji</th>
		   <th>description</th>
		 <tr>
	   </thead>
	   <tbody>
		 {@render monkey('smile', 'see no evil')}
	   </tbody>
	 </table>

Сниппеты можно передавать дочерним компонентам через пропсы:

	Файл App.svelte

	 {#snippet header()} ... {/snippet} 
	 {#snippet row(d)} ... {/snippet} 

	 <FilteredList data={colors} {header} {row} />

	Файл FilteredList.svelte

	 <script>
	   let { data, header, row } = $props();
	 </script>

	 <div class="header">
		{@render header()}
	 </div>

	 <div class="content">
	   {#each data as item}
		 {@render row(item)}
	   {/each}
	 </div>

Снипеты, объявленные внутри компонента, автоматически становятся его пропсами:

	 <FilteredList data={colors}>
	   {#snippet header()} ... {/snippet} 
	   {#snippet row(d)} ... {/snippet} 
	 </FilteredList>

Кроме этого, любой HTML внутри тега также превращается в специальный снипет children.

	 <FilteredList data={colors}>
	   <header> ... </header>
	   {#snippet row(d)} ... {/snippet} 
	 </FilteredList>

	 ...

	 let { data, children, row } = $props();
	 <div class="header">
		{@render children()}  // <header></header>
	 </div>

Чтобы реализовать плавное изменение числа (от 0 до 1), можно использовать встроенный класс
Tween. Объект Tween имеет два свойства - current и target. Изменяя target, current будет
плавно нагонять его. Плавность можно задать через easing-функцию. Также можно задать 
задержку и прочие анимационные настройки (передаются в конструктор, как опции).

Еще есть класс Spring, который также позволяет плавно менять значения. Но он может менять 
не только числа, но и объекты (например координаты). Этот класс, помимо current и target,
имеет 2 доп. свойства - stiffness и damping. Они задают жесткость и демфирование анимации.

Элемент с атрибутом contenteditable поддерживает привязку свойств innerHTML и textContent

	 <div bind:innerHTML={myContent} contenteditable></div>

Привязку можно сделать и для свойств у элементов <autio> и <video>

	 <audio {src} bind:currentTime={time} bind:duration bind:paused></audio>
	 <button class="play" onclick={() => paused = !paused}></button>

У любых блочных элементов доступна также привязка свойств: clientWidth, clientHeight,
offsetWidth и offsetHeight. При изменении их значений, Svelte будет обновлять привязанные
состояния, используя ResizeObserver.

	 <div bind:clientWidth={w} bind:clientHeight={h}>
	   <span class="size">{w} x {h}px</span>
	 </div>

Чтобы сделать привязку к DOM-элементу, используется директива bind:this. Но следует помнить,
что привязанная переменная получит значение только после монтирования компонента.

	 <script>
	   import { paint } from './gradient.js';

	   let canvas;

	   $effect(() => {
		 // Здесь можно обратиться к canvas	
	   });
	 </script>

	 <canvas bind:this={canvas} width={32} height={32}></canvas>

Помимо привязки к свойствам DOM-элементов, можно также выполнять привязку к пропсам
компонентов. Для этого нужные пропсы нужно определять с руной $bindable.

	Файл Keypad.svelte

	 let { value = $bindable(''), onsubmit } = $props();

	Файл App.svelte

	 <Keypad bind:value={pin} {onsubmit} />

Чтобы сделать привязку к экземпляру компонента, также используется bind:this. В этом случае
привязанный компонент должен экспортировать часть своего API, чтобы к нему можно было
обращаться из внешнего кода.

	Файл Canvas.svelte

	 let canvas = $state();
	 let context = $state();
	 
	 export const clear () => {
	   context.clearRect(0, 0, canvas.width, canvas.height);
	 };  

	Файл App.svelte

	 <script>
	   let canvas;
	   ...
	 </script>

	 <Canvas bind:this={canvas} />
	 <button onclick={() => canvas.clear()}>Clear</button>

Svelte поддерживает отложенные анимационные переходы. Это достигается за счет использования
функции crossfade, которая возвращает 2 transition-функции receive и send. Первая
используется с директивой in:, а вторая - с out:. Они принимают объект с ключом, который
указывает на новое переходное место. Как только элемент становится неактивен, то он 
плавно переходит на новую позицию. Например из одного списка в другой. 
См. https://svelte.dev/tutorial/svelte/deferred-transitions

В примере, по ссылке выше, анимируются только те элементы, которые непосредсвенно переходят
из списка в список. При этом остальные элементы в списках резко сдвигаются и раздвигаются, 
без анимации. Чтобы они также плавно сдвигались и раздвигались, к ним, помимо 
in:receive и out:send, нужно дополнительно добавить директиву animate.
См. https://svelte.dev/tutorial/svelte/animations

Чтобы пробросить данные из родительского компонента в глубоко вложенные компоненты, 
можно использовать context API. (как provide/inject из Vue).

	Файл Canvas.svelte

	 import { setContext } from 'svelte';

	 let items = new SvelteSet();
	 setContext('canvas', { addItem });   // может пробрасываться всё что угодно, 
                                          // а не только объекты
	 function addItem(fn) {          
	   $effect(() => {
		 items.add(fn);
		 return () => items.delete(fn);
	   });
	 }

	Файл Square.svelte

	 import { getContext } from 'svelte';
	 getContext('canvas').addItem(() => { ... });

	Файл App.svelte

	 <Canvas>
	   {#each Array(12) as _, c}
		 {#each Array(22) as _, r}
		   <Square 
			 x={180 + c * 40 + jitter(r * 2)} 
		     y={180 + r * 40 + jitter(r * 2)}
		     rotate={jitter(r * 0.05)}
		   />
		 {/each}
	   {/each}
	 </Canvas>

Методы setContext() и getContext() должны вызываться при инициализации компонентов. 
В качестве ключей могут задаваться не только строки.

Чтобы задать обработчики событий на объекте window, используется тег <svelte:window>
Также, с пом. этого тега можно задать привязки для свойств window. Привязать можно только
следующие свойства: innerWidth, innerHeight, outerWidth, outerHeight, scrollX, scrollY 
и online - алиас для window.navigator.onLine

	 <svelte:window {onkeydown} />
	 <svelte:window bind:scrollY={y} />

Специальный тег <svelte:document> позволяет прослушивать события объекта document.
Cледует избегать прослушивания событий mouseenter и mouseleave на document, посколько
большинство событий не вызываются на тем. Вместо этого нужно использовать <svelte:body>

	 <svelte:document {onselectionchange} />

Специальный тег <svelte:body> позволяет прослушивать события объекта document.body:

	 <svelte:body
	   onmouseenter={() => hereKitty = true}
	   onmouseleave={() => hereKitty = false}
	 />

Специальный тег <svelte:head> позволяет вставлять в элемент <head> различные метатеги 
<title> и прочее, что необходимо для SEO:

Специальный тег <svelte:element> позволяет задать условный элемент, содержимое которого 
будет рендериться в зависимости от переданного falsy-значения в this (используются 
вместо большого кол-ва {#if} блоков) 

	 <svelte:element this={isActive}>
	   I'm a <code>{selected}</code> element
	 </svelte:element>

Специальный тег <svelte:boundary> позволяет перехватывать ошибки, возникающие в его дочерних
компонентах. Чтобы заменить компонент с багом на пользовательский шаблон, нужно также
определить внутри сниппет с названием failed.

	 <svelte:boundary>      // тегу можно задать слушатель onerror
	   <FlakyComponent />   // компонент выбрасывает ошибку

	   {#snippet failed(error, reset)}
		 <p>Oops! {error.message}</p>
		 <button onclick={reset}>Reset</button>
	   {/snippet}
	 </svelte:boundary>

В компоненте, кроме обычного тега <script>, можно также объявить тег <script module>.
Все, что находится внутри такого модуля, выполняется единожды (как в ES-модулях). 
Из <script module> можно экспортировать доп. функционал компонента.

	Файл AudioPlayer.svelte

	 <script module>
	   let current;    // текущий плеер

	   export const pauseAll = () => {    // Экспорт по умолчанию зарезервирован 
		 current?.pause();                // за самим компонентом
	   };
	 </script>

	 <script>
	   let { src } = $props();

	   const play = (e) => {
		 const audio = e.currentTarget;
		 if (audio !== current) {
		   current?.pause();
		   current = audio;
		 }
	   };
	 </script>
	 
	 <audio {src} onplay={play}></audio>

	Файл App.svelte

	 <script>
	   import AudioPlayer, { pauseAll } from './AudioPlayer.svelte';
	   import { tracks } from './tracks.js';
	 </script>

	 <div class="container">
	   {#each tracks as track}
		 <AudioPlayer {...track} />
	   {/each}

	   <button onclick={pauseAll}>Pause</button>
	 </div>

-----------------------

БАЗОВЫЙ SVELTEKIT

