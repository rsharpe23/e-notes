BASH-СКРИПТЫ

Это текстовые, исполняемые файлы, содержащие последовательность команд.
Пример bash-скрипта (или shell-скрипта):

 #!/bin/bash
 # Мой первый скрипт
 echo hello world!
 exit 0

В первой строке стоит shebang. Он сообщает оболочке, какую подоболочку следует 
выполнить для запуска скрипта. Этот элемент всегда начинается с #! после чего следует 
имя подоболочки /bin/bash (может быть и другая).

После shebang идет комментарий, который начинается с символа #.
После комментария идет обычная команда с echo. 

В конце идет команда exit 0, которая завершает скрипт. Этой команде передается 
числовой код, указывающий как завершился скрипт. Число 0 означает успешное завершение, 
а все другие - что возникла проблема.

В сложный скриптах можно использовать разные числовые коды, чтобы указать, 
что определенное условие не выполнено.

Есть несколько способов, выполнить скрипт:

 * сделать текстовый файл исполняемым и запустить как обычную программу;
 * передать название скрипта в качестве агрумента программы bash;

 * включить скрипт в текущую оболочку (полезно если скрипт содержит переменные, 
   которые надо сделать активными в текущей оболочке).

Первый способ: chmod +x myscript и ./myscrypt
Второй способ: bash myscript
Третий способ: . myscript (или source myscript) 

При использовании третьего способа следует учитывать, что команда exit закрывает 
текущую оболочку, поэтому её в этом случае лучше не использовать.

Переменная определяется так: имя=значение. 
Для обращения к переменной используется её имя со знаком $

 message="Hello world!" 
 age=39
 echo $message

Работать с переменными можно как в скрипте, так и непосредственно в терминане.
Также в системе имеются и глобальные переменные (переменные окружения) 
к которым можно обращаться тоже, через $: echo $USER

Чтобы переменная из родительской оболочки была доступна в подоболочке, 
её нужно объявлять с ключевым словом export:
 
 export message="Hello world!" (в терминале создаем переменную, после чего запускаем
 bash myscript                  скрипт, который сможет также к ней обращаться)

Переменные можно встраивать в оболочку, записав предварительно в общий bash-скрипт:
Для встраивания применяется точка или команда source:

 . myvars  (встраиваем скрипт в терминал)
 echo $name; echo $age  (команды в одну строку разделяются точкой с запятой)

Команда read используется, чтобы записать ввод из терминала в некоторую переменную:
 
 #!/bin/bash
 echo Enter your name:
 read name
 echo -e "Your name: $name"
 exit 0

Скрипту можно передавать аргументы командной строки. 
Аргументы указываются через пробел: bash myscript arg1 arg2.

Внутри скрипта они доступны через идентификаторы. Первый аргумент - это $1, 
второй $2 и т.д., а $0 содержит имя скрипта.

Специальные идентификаторы:
 $# - число аргументов;
 $@ (или $*) - строка с аргументами.

Переменным можно присваивать результаты команд. Это называется подстановкой команды 
(command substitution). Для этого команда помещается в косые кавычки:

 today=`date +%d.%m.%y`
 echo $today

 echo "Today is `date +%d.%m.%y`" (сразу в строке)

Операторы подстановки:

 * ${var:-value} - показывает значение value, если переменная не определена;

 * ${var:+value} - показывает value, если переменная имеет значение 
  (если значения нет, ничего не происходит);

 * ${var=value} - присваивает value переменной, если та не существует 
  (ничего не делает, если переменная существует);

 * ${var:=value} - присваивает value переменной, если та не имеет 
   значения или не существует;

 * ${var:?value} - показывает value, если переменная не существует или пуста
  (использование приведет к немедленному прерыванию скрипта);

Примеры использования (NIL изначально не существует):
 echo ${NIL:-Is undefined}  -->  Is undefined
 echo ${NIL=default}  -->  default
 echo ${NIL:=null}    -->  default (т.к. было установлено выше)
 
Операторы сопоставления (найдя шаблон, изменяют по нем переменную):
 * ## - используется для поиска самого длинного соответсвия шаблону, с начала строки;
 * # - для поиска самого короткого соответсвия шаблону, с начала строки;
 * %% -  для поиска самого длинного соответсвия, с конца строки;
 * % - для поиска самого короткого сввответсвия, с конца строки.

Примеры использования (применяется к 1$, в который передается путь к файлу):

 filename=${1##*/} (ищет самое длинное соответсвия шаблону */, и все, что перед ним, 
                    и удаляет это, оставляя только имя файла)

 path=${1#*/} (ищет самое короткое соответсвие, т.е. первый слэш, и удаляет его)
 rel_path=${1#$PWD/} (здесь шаблон устанавливается на основе $PWD и /)
 dirname=${1%/*} (ищет последний слэш с конца, после кот. стоит произвольн. символ)

Математических операции имеют след. синтаксис: $((operand1 operation operand2))
Bash поддерживает выполнение простейших операций: +, -, *, /, %.

 result=$((1 + 3))
 
 a=240; b=90
 c=$((a - b))  // внутри скобок переменные без $

Также есть другой способ определения мат. операций - с пом. команды expr:
 sum=`expr 5 + 2`; echo $sum (для присвоения используется подстановка команды)
 expr 5 \* 2 (умножение надо экранировать, иначе будет ошибка)

Если результат присваивается переменной, объявленной через let, 
то expr можно не указывать:

 let result="5 * 2"
 echo $result

Условия и команда test...

---------------

РАЗНОЕ

Команда which находит расположение файла указанной команды, т.е. по сути она 
помогает определить существует ли заданная команда.

Чтобы запустить программу, нужно к её названию добавить префикс "./"

