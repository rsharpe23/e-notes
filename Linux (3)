BASH-СКРИПТЫ

Это текстовые, исполняемые файлы, содержащие последовательность команд.
Пример bash-скрипта (или shell-скрипта):

 #!/bin/bash
 # Мой первый скрипт
 echo hello world!
 exit 0

В первой строке стоит shebang. Он сообщает оболочке, какую подоболочку следует 
выполнить для запуска скрипта. Этот элемент всегда начинается с #! после чего следует 
имя подоболочки /bin/bash (может быть и другая).

После shebang идет комментарий, который начинается с символа #.
После комментария идет обычная команда с echo. 

В конце идет команда exit 0, которая завершает скрипт. Этой команде передается 
числовой код, указывающий как завершился скрипт. Число 0 означает успешное завершение, 
а все другие - что возникла проблема.

В сложный скриптах можно использовать разные числовые коды, чтобы указать, 
что определенное условие не выполнено.

Есть несколько способов, выполнить скрипт:

 * сделать текстовый файл исполняемым и запустить как обычную программу;
 * передать название скрипта в качестве агрумента программы bash;

 * включить скрипт в текущую оболочку (полезно если скрипт содержит переменные, 
   которые надо сделать активными в текущей оболочке).

Первый способ: chmod +x myscript и ./myscrypt
Второй способ: bash myscript
Третий способ: . myscript (или source myscript) 

При использовании третьего способа следует учитывать, что команда exit закрывает 
текущую оболочку, поэтому её в этом случае лучше не использовать.

Переменная определяется так: имя=значение. 
Для обращения к переменной используется её имя со знаком $

 message="Hello world!" 
 age=39
 echo $message

Работать с переменными можно как в скрипте, так и непосредственно в терминане.
Также в системе имеются и глобальные переменные (переменные окружения) 
к которым можно обращаться тоже, через $: echo $USER

Чтобы переменная из родительской оболочки была доступна в подоболочке, 
её нужно объявлять с ключевым словом export:
 
 export message="Hello world!" (в терминале создаем переменную, после чего запускаем
 bash myscript                  скрипт, который сможет также к ней обращаться)

Переменные можно встраивать в оболочку, записав предварительно в общий bash-скрипт:
Для встраивания применяется точка или команда source:

 . myvars  (встраиваем скрипт в терминал)
 echo $name; echo $age  (команды в одну строку разделяются точкой с запятой)

Команда read используется, чтобы записать ввод из терминала в некоторую переменную:
 
 #!/bin/bash
 echo Enter your name:
 read name
 echo -e "Your name: $name"
 exit 0

Скрипту можно передавать аргументы командной строки. 
Аргументы указываются через пробел: bash myscript arg1 arg2.

Внутри скрипта они доступны через идентификаторы. Первый аргумент - это $1, 
второй $2 и т.д., а $0 содержит имя скрипта.

Специальные идентификаторы:
 $# - число аргументов;
 $@ (или $*) - строка с аргументами.

Переменным можно присваивать результаты команд. Это называется подстановкой команды 
(command substitution). Для этого команда помещается в косые кавычки:

 today=`date +%d.%m.%y`
 echo $today

 echo "Today is `date +%d.%m.%y`" (сразу в строке)

Операторы подстановки:

 * ${var:-value} - показывает значение value, если переменная не определена;

 * ${var:+value} - показывает value, если переменная имеет значение 
  (если значения нет, ничего не происходит);

 * ${var=value} - присваивает value переменной, если та не существует 
  (ничего не делает, если переменная существует);

 * ${var:=value} - присваивает value переменной, если та не имеет 
   значения или не существует;

 * ${var:?value} - показывает value, если переменная не существует или пуста
  (использование приведет к немедленному прерыванию скрипта);

Примеры использования (NIL изначально не существует):
 echo ${NIL:-Is undefined}  -->  Is undefined
 echo ${NIL=default}  -->  default
 echo ${NIL:=null}    -->  default (т.к. было установлено выше)
 
Операторы сопоставления (найдя шаблон, изменяют по нем переменную):
 * ## - используется для поиска самого длинного соответсвия шаблону, с начала строки;
 * # - для поиска самого короткого соответсвия шаблону, с начала строки;
 * %% -  для поиска самого длинного соответсвия, с конца строки;
 * % - для поиска самого короткого сввответсвия, с конца строки.

Примеры использования (применяется к 1$, в который передается путь к файлу):

 filename=${1##*/} (ищет самое длинное соответсвия шаблону */, и все, что перед ним, 
                    и удаляет это, оставляя только имя файла)

 path=${1#*/} (ищет самое короткое соответсвие, т.е. первый слэш, и удаляет его)
 rel_path=${1#$PWD/} (здесь шаблон устанавливается на основе $PWD и /)
 dirname=${1%/*} (ищет последний слэш с конца, после кот. стоит произвольн. символ)

Математических операции имеют след. синтаксис: $((operand1 operation operand2))
Bash поддерживает выполнение простейших операций: +, -, *, /, %.

 result=$((1 + 3))
 
 a=240; b=90
 c=$((a - b))  // внутри скобок переменные без $

Также есть другой способ определения мат. операций - с пом. команды expr:
 sum=`expr 5 + 2`; echo $sum (для присвоения используется подстановка команды)
 expr 5 \* 2 (умножение надо экранировать, иначе будет ошибка)

Если результат присваивается переменной, объявленной через let, 
то expr можно не указывать:

 let result="5 * 2"
 echo $result

Команда test проверяет соответсвие некоторому условию:

 * test $var - определена ли переменная $var;
 * test -e $var - является ли $var файлом;

 * test -f $var - является ли $var обычный файлом (а не файлом устройства, 
   каталогом или исполняемым файлом);

 * test -d $var - является ли $var каталогом;
 * test -x $var - является ли $var исполняемым файлом;
 * test $var1 -nt $var2 - явяется ли $var1 новее, чем $var2;
 * test $var1 -ot $var2 - старше ли $var1, чем $var2;
 * test $var1 -eq $var2 - равны ли числа $var и $var2;
 * test $var1 -ne $var2 - не равны ли числа $var1 и $var2;
 * test $var1 -gt $var2 - больше ли число $var1 чем $var2;
 * test $var1 -lt $var2 - меньше ли число $var1 чем $var2;
 * test $var1 -ge $var2 - является ли число $var1 большим или равным $var2;
 * test $var1 -le $var2 - является ли число $var1 меньшим или равным $var2;
 
 * test $var1 = $var2 - сопвадают ли строки $var1 и $var2; также применяется 
   для сравнения значений 2х переменных;

 * test $var1 != $var2 - не равны ли строки $var1 и $var2; знак "!" можно использовать 
   со всеми другими командами test, а также для проверки отрицательного утверждения. 

Также для проверки можно использовать сокращенную форму, при которой вся команда 
помещается в квадратные скобки (с пробелами), а слово test опускается:

 [ -f $1 ]  (тоже самое что и test -f $1)

С помощью операторов && и || можно объединять проверки и различные команды:

 [ -f $path ] && echo "$path is a file"  (веведет строку, если $path явл. файлом)

 mkdir ~/Documents/test && echo "Folder created!"  (выводится сообщение, если папка
                         test успешно создана в домашнем каталоге пользователя; но если 
                         папку не удастся создать, тогда вторая команда не выполнется).
 
 mkdir ~/Documents/test || echo "Unable to create"  (наоборот, выполнит вторую команду, 
                  если не удалось выполнить первую; например, когда папка уже существует).

Условная конструкция if/else выглядит так (наверно then как и do 
можно располагать на одной строке):

 if [ $a -eq $b ]          if [ $a -eq $b ]             if [ $a -gt $b ]
 then                      then                         then
     echo "a и b равны"        echo "числа равны"           echo "a больше b"
 fi                        else                         elif [ $a -lt $b ]
                               echo "числа не равны"    then
                           fi                               echo "a меньше b"
                                                        else
                                                            echo "a и b равны"
                                                        fi

После if/elif указывается условие, а после then - набор команд. 
Заканчивается вся конструкция словом fi.

Конструкция case in (то же что и switch/case в других языках) выглядит так:

case $value in              case $value in      
    1)                          1)
    echo "value равно 1"        echo "value равно 1" 
    ;;                          ;;
    2)                          1|2|3)
    echo "value равно 2"        echo "value равно или 1, или 2, или 3"
    ;;                          ;;
    3)                          *)
    echo "value равно 3"        echo "блок по умолчанию"
    ;;                          ;;
esac

После case идет переменная, которую надо сравнивать с набором значений.
Блок каждого значения имеет следующий формат:

 value)
 command
 ;;

Заканчивается конструкция словом esac.

Цикл while выполняется, пока соблюдается некоторое условие:

 while [ $value -lt 5 ]
 do
     echo "value равно $value"
     $value=$((value + 1))
 done

Цикл until противоположен while, выполняется, пока не будет выполнено условие:

 until [$value -eq 5] 
 do
     echo "value равно $value"
     $value=$((value + 1))
 done

Цикл for выполняет набор команд определенное количество раз. Для определения 
условий можно использ. операторы сравнения: <, >, <=, >=, ==, !=. Для приращения 
переменной используются операторы инкремента ++, и деркемента --.

 for ((i = 0; i < 5; i++)); do
     echo "i равно $i"
 done

Цикл for in выполняет перебор значений:

 for str in `cat /etc/passwd` do (перебор текстового файла по отдельной строке)
     echo str
 done

 for i in $@    ($@ позволяет обратиться ко всем передаваемым аргументам)
 do 
    ping -c 1 192.168.1.$i
 done

Между do и done идут команды цикла.

---------------

РАЗНОЕ

Команда which находит расположение файла указанной команды, т.е. по сути она 
помогает определить существует ли заданная команда.

Чтобы запустить программу, нужно к её названию добавить префикс "./"
Полны путь к файлу: readlink -f myfile

В Live-версии, пароль для root прав - это "toor" (root наоборот).

Хороший пароль должен содержать не менее 8 символов, несколько заглавных 
букв, а также 3-4 других знака.

Раздел swap должен быть в 2 раза больше объема оперативной памяти.

Чтобы изменить порядок ОС в загрузчике grub, нужно открыть файл /etc/default/grub 
и в поле GRUB_DEFAULT указать название нужной ОС. После этого нужно выполнить команду: 
sudo update-grub2. Название ОС можно узнать в файле /boot/grub/grub.cfg

Горячие клавиши для навигации в терминале:
 * Ctrl + A - аналог Home
 * Ctrl + E - аналог End
 * Ctrl + R - поиск команды из истории по первым символам

Горячие клавиши для вызова терминала: Ctrl + Alt + T.

Температура GPU: watch -n 2 nvidia-smi
Температура CPU: watch -n 2 sensors

Если поставить пробел перед командой, то она не будет записана в историю.

Чтобы сделать шрифт более четким, нужно установить bitmap шрифты. 
При их установке удаляется какие-то настройки, влияющие на сглаживание 
и после этого все шрифты рендерятся лучше.

Cкачать сайт с помощью wget: wget -r -k -l 7 -p -E -nc http://site.com/

 -r - указывает на то, что нужно рекурсивно переходить по ссылкам
  на сайте, чтобы скачивать страницы.

 -k - используется для того, чтобы wget преобразовал все ссылки в 
  скаченных файлах таким образом, чтобы по ним можно было переходить 
  на локальном компьютере (в автономном режиме).

 -p - указывает на то, что нужно загрузить все файлы, которые требуются 
  для отображения страниц (изображения, css и т.д.).

 -l - определяет максимальную глубину вложенности страниц, которые wget должен 
  скачать (по умолчанию значение равно 5); в большинстве случаев сайты имеют страницы 
  с большой степенью вложенности и wget может просто закопаться, скачивая их все;

 -E - добавлять к загруженным файлам расширение .html

 -nc - при использовании данного параметра существующие файлы не будут перезаписаны; 
  это удобно, когда нужно продолжить загрузку сайта, прерванную в прошлый раз. 

