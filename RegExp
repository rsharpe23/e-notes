Регулярные выр-я реализованы с пом. объекта RegExp и интегрированы в методы строк.

Есть 2 синтаксиса для создания регулярных выражений.
1) Длинный: new RegExp('шаблон', 'флаг');
2) Короткий, через слэши: /шаблон/флаг  -->  это тот же RegExp

Короткий синтаксис не допускает никаких вставок переменных, типа ${...} и т.п.
Он используется когда точно известно, каким должно быть регулярное выражение. 
А длинный - когда необходимо создавать рег. выр-е динамически, "на лету".

Флаги (они влияют на поиск):
* i - поиск не зависит от регистра (нет разницы между "А" и "а");
* g - поиск ищет все совпадения в строке, а без него только первое;
* s - включает режим "dotall"; см. далее;
* u - включает полную поддержку Юникода; см. далее;
* m - многострочный режим; см. далее;
* y - режим поиска на заданной позиции в тексте; см. далее.

Символьные классы (заменяют собой какие-то символы):
* \d - цифры, от 0 до 9;
* \D - всё, кроме цифр (например буквы);
* \s - пробелы, включая символы \t и \n;
* \S - всё, кроме пробелов (цифры или буквы);
* \w - лат. буквы, цифры и символ подчёркивания;
* \W - всё, кроме букв, цифр и подчёркивания (пробел, русские буквы);
*  . - любой символ, кроме \n. 

Чтобы точка также соответствовала и \n, рег. выр-е должно иметь флаг "s":
/A.B/  -->  совпадает с "A\nB" 

Чтобы рег. выр-е могло правильно интерпритировать все символы (русские/китайские
арабские буквы, смайлики и другие сурогатные пары), оно должно иметь флаг "u".
Кроме того, этот флаг также требуется если нужно использовать класс \p{}.

В его фигурных скобках указ. спец. свойство, принадлежащее символу Юникода. Например
Letter означает букву на любом языке: /p{Letter}/u  -->  F Ц ბ (совпадение с любой)
Также это могут быть различные апострофы, символы валют, шестнадцатирич. цифры и т.д.

Символы каретки "^" и доллара "$" называются якорями. 
Каретка означает совпадение в начале, а доллар - совпадение в конце.
...
/^Mary/  -->  совпадает с "Mary had a lamb"
/snow$/  -->  совпадает с "Fleece white as show"

Оба якоря часто используют вместе чтобы проверить текст на полное совпад. с шаблоном.
Например шаблон времени \d\d:\d\d может соответств. тексту с буквами, цифрами и т.д,
тогда как ^\d\d:\d\d$ четко говорит о том, что текст должен начин. и заканч. цифрами.

Якоря в многострочном режиме означают не только начало/конец текста, но и начало/конец
каждой строки в тексте. Включается он с помощью флага "m".

Граница слова, как и якоря, также является проверкой. Она нужна чтобы находить
отдельные слова в тексте, но может работать и с цифрами. Задается через символ \b.
...
/\bJava\b/   -->  совпадает с "Hello Java", но не c "Hello, JavaSript"
/\b\d\d\b/g  -->  в строке "1 23 456 78" найдет только 23 и 78

Есть 3 вида позиций, которые являются границами слова:
1) Начало текста, если его первый символ \w.
2) Позиция внутри текста, если слева \w, а справа - не \w, или наоборот.
3) Конец текста, если его последний символ \w.

Граница слова работает только с латинским алфавитом.

Чтобы экранировать спец. символы, нужно добавить к ним обратный слэш "\".
Их перечень: [ ] \ ^ $ . | ? * + ( ).  Символьные классы - это те же спец. символы.

Также, следует помнить что обычные строки съедают обратный слэш. Поэтому его 
необходимо удваивать, если рег. выр-е берется оттуда:
...
'\d\.\d'  -->  совпадает с "d*d", где * - это любой символ
'\\d\\.\\d'  -->  совпадает с "5.5", "1.2" и т.п.

Квадратные скобки задают набор. Это означает, искать любой символ из заданных.
/[тх]оп/  -->  либо "топ", либо "хоп"

А ещё они задают диапазоны символов, например диапазон [a-z] будет соответствовать
любому символу от "a" до "z", или [0-9] - любой цифре от 0 до 9. 

Диапазонов может быть сразу несколько: 
[0-9A-Z]  -->  либо цифра от 0 до 9, либо буква от "A" до "Z"
[a-zA-Z]  -->  буквы как в верхнем, так и в нижнем регистрах (либо использ. флаг i)  

Также в кврадратных скобках могут размещаться и символьные классы:
[\s\d]  -->  или пробел, или цифра

Символьные классы это всего лишь сокращения для наборов:
* \d - это тоже самое, как если б написать [0-9];
* \w - тоже, что и [a-zA-Z0-9_] (поэтому и не ищет русских букв);
* \s - тоже, что и [\t\n\r] + несколько редких пробельных символов.

Кроме того, есть ещё и исключающие диапазоны: [^...]. Символ каретки означает что
диапазон соответствует любому символу за исключением заданных.
...
[^aey]  -->  любой символ, за исключением "а", "е", "у"
[^0-9]  -->  любой символ, за исключением диапазона цифр от 0 до 9 (тоже, что и \D)

Большинство спец. символов внутри квадратных скобок экранировать не нужно:
[^.+-()]  -->  будет искать один из символов: ^ . + - ( )

Фигурные скобки обозначают квантификатор. Он указывает на кол-во повторений и задается
вместе с каким-то символом, символьным классом, набором и т.д, например: \d{5} 
означает \d\d\d\d\d. Чтобы исключить числа длиннее, пишем: \b\d{5}\b 

Границы указываются так: \d{3,5} -->  все числа от 3 до 5 цифр.
Если записать \d{3,} то находится будут числа длинной только 3 и более цифр.

Самые востребованные квантификаторы имеют сокращения:
* "+" - один или более; тоже, что и {1,} (\d+ это все цифры в "123-45-6") 
* "?" - ноль или один; тоже, что и {0,1} (colou?r это "color" либо "colour")
* "*" - ноль или более; тоже, что и {0,} (\d0* найдет цифру и все нули за ней)

По умолчанию квантификаторы работают в жадном режиме. Например, вот что будет 
если попытаться найти все слова в кавычках, через рег. выр-е /".+"/g

Сначала квантификатор .+ будет подгребать все символы, пока не дойдет до конца
  "............................. ->
a "witch" and her "broom" is one

А когда строка закончится, будет сокращать их, пока не встретит тот остаток, 
что указан после него в шаблоне, т.е. кавычку
  "....................." <-
a "witch" and her "broom" is one

Но иногда, чтобы получить корректный результат, нужно переключится в ленивый режим.
Это делается с пом. доп. знака "?", после квантификатора: /".+?"/g

Теперь квантификатор .+? после каждой точки будет проверять текст и на остаток. 
А когда его найдет, то поиск закончится:

  "." ->
a "witch" and her "broom" is one

  ".." ->
a "witch" and her "broom" is one

При этом след. учитывать, что хорошо настроенный жадный поиск в некоторых случаях 
может работать ещё лучше чем ленивый, например: /"[^"]+"/g

Круглые скобки - это скобочная группа. Они группируют часть рег. выр-я. 
Если задать после них квантификатор или другую операцию, то это будет применяться 
ко всему содержимому внутри, а не к одному символу.
...
/go+/    -->  без скобок: go, gooo, gooooo и т.д.
/(go)+/  -->  со скобками: go, gogo, gogogo
/(\w+\.)+\w/g  -->  mail.com, user.mail.com, super.user.mail.com и т.п.

Поисковой движок запоминает содержимое каждой скобочной группы, и позволяет получить
его в результате. Например метод str.match возвращает массив, где каждый элемент
представляет детали отдельной скобочной группы из рег. выр-я.
...
let res = '<div class="my">'.match(/<(([a-z]+)\s*([^>]*))>/);
res[0];  -->  <div class="my"> (общий результат)
res[1];  -->  div class="my"   (первая скобка)
res[2];  -->  div              (первая вложенная скобка)
res[3];  -->  class="my"       (вторая вложенная)

Если рег. выр-е содержит флаг "g", то метод str.match не возвращает скобочные группы.
Результатом будет массив совпадений, но без деталей. Для того чтобы получить 
также и детали, вместо match нужно использовать matchAll.

Скобочные группы можно именовать, добавив ?<name> после открытия скобки:
...
let res = '2019-04'.match(/(?<year>[0-9]{4})-(?<month>[0-9]{2}>)/g);
let groups = res.groups;  -->  с флагом "g" группы доступны через это свойство
groups.year; groups.month;

Метод str.replace заменяет все найденные совпадения в строке, производя поиск по 
рег. выр-ю. При этом, в заменяющем шаблоне можно размещать содержимое скобок в любом
месте. Это делается через обозначение "$n", где n - номер скобочной группы.
Для именованных скобок, ссылка будет выглядеть как "$<name>".
...
'John Bull'.replace(/(\w+) (\w+)/, '$2, $1');  -->  "Bull, John"
'2019-04'.replace(/(?<year>[0-9]{4})-(?<month>[0-9]{2})/, '$<month>.$<year>');

(другие обозначения: https://learn.javascript.ru/regexp-methods)

Чтобы исключить скобочную группу из массива совпаден, нужно доб. "?:" после открытия.
Кроме того, такую группу нельзя будет использовать через $n, в строке замены.
...
let res = 'Gogogo John!'.match(/(?:go)+ (\w+)/i);
res[0];  -->  "Gogogo John"
res[1];  -->  "John"

К содержимому скобок можно обращаться и внутри самого регулярного выражения.
Делается это с помощью записи "\N", где N - номер скобочной группы.
...
`He said "She's the one!"`.match(/(['"])(.*?)\1/g);  -->  `"She's the one!"`

Сначала выражение, с пом. (['"]) находит первую кавычку и запонимает её, т.к. \1
указывает именно на эти скобки. Далее, в шаблоне, на место \1 подставляется то, 
что было запомнено ранее. Т.о. выражение как бы трансформируется в /"(.*?)"/g

Для обращения к именованным скобкам используется запись \k<name>, например: 
`He said "She's the one!"`.match(/(?<quote>['"])(.*?)\k<quote>/g);

Альтернация - это ИЛИ. Записывается она с помощью знака "|". Она напоминает квадратные
скобки, но при этом является более мощным механизмой, разделяющим не только символы, 
но и целые под-выражения. Например: /[01]\d|2[0-3]/  -->  час, от 00 до 24

В регулярных выражениях существуют опережающие и ретроспективные проверки. 
Первая задается так: X(?=Y). Это означает: найти X, при условии, что за ним следует Y.

Допустим есть строка, и в ней нужно найти число, после котор. есть знак €.
'Индейка стоит 30€'.match(/\d+(?=€)/);  -->  "30"

Возможны и более сложные варианты, например X(?=Y)(?=Z) означает, что нужно найти X 
при условии, что за ним идет и Y, и Z.

Негативная проверка задается так: X(?!Y), т.е. найти X, за которым не следует Y.

Ретроспективная проверка: (?<=Y)X. Она ищет совпадение с X при условии, что ПЕРЕД ним
есть Y: И, аналогично, негативная ретроспективная проверка: (?<!Y)X.
...
'Индейка стоит $30'.match(/(?<=\$)\d+/);  -->  "30"

Как правило, тот Y, что входит в скобки, не включается в результат.
Но если требуется захватить и его, то он должен быть обернут в доп. скобки.
...
'Индейка стоит 30€'.match(/\d+(?=(€))/);  -->  "30", "€"

Флаг "y" позволяет задать поиск на конкертной позиции в тексте. В основном он
используется для улучшения производительности. Позицию можно задать через свойство
lastIndex, объекта regexp. Оно доступно только если рег. выр-е имеет флаг "y" или "g".
...
let text = 'let value = "hello"';
let regexp = /\w+/y;

regexp.lastIndex = 3;
regexp.exec(text)  -->  null (позиция 3 не соотв. шаблону)

regexp.lastIndex = 4;
regexp.exec(text)  -->  value

При этом, если вместо "y" поставить "g", то след. запись будет верна:
...
regexp.lastIndex = 3;
regexp.exec(text)  -->  value (ищет, начиная с 3 позиции и далее)

Если рег. выр-е используется вместе с флагом "g", то свойство lastIndex всегда
возвращает позицию, после каждого найденного совпадения.
...
regexp.lastIndex;   -->  0

regexp.exec(text);  -->  let 
regexp.lastIndex;   -->  3

regexp.exec(text);  -->  value
regexp.lastIndex;   -->  9

regexp.exec(text);  -->  null (больше сопадений нет)
regexp.lastIndex;   -->  0 (сбрасывается по окончании поиска)

Если рег. выр-е имеет большое кол-во комбинаций, которые усложняют поиск, то оно может
привести к зависанию интерпритатора JS. Это называется - катастрофический возврат.

Регулярные выражения используются в следующих методах:

* str.match(regexp) - ищет совпадения в строке; regexp без флага "g", возвращает первое
совпадение, с флагом - массив всех совпадений, но без деталей; иначе null.

* str.matchAll(regexp) - возвращает перебираемый объект, где каждое совпадение - это
массив с его деталями; иначе пустой перебираемый объект; раньше вместо этого метода
использался regexp.exec, когда нужны были детали всех совпадений;

* str.split(regexp|str, limit) - разбивает строку на массив подстрок по разделителю;
* str.search(regexp) - возвращает позицию только первого совпадения; иначе -1;

* str.replace(regexp|str, str|func) - ищет и заменяет все совпадения; если первый
агрумент строка, то заменяет только первое совпадение;

* regexp.exec(str) - альтернативный вариан для str.match;
* regexp.test(str) - ищет совпадение и возвращает true/false.

Методы exec и test также необходимы, когда нужен поиск с использованием флага "y".
Одно и тоже рег. выр-е, использ. повторно в этих методах, может дать другой результат.
...
let regexp = /javascript/g;
regexp.test('javascript');  -->  true
regexp.test('javascript');  -->  false, т.к. lastIndex уже 10, а не 0

Чтобы это исправить, нужно вызывать regexp.lastIndex = 0; перед каждым поиском.
