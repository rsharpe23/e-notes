Мои основные правила работы:

Всегда спрашивай себя - "а для чего конкретно здесь нужен этот ф-ционал?" 
Возможно он не пренадлежит данному контексту и его лучше вынести в другое место.

Если что-то упорно не удается реализовать, значит основная идея неверна. 
Нужно попытаться найти альтернативное решение.

Выразительные имена нужно придумывать после реализации логики, а не перед. Т.к. на
этапе реализации логика может измениться и имена будут искажать актуальные намерения.

-----------------------

Согласнно принципу "единственной ответсвенности" SOLID, наследование лучше применять
тогда, когда производный класс расширяет ответсвенность базового класса. Если производ.
класс привносит новую ответсвенность, то в этом случае нужно использовать композицию.

Допустим если класс, предназначенный для перемещения по сцене (это его ответсвенность),
то у него также могут быть производные классы, дополняющие эту ответсвенность 
новыми методами перемещения, поворота и т.д.

Но если классу нужны другие действия, не относящиеся к перемещению, например выбор по
клику, то это уже другая ответсвенность, и она не должна реализ. производными классами.

-----------------------

Разработку через интерфейсы следует вести тогда, когда у класса древовидная иерархия.
В этом случае с помощью базового интерфейса можно будет добавлять ответвления
от основной иерархии (т.е. делать композицию).

-----------------------

Названия переменных должны быть максимально информативны. Их названия должны говорить
не только о том, что они хранят, но и то, для какого контекста это все нужно. 
Тоже самое справедливо и для названий ф-ций.

// Это неправильно!
const dirLength = calcLength( calcDiff(vec1, vec2) );  

// Надо делать так
const calcDist = (vec1, vec2) => calcLength( calcDiff(vec1, vec2) );
const distToDragPos = calcDist(vec1, vec2);  

-----------------------

Вместо private static методов лучше использовать вспомогательные ф-ции, объявленные 
вне класса (но, в том же контексте). В тех языках, где нельзя создавать ф-ции отдельно
от классов, можно использовать дополнительные классы-хелперы.

-----------------------

Ф-ция должна выполнять исключительно ту работу, для которой она предназначена. 
Если, помимо основного ф-ционала, имеются какие-то подготовительные действия, 
то ф-цию нужно разбить на несколько вариантов. 

function process(arg) {
  const concreate = getConcrete(arg);
  _process(concrete);
}

function _process(concrete) {
  // Весь основной ф-ционал выполняется здесь, вокруг пар-ра concrete, 
  // а получение этого пар-ра - это подготовительные действия.
}

В языках со статической типизацией можно использовать перегрузку ф-ций.
В JS перегрузку ф-ции можно удобно реализовать с пом. iife внутри основной ф-ции. 

-----------------------

При переборе, если коллекция имеет абстрактное название, то элемент лучше называть
"item". Если же у коллекции конкретное название, то и название элемента
также должно быть конкретным.

list.map(item => item.id);
disks.map(disk => disk.id);

Название "it" используется для именования итераторов.

-----------------------

[C++] Ключевое слово var/auto (и т.п.) может использоваться не только как сокращение, 
когда известна правай часть инициализации, но и когда тип имеет большую вложенность:

MyClass1.MySubClass.Inner value = getValue();
var value = getValue();  // можно написать и так

-----------------------

WebApi лучше оформлять как и любой другой api:

webApi.post('/products', data, cb); // нормально
shop.buyProducts(products, cb);     // лучше

-----------------------

Если у ф-ции много параметров, то часть из них можно перенести на следующую строку:

gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height,
  0, gl.RGBA, gl.UNSIGNED_BYTE, null);

Если у ф-ции первый аргумент начинается с новой строки, то и все остальные аргументы 
лучше начинать с новых строк, подобно тому, как это делается в объекте:

gl.framebufferRenderbufferAndAnotherAction(
  gl.TEXTURE_2D, 0, gl.RGBA, 
  width, height, 0, gl.RGBA, 
  gl.UNSIGNED_BYTE
);

-----------------------

При выполнении цепочки вызовов, ф-ции лучше выравнивать по одному уровню. Но если цепочка 
вызовов используется как возвращаемое значение, то достаточно одного отступа.

node.querySelector('.title')
    .formatText(typesMap[type])
    .formatText(words[0], words[1]);

// Из-за return и const придется делать слишком отступов

return node.querySelector('.title')
  .formatText(typesMap[type])
  .formatText(words[0], words[1]);

const newNode = node.querySelector('.title');
  .formatText(typesMap[type])
  .formatText(words[0], words[1]);

По возможности лучше вообще избегать цепочек вызовов, т.к. их сложнее отлаживать.

// Плохо
return Object.keys(obj).findIndex(k => k === key);

// Лучше (результат можно узнать во внешнем контексте)
const keys = Object.keys(obj);
return keys.findIndex(k => k === key);

-----------------------

Если название переменной состоит из одного слова, то его желательно записывать
полностью (если оно не длинное или не многоизвестно в сокращенном виде). Если же
название состоит из нескольких слов, то их можно сокращать. Названия ф-ций, 
а тем более классов, сокращать не нужно.

position, attr, val, callback, proxyCb;

Если в одном контексте есть несколько переменных, в названиях которых присутсвуют 
общие слова, то лучше чтобы они были одинаковыми (если слово сокращено в одной
переменной, то и в других лучше сократить по нему и наоборот)

position, relativePos;  // плохо
position, relPosition;  // лучше сократить relative

-----------------------

Если ф-ция создает новый объект, то в её имени должен быть префикс create.
Если ф-ция получает уже существующий объект или находит его, то get/find соответсвенно.

-----------------------

Если аббревиатура идет в начале слова, то её можно записывать в нижнем регистре, 
а если в конце - то в верхнем. При этом, длинную аббревиатуру (более 2х символов) 
лучше записывать через camelCase, даже если она в конце.

function urlToPath() {}
function getIO() {}
function createBlob() {}

-----------------------

Чтобы ф-ции утилит не требовали импорта зависимостей, они должны проектироваться 
через колбэки или с зависимостями в параметрах:

// Нормально
import module from 'my-module';
export function fn1() {}  // эта ф-ция использует модуль
export function fn2() {} 

// Так лучше
export function fn1(module) {}  // вместо модуля может быть колбэк 
export function fn2() {}

-----------------------

Во множественном числе лучше именовать каталоги, а не файлы. При этом, если в файле
определены ф-ции, то он также может именоваться во множественном числе.

mat-util.js // экспортирует только одну сущность (объект или класс)
utils.js    // экспортирует одну или несколько ф-ций

-----------------------

Если название ф-ции во множественном числе, но при этом ф-ция не возвращает 
коллекцию, то к названию лучше добавить окончание "Of":

getNumComponents --> getNumComponentsOf  // возвращает кол-во компонентов чего-то

-----------------------

Иногда можно выносить часть логики во внешний контекст:

// Нормально
function fn(meshes, data) {
  const meshProvider = new MeshProvider(data);
  return meshes.map(mesh => meshProvider.getMesh(mesh));
}

// Так лучше
function fn(meshes, meshProvider) {
  return meshes.map(mesh => meshProvider.getMesh(mesh));
}

-----------------------

Provider - это некая абстракция для экранирования геттера из какого-то большого класса.

class GLUtil {
  createShader() {}
  setVertexAttr() {}
  getBuffer(data, target) {}
}

function createBuffer(data, bufferProvider) {
  return bufferProvider.getBuffer(data, gl.ARRAY_BUFFER);
}

const buffer = createBuffer(myData, new GLUtil());

-----------------------

Названия локальных стрелочных ф-ций могут быть без префикса get/create.
Колбеки можно именовать через префикс on*. Название callback можно использовать 
если имя метода совпадает с именем колбека.

const buffer = (gl, store) => { ... } 
function fn(obj, onClick) { ... }      // onClick вместо callback
function traverse(callback) { ... }    // callback вместо onTraverse

-----------------------

Если метод класса возвращает поле класса, то это должно быть свойство:

get matrix() {
  if (this.parent) {
    mat4.mul(this._matrix, this.parent.matrix, this._matrix);
  }

  return this._matrix;
}

-----------------------

В последнее время, вместо function declaration модно определять стрелочные ф-ции.
Скорей всего это пошло из-за работы с es-модулями. Так, например, если модуль имеет
всего одну ф-цию, то её можно экспортировать по умолчанию, а для этого нужно использ.
либо стрелочну ф-цию, либо function expression. Но поскольку в новом синтаксисе первое
заменяет второе, то чтобы не смешивать разные способы определения, видимо и было
принято такое внегласное решение, среди комьюнити, определять все ф-ции в одном стиле.

-----------------------

Композиция в основном используется тогда, когда в системе есть уже созданные объекты 
и их нужно как-то расширить. Если же обьекты можно создавать самому, то подойдет и
обычное наследование. Также композиция используется тогда, когда нужно сделать
ответвление от основной иерархии наследования.

-----------------------

Утилиты - это набор вспомогательных ф-ций, реализующих дополнительные
возможности в контексте какого-то компонента.

API - это набор утилит (состоящий как из ф-ций, так и классов), для управления
программой, файлом, системой и т.п. (может быть частью утилит): 

// API группирует файлы (без index-файла)
gltf-api
  gltf-parser 
  gltf-adapt.js
  gltf-loader.js

-----------------------

Через this лучше обращаться к тем свойствам, которые требуют изменения состояния:

// Плохо
setLocations() {
  this.a_Position = this.gl.getAttribLocation(this.target, "a_Position");
  this.a_Normal = this.gl.getAttribLocation(this.target, "a_Normal");
}

// Хорошо
setLocations({ gl, target }) {
  this.a_Position = gl.getAttribLocation(target, "a_Position");
  this.a_Normal = gl.getAttribLocation(target, "a_Normal");
}

-----------------------

Если условие (или цикл) состоит всего из одной строки, то его можно записать без
фигурных скобок. Такая запись делает код более читабельным. Если в условии есть блок
else[ if], с более чем одной строкой, то скобки нужно ставить во всех блоках.

// Хорошо                // Хорошо                // Плохо
function fn(arg) {       function fn(arg) {       function fn(arg) {    
  if (!arg) return;        if (arg)                 if (arg)  
  doFn();                    doFnWith(arg);           doFnWith(arg);
}                        }                          else {
                                                      doFn();
                                                      doSomthingElse();
                                                    } 
                                                  }
-----------------------

Правила именования модульных файлов:

* Если модуль экспортирует несколько ф-ций, то название файла может быть во
множественном числе либо называться как объект (пространство имен).

* Если модуль экспортирует только одну ф-цию по умолчанию, то файл может называться
глаголом. Название может быть как прямое, так и обратное (load-gltf.js и gltf-load.js).
В первом случае, предполагается что ф-ция используется как некое дополнение к основному
модулю, а во втором - что она и есть основной модуль (при импорте ф-ции из файла 
gltf-load.js её название должно быть просто load, без gltf; приставка - это
что-то вроде пространства имен, в этом случае).

* Файлы модулей со смешаными экспортом могут именоваться названием дефолт. экспорта.

-----------------------

Замыкания чаще всего нужны в 3х ситуациях:

1) При использовании колбеков.

2) Вместо invokable-класса (т.е. класса с инициализацией и одним методом) 
Создается ф-ция, которая возвращает другую ф-цию. Внешняя ф-ция будет вместо констурктора, 
а возвращаемая - выполнять основное действие. Внешняя ф-ция также называется 
ф-цией высшего порядка, а возвращаемая ф-ция - замыканием.

3) При реализации паттерна "модуль".

-----------------------

[X] Структура кода для однофайлового проекта (паттерны: "модуль" + "объектный литерал").

** Нужно также отметить, что объектные литералы здесь, это не просто объекты с методами, 
а пространства имен. И чтобы это подчеркнуть, лучше обращаться ко всем их членам через ссылку 
на объект, а не через this. А чтобы такое обращение было более логичным, вместо методов 
можно использовать стрелочные ф-ции, у которых нет своего this.

(() => {
  
  const util = () => new Date();
  
  const wgt = {
    opts: [],
    someValue: 0,
    
    Widget: (() => {
      const value = 23;   
      const fn = name => `Hello ${name} ${value}`;
      
      const Inner = class {
        constructor(widget) { this.widget = widget; }
        getMsg() { return fn(this.widget.name); }
      };
      
      return class {
        constructor(name) { this.name = name; }
        
        printMsg() {
          const inner = new Inner(this);
          console.log(inner.getMsg());
        }
      };
    })(),
    
    MyEvent: class extends CustomEvent {},
    ClassWithoutPrivateData: class {},
    
    // ** Стрелочная ф-ция вместо метода   
    create: () => {
      if (wgt.someValue > 0)
        throw new Error('Some error');
      
      return new wgt.Widget('CheckBox');
    }
  };
  
  wgt.Menu = (() => {
    // Большие классы лучше размещать в доп. локальном пространстве
    return class extends wgt.Widget {
      constructor(name, type) {
        super(name);
        this.type = type;
      }
      
      printMsg() {
        super.printMsg();
        console.log(`My type is ${this.type}`);
      }
    }
  })();
  
  const widget = wgt.create();
  widget.printMsg();
  
  const widget2 = new wgt.Menu('foo', 'bar');
  widget.printMsg();
  
  console.log(util());
  
})();

-----------------------

При определении ф-ции, если у нее только один параметр, то подойдут общие названия: 
findIndexOf(node), createBy(tag) и т.п. Если у ф-ции несколько параметров, то названия 
лучше уточнять: findIndexOfNode(node, value), creatByTag(tag, opts)

-----------------------

Статические методы бывают очень полезны, когда требуется вспомогательный ф-ционал 
для конкретного класса (чтобы не плодить утилиты):

class Tooltip {
  static targetTag = 'sub';    

  constructor() { ... }
  open() { ... }
  close() { ... }

  static findTargets(range) {
    return nodeUtil.findNodesInRange(
      range, node => node.tag === Tooltip.targetTag);
  }
}

-----------------------

Если из коллбека требуется вернуть значение, то лучше предварительно присвоить его 
в описательную переменную. Иначе может быть непонятно, что возвращать.

respondWith(() => {
  const cache = await caches.open(CACHE_NAME);
  const cachedResponse = await cache.match(requestUrl);  // переменная cachedResponse поясняет, что нужно
  return cachedResponse;                                 // вернуть из коллбека, т.к. здесь непонятно,
});                                                      // что даёт cache.match()

Тоже самое касается и деструктуризации. Если названия свойств не соответсвуют 
вызываемому контексту, то лучше просто использовать описательную переменну.

const { url } = e.cacheRequest;  // Плохо, т.к. вызываемый контекст предполагает работу с кэшем. 
                                 // Здесь будет непонятно, что это за url 

const cachedUrl = e.cacheRequest.url; // Лучше без деструктуризации.

-----------------------

Названия переменных и названия ф-ций могут дополнять друг-друга. 
Чтобы контекст происходящего был описан еще лучше...

-----------------------

Статические классы - это особенность ООП-языков, которая имитирует процедурный подход, 
когда нужно чтобы ф-ции были доступны для вызова напрямую и не акцентировались на объектах.

-----------------------

Приватные свойства класса не следует отрывать от класса. Лучше, чтобы они были внутри него. 
При этом методы выносить можно, в этом случае они могут считаться просто утилитами.

const MyClass = (() => {
  let _offset = 0; // Так лучше не делать!
  const calcOffset = () => {};  // Нормально

  return class {
    constructor(app, offset) {
      this.app = app;
      _offset = offset;
    }
  };
})();

-----------------------

Для реализации синглтона хорошо подходит паттерн "модуль" в связке с IIFE. При этом, 
лучше ничего не объявлять внутри возвращаемого объекта, а передать ему уже готовые данные.

const singleton = (() => {
  let publicProp, privateProp;

  const init = (_publicProp, _privateProp) => {
    publicProp = _publicProp;
    publicProp = _privateProp;
  };

  const fn = (() => {
    const innerVar = 0;
    const innerFn = () => {};

    return (arg, arg2) => {
      ...
    };
  })();

  return { publicProp, init, fn };
})();

Для реализации пространства имен подойдет обычный литерал объекта. 
Но если в пространстве имеются классы, то их лучше вынести из объектного литерала, 
а само пространство имен организовать через IIFE.

const ns = { 
  data: [],
  fn1: () => {},
  fn2: (arg) => {},
};

const ns = (() => {
  const Plugin = class {};
  const ExtendedPlugin = class extends Plugin {};
  return { 
    data: [], 
    fn: () => {},
    Plugin,
    ExtendedPlugin,  
  };
})();

При использование ES6-модулей, пространство имен определяется так:

import * as ns from './my-module.js';
const plugin = new ns.Plugin();
ns.fn(plugin);

-----------------------

Dependency Injection следует использовать только в контексте той системы, 
которая его предоставляет (например для приложений на Angular - этот контекст может 
ограничиваться компонентами и сервисами, но не third-party библиотеками).

Не нужно пытаться создавать все аспекты приложения с использованием DI только потому, 
что ядро или фреймворк предоставляет такую возможность. Thrid-party библиотеки, утилиты 
и более низкоуровневый функционал (который не относится к доменной области приложения) 
могут реализовываться как угодно под капотом.

-----------------------

Иногда бывает сразу неочевидно, как лучше назвать ту или иную ф-цию/переменную/класс, 
Это происходит из-за того, что нет четкого понимания, что конкретно должно выполняться.

В этом случае сначала нужно дать самое примитивное название, а уже после, поэтапно проработав
весь необходимый функионал, уже придумывать наиболее подходящее название (поскольку в
процессе можно придумать более интересную реализацию).

-----------------------

Компоненты в различных frontend-фреймворках лучше воспринимать по такой же логике, как
задумано в web-components. Т.е. компонент - это какой-то виджет, где есть хотя бы небольшая
разметка и логика. А вот обертки вогруг стандартных html-элементов, которые необходимы только
для инкапсуляции стилей (<button> --> <AppButton>) лучше не делать, т.к. особой пользы это 
не принесет, а только усложнит навигацию по проекту (большим кол-вом "глупых компонентов")

Cтили для стандартных элементов лучше оставлять в глобальном файле или в отдельном theme.css.
И если понадобиться их заменить, то можно просто подгрузить другой файл стилей.

