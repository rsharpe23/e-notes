Согласнно принципу "единственной ответсвенности" SOLID, наследование лучше применять
тогда, когда производный класс расширяет ответсвенность базового класса. Если производ.
класс привносит новую ответсвенность, то в этом случае нужно использовать композицию.

Допустим если класс, предназначенный для перемещения по сцене (это его ответсвенность),
то у него также могут быть производные классы, дополняющие эту ответсвенность 
новыми методами перемещения, поворота и т.д.

Но если классу нужны другие действия, не относящиеся к перемещению, например выбор по
клику, то это уже другая ответсвенность, и она не должна реализ. производными классами.

-----------------

Разработку через интерфейсы следует вести тогда, когда у класса есть иерархия.
В этом случае с помощью базового интерфейса можно будет всегда добавлять ответвления
для основной иерархии (т.е. делать композицию).

-----------------

Названия переменных должны быть максимально информативны. Их названия должны говорить
не только о том, что они хранят, но и то, для какого контекста это все нужно. 
Тоже самое справедливо и для названий ф-ций.
...
const dirLength = calcLength( calcDiff(vec1, vec2) );  -->  НЕПРАВИЛЬНО!

const calcDist = (vec1, vec2) => calcLength( calcDiff(vec1, vec2) );
const distToDragPos = calcDist(vec1, vec2);  -->  ПРАВИЛЬНО!

-----------------

Вместо private static методов лучше использовать вспомогательные ф-ции, объявленные вне
класса (но, в том же контексте). В тех языках, где нельзя создавать ф-ции отдельно от
классов, можно использовать дополнительные классы-хелперы для этого.

-----------------

При разработке спрашивать себя - "а для чего конкретно здесь нужен этот ф-ционал".
Возможно он не пренадлежит данному контексту и его лучше вынести в другое место.

-----------------

Ф-ция должна выполнять исключительно ту работу, для которой она предназначена. 
Если, помимо основного ф-ционала, имеются какие-то подготовительные действия, 
то ф-цию нужно разбить на несколько частей. 
...
function process(arg) {
  const concreate = getConcrete(arg);
  doProcess(concrete);
}

function doProcess(concrete) {
  // Весь основной ф-ционал выполняется здесь, вокруг пар-ра concrete, 
  // а получение этого пар-ра - это подготовительные действия.
}

В языках со статической типизацией можно использовать перегрузку ф-ций.

-----------------

При итерации, если коллекция имеет абстрактное название, то элемент лучше называть
"it" или "item". Если же у коллекции конкретное название, то и название элемента
также должно быть конкретным:
...
list.map(it => it.id);
disks.map(disk => disk.id);

-----------------

