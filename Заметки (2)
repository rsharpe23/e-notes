Согласнно принципу "единственной ответсвенности" SOLID, наследование лучше применять
тогда, когда производный класс расширяет ответсвенность базового класса. Если производ.
класс привносит новую ответсвенность, то в этом случае нужно использовать композицию.

Допустим если класс, предназначенный для перемещения по сцене (это его ответсвенность),
то у него также могут быть производные классы, дополняющие эту ответсвенность 
новыми методами перемещения, поворота и т.д.

Но если классу нужны другие действия, не относящиеся к перемещению, например выбор по
клику, то это уже другая ответсвенность, и она не должна реализ. производными классами.

-----------------------------------

Разработку через интерфейсы следует вести тогда, когда у класса древовидная иерархия.
В этом случае с помощью базового интерфейса можно будет добавлять ответвления
от основной иерархии (т.е. делать композицию).

-----------------------------------

Названия переменных должны быть максимально информативны. Их названия должны говорить
не только о том, что они хранят, но и то, для какого контекста это все нужно. 
Тоже самое справедливо и для названий ф-ций.
...
// Это неправильно!
const dirLength = calcLength( calcDiff(vec1, vec2) );  

// Надо делать так
const calcDist = (vec1, vec2) => calcLength( calcDiff(vec1, vec2) );
const distToDragPos = calcDist(vec1, vec2);  

-----------------------------------

Вместо private static методов лучше использовать вспомогательные ф-ции, объявленные вне
класса (но, в том же контексте). В тех языках, где нельзя создавать ф-ции отдельно от
классов, можно использовать дополнительные классы-хелперы для этого.

-----------------------------------

При разработке всегда спрашивай себя - "а для чего конкретно здесь нужен этот ф-ционал?"
Возможно он не пренадлежит данному контексту и его лучше вынести в другое место.

-----------------------------------

Ф-ция должна выполнять исключительно ту работу, для которой она предназначена. 
Если, помимо основного ф-ционала, имеются какие-то подготовительные действия, то 
ф-цию нужно разбить на несколько частей. 
...
function process(arg) {
  const concreate = getConcrete(arg);
  _process(concrete);
}

function _process(concrete) {
  // Весь основной ф-ционал выполняется здесь, вокруг пар-ра concrete, 
  // а получение этого пар-ра - это подготовительные действия.
}

В языках со статической типизацией можно использовать перегрузку ф-ций.

-----------------------------------

При переборе, если коллекция имеет абстрактное название, то элемент лучше называть
"item". Если же у коллекции конкретное название, то и название элемента
также должно быть конкретным.
...
list.map(item => item.id);
disks.map(disk => disk.id);

Название "it" используется для именования итераторов.

-----------------------------------

(C++) Ключевое слово var/auto (и т.п.) может использоваться не только как сокращение, 
когда известна правай часть инициализации, но и когда тип имеет большую вложенность:
...
MyClass1.MySubClass.Inner value = getValue();
var value = getValue();  // можно написать и так

-----------------------------------

Web Api лучше оформлять как любой другой Api:
api.post('/products', data, cb)  -->  shop.buyProducts(products, cb).

-----------------------------------

А если у ф-ции длинное название, то параметры лучше начинать с новой строки.
...
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height,
  0, gl.RGBA, gl.UNSIGNED_BYTE, null);

gl.framebufferRenderbufferAndAnotherAction(
  gl.TEXTURE_2D, 0, gl.RGBA, 
  width, height, 0, gl.RGBA, 
  gl.UNSIGNED_BYTE
);

-----------------------------------

Если название переменной состоит только из одного слова, то его желательно записывать
полностью (если оно не длинное или не очевидно под сокращением). Если же название
состоит из нескольких слов, то их можно сокращать. Названия ф-ций, а тем более 
классов, лучше вообще не сокращать.
...
const position = [0, 1, 0];
const attrPos = 23;

-----------------------------------

Если внутри ф-ции создается какой-то объект непосредственно, то его название должно
иметь префикс create, а если объект создается с пом. вспомогательной ф-ции, тогда 
get (если только ф-ция не является перегрузкой другой ф-ции).
...
function createObject() {
  return { index, name, value };
}

function getObject() {
  return createObject();
}

Обычно ф-ции с префиксом get имеют более высокую абстракцию.

-----------------------------------

Литерал объект подойдет, когда нужен синглтон, который не зависит от внешних данных.
Если же нужна предварительная инициализация, то лучше использовать класс.

-----------------------------------

Если аббревиатура идет в начале слова, то её можно записывать 
в нижнем регистре, а если в конце - то в верхнем:
...
function urlToPath() {}
function getURL() {}

-----------------------------------

Если есть набор ф-ций с одинаковым параметром (например Web API), то вместо того, 
чтобы создавать класс, можно просто сгруппировать их через ф-цию обертку.
...
export default value => {
  return {
    fn1() { process1(value); },
    fn2() { process2(value); },
  };
};

-----------------------------------

Объектный литерал должен использоваться только как пространство имен. 
Он не должен заменять собой синглтон с методом init().
...
// Это неправильно! Если нужна инициализация, 
// то нужо использовать класс
const Plugin = {
  init(data) {},
};

// Нужно делать так
const myProject = { 
  data: [],
  Plugin: class {},
  staticFn() {},
};

-----------------------------------

Если требуется зависимость для одной из ф-ций, которые сгруппированы в объекте без состояния (например Web API или утилиты), то её/их можно передавать через параметры:
...

// Это неправильно!
import module from 'my-module';
export default {
  fn1() {}  // только эта ф-ция использует модуль
  fn2() {}
};

// Нужно делать так
export default {
  fn1(module) {},
  fn2() {},
};

-----------------------------------

Если название ф-ции во множественном числе, но при этом ф-ция не возвращает 
коллекцию, то к названию нужно добавлять постфикс "Of":
...
getNumComponents --> getNumComponentsOf  // возвращает кол-во компонентов

-----------------------------------

Иногда можно выносить часть логики во внешний контекст:
...

// Нормально
function fn(meshes, data) {
  const meshProvider = new MeshProvider(data);
  return meshes.map(mesh => meshProvider.getMesh(mesh));
}

// Так лучше
function fn(meshes, meshProvider) {
  return meshes.map(mesh => meshProvider.getMesh(mesh));
}

