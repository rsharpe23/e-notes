Мои основные правила работы таковы:

Всегда спрашивай себя - "а для чего конкретно здесь нужен этот ф-ционал?" 
Возможно он не пренадлежит данному контексту и его лучше вынести в другое место.

Если что-то упорно не удается реализовать, значит основная идея неверна. 
Нужно попытаться найти альтернативное решение.

Выразительные имена нужно придумывать после реализации логики, а не перед. Т.к. на
этапе реализации логика может измениться и имена будут искажать актуальные намерения.

-----------------------

Согласнно принципу "единственной ответсвенности" SOLID, наследование лучше применять
тогда, когда производный класс расширяет ответсвенность базового класса. Если производ.
класс привносит новую ответсвенность, то в этом случае нужно использовать композицию.

Допустим если класс, предназначенный для перемещения по сцене (это его ответсвенность),
то у него также могут быть производные классы, дополняющие эту ответсвенность 
новыми методами перемещения, поворота и т.д.

Но если классу нужны другие действия, не относящиеся к перемещению, например выбор по
клику, то это уже другая ответсвенность, и она не должна реализ. производными классами.

-----------------------

Разработку через интерфейсы следует вести тогда, когда у класса древовидная иерархия.
В этом случае с помощью базового интерфейса можно будет добавлять ответвления
от основной иерархии (т.е. делать композицию).

-----------------------

Названия переменных должны быть максимально информативны. Их названия должны говорить
не только о том, что они хранят, но и то, для какого контекста это все нужно. 
Тоже самое справедливо и для названий ф-ций.

// Это неправильно!
const dirLength = calcLength( calcDiff(vec1, vec2) );  

// Надо делать так
const calcDist = (vec1, vec2) => calcLength( calcDiff(vec1, vec2) );
const distToDragPos = calcDist(vec1, vec2);  

-----------------------

Вместо private static методов лучше использовать вспомогательные ф-ции, объявленные 
вне класса (но, в том же контексте). В тех языках, где нельзя создавать ф-ции отдельно
от классов, можно использовать дополнительные классы-хелперы.

-----------------------

Ф-ция должна выполнять исключительно ту работу, для которой она предназначена. 
Если, помимо основного ф-ционала, имеются какие-то подготовительные действия, то 
ф-цию нужно разбить на несколько вариантов. 

function process(arg) {
  const concreate = getConcrete(arg);
  _process(concrete);
}

function _process(concrete) {
  // Весь основной ф-ционал выполняется здесь, вокруг пар-ра concrete, 
  // а получение этого пар-ра - это подготовительные действия.
}

В языках со статической типизацией можно использовать перегрузку ф-ций.

-----------------------

При переборе, если коллекция имеет абстрактное название, то элемент лучше называть
"item". Если же у коллекции конкретное название, то и название элемента
также должно быть конкретным.

list.map(item => item.id);
disks.map(disk => disk.id);

Название "it" используется для именования итераторов.

-----------------------

[C++] Ключевое слово var/auto (и т.п.) может использоваться не только как сокращение, 
когда известна правай часть инициализации, но и когда тип имеет большую вложенность:

MyClass1.MySubClass.Inner value = getValue();
var value = getValue();  // можно написать и так

-----------------------

WebApi лучше оформлять как и любой другой api:

webApi.post('/products', data, cb); // нормально
shop.buyProducts(products, cb);     // лучше

-----------------------

А если у ф-ции длинное название, то параметры лучше начинать с новой строки.

gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height,
  0, gl.RGBA, gl.UNSIGNED_BYTE, null);

gl.framebufferRenderbufferAndAnotherAction(
  gl.TEXTURE_2D, 0, gl.RGBA, 
  width, height, 0, gl.RGBA, 
  gl.UNSIGNED_BYTE
);

При выполнении цепочки вызовов, ф-ции лучше выравнивать по одному уровню. Но если цепочка 
вызовов используется как возвращаемое значение, то достаточно одного отступа.

node.querySelector('.title')
    .formatText(typesMap[type])
    .formatText(words[0], words[1]);

// Из-за return и const придется делать слишком отступов

return node.querySelector('.title')
  .formatText(typesMap[type])
  .formatText(words[0], words[1]);

const newNode = node.querySelector('.title');
  .formatText(typesMap[type])
  .formatText(words[0], words[1]);

По возможности лучше вообще избегать цепочек вызовов, т.к. их сложнее отлаживать.

// Плохо
return Object.keys(obj).findIndex(k => k === key);

// Хорошо
const keys = Object.keys(obj);
const index = keys.findIndex(k => k === key);
return index;

-----------------------

Если название переменной состоит из одного слова, то его желательно записывать
полностью (если оно не длинное или не многоизвестно в сокращенном виде). Если же
название состоит из нескольких слов, то их можно сокращать. Названия ф-ций, 
а тем более классов, сокращать не нужно.

const position, attr, val, callback, proxyCb;

Если в одном контексте есть несколько переменных, в названиях которых присутсвуют 
общие слова, то лучше чтобы они были одинаковыми (если слово сокращено в одной
переменной, то и в других лучше сократить и наоборот)

const position, relativePos;  // плохо
const position, relPosition;  // лучше сократить relative

-----------------------

Если ф-ция создает новый объект, то в её имени должен быть префикс create.
Если ф-ция получает уже существующий объект или находит его, то get/find соответсвенно.

-----------------------

Если аббревиатура идет в начале слова, то её можно записывать в нижнем регистре, 
а если в конце - то в верхнем. При этом, длинную аббревиатуру (более 2х символов) 
лучше записывать через camelCase, даже если она в конце.

function urlToPath() {}
function getIO() {}
function createBlob() {}

-----------------------

Объектный литерал может использоваться не только как синглтон, но и как пространство
имен. Он не должен использоваться, если нужна предварительная инициализация.

// Это неправильно! Если требуется инициализация, 
// то нужо использовать класс
const Plugin = {
  init(data) {},
};

// Нужно делать так
const myModule = { 
  data: [],
  Plugin: class {},
  staticFn() {},
};

При использование ES6-модулей, пространство имен определяется так:

import * as myModule from './module1.js';
const plugin = new myModule.Plugin();

-----------------------

Чтобы ф-ции утилит не требовали импорта зависимостей, они должны проектироваться 
через колбэки или с зависимостями в параметрах:

// Нормально
import module from 'my-module';
export function fn1() {}  // эта ф-ция использует модуль
export function fn2() {} 

// Так лучше
export function fn1(module) {}  // вместо модуля может быть колбэк 
export function fn2() {}

-----------------------

Во множественном числе лучше именовать каталоги, а не файлы. При этом, если в файле
определены ф-ции, то он также может именоваться во множественном числе.

mat-util.js // экспортирует только одну сущность (объект или класс)
utils.js    // экспортирует одну или несколько ф-ций

-----------------------

Если название ф-ции во множественном числе, но при этом ф-ция не возвращает 
коллекцию, то к названию можно добавить окончание "Of":

getNumComponents --> getNumComponentsOf  // возвращает кол-во компонентов

-----------------------

Иногда можно выносить часть логики во внешний контекст:

// Нормально
function fn(meshes, data) {
  const meshProvider = new MeshProvider(data);
  return meshes.map(mesh => meshProvider.getMesh(mesh));
}

// Так лучше
function fn(meshes, meshProvider) {
  return meshes.map(mesh => meshProvider.getMesh(mesh));
}

-----------------------

Provider - это некая абстракция для экранирования какого-то большого класса.

class GLUtil {
  createShader() {}
  setVertexAttr() {}
  getBuffer(data, target) {}
}

function createBuffer(data, bufferProvider) {
  return bufferProvider.getBuffer(data, gl.ARRAY_BUFFER);
}

const buffer = createBuffer(myData, glu);

-----------------------

Названия локальных стрелочных ф-ций могут быть без префикса get/create.
Колбеки можно именовать через префикс on*. Название callback можно использовать 
если имя метода совпадает с именем колбека.

const buffer = (gl, store) => { ... } 
function fn(obj, onClick) { ... }      // onClick вместо callback
function traverse(callback) { ... }    // callback вместо onTraverse

-----------------------

Если метод класса возвращает поле класса, то это должно быть свойство:

get matrix() {
  if (this.parent) {
    mat4.mul(this._matrix, this.parent.matrix, this._matrix);
  }

  return this._matrix;
}

-----------------------

В последнее время, вместо function declaration модно определять стрелочные ф-ции.
Скорей всего это пошло из-за работы с es-модулями. Так, например, если модуль имеет
всего одну ф-цию, то её можно экспортировать по умолчанию, а для этого нужно использ.
либо стрелочну ф-цию, либо function expression. Но поскольку в новом синтаксисе первое
заменяет второе, то чтобы не смешивать разные способы определения, видимо и было
принято такое внегласное решение, среди комьюнити, определять все ф-ции в одном стиле.

-----------------------

Композиция в основном используется тогда, когда в системе есть уже созданные объекты 
и их нужно как-то расширить. Если же обьекты можно создавать самому, то подойдет и
обычное наследование. Также композиция используется тогда, когда нужно сделать
ответвление от основной иерархии наследования.

-----------------------

Утилиты - это набор вспомогательных ф-ций, реализующих дополнительные
возможности в контексте какого-то компонента.

API - это набор утилит (состоящий как из ф-ций, так и классов), для управления
программой, файлом, системой и т.п. (может быть частью утилит): 

// API группирует файлы (без index-файла)
gltf-api
  gltf-parser 
  gltf-adapt.js
  gltf-loader.js

-----------------------

Через this лучше обращаться к тем свойствам, которые требуют изменения состояния:

// Плохо
setLocations() {
  this.a_Position = this.gl.getAttribLocation(this.target, "a_Position");
  this.a_Normal = this.gl.getAttribLocation(this.target, "a_Normal");
}

// Лучше
setLocations() {
  const { gl, target } = this;
  this.a_Position = gl.getAttribLocation(target, "a_Position");
  this.a_Normal = gl.getAttribLocation(target, "a_Normal");
}

// Хорошо
setLocations({ gl, target }) {
  this.a_Position = gl.getAttribLocation(target, "a_Position");
  this.a_Normal = gl.getAttribLocation(target, "a_Normal");
}

-----------------------

Если условие (или цикл) состоит всего из одной строки, то его можно записать без
фигурных скобок. Такая запись делает код более читабельным. Если в условии есть блок
else[ if], с более чем одной строкой, то скобки нужно ставить во всех блоках.

// Хорошо                // Хорошо                // Плохо
function fn(arg) {       function fn(arg) {       function fn(arg) {    
  if (!arg) return;        if (arg)                 if (arg)  
  doFn();                    doFnWith(arg);           doFnWith(arg);
}                        }                          else {
                                                      doFn();
                                                      doSomthingElse();
                                                    } 
                                                  }
-----------------------

Правила именования модульных файлов:

* Если модуль экспортирует несколько ф-ций, то название файла может быть во
множественном числе либо называться как объект (пространство имен).

* Если модуль экспортирует только одну ф-цию по умолчанию, то файл может называться
глаголом. Название может быть как прямое, так и обратное (load-gltf.js и gltf-load.js).
В первом случае, предполагается что ф-ция используется как некое дополнение к основному
модулю, а во втором - что она и есть основной модуль (при импорте ф-ции из файла 
gltf-load.js её название должно быть просто load, без gltf; приставка - это
что-то вроде пространства имен, в этом случае).

* Файлы модулей со смешаными экспортом могут именоваться названием дефолт. экспорта.

-----------------------

Бывают ситуации когда в пространстве имен нужно объявить ф-цию с доп. ф-циями. Это можно сделать 
либо создав локальные ф-ции внутри основной, либо расширить основную ф-цию как объект.
Второй вариант предпочтительнее, если нужна оптимизация.

const ns = {

  fn() {
    // Создастся объект лок. ф-ции, и удалиться после выполнения основной
    const innerFn = () => {};
    innerFn();  
  },

  // Использовать function expression предпочтетельнее стрелочной ф-ции 
  // т.к. это более короткая форма доступа к локальным ф-циям

  fn2: Object.assign(function f() {
    f.locFn();
  }, {
    innerFn() {
      this.innerFn() // Если нужна рекурсия, обращаемся через this        
    }
  }),

};

-----------------------

Замыкания чаще всего нужны в 3х ситуациях:

1) При использовании колбеков.

2) Вместо invokable-класса (класса с одним методом) создается ф-ция, которая возвращает 
другую ф-цию; внешняя ф-ция будет вместо констурктора, а возвращаемая - выполнять основное действие.

3) При реализации паттерна "модуль".

-----------------------

Структура кода для однофайлового проекта (паттерн "модуль" + "объектный литерал"):

(() => {
  
  const util = () => new Date();
  
  const wgt = {
    opts: [],
    someValue: 0,
    
    Widget: (() => {
      const value = 23;      
      const fn = name => `Hello ${name} ${value}`;
      
      const Inner = class {
        constructor(widget) { this.widget = widget; }
        getMsg() { return fn(this.widget.name); }
      };
      
      return class {
        constructor(name) { this.name = name; }
        
        printMsg() {
          const inner = new Inner(this);
          console.log(inner.getMsg());
        }
      };
    })(),
    
    MyEvent: class extends CustomEvent {},
    ClassWithoutPrivateData: class {},
    
    create() {
      if (wgt.someValue > 0)
        throw new Error('Some error');
      
      return new wgt.Widget('CheckBox');
    }
  };
  
  wgt.Menu = (() => {
    // Большие классы лучше размещать в доп. локальном пространстве
    return class extends wgt.Widget {
      constructor(name, type) {
        super(name);
        this.type = type;
      }
      
      printMsg() {
        super.printMsg();
        console.log(`My type is ${this.type}`);
      }
    }
  })();
  
  const widget = wgt.create();
  widget.printMsg();
  
  const widget2 = new wgt.Menu('foo', 'bar');
  widget.printMsg();
  
  console.log(util());
  
})();

-----------------------

При переопределении ф-ции, если у нее только один параметр, то подойдут общие названия: 
findIndexOf(node), createBy(tag) и т.п. Если у ф-ции несколько параметров, то название 
лучше уточнять: findIndexOfNode(node, value), creatByTag(tag, opts)

