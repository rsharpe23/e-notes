ОСНОВЫ QT

Приложение должно начинаться с подключения хотя бы одного их следующих модулей: 
QtCore, QtGui, QtWidgets. Но обычно подключают только QtWidgets.

Далее необходимо создать объект класса QApplication. Он осуществяет управление
приложением. Для каждого приложения этот объект должен создаваться только один раз 
и до любых операций, связанных с пользовательским интерфейсом.

После создания этого объекта, необходимо вызвать его метод exec(). Он запустит цикл
обработки событий. Этот цикл передает получаемые от системы события на обработку. 
По завершении работы приложения, метод exec() возвращает код завершения.

Виджеты (элементы управления) не отображаются сразу после создания. 
Для их отображения нужно использовать метод show().

Пример минимального приложения:
...
#include <QtWidgets>

int main(int argc, char** argv) 
{
    QApplication app(argc, argv);

    QLabel label("Hello!");  --> виджет
    label.show();

    return app.exec();  
}

Библиотека Qt разбита на модули:
* QtCore - модуль ядра, состоящий из классов, не связанных с GUI;
* QtGui - модуль базовых классов для работы с GUI и OpenGL; 
* QtWidgets - модуль, дополняющий QtGui виджетами и хранящий QApplication;
* QtQuick - модуль, содержащий фреймворк для быстрого создания GUI;
* QtQML - модуль, содержащий движок для языков QML и JS;
* QtNetwork - модуль для работы с сетью;
* QtSql - модуль для работы с базами данных;
* QtSvg - модуль для работы с SVG
* QtXml - модуль поддержки XML, с классами относящимися к SAX и DOM;
* QtXmlPatternts - модуль поддержки XPath, XQuery, XSLT и XmlShemaValidator;
* QtMultimedia - модуль классов для работы со звуком, видео, камерой, радио и т.п.;
* QtMultimediaWidgets - модуль виджетов для QtMultimedia;
* QPrintSupport - модуль для работы с принтером;
* QtTest - модуль для тестерования кода.

Для каждого модуля предоставляется отдельный заголовочный файл. Название такого файла
всегда соответсвует названию самого модуля, например: #include <QtGui>

Модуль QtCore является базовым для всех других модулей. Он позволяет реализовывать
приложения без GUI, например консольные приложения.

Модули QtQuick и QtQML - это альтернатива виджетам. Они предоставляют набор технологий
для быстрой и современной разработки графических приложений на QML и JS.

Допольнительные модули:
* QtWebEngineCore - интегрирует в приложение возможности веб;
* QtWebEngineWidgets - удобные виджеты для веб;
* Qt3D - модуль для упрощенной работы с 3d графикой;
* QtBluetooth - модуль для работы с Bluetooth;
* QtLocation - модуль для работы с геолокацией и местоположением;
* QtSensors - обеспечивает доступ к сенсорам моб. устройств и акселерометрам;
  поддерживает такие платформы, как: Android, iOS, SailFish, WinRT;
* QtCharts - модуль для отображения графиков;
* QtDataVisialization - модуль для отображения графиков в 3d;
* QtVirtualKeyboard - виртуальная клавиатура для настольных компьютеров;
* QtRemoteObjects - модуль для межпроцессного взаимодействия (IPC), 
  обеспечивающий обмен информацией между приложениями;

Пространство имен Qt содержит ряд перечислений и констант, которые часто применяются
при работе. Подключить его можно так: using namespace Qt.

Qt расширяет C++ дополнительными ключевыми словами. Делает он это с помощью MOC. 
MOC (метаобъектный компилятор) - это прероцессор, который анализирует классы на наличие
в них специального макроса Q_OBJECT и дополняет их отдельными cpp-файлами, содержащими
реализацию по замене ключевых слов на понятный для компилятора код (метаинформация). 

Cpp-файлы с метаинформацией называются так: moc_<filename>.cpp

Если классу не требуется метаинформация, то этот макрос можно не внедрять. 
А если он есть, тогда должен стоять в самом начале, раньше всех других макросов.

Qt полностью построен на классах. Базовым классом для всех объектов является QObject.
Объекты типа QObject и его наследники предоставляет поддержку:

* сигналов и слотов;
* таймера;
* механизма объединения объектов в иерархии;
* событий и их фильтрации;
* организации объектных иерархий;
* метаобъекной информации;
* приведения типов;
* свойств.

Объекты QObject в основном располагаются в иерархии. Такой подход позволяет не
беспокоится об освобождении памяти, после их создания. Механизмы Qt будут 
делать это автоматически. 

Конструктор класса QObject имеет вид: QObject(QObject* pobj = 0);
Это означает что каждый объект хранит указатель на своего предка в иерархии.

Все объекты QObject (особенно те, что имеют предков) должны создаваться через new,
иначе нарушится механизм автоматического освобождения памяти.
...
QObject* pobj1 = new QObject();
QObject* pobj2 = new QObject(pobj1);
QObject* pobj3 = new QObject(pobj2);

При множественном наследовании нужно помнить, что QObject должен всегда стоять первым,
иначе MOC неправильно распознает класс и будет ошибка компиляции. Кроме того, нельзя
наследоваться сразу от нескольких классов, которые наследуют QObject.

Все объекты типа QObject и их наследники хранят метаобъектную информацию (см. выше). 
В ней хранится информация о сигналах и слотах, о классе и о наследовании. 
Получить доступ к ней можно с помощью метода metaObject().
...
pobj->metaObject()->className();
pobj->inherits("QWidget");

Свойства в Qt - это поля, у которых есть вспомогательные методы доступа.
Они широко применяются в визуальной среде разработки интерфейсов Qt Designer.

Свойства задаются с помощью макроса Q_PROPERTY:
Q_PROPERTY(type name READ getter [WRITE setter RESET resetFn DESIGNABLE bool 
    SCRIPTABLE bool STORED bool])

class MyClass : public QObject 
{
Q_OBJECT
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

private:
    bool m_readOnly;

public:
    MyClass(QObject* pobj = 0) : QObject(pobj), m_readOnly(false)

public:
    bool isReadOnly() { return m_readOnly; }
    void setReadOnly(bool value) { m_readOnly = value; }
};

pobj->setProperty("readOnly", true);
bool readyOnly = pobj->property("readOnly").toBool();

Механизм сигналов и слотов необходим для обработки событий от GUI, а также для связи
виджетом. Раньше, вместо них использовались колбеки. Концепция колбеков устарешая, 
но она лежит в основе WinAPI, который построен на процедурном стиле. 

Многие разработчики, при разработке под Windows, используют библиотеку MFC. 
Она немного облегчает разработку, добавляя классы.

Сигналы и слоты можно соединять в любой точке приложения. Сигнал можно соединять с
любым кол-во слотов и наоборот, слот может получ. сообщения от любого кол-ва сигналов.

Сигналы определяются в классе как обычные методы, но без реализации. Реализацию берет
на себя MOC. Также методы сигналов должны возвращать void. Послать сигнал можно 
с помощью ключевого слова emit.

class MyClass1 : public QObject
{
    Q_OBJECT
    
public:
    void sendMessage() { 
        emit mySignal("hello"); 
    }

signals:
    void mySignal(QString&);
};

Слоты - это методы, обрабатывающие сигналы. Если требуется, чтобы слот реагировал
только на сигналы, но при этом был не доступен для вызова как обычный метод, 
то его нужно объявлять с модификатором private либо protected.

Слоты могут быть виртуальными, но соединение таких слотов с сигналами медленное.
В слотах нельзя использовать параметры по умолчанию или определять их статическими.
Внутри слота вызовом метода sender() можно узнать, от какого объекта был вызван сигнал.

class MyClass2 : public QObject
{
    Q_OBJECT

public slots:
    void mySlot(QString& msg) {
        cout << msg << sender()->objectName();
    }
};

Соединение сигналов со слотами осуществл. с пом. статич. метода connect().
Методу connect() передаются следующие параметры:

* sender - объект, отправляющий сигнал;
* signal - прототип сигнала, заключенный в макрос SIGNAL();
* receiver - объект, имеющий слот для обработки сигнала;
* slot - прототип слота, заключенный в макрос SLOT();
* type - режим обработки сигнала;

int main() 
{
    QApplication app();

    MyClass1 a;
    MyClass2 b;

    QObject::connect( 
        &a, SIGNAL(mySignal(QString&)),  -->  слот может игнорир. парам. сигнала
        &b, SLOT(mySlot(QString&))            т.е. можно так: SLOT(mySlot()) 
    );
    a.sendMessage();

    return app.exec();
}

Если слот не делает ничего, кроме проброски полученного сигнала дальше, то
можно вообще обойтись без него и просто соединить друг с другом только сигналы.

Метод connect возвращает объект Connection. Его можно привести к типу bool, если
требуется проверить, было ли соединение успешным.

При уничтожении объекта происходит автоматическое разъединение всех его сигнально-
слотовых связей. Но разъединение можно выполнить и вручную с пом. статического метода
QObject::disconnect(). Они принимает такие же параметры, что и connect().

Если нужно сократить кол-во слотов либо обрабатывать одним слотом разные сигналы, 
то можно воспользоваться классом QSignalMapper.

В Qt есть собственные примитивные типы данных: qint8, qlonglong и пр. (стр. 70).
Они нужны для того, чтобы абстрогироваться от особенностей той или иной архитектуры,
например qint64 где-то может быть __int64, а где-то long long.

В заголовочном файле <QtGlobal> содержатся полезные макросы и ф-ции:
* qMax(a, b) - максимальное число;
* qMin(a, b) - минимальное число;
* qAbs(value) - модуль числа;
* qRound(value) - округляет число;
* qBound(min, max, value) - значение между минимум и максимумом;
* qFuzzyCompare(a, b) - сравнивает вещественные значения. 

Компилятор ресурсов RCC внедряет сторонние ресурсы (картинки, файлы перевода и т.п.)
в иcполняемые модули, чтобы приложение могло обращаться к ним в рантайме.

Ресурсы описываются через XML, в специальных файлах с раширением ".qrc". Эти файлы 
добавляются в проект также, как и все остальные исходники (через CMake/QMake).
...
<!DOCTYPE RCC>
<qresource>
    <file>images/icon.png</file>
    <file>images/photo.jpg</file>
</qresource>
</RCC>

RCC парсит xml и создает на его основе cpp-файл, где данные представлены 
в виде одного большого массива. 

Получить доступ к ресурсу из кода, например к картинке, можно так:
plbl->setPixmap(QPixmap(":/images/photo.jpg"));

Структура Qt-проекта состоит из исходников в виде заголовочный файлов и файлов cpp.
Помимо исходников в нём также есть файл с расширением ".pro", из которого, 
через qmake, генерируется make-файл проекта. 

В make-файле содержится вызов MOC для создания доп. cpp-файлов с метаинформацией. 
Если в проекте есть qrc-файлы, то будут также созданы cpp-файлы с данными ресурсов. 
По итогу все исходники + доп. файлы компилируются в файлы объектного кода и
объединяются линковщиком в готовый испольняемый модуль (программу).

При отладке, полезно использовать методы dumpObjectInfo() и dumpObjectTree().
Они возвращают метаинформацию об объекте типа QObject или его иерархии.
Для облегчения отладки, всем объектам QObject нужно давать имена.

Помимо дамп-методов есть также методы для вывода форматированных сообщений: 
qDebug(), qWarning(), qFatal(). Они работают как cout, но учитывают особенности ОС.
А если нужно перенаправить их поток вывода, то здесь поможет qInstallMessageHandler().

Также, с помощью метода qInstallMessageHandler() можно сделать, чтобы сообщения 
выводились только в отладочной версии программы, а в релизной были скрыты (стр. 69).

Получить информацию о библиотеке (узнать версию или где наход. расширения plug-ins),
можно с помощью класса QLibraryInfo, который предоставляет ряд статич. методов.

---------------------------

КОНТЕЙНЕРЫ

Tulip - это встроенная в Qt библиотека контейнеров. Она похожа на STL, и даже
совместима с ней. Обычный STL также можно использовать, хотя Tulip считается более
оптимизированной и занимает меньше места в билде.

Последовательные контейнеры - это упорядоченные коллекции, где позиция элемента 
зависит от места его вставки. Qt содержит 5 классов этой категории:

* QVector<T> - ветор;
* QList<T> - список;
* QLinkedList<T> - двусвязаный список;
* QStack<T> - стек;
* QQueue<T> - очередь.

Ассоциативные контейнера - это коллекции, в которых позиция элемента 
от его значения. Классы этой категории:

* QSet<T> - множество;
* QMap<K, V> - словарь;
* QMultiMap<K, V> - мультисловарь;
* QHash<K, V> - хэш;
* QMultiHash<K, V> - мультихэш.

Объекты QObject и потомки не могут храниться в этих контейнерах, т.к. у этого типа
конструктор копирования и опиратор присвоения находятся в секции private. 
Но указатели на них сохранять можно!

Qt предоставляет 2 стиля итераторов:
* итераторы в стиле Java;
* итераторы в стиле STL;

Итераторы в стиле Java компактнее при записи, но занимают больше места в билде.
...
QList<QString> list;
list << "hello" << "world";
QListIterator<QString> it(list);
while (it.hasNext()) {
    qDebug() << "element:" << it.next();
}

Итераторы типа QListIterator являются константными. Чтобы была возможность для
изменения элементов, необходимо использовать такие же, но с приставкой "Mutable":
QMutableListIterator, QMutableHashIterator, QMutableMapIterator и т.д. 

Итераторы в стиле C++ эффективнее и могут использоваться с STL:
...
QVector<QString> vect;
vect << "hello" << "world";
QVector<QString>::iterator it vect.begin();
for (; it != vect.end(); it++) {
    qDebug() << "element:" << *it;
}

В Qt также имеется макрос foreach, являющийся альтернативой для перебора.
...
QList<QString> list({ "hello", "world" });
foreach(QString str, list) {
    qDebug() << "element:" << str;
}

Скорость выполнения операций для последовательных контейнеров:
------------------------------------------------------------------------------
    КОНТЕЙНЕР    |  ДОСТУП  | ВСТАВКА/УДАЛЕНИЕ | ДОБ. В КОНЕЦ | ДОБ. В НАЧАЛО
------------------------------------------------------------------------------
  QList, QQueue  |  быстро  |    медленно      |    быстро    |    быстро
------------------------------------------------------------------------------
 QVector, QStack |  быстро  |    медленно      |    быстро    |   медленно
------------------------------------------------------------------------------
   QLinkedList   | медленно |     быстро       |    быстро    |    быстро
------------------------------------------------------------------------------

Специфические методы QVector:
* data() - возвращает указатель на обычный массив;
* toList() - возвращает объект QList;
* toStdVector() - возвращает объект std::vector.

Массив байтов QByteArray - контейнер, похожий на вектор, элементы которого могут
хранить только один байт. Подходит для хранения промежуточных данных.

К QByteArray можно применять операции сжатия и распаковки:
...
QByteArray arr = "Test Data";
QByteArray arr2 = qCompress(arr);
qDebug() << qDecompress(arr2);

Чтобы представить бинарные данные в виде текста, можно воспользоваться 
методами: toBase64() и fromBase64().
...
QByteArray arr3 = arr.toBase64();  -->  VGVzdCBEYXRh
QByteArray::fromBase64(arr3);  -->  Test Data

Перед кодированием в base64, данные можно дополнительно сжать.

Также, существует ещё и массив битов QBitArray. Его элементы занимают всего по одному
биту. Этот тип можно использовать для хранения большого кол-ва булевых переменных.

Специфические методы QList:
* move() - перемещает элемент с одной позиции на другую;
* swap() - меняет местами два элемента на указанных позициях;
* toSet() - возвращает объект QSet;
* toVector() - возвращает объект QVector;
* toStdList() - возвращает объект std::list.

Если, при получении эл-та, нет необходимости его изменять, то вместо индексатора []
лучше использовать at(), т.к. он возвращает константную ссылку на элемент.

При работе с большими списками или если требуется часто вставлять эл-ты, лучше
использовать QLinkedList. Но у него нет индексатора и метода at().

Класс QStack представляет собой реализацию стековой структуры. 
QStack унаследован от QVector, а QQueue - от QList.

Пример работы с QMap:
...
QMap<QString, QString> phonebook;
phonebook["Piggy"] = "+49 (631) 242391";
phonebook["Kemit"] = "+49 (631) 852331";
phonebook["Gonzo"] = "+49 (347) 123563";

QMap<QString, QString>::iterator it = phonebook.begin();
for (; it != phonebook.end(); it++) {
    qDebug() << "name:" << it.key() << "phone": << it.value();
}

Если обратиться к эл-ту которого нет в словаре, то он создастся c пустым значением. 
Посему, перед обращением, надо проверять их наличие с пом. метода contains():
Это правило относится ко всем ассоциативным контейнерам.
...
if (phonebook.contains("Gonzo")) {
    qDebug() << "phone:" << phonebook["Gonzo"];
}

Специфические методы QMap:
* lowerBound() - итератор первого эл-та с заданным ключом;
* upperBound() - итератор последнего эл-та с заданным ключом;
* toStdMap() - возвращает стандартный словарь STL.

Специфические методы QHash:
* capacity() - возвращает размер хэш-таблицы;
* reserve() - задает размер хэш-таблицы;
* squeeze() - уменьшает объем хэш-таблицы, для уменьшения памяти.

Специфические методы QSet:
* unit() - объединяет эл-ты множеств;
* intersect() - пересечение эл-тов множеств 
  (удаляет эл-ты, которых нет в обоих множествах);
* substract() - разность эл-тов множеств
  (удаляет эл-ты, которые есть в обоих множествах);

Алгоритмы определены в заголовочном файле QtAlgorithms, в виде шаблонных ф-ций.
Но если их окажется недостаточно, можно воспользоваться алгоритмами SLT.

* qBinaryFind() - бинарный поиск элементов;
* qCopy() - копирование эл-тов, начиная с первого;
* qCopyBackward() - копирование эл-тов, начиная с последнего;
* qCount() - количество элементов;
* qDeleteAll() - удаление всех элементов;
* qEqual() - сравнение элементов;
* qFill() - присваивает всем эл-там заданное значение;
* qFind() - поиск элементов;
* qLowerBound() - нахожден. эл-та, со значен. большим либо равным заданному;
* qUpperBound() - нахожден. эл-та, со значен. строго большим заданного;
* qSort() - сортировка элементов;
* qStableSort() - сортировка, с сохранен. порядка следования равных эл-тов;
* qSwap() - обмен значений между двумя эл-тами.

При использовании ф-ций сравнения и сортировки необходимо чтобы передаваемые 
объекты определяли оператор ==.

Строки представлены контейнером QString. Строки хранятся в формате Unicode, 
где каждый символ занимает 2 байта. Элементы относятся к типу QChar.

Методы QString:
* isEmpty() - проверяет, пуста ли строка;
* append() - конкатенация строк (либо оператор +);
* replace() - заменяет часть строки;
* toLower/Upper() - перевод символов в нижний/верхний регистр;
* setNum() - конвертация числа в строку; 
* toInt/Double() - конвертация строки в число;
* split() - разбивает строку на список строк (QStringList);
* join() - объединяет список строк в одну строку;
* starts/endsWith() - проверяет, начин./заканч. ли строка на заданное значение;
* contains() - проверяет, содержит ли строка подстроку;
* indexOf() - индекс найденной подстроки, поиск с начала;
* lastIndexOf() - индекс найденной подстроки, поиск с конца;
* left/right() - часть строки с указанным кол-вом символов слева/справа;
* mid() - часть строки, начиная с указанной позиции;
* simplified() - удаляет повторяющиеся знаки пробелов;
* left/rightJustified() - дополняет строку заданным символов слева/справа;

Некоторые из этих методов работают с регулярными выражениями, например: 
contains(), indexOf(), lastIndexOf(),

Другие варианты конвертации числа в строку:
...
QString str = QString::number(35.123);
QTextStream(&str2);  -->  с пом. текстового потока

Если требуются строки в кодировке UTF-16, то вместо QString использ. QStringView.

Для работы с регулярными выражениями используется объект класса QRegExp. 
Рег. выр-я работают медленнее, чем методы в QString. 
...
QRegExp reg("[0-9]{1,3}");
QString str = "Serial number: 123-234-12";
str.contains(reg) > 0;  -->  true;

Пример фильтрации списка строк:
...
QStringList list({ "576", "3GH", "010" });
QStringList result = list.filter(QRegExp("^\\d+?"));

Методы QRegExp:
* indexIn() - индекс найденного совпадения;
* exactMatch() - определение совпадения (true/false);

Объекты класса QVariant могут содержать данные разного типа, включая контейнеры.
Но его частое применение снижает скорость работы программы.
...
QVariant var(34);
QVariant var2("hello world!");
int num = var.toInt() + 6;
QString str = var.value<QString>();

В Qt используется модель общего использования данных, для увеличения эффективности 
при инициализац. и присвоен. объектов (напоминает паттерн Flyweight, стр. 101).

---------------------------

ВИДЖЕТЫ

Класс QWidget является базовым для всех остальных виджетов. Он унаследован от QObject.
Помимо встроенного набора виджетов, можно также создавать и пользовательские.

Каждый виджет может быть контейнером для других виджетов. Если виджет-предок станет
недоступным, то все его виджеты-потомки также станут недоступны. 

Задать предка виджету можно через его конструктор. Если у виджета нет предка, тогда 
он будет виджетом верхнего уровня. Они имеют собственные окна.

Метод setWindowFlags() позволяет задать настройки окна виджета. Например, флаг
Qt::WindowStaysOnTopHint позволит окну всегда находится на переднем плане, 
чтобы его не перекрывали другие окна.

Слот-метод setWindowTitle() - задает надпись заголовка окна. Это имеет смысл 
только для виджетов верхнего уровня.

Слот setEnabled() устанавливает виджет в доступное/недоступное состояние.
А чтобы узнать стостояние, нужно использовать метод isEnabled().

При создании пользовательских виджетов важно, чтобы они обрабатывали события.
Например, для обработки событий мыши необходимо переопределить один из их методов:
mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), mouseDoubleClickEvent().

Виджет представляет собой прямоугольную область. Методы size(), height() и width()
возвращают размеры виджета. А методы pos(), x() и y() - координаты.

Положение и размеры виджета можно изменять c помомщью методов move() и resize().
А для того, чтобы делать это одновременно, используется метод setGeometry().
Также это может задаваться и автоматически, с пом. классов компоноки.

Для отображения/скрытия виджета, используются методы show() и hide().
Отрисовка виджетов кешируется в памяти. Они перерисовываются только тогда, 
когда это действительно необходимо, что повышает производительность отображения.

Виджеты имеют важное свойство autoFillBackground, которое позволяет им автоматически
заполняться фоном и быть видимыми (по умолчанию оно false). Но перед заполнением 
нужно сначала создать палитру и установить её через setPalette().

Пример добавления виджетов:
...
#include <QtWidgets>

int main(int argc, char** argv)
{
    QApplication app(argc, argv);

    QWidget wgt;  -->  самый верхний виджет будет окном
    QWidget* wgt2 = new QWidget(&wgt);

    QPalette palette;
    palette.setColor(wgt2->backgroundRole(), Qt::blue);

    wgt2->setPalette(palette);
    wgt2->resize(100, 100);
    wgt2->move(25, 25);
    wgt2->setAutoFillBackground(true);

    wgt.resize(200, 200);
    wgt.show();

    return app.exec();
}

Изменить указатель мыши для виджета можно с помощью метода setCursor(). Он может
принимать как уже готовые значения типа CursorShape (ArrowCursor, WaitCursor,
CrossCursor и т.п.), так и пользовательские изображения типа QBitmap.
...
QPixmap pix(":/clock.png");
QCursor cursor(pix);
wgt.setCursor(cursor);

Ччтобы изменить курсор для всего приложения, нужно использовать статический метод
QGuuApplication::setOverrideCursor(). Это полезно, когда к примеру, выполняется долгая
фоновая операции. В этом случае обычная стрелка меняется на песочные часы.

Получить/изменить позацию курсора можно методами pos() и setPos(), класса QCursor.

QFrame - это виджет рамки. Стиль рамки устанавливается с пом. setFrameStyle().
Методы setLineWidth() и setMidLineWidth() задают толщину рамки.

QStackedWidget - стековый виджет, показывающий в отдельно взятый промежуток 
времени только одного из своих потомков. Унаследован от QFrame.

QScrollArea - виджет видовой прокрутки. Он отображает окно с полосой прокрутки, 
в котором распологается часть содержимого. Также унаследован от QFrame.
Этот виджет является совокупностью сразу нескольих виджетов.

Метод viewport() дает доступ к виджету области просмотра. Методы verticalScrollBar() 
и horizontalScrollBar() дают доступ к виджетам полос прокрутки. А cornerWidget() 
- доступ к виджету из правого нижнего угла.

Чтобы установить какой-то виджет как видимую область для QScrollArea, 
нужно использовать метод setWidget(), а чтобы получить его - метод widget().
Удаление виджета из QScrollArea выполняется через removeChild().

Пример создания картинки с прокруткой:
...
QScrollArea sa;
QWidget* wgt = new QWidget();

QPixmap pix(":/picture.jpg");

QPalette palette;
palette.setBrush(wgt->bachgroundRole(), QBrush(pix));

wgt->setPalette(palette);
wgt->setAutoFillBackground(true);
wgt->setFixedSize(pix.width(), pix.height());

sa.setWidget(wgt);
sa.resize(350, 150);
sa.show();

Классы компоновки изменяют размеры и позиции виджетов автоматически, после изменения
окна программы. Также, они задают расположение виджетов относительно друг друга 
и удаляют выделенную память, связанных виджетов верхнего уровня. 

Менеджеры компоновки (layout managers). 
* QBoxLayout - для размещения по горизонтали и вертикали;
* QHBoxLayout - размещение только по горизонтали;
* QVBoxLayout - размещение только по вертикали;
* QGridLayout - для табличного размещения;
* QFormLayout - таблица из 2х столбцов.

Они имеют такие методы (дописать):
* addWidget() - добавление виджета в компоновку;
* removeWidget() - удаление виджета из компоновки;
* setSpacing() - задает расстояние между виджетами, для их разделения;
* setContentsMargins() - устанавливает отступы от границ виджета до содержимого;
* addLayout() - добавляет дополнительный менеджер компоновки;
* addStretch() - добавляет фактор растяжения.

Конструктор QBoxLayout принимает один из параметров собственного перечисления:
LeftToRight, RightToLeft, TopToBottom, BottomToTop.

Виджеты установливают компоновку с помощью метода setLayout():
...
QWidget wgt;  -->  виджет верхнего уровня

QPushButton btn1 = new QPushButton("A");
QPushButton btn2 = new QPushButton("B");

QBoxLayout* layout = new QBoxLayout(QBoxLayout::LeftToRight);
layout->addWidget(btn1, 1);  
layout->addWidget(btn2, 2);  -->  второй параметр - это фактор растяжения

wgt.setLayout(layout);
wgt.resize(450, 40);
wgt.show();

Комбинируя между собой разные менеждеры компоновок, можно добиться практически 
любой сложности размещения виджетов (метод addLayout()).

Класс QGridLayout позволяет быстро создавать сложные размещения.
Таблица состоит из ячеек, позиции которых задаются строками и столбцами.

Фактор растяжения для строк и столбцов, устанавливается методами 
setRowStretch() и setColumnStretch().

Класс QFormLayout подойдет для маленьких виджетов, например для диалоговых окон.
Добавление виджетов здесь осуществяется с пом. метода addRow().

Пример калькулятора, построенного на QGridLayout (стр. 125).

При нажатии на Tab просходит перевод фокуса с одного виджета на другой.
Порядок при переводе соответсвует очередности установки дочерних виджетов.

Если требуется, чтобы порядок был более логичным, то его можно изменить 
с помощью статического метода QWidget::setTabOrder().

Класс QSplitter задает разделить. Он полезн, когда к примеру, нужно разделить 
текстовое и графическое содержимое виджета. Черту разделителя можно двигать мышью.

Если необходимо, чтобы виджеты разделителя были проинформированы об изменении 
размеров, то тогда нужно вызвать метод setOpaqueResize(true).

QLabel - это виджет надписи. Унаследован от QFrame и может иметь рамку. 
Выводит: текст, html, картинку, анимацию с пом.: setText(), setPixmap(), setMovie(). 
...
QLabel label("<h1>Title</h1><p>text</p>");
label.show();

Выравниваение текста задается через метод setAlignment(), принимающий флаги. 
Флаги выравнивания можно комбинировать, например: AlignCenter тоже самое, 
что и AlignVCenter | AlignHCenter.

Метод setBuddy() привязывает виджет к QLabel. Если текст содержит амперсанд,
то символ, перед которым он стоит, будет подчернутыми. При нажатии клавиши этого
символа вместе с Alt, фокус перейдет к привязанному виджету.
...
QLabel* label = new QLabel("&Name");
QLineEdit* input = new QLineEdit();
input->setBuddy(label);  -->  при нажатии "N", фокус перейдёт к input'у

Чтобы геперссылки, внутри QLabel, могли открываться через браузере, нужно
воспользоваться методом setOpenExternalLinks(true):

QProgressBar - виджет индикитора выполнения. Метод setRange() задает кол-во шагов.
Метод setMinimumWidth() - длину виджета в пикселях. А setValue() - текущий шаг.

QLCDNumber - виджет элекронного дисплея чисел. Стиль дисплея можно изменять, а также
использовать разные режимы отображения чисел: в двоичной, восьмеричной, десятеричной
и шестнадцатеричной сестемах счисления. Кроме того, допускается использование точки
между позициями сегментов, с помощью метода setSmallDecimalPoint().

Кнопками являются классы: 
* QPushButton - обычная кнопка; 
* QCheckBox - флажок;
* QRadionButton - переключатель.

Для получения и установки текста кнопки, использ. методы text() и setText().
Для получения и установки изображения - методы icon() и setIcon(). 
Для размеров изоборажения - методы iconSize() и setIconSize().

Кнопки имеют следующие сигналы:
* pressed() - отправляется при нажатии на кнопку мыши;
* released() - отправляется при отпускании кнопки мыши;
* clicked() - когда пользователь нажал и отпустил кнопку мыши;
* toggled() - при изменении переключателя.

Методы опроса состояния кнопки:
* isDown() - возвращает true, если кнопка находится в нажатом состоянии;
* isChecked() - возвращает true, если кнопка находится в выбранном состоянии;
* isEnabled() - кнопка доступна, т.е. может реагировать на действия пользователя.

Метод setCheckable() позволяет кнопке работать как флажок (toggle button).
Метод setFlat() делает кнопку без видимых контуров (секретная кнопка).

Метод setMenu() позволяет кнопке вызывать выпадающее меню, которое задается с пом.
класса QMenu. Чтобы добавить в QMenu элементы, используется метод addAction().
...
QPushButton btn("Menu");

QMenu* menu = new QMenu(&btn);
menu->addAction("Item 1");
menu->addAction("Item 2");

btn.setMenu(menu);
btn.show();

Флажки применяются, когда нужны какие-то опции. В отличии от toggle button, они 
могут иметь третье состояние - неопределенное. Это когда в рамке, вместо галочки,
находится маленький квадратик (как в инсталляторах).

Чтобы изменить состояние обычного флажка, используется метод setChecked().
А чтобы изменить состояние "tristate" флажка - метод setCeckState(), но перед этим 
его нужно перевести в этот режим, с пом. setTristate().

Переключатели, как и флажки, изменяют своё состояние с помощью setChecked().
Переключатели не могут использоваться по отдельности и должны быть сгруппированы.

Группируются они с пом. класса QGroupBox. Если кол-во переключателей больше пяти, 
то лучше использовать выпадающий список QComboBox.
...
QGroupBox gbx("&Colors");

QRadioButton* red = new QRadioButton("&Red");
QRadioButton* blue = new QRadioButton("&Blue");
red->setChecked(true);

QVBoxLayout* layout = new QVBoxLayout();
layout->addWidget(red);
layout->addWidget(blue);

gbx.setLayout(layout);
gbx.show();

Группироваться могут не только переключатели но и другие виджеты, которые объединены 
между собой логически (для лучшего визуального восприятия).

Виджеты, относящиеся к элементам настройки, используются для установки значений, не
требующих большой точности, например: настройка громкости, скроллинга окна и т.п.

Они определены такими классами: 
* QSlider - ползунок; 
* QScrollBar - полоса прокрутки; 
* QDial - установщик (кружок, как в стиралке).

Обычно, полоса прокрутки встроена в виджет QAbstractScrollArea, и сама по себе
используется редко (т.е. вместо QScrollBar лучше использовать виджеты, 
производные от QAbstractScrollArea).

Большая часть виджетов ввода поддерживает операцию Drag&Drop.

Виджет QLineEdit представляет собой однострочное текстовое поле. А для ввода
многострочного текста, используется QTextEdit.

Сигнал textChanged() вызывается при изменении текста. Если текст был изменен 
не программно, а пользователем, то вызывается textEdited(). Сигнал returnPressed()
вызывается, когда пользователь нажимает на Enter.

Для QLineEdit можно включить режим ввода пароля, с помощью метода
setEchoMode(QLineEdit::Password);

В QLineEdit есть слоты для работы с буфером обмена:
* copy() - копирует выделенный текст;
* cut() - копирует выделенный текст и удаляет его из поля ввода;
* paste() - вставляет текст, стирая выделенное.

Методы undo() и redo() отменяют/повторяют последнюю операцию. Проверить возможность
использования этих операций можно c пом. isUndoAvailable() и isRedoAvailable().

Класс QTextEdit также поддерживает редактирование html. Но если требуется только
отобразить текст в html, без редактирования, то лучше использовать QLabel.

Некоторые методы QTextEdit:
* text() - получение текущего текста;
* setPlainText() - установка обычного текста;
* setHtml() - установка текста в html;
* selectAll(), deselect() - выделение и снятие выделения всего текста.
* append() - добавляет текст, на который не действуют операции undo/redo;
  благодаря чему, работает быстрее;
* find() - ищет и выделяет строку в тексте.

Если нужен редактор обычного текста, то лучше использовать виджет QPlainTextEdit, 
т.к. он более легковесный и занимает меньше памяти.

Виджеты QTextEdit и QLineEdit имеют похожие методы и сигналы. QTextEdit можно
использовать совместно с QSyntaxHighlighter для подсветки синтаксиса.
Пример реализации редактора кода, стр. 165.

Для работы с выделенным текстом используется класс QTextCursor, объект которого
хранится в самом виджете QTextEdit. А для управления документом - методы: 
document() и setDocument().

Документ представлен классом QTextDocument. Класс QTextDocumentWriter позволяет
записать его текст в файлы 3х форматов: PlainText, HTML, ODF.
...
QTextEdit* txt = new QTextEdit("This is a <h2>TEST</h2>");
QTextDocumentWriter writer;
writer.setFormat("odf");
writer.setFileName("output.odf");
writer.write(txt->document());

QTextDocumentWriter не поддерживает запись в PDF, но это можно реализовать путём
рисования в контексте QPrinter (из модуля QtPrintSupport), либо с помощью QPdfWriter.

Виджеты счетчиков:
* QSpinBox - счетчик (числовое поле, как <input type="number">);
* QDoubleSpinBox - счетчик для значений типа double;
* QDateTimeEdit - виджет ввода даты и времени.

Метод setWrapping() устанвливает циклический режим, когда за максимальным 
значением следует минимальное, и наоборот.

Методы setPrefix() и setSuffix() изменяют отображение чисел, например с помощью 
них можно добавить числам скобки и т.п.

Контроллер QValidator реализует правильность ввода текста. Установить объект
контроллера можно с помощью метода setValidator(), который содержатся
в QComboBox и QLineEdit. 

Для проверки ввода чисел используются встроенные валидаторы: 
QIntValidator и QDoubleValidator.

Для создания собственного валидатора, нужно наследоваться от QValidator 
и перезаписать метод validate().
...
class NameValidator : public QValidator 
{
public:
    virtual State validate(QString& str, int& pos) const
    {
        QRegExp rxp = QRegExp("[0-9]");
        return str.contains(rxp) ? QValidator::Invalid 
            : QValidator::Acceptable;
    }
}

QLineEdit* txt = QLineEdit();
NameValidator* validator = new NameValidator(txt);
txt->setValidator(validator);

Элементы выбора представлены виджетами: QListWidget, QTreeWidget, QTableWidget,
QTabWidget, QComboBox и QToolBox. Их item'ы, помимо текста и картинок, могут быть
также виджетами. Но это снижает быстродействие.

QListWidget - виджет списка. Элементы списка представлены классом QListWidgetItem.
Элементы-виджеты задаются такие с помощью метода setItemWidget().

Пример создания списка:
...
QListWidget list;
QListWidgetItem* item = 0;

foreach(QString str, strArr) {
    item = new QListWidgetItem(str, &list);
    item->setIcon(QPixmap(":/" + str + ".jpg"));
}

list.resize(125, 175);
list.show();

Узнать, какой элемент выбрал пользователь, можно с пом. метода currentItem().
Если выбранных элементов несколько, то надо использовать selectedItems(). Режим
множествен. выделения задается: setSelectionMode(QAbstractItemView::MultiSelection);

C пом. метода setFlags(Qt::ItemIsEditable) можно предоставить пользователю 
возможность редактирования текста элемента.

Также, список можно перевести в режим пиктограмм (когда эл-ты в виде значков).
Это позволит проводить операцию перетаскивания Drag&Drop.
...
list.setSelectionMode(QAbstractItemView::MultiSelection);
list.setViewMode(QListView::IconMode);  -->  задается режим пиктограмм

foreach(QString str, strArr) {
    item->setFlags(Qt::ItemIsSelectable | Qt::ItemIsDragEnabled);
}

QTreeWidget - виджет древовидного списка. Поддерживает возможность выбора одного 
или нескольких значений, а также Drag&Drop.

Элементы будут с флажками, если задать Qt::ItemIsUserCheckable.
...
QTreeWidgetItem* item = new QTreeWidgetItem(treeWgt);
item->setFlags(Qt::ItemIsUserCheckable);
item->setCheckState(0, Qt::Checked);

Узнать состояние флажка элемента, можно с пом. checkState(номер_столбца):
if (item->checkState(0) == Qt::Checked) { }

Элементы QTreeWidget и могут иметь несколько столбоц с данными. Добавить столбцы 
можно с пом. метода addChildren(). Метод setExpanded() разворачивает эл-нт.

С помощью итератора QTreeWidgetIterator можно пройтись по элементам списка, 
а чтобы пройтись только по выделенным, нужно передать в конструктор флаг Selected.

Метод sortItems() позволяет сортировать эл-ты у обоих списков. Для сортировки по 
датам, нужно создать новый виджет эл-та, и перезаписать в нём operator<().

QTableWidget - виджет таблицы. Элементы таблицы представлены через QTableWidgetItem.
Задать элемент в таблице можно с пом. метода setItem(rowNum, colNum).

QComboBox - виджет выпадающего списка. Он предоставляет возможность выбора только
одного элемента. По ф-циональному назначению совпадает с QListWidget.

Вызов метода setDuplicatesEnabled(false), исключает попадание повторяющихся эл-тов.
Чтобы узнать текущий элемент, используется метод currentIndex(). Если вызвать
setEditable(true), то пользователь сам сможет добавлять элементы в список.

QTabWidget - виджет вкладок (по горизонтали). 
QToolBox - виджет панели инстументов (вертикальные вкладки).

Интервью, или модель-представление - это паттерн, который используется в Qt 
для разделения логики и визуализации данных.

Модель отвечает за управление данными. Чтобы создать модель, нужно унаследоваться 
от класса QAbstractItemModel или его потомков. Список некоторых потомков:

* QAbstractListModel - модель, представляющая одномерный список;
  * QStringListModel - модель, для работы со списком строк;

* QAbstractTableModel - модель, представляющая таблицу;
  * QSqlQueryModel - модель, для работы с sql-запросами;

* QStandartItemModel - позволяет напрямую сохранять данные в модели; 
  удобно использовать в маленьких приложениях, с небольшим набором данных;

* QAbstractProxyModel - модель, для промежуточной обработки данных;
* QFileSystemModel - модель, для работы с файловой системой.

Представление отвечает за отображение данных. Чтобы создать представление, нужно
унаследоваться от класса QAbstractItemView или его потомков. Метод setModel()
устанавливает представлению модель, а setItemDelegate() - делегат.

Основные потомки QAbstractItemView:
* QListView - одномерный список; располагает режимом пиктограмм;
* QTreeView - древовидный список, отображающий столбцы данных;
* QTableView - отображает данные в виде таблицы.

Пример работы с данными, через модель-представление:
...
QWidget wgt;

QStringListModel model;
model.setStringList(QStringList() << "Item1" << "Item2");

QListView* listView = new QListView();
listView->setModel(&model);

QTableView* tableView = new QTableView();
tableView->setModel(&model);

QItemSelectionModel sModel(&model);
listView->setSelectionModel(&sModel);
tableView->setSelectionModel(&sModel);

QHBoxLayout* layout = new QHBoxLayout();
layout->addWidget(listView);
layout->addWidget(tableView);

wgt.setLayout(layout);
wgt.show();

Делегат отвечает за отрисовку элементов представления. Чтобы создать делегат, нужно
унаследоваться от классов QStyledItemDelegat или QAbstractItemDelegat.

Пример делегата, выделяющего виджет при наведении курсора:
...
class MyDelegate : public QStyledItemDelegate
{
public:
    void paint(QPainter* painter, QStyleOptionViewItem& option, 
               QModelIndex& index)
    {
        if (option.state & QStyle::State_MouseOver) {
            QRect rect = option.rect;

            QLinearGradient gradient(0, 0, rect.width(), rect.height());
            gradient.setColorAt(0, Qt::red);
            gradient.setColorAt(1, Qt::green);

            painter.setBrush(gradient);
            painter.drawRect(rect);
        }

        QStyledItemDelegate::paint(painter, option, index);
    }
}

QListView listView;
listView.setModel(&model);
listView.setItemDelegate(new MyDelegate(&listView));
listView.viewport()->setAttribute(Qt::WA_Hover);
listView.show();

Флаг WA_Hover задается, чтобы QListView мог реагировать на перемещение 
курсора мыши над собой. 

Чтобы получить данные из ячейки таблицы, используют индекс модели.
Проверить данные по заданным координатам можно с помощью метода isValid().
...
QModelIndex index = tableModel->index(2, 5, QModelIndex());
if (index->isValid()) {
    QVariant value = tableModel->data(index);
}

Чтобы правильно отображать данные, представления используют роли.
* DisplayRole - текст для показа;
* DecorationRole - растровое изображение;
* FontRole - шрифт для текста;
* ToolTipRole - текст для подсказки;
* WhatThisRole - текст для подсказки "что это?";
* TextColorRole - цвет текста;
* BackgroundColorRole - цвет фона.

Роли связаны с индексами модели, а те, в свою очередь, являются как бы идентификаторами
данных. Для пользовательских моделей можно создавать свои собственные роли. 

Пример списка, где каждый item выводит: текст, картинку и подсказку.
...
QStringList list;
list << "Linux" << "Windows" << "MacOS";

QStandartItemModel model(list.size(), 1);  -->  индексы есть не только у таблиц

for (int i = 0; i < model.rowCount(); i++) {
    QModelIndex index = model.index(i, 0);
    QString str = list.at(i);
    model.setData(index, str, Qt::DisplayRole);
    model.setData(index, "Tooltip:" + str, Qt::ToolTipRole);
    model.setData(index, QIcon(str + ".jpg"), Qt::DecorationRole);
}

QListView listView;
listView.setViewMode(QListView::IconMode);
listView.setModel(&model);
listView.show();

Виджеты: QListWidget, QTreeWidget и QTableWidget построены на основе элементно
ориентированного подхода, т.е. они унаследованы от представлений QListView 
и т.д., и имеют внутренние модели данных.

При этом, их модели можно разделять с отдельными представлениями:
...
QListWidget wgt;
wgt.setWindowTitle("List Widget");
wgt.show();

QListView view;
view.setModel(wgt.model());  -->  отобразит данные из виджета по своему
view.setWindowTitle("List View");
view.show();

Все цвета виджета хранятся в цветовой палитре. Чтобы получить доступ к объекту 
палитры, используется метод palette(), класса QWidget. 

Объект QPalette имеет 3 группы, которые отвечают за 3 состояния виджета: активное,
неактивное и недоступное. Каждая группа состоит из цветовых ролей, а каждая роль 
имеет кисть QBrush (заливка по паттерну), и цвет QColor (сплошная заливка). 

Цветовые роли (полный список на стр. 218):
* Text - цвет текста;
* ButtonText - цвет текста на кнопках;
* Highlight - цвет фона, когда элемент активен (выделен);
* HighlightText - цвет текста, когда элемент активен;
* Window - основной цвет фона;
* Button - цвет кнопки;
* Link - цвет гиперссылки.

Пример переопределения цветов виджета:
...
QSpinBox spinBox;

QPalette palette = spinBox.palette();
// Кнопки будут залиты красными точками и иметь синий текст
palette.setBrush(QPalette::Button, QBrush(Qt::red, Qt::Dense3Pattern));
palette.setColor(QPalette::ButtonText, Qt::blue);

spinBox.setPalette(palette);
spinBox.resize(150, 74);
spinBox.show();

Чтобы переопределить цвета для всех виджетов (глобально), нужно использзовать
статический метод QApplication::setPalette().

При создании объекта палитры, можно указать только 2 цвета: цвет для кнопок и основной
цвет. А все остальные цвета будут вычеслены автоматически, на основе них.

---------------------------

СОБЫТИЯ

Цикл событий начинает обрабатывается с момента вызова exec(); События обрабатываются
всеми классами, унаследованными от QObject, т.е. для их обработки, нужно просто
переопределить нужные методы в пользовательских классах. 

Сигналы и слоты, отличается от событий тем, что является более высокоуровневым
механизмом, предназначенным для связи объектов.

Обычно, события используются когда нужно получить какую-то информацию о происходящем,
например, получить координаты мыши, а сигналы и слоты - для оповещения, что было 
просто сделано какое-то действие.

Некоторые события вызываются ОС, например события таймера. Одни события вызываются
сразу, а другие ставятся в очередь и вызываются, когда программа получает управление.

Класс QEvent является базовым для всех событий. Список всех событий на стр. 223.
У каждого типа событий есть идентификатор, который можно получить с пом. метода type().
Методы accept() и ignore() регулируют дальнейшую обработку события.

QInputEvent - базовый класс события ввода. Узнать клавишу ввода (модификатора), 
можно с помощью метода modifiers().

QKeyEvent - класс события клавиатуры. Передается в методы виджета keyPressEvent() 
и keyReleaseEvent(). Первый вызывается при нажатии клавиши, а второй - при отпускании. 

Информацию о нажатых клавишах получает только тот виджет, который находится в фокусе.
Метод key(), класса QKeyEvent, возвращает код клавиши, а text() - текст клавиши.

Коды от 20 до 3F соответсвуют значениям ASCII-кодов.
Коды от 30 до 39 - соответсвуют цифровым клавишам (возле букв).
Коды от 41 до 5A - идентификаторы букв.

Коды обозначаются константами (полный список на стр. 226):
* Qt::Key_Space - 20;
* Qt::Key_Percent - 25;
* Qt::Key_Plus - 2B;

Когда виджет получает/теряет фокус, у него вызываются методы: focusInEvent() 
и focusOutEvent(). Им передается объект QFocusEvent.

QMouseEvent - класс события мыши. Передается в следующие методы:
* mousePressEvent() - вызывается при нажатии кнопок мыши по области виджета;
* mouseMoveEvent() - вызывается при движении мыши, когда одна из её кнопок нажата;
* mouseReleaseEvent() - вызывается при отпускании кнопок мыши;
* mouseDoubleClickEvent() - вызывается при двойном щелчке.

Для определения позиции указателя мыши, используются методы pos() и globalPos().
Первый возвращает координаты, относительно верхнего левого угла виджета, а второй -
относительно верхнего левого угла экрана.

Метод button() позволяет узнать, какая из кнопок была нажата, в момент наступления
события. Возвращает битовую комбинацию.

QWheelEvent - класс события колёсика мыши. Передается в wheelEvent(). Содержит
специфический метод angleDelta(), позволяющий узнать угол поворота колёсика, а также
pixelDelta(), возвращающий дельту, при прокрутке через тачпад.

Когда указатель мыши попадает/покидает область виджета, вызываются методы:
enterEvent() и leaveEvent() соответственно.

QPaintEvent вызывается при перерисовке. События перерисовки возникают при вызове
методов: show(), repaint(), update(). Передается в paintEvent(), в котором 
реализуется отображение виджетов.

Полную перерисовку можно делать в маленьких виджетах. В больших виджетах, лучше
перерисовывать только отдельную область. Координаты и размеры области можно получить
с пом. метода region(), а contains() проверяет, находится ли объект в заданной области.
...
MyClass::paintEvent(QPaintEvent* e)
{
    QPainter painter(this);
    QRect rect(40, 40, 100, 100);

    if (e->region().contains(rect)) {
        painter.drawRect(rect);
    }
}

QTimerEvent - класс события таймера. Передается в метод timerEvent().
Метод timerId() возвращает идентификатор таймера.

Классы событий Drag&Drop:
* QDragEnterEvent - передается в dragEnterEvent(), когда объект, 
  при перетаскивании, попадает в область;
* QDragLeaveEvent - передается в dragLeaveEvent(), когда объект, 
  при перетаскивании, выходит за область;
* QDragMoveEvent - передается в dragMoveEvent(), когда объект, 
  при перетаскивании, находится в области.
* QDropEvent - передается в dropEvent() при отпускании объекта в области.

QChildEvent - класс события создания или удаления объекта-потомка. Передается в
childEvent(). Метод child() возвращает указатель на объект-потомок, а методы added() 
и removed() позволяют узнать о создании и удалении объекта-потомка.

QCloseEvent - класс события закрытия окна. Возникает также при вызове метода 
виджета close(). Передается в closeEvent(), в котором можно запросить подтвержение.
Методы accept() и ignore() сообщают о согласии или игнорировании запроса.

QHideEvent - класс события свертывания окна. Возникает также при вызове метода 
виджета hide(). Передается в hideEvent().

QMoveEvent - класс события перемежения окна или виджета. Передается в moveEvent().
Методы pos() и oldPos() возвращают новые/старые координаты.

QShowEvent - класс события, возникающего при создании виджета или при вызове 
метода show(). Передается в showEvent().

QResizeEvent - класс события, возникающего при изменении размеров окна или виджета.
Передаётся в resizeEvent(). Методы size() и oldSize() возвращают новые/старые размеры.

Чтобы реализовать пользовательское событие, нужно создать класс, унаследованный от
QEvent; в конструктор передать идентификатор типа события, который должен быть больше
значения QEvent::User (равен 1000) и определить необходимые методы.

Пользоват. события отсылаются с пом. статич. методов QCoreApplication::sendEvent() 
и postEvent(), а обрабатываются - методами QObject: event() и customEvent().

Разница между sendEvent() и postEvent() в том, что первый отсылает события сразу,
а второй, помещает их в системную очередь для дальнейшей обработки.

Метод event() напоминает роутер. Он определяет тип события и вызывает соответсвующий
обработчик, например, для событий клика мыши, он вызовет mousePressEvent().
...
bool MyClass::event(QEvent* e)
{
    if (e->type() == QEvent::KeyPress) {
        ...
        return true;  -->  если вернуть false, то событие будет 
    }                      передано дальше, виджету-предку.

    return QWidget::event(e);
}

Некоторые типы событий (полный список на стр. 237):
* QEvent::None - 0;
* QEvent::Timer - 1;
* QEvent::MouseMove - 5;
* QEvent::KeyPress - 6;

Мультитач-события (одновременное касание к двум и более точкам) представлены классом
QTouchEvent и обрабатываются методом event(). По умолчанию они игнорируются. Чтобы
включить их обработку, нужно вызвать setAttribute(Qt::WA_AcceptsTouchEvents).

Метод touchPoints() возвращает список точек касания, которые представлены классом
TouchPoint. Метод device() позволяет узнать тип устройства.

Объекты QGraphicsItem, как и виджеты, способны получать и обрабатывать эти события.

Для установки мультитач в QAbastractSrollArea, атрибут WA_AcceptsTouchEvents нужно
установливать виджету, который возвращается методом viewPort(). А для обработки,
переопределить метод viewportEvent().

Типы мультитач-событий:
* QEvent::TouchBegin - открывает цепочку событий;
* QEvent::TouchUpdate - сигнализирует об активности пользователя;
* QEvent::TouchEnd - сообщает, что прошло последнее событие цепочки.

Пример реализации мультитач приложения на стр. 241.

Если запустить ресурсоемкую операцию в основном потоке, то она заблокирует обработку
всех событий, а также перерисовку интерфейса. Чтобы этого избежать, нужно 
запускать такие операции в отдельных потоках.

Альтернативным вариантом, для выполнения всех накопившихся событий, является
использование метода QCoreApplication - processEvents().
...
for (int i = 0; i < 1000; i++) {
    // Выполнить ресурсоемкие вычисления

    app->processEvents();  -->  вставить накопившиеся события 
}                               в промежуток выполения

В Qt существует механизм перехвата событий, который позволяет обрабатывать события, 
без реализации их классов. Этим механизмом являются фильтры.

Чтобы реализовать фильтр событий, нужно создать потомка от QObject и переопределить 
в нём метод eventFilter(). Этот метод вызывается при каждом событии. Если событие 
не должно передаваться дальше, то метод должен возвращать true. 

Обычно, в конструктор фильтра передается виджет, которому он необходим. 
Это позволяет при уничтожении виджета автоматически уничтожать и объект фильтра. 
Привязать фильтр к виджету можно с помощью метода installEventFilter().
...
class MyFilter : public QObject
{
public:
    MyFilter(QObject* parent) : QObject(parent) {}

protected:
    virtual void eventFilter(QObject parent, QEvent* e)
    {
        if (e->type() == QEvent::MouseButtonPress) {
            if (static_cast<QMouseEvent*>(e)->button() == Qt::LeftButton) {
                QMessageBox::information(0, "ЛКМ");
                return true;
            }
        }

        return false;
    }
}

QLabel label("My label");
label.installEventFilter(new MyFilter(&label));
label.show();

Виджетам можно привязывать сразу несколько фильтров, при этом последний фильтр 
будет применятся самым первым.

---------------------------

ГРАФИКА И ЗВУК

Рисование выполняется с помощью классов: QPainter, QPaintEngine, и QPaintDevice. 
Первый класс управляет отрисовкой, создает фигуры и т.п. Второй класс создает контекст
рисования. А третий - это и есть контекст (область вывода графики).

Классы, которые хоть что-то выводят на экран, наследуются от QPaintDevice
(QWidget, QPixmap, QOpenGLWindow и т.д.).

Рисование выполняется в обработчике paintEvent(). Класс QPaintEvent содержит метод
region(), который возвращает область перерисовки, а метод rect() возвращает
прямоугольник, охватывающий эту область.

Объекту QPainter принимает контекст. Передать его можно, либо через конструктор, 
либо через метод begin(). Если используется метод, то вся отрисовка должна быть между
begin() и end(). Их смысл в том, чтобы рисовать в одном контексте разными объектами
QPainter, но чаще всего используется один QPainter для разных контекстов.
...
void MyWidget::paintEvent(QPaintEvent*)
{
    QPainter painter;  -->  один, для разных контекстов
    QPixmap pixmap(rect());

    painter.begin(this);
    // Рисование в контексте виджета
    painter.end();

    painter.begin(&pixmap);
    // Рисование в контексте растрового изображения
    painter.end();
}

Перед началом рисования рекомендуется сохранять настройки QPainter, методом save(), 
а по окончанию, восстанавливать их через restore().

Чтобы задать контур линии, используется перо. Оно представлено классом QPen.
Для заполнения контуров фоном, используется кисть. Представлена классом QBrush.
Градиенты представлены классами: QLinearGradient, QConicalGradient и QRadialGradient.
Сглаживание задается с помощью метода setRenderHint(QPainter::Antialiasing, true).
...
QPainter painter(this);
painter.setPen(QPen(Qt::red, 3, Qt::DashLine));  -->  цвет, толщина и стиль

QLinearGradient gradient(0, 0, width(), height());
gradient.setColor(0, Qt::red);
gradient.setColor(0.5, Qt::green);
gradient.setColor(1, Qt::blue);

painter.setBrush(QBrush(Qt::red, Qt::HorPattern));
painter.setBrush(gradient);  -->  вместо кисти градиент

Для создания точек используются классы QPoint и QPointF. Первый описывает точку 
с целочисленными координатами, а второй - с вещественными.

Двумерный размер определяется классами QSize и QSizeF.

Прямоугольная область создается через QRect и QRectF. Методы dx() и dy() возвращают
проекции на оси X и Y. Многоугольник создается через QPolygon и QPolygonF.
Многоугольник - это по сути массив точек QVector<QPoint>.

При установке координат, следует учитывать что ось Y направлена вниз.
Объекты точек можно складывать и вычитать, а также умножать и делить на числа.

Класс QColor хранит цвета различных цветовых моделей (RGB, HSV, CMYK). Модель CMYK
распростран. в полиграфии. Методы lighter() и darker() делают цвет светлее или темнее.

Структуры QRgb/QRgba хранят цветовые значения. Им также можно присваивать
шестнадцатиричные коды: QRgb rgb = 0x000000FF; 

Методы рисования:
* drawPoint() - рисует точку;
* drawLine() - риует линию;
* drawPolyLine() - соединяет точки линиями; первая и последняя 
  точки не соединяются;
* fillRect() и eraseRect() - рисуют прямоугольники без контуров; 
  второй метод отличается тем, что использует фон фиджета;
* drawPath() - рисует грифическую траекторию;

Методы рисования картинок:
* drawImage() - рисует картинку из QImage;
* drawPixmap() - рисует картинку из QPixmap;


Методы рис. заполненных фигур:
* drawRect() - рисует прямоугольник;
* drawRoundRect() - рисует прямоугольник с закруглёнными углами;
* drawEllipse() - рисует заполненный эллипс;
* drawChord() - рисует хорду, отсукающую часть эллипса;
* drawPie() - рисует круговую диаграмму;
* drawPolygon() - рисует заполненный многоугольник.

Если требуется нарисовать только контур фигуры, без фона, то нужно установить
setBrush(QBrush::NoBrush). А если треб. фигуры без контура, то setPen(QPen::NoPen).

Пример рисования прямоугольника:
...
QPainter painter(this);
painter.setRenderHint(QPainter::Antialiasing, true);
painter.setBrush(QBrush(Qt::red, Qt::DiagCrossPattern));
painter.setPen(QPen(Qt::blue, 3, Qt::DashLine));
painter.drawRect(QRect(10, 10, 110, 70));

С пом. класса QPicture можно записывать команды рисования в файлы, 
а потом их воспроизводить:
...
QPicture picture;
QPainter painter;
painter.begin(&picture);
painter.drawLine(20, 20, 50, 50);
painter.end();
pictire.save("figure.dat");

QPicture picture2;
picture2.load("figure.date");
QPainter painter2;
painter2.begin(this);
painter2.drawPicture(QPoint(0, 0), picture2);
painter2.end();

Методы трансформации:
* translate() - перемещение; положительные значения перемещают фигуру
  вправо и вниз, а отрицательные - влево и вверх;
* rotate() - поворот в градусах; положительные значения поворачивают фигуру 
  по часовой стрелке, а отрицательные - против неё.
* scale() - масштабирование; значение меньше единицы уменьшают фигуру, 
  а больше единицы - увеличивают;
* shear() - сдвиг по вертикали и горизонтали.

Порядок трансформаций имеет значение. Если фигуру сначала повернуть, а затем сдвинуть,
то она будет повернута локально и помещена в нужное место. Если сначала сдвинуть, 
а затем повернуть, то она будет повернута глобально, идя по кругу.

Трансфорамации можно задать одновременно с пом. метода setTransform().
Он принимает матрицу, размером 3х3.
...
QTransform matrix(1, 0, 0, 1, 20, 10);
painter.setTransform(matrix);  -->  перемещение по коорд. 20, 10

Трансформационная матрица:
--------------------------------------------------    
 ЭЛЕМЕНТ | ПЕРЕМЕЩ. | ПОВОРОТ | СКОС | МАСШТАБИР.        a11 a12 0
--------------------------------------------------       a21 a22 0
   a11   |    1     |  cos(α) |   1  |     x             dx  dy  0
--------------------------------------------------
   a12   |    0     |  sin(α) |   x  |     0      
--------------------------------------------------
   a21   |    0     | -sin(α) |   y  |     0
--------------------------------------------------
   a22   |    1     |  cos(α) |   1  |     y
--------------------------------------------------
    dx   |    x     |    0    |   0  |     0
-------- -----------------------------------------
    dy   |    y     |    0    |   0  |     0
--------------------------------------------------

Графическая траектория позволяет создавать произвольные формы, соединяя между собой
разные фигуры. Сначала она заполняется, а затем, рисует всё вместе одним методом. 

Отсечения ограничивают вывод графики определенной фигурой (как наложение маски).
Установка области отсечения выполняется с помощью метода setClipRect().

Сложные области устанавливаются методом setClipRegion(), в который передается 
объект QRegion. Он имеет методы, позволяющие ему комбинироваться с другими QRegion.

Режим совмещения задается с помощью метода setCompositionMode(). Это что-то вроде
буфера глубины. По умолчанию используется режим, при котор. каждая последующая фигура
перекрывает предыдущие. Есть также и режимы, когда фигура вырезает собой дырку и пр.

Графические эффекты позволяют виджетам изменять свом цветовые параметры.
Из коробки доступно 4 эффетка: размытие, расцвечивание, тень и непрозрачность.
Устанавливаются эффекты с помощью метода setGraphicsEffect().
...
QLabel* label = new QLabel();
label.setGraphicsEffect(new GraphicsBlurEffect());

Если нужен свой эффект, то необходимо создать класс, унаследованный от 
QGraphicsEffect, и переопределить в нём метод draw().

Графические эффекты хорошо сочетаются с анимациями.

QImage - класс растрового изображения. Изображения состоят из набора символов. 
Каждый символ представляет собой отдельный пиксель.

@@@$$@@@   Вот так, примерно, устроено изображение крестика. Символ @ - это пиксель
@@@$$@@@   серого цвета, а $ - пиксель белого цвета, но могут встречаться и 
$$$$$$$$   другие обозначения для пикселей (точка, пробел и пр.).
$$$$$$$$   
@@@$$@@@   Для черно-белых изображений каждый пиксель может быть представлен 
@@@$$@@@   одним битом, у цветных - может занимать 8 бит и более.

QImage является классом контекстно-независимого представления. Это означает, что он 
не использует возможности видеокарты. Он помещает пиксели изображения в обычный
массив и позволяет выполнять над ними операции считывания и записи.

QImage может быть контекстом рисования когда нужно качественное отображение.
Но при этом, оно будет медленным.

Контекстно-зависимое представление отображает изображения быстро за счет видеокарты.
Классы контекстно-зависомого представления: QPixmap, QPixmapCahce, QBitmap.

QPixmap - класс растрового изображения, которое не отображается на экране. Его можно
использовать как промежуточный буфер для рисования и отображать через QPainter.

QPixmap содержит не сами данные, а их идентификаторы, с пом. которых он обращается 
к видеокарте и получает информацию. Из-за этого доступ к каждому пикселю по
отдельностости будет медленным и в этом случ. лучше использ. QImage.

QPixmapCache - реализует кэш для объектов QPixmap. В кэш имеет смысл помещать
изображения, часто используемые в программе, - чтобы избежать загрузки 
из файла при каждом обращении к ним.

QBitmap - наследник QPixmap. Используется для изображений с глубиной цвета в 1 бит.
Это могут быть различные маски либо примитивные черно-белые иконки.

Работа со шрифтами...

---------------------------

РАЗНОЕ

Qt Assistant - программа, предоставляющая документацию по Qt. Встроена в Qt Creator.
Утилита QMake - это генератор платформозависимых make-файлов (уже устарела).

Отладку приложения можно выполнить и без графического интерфеса в IDE. Для этого 
нужно скомпилировать программу с флагом -g и при запуске через консоль, использовать
команды: run, up, attach, where, break, next, step, continue, until и др. (стр. 64)

Текущую дату и время можно получить с помощью QDateTime::currentDateTime().

Бывает так, что при перерисовке возникает эффект мерцания. Это происходит потому, 
что пиксели за короткие промежутки времени перерисовываются разными цветами.
Также бывает баг, когда при изменении размеров окна или при его перекрытии другим
окном, пропадает картинка. Избавиться от этого позволяет двойная буферизация. 
В Qt, по умолчанию, она уже включена. Чтобы её отключить, нужно вызвать
setAttribute(Qt::WA_PaintOnScreen).

