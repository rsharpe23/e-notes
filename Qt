ОСНОВЫ БИБЛИОТЕКИ

Приложение должно начинаться с подключения хотя бы одного их следующих модулей: 
QtCore, QtGui, QtWidgets. Но обычно подключают только QtWidgets.

Далее необходимо создать объект класса QApplication. Он осуществяет управление
приложением. Для каждого приложения этот объект должен создаваться только один раз 
и до любых операций, связанных с пользовательским интерфейсом.

После создания этого объекта, необходимо вызвать его метод exec(). Он запустит цикл
обработки событий. Этот цикл передает получаемые от системы события на обработку. 
По завершении работы приложения, метод exec() возвращает код завершения.

Элементы управления (виджеты) не отображаются сразу после создания. 
Для их отображения нужно использовать метод show().

Пример минимального приложения:
...
#include <QtWidgets>

int main(int argc, char** argv) 
{
    QApplication app(argc, argv);

    QLabel label("Hello!");  -->  элемент управления
    label.show();

    return app.exec();  
}

Библиотека Qt разбита на модули:
* QtCore - модуль ядра, состоящий из классов, не связанных с GUI;
* QtGui - модуль базовых классов для работы с GUI и OpenGL; 
* QtWidgets - модуль, дополняющий QtGui виджетами и хранящий QApplication;
* QtQuick - модуль, содержащий фреймворк для быстрого создания GUI;
* QtQML - модуль, содержащий движок для языков QML и JS;
* QtNetwork - модуль для работы с сетью;
* QtSql - модуль для работы с базами данных;
* QtSvg - модуль для работы с SVG
* QtXml - модуль поддержки XML, с классами относящимися к SAX и DOM;
* QtXmlPatternts - модуль поддержки XPath, XQuery, XSLT и XmlShemaValidator;
* QtMultimedia - модуль классов для работы со звуком, видео, камерой, радио и т.п.;
* QtMultimediaWidgets - модуль виджетов для QtMultimedia;
* QPrintSupport - модуль для работы с принтером;
* QtTest - модуль для тестерования кода.

Для каждого модуля предоставляется отдельный заголовочный файл. Название такого файла
всегда соответсвует названию самого модуля, например: #include <QtGui>

Модуль QtCore является базовым для всех других модулей. Он позволяет реализовывать
приложения без GUI, например консольные приложения.

Модули QtQuick и QtQML - это альтернатива виджетам. Они предоставляют набор технологий
для быстрой и современной разработки графических приложений на QML и JS.

Допольнительные модули:
* QtWebEngineCore - интегрирует в приложение возможности веб;
* QtWebEngineWidgets - удобные виджеты для веб;
* Qt3D - модуль для упрощенной работы с 3d графикой;
* QtBluetooth - модуль для работы с Bluetooth;
* QtLocation - модуль для работы с геолокацией и местоположением;
* QtSensors - обеспечивает доступ к сенсорам моб. устройств и акселерометрам;
  поддерживает такие платформы, как: Android, iOS, SailFish, WinRT;
* QtCharts - модуль для отображения графиков;
* QtDataVisialization - модуль для отображения графиков в 3d;
* QtVirtualKeyboard - виртуальная клавиатура для настольных компьютеров;
* QtRemoteObjects - модуль для межпроцессного взаимодействия (IPC), 
  обеспечивающий обмен информацией между приложениями;

Пространство имен Qt содержит ряд перечислений и констант, которые часто применяются
при работе. Подключить его можно так: using namespace Qt.

Qt расширяет C++ дополнительными ключевыми словами. Делает он это с помощью MOC
(метаобъектный компилятор). MOC анализирует классы на наличие в них спец. макроса Q_OBJECT и внедряет в отдельный файл файл доп. информацию. Это напоминает то, 
как создается промежуточный код в Java или C#.

Внедрять этот макрос стоит в тех случаях, когда класс использует механизм сигналов 
и слотов или если ему необходима информация о свойствах.

Qt полностью построен на классах. Базовым классом для всех других является QObject.
При множественном наследовании нужно помнить, что QObject должен всегда стоять первым, иначе MOC неправильно распознает класс и будет ошибка компиляции. Кроме того, нельзя наследоваться сразу от нескольких классов, которые наследуют QObject.

Класс QObject предоставляет поддержку:
* сигналов и слотов;
* таймера;
* механизма объединения объектов в иерархии ???;
* событий и их фильтрации;
* организации объектных иерархий;
* метаобъекной информации;
* приведения типов;
* свойств.

Свойства в Qt - это поля, у которых есть вспомогательные методы доступа.
Они широко применяются в визуальной среде разработки интерфейсов Qt Designer.

Свойства задаются с помощью макроса Q_PROPERTY:
...
Q_PROPERTY(type name READ getter [WRITE setter RESET resetFn 
           DESIGNABLE bool SCRIPTABLE bool STORED bool])

class MyClass : public QObject 
{
Q_OBJECT  -->  этот макрос должен идти на след. строке, 
               после ключевого слова class

Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

private:
    bool m_readOnly;

public:
    MyClass(QObject* pobj = 0) : QObject(pobj), m_readOnly(false)

public:
    bool isReadOnly() { return m_readOnly; }
    void setReadOnly(bool value) { m_readOnly = value; }
};

pobj->setProperty("readOnly", true);
bool readyOnly = pobj->property("readOnly").toBool();

Механизм сигналов и слотов необходим для обработки событий от GUI. Раньше, вместо них использовались колбеки. Концепция колбеков устарешая. Но она лежит в основе WinAPI, который построен на процедурном стиле. Многие разработчики, при разработке под Windows, используют библиотеку MFC. Она немного облегчает разработку, добавляя классы.
Но отправка сигналов происходит медленнее, чем вызов колбека.

Сигналы и слоты можно соединять в любой точке приложения. Сигнал можно соединять с любым кол-во слотов и наоборот, слот может получ. сообщения от любого кол-ва сигналов.

Сигналы определяются в классе как обычные методы, но без реализации. Реализацию берет на себя MOC. Также методы сигналов должны возвращать void. Послать сигнал можно 
с помощью ключевого слова emit.

class MyClass1 : public QObject
{
    Q_OBJECT
    
public:
    void sendMessage() { 
        emit mySignal("hello"); 
    }

signals:
    void mySignal(QString&);
};

Слоты - это методы, обрабатывающие сигналы. Если требуется, чтобы слот реагировал только на сигналы, но при этом был не доступен для вызова как обычный метод, то его нужно объявлять с модификатором private либо protected.

Слоты могут быть виртуальными, но соединение таких слотов с сигналами медленное.
В слотах нельзя использовать параметры по умолчанию или определять их статическими.
Внутри слота вызовом метода sender() можно узнать, от какого объекта был вызван сигнал.

class MyClass2 : public QObject
{
    Q_OBJECT

public slots:
    void mySlot(QString& msg) {
        cout << msg << sender()->objectName();
    }
};

Соединение сигналов со слотами осуществл. с пом. статич. метода QObject::connect().
Методу connect() передаются следующие параметры:

* sender - объект, отправляющий сигнал;
* signal - прототип сигнала, заключенный в макрос SIGNAL();
* receiver - объект, имеющий слот для обработки сигнала;
* slot - прототип слота, заключенный в макрос SLOT();
* type - режим обработки сигнала;

int main(int argc, char** argv) 
{
    QApplication app(argc, argv);

    MyClass1 a;
    MyClass2 b;

    QObject::connect( 
        &a, SIGNAL(mySignal(QString&)),  -->  слот может игнорировать парам. сигнала
        &b, SLOT(mySlot(QString&))            т.е. можно просто SLOT(mySlot()) 
    );
    a.sendMessage();

    return app.exec();
}

Метод connect возвращает объект Connection. Его можно привести к типу bool, чтобы проверить, было ли соединение успешным.

При уничтожении объекта происходит автоматическое разъединение всех его сигнально-
слотовых связей. Но разъединение можно выполнить и вручную с пом. статического метода QObject::disconnect(). Они принимает такие же параметры, что и connect().

Если нужно сократить кол-во слотов либо обрабатывать одним слотом разные сигналы, 
то можно воспользоваться классом QSignalMapper.

Организация объектных иерархий...


