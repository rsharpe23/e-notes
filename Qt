ОСНОВЫ QT

Приложение должно начинаться с подключения хотя бы одного их следующих модулей: 
QtCore, QtGui, QtWidgets. Но обычно подключают только QtWidgets.

Далее необходимо создать объект класса QApplication. Он осуществяет управление
приложением. Для каждого приложения этот объект должен создаваться только один раз 
и до любых операций, связанных с пользовательским интерфейсом.

После создания этого объекта, необходимо вызвать его метод exec(). Он запустит цикл
обработки событий. Этот цикл передает получаемые от системы события на обработку. 
По завершении работы приложения, метод exec() возвращает код завершения.

Элементы управления (виджеты) не отображаются сразу после создания. 
Для их отображения нужно использовать метод show().

Пример минимального приложения:
...
#include <QtWidgets>

int main(int argc, char** argv) 
{
    QApplication app(argc, argv);

    QLabel label("Hello!");  -->  элемент управления
    label.show();

    return app.exec();  
}

Библиотека Qt разбита на модули:
* QtCore - модуль ядра, состоящий из классов, не связанных с GUI;
* QtGui - модуль базовых классов для работы с GUI и OpenGL; 
* QtWidgets - модуль, дополняющий QtGui виджетами и хранящий QApplication;
* QtQuick - модуль, содержащий фреймворк для быстрого создания GUI;
* QtQML - модуль, содержащий движок для языков QML и JS;
* QtNetwork - модуль для работы с сетью;
* QtSql - модуль для работы с базами данных;
* QtSvg - модуль для работы с SVG
* QtXml - модуль поддержки XML, с классами относящимися к SAX и DOM;
* QtXmlPatternts - модуль поддержки XPath, XQuery, XSLT и XmlShemaValidator;
* QtMultimedia - модуль классов для работы со звуком, видео, камерой, радио и т.п.;
* QtMultimediaWidgets - модуль виджетов для QtMultimedia;
* QPrintSupport - модуль для работы с принтером;
* QtTest - модуль для тестерования кода.

Для каждого модуля предоставляется отдельный заголовочный файл. Название такого файла
всегда соответсвует названию самого модуля, например: #include <QtGui>

Модуль QtCore является базовым для всех других модулей. Он позволяет реализовывать
приложения без GUI, например консольные приложения.

Модули QtQuick и QtQML - это альтернатива виджетам. Они предоставляют набор технологий
для быстрой и современной разработки графических приложений на QML и JS.

Допольнительные модули:
* QtWebEngineCore - интегрирует в приложение возможности веб;
* QtWebEngineWidgets - удобные виджеты для веб;
* Qt3D - модуль для упрощенной работы с 3d графикой;
* QtBluetooth - модуль для работы с Bluetooth;
* QtLocation - модуль для работы с геолокацией и местоположением;
* QtSensors - обеспечивает доступ к сенсорам моб. устройств и акселерометрам;
  поддерживает такие платформы, как: Android, iOS, SailFish, WinRT;
* QtCharts - модуль для отображения графиков;
* QtDataVisialization - модуль для отображения графиков в 3d;
* QtVirtualKeyboard - виртуальная клавиатура для настольных компьютеров;
* QtRemoteObjects - модуль для межпроцессного взаимодействия (IPC), 
  обеспечивающий обмен информацией между приложениями;

Пространство имен Qt содержит ряд перечислений и констант, которые часто применяются
при работе. Подключить его можно так: using namespace Qt.

Qt расширяет C++ дополнительными ключевыми словами. Делает он это с помощью MOC. 
MOC (метаобъектный компилятор) - это прероцессор, который анализирует классы на наличие
в них специального макроса Q_OBJECT и дополняет их отдельными cpp-файлами, содержащими
реализацию по замене ключевых слов на понятный для компилятора код (метаинформация). 

Cpp-файлы с метаинформацией называются так: moc_<filename>.cpp

Если классу не требуется метаинформация, то этот макрос можно не внедрять. 
А если он есть, тогда должен стоять в самом начале, раньше всех других макросов.

Qt полностью построен на классах. Базовым классом для всех объектов является QObject.
Объекты типа QObject и его наследники предоставляет поддержку:

* сигналов и слотов;
* таймера;
* механизма объединения объектов в иерархии;
* событий и их фильтрации;
* организации объектных иерархий;
* метаобъекной информации;
* приведения типов;
* свойств.

Объекты QObject в основном располагаются в иерархии. Такой подход позволяет не
беспокоится об освобождении памяти, после их создания. Механизмы Qt будут 
делать это автоматически. 

Конструктор класса QObject имеет вид: QObject(QObject* pobj = 0);
Это означает что каждый объект хранит указатель на своего предка в иерархии.

Все объекты QObject (особенно те, что имеют предков) должны создаваться через new,
иначе нарушится механизм автоматического освобождения памяти.
...
QObject* pobj1 = new QObject();
QObject* pobj2 = new QObject(pobj1);
QObject* pobj3 = new QObject(pobj2);

При множественном наследовании нужно помнить, что QObject должен всегда стоять первым,
иначе MOC неправильно распознает класс и будет ошибка компиляции. Кроме того, нельзя
наследоваться сразу от нескольких классов, которые наследуют QObject.

Все объекты типа QObject и их наследники хранят метаобъектную информацию (см. выше). 
В ней хранится информация о сигналах и слотах, о классе и о наследовании. 
Получить доступ к ней можно с помощью метода metaObject().
...
pobj->metaObject()->className();
pobj->inherits("QWidget");

Свойства в Qt - это поля, у которых есть вспомогательные методы доступа.
Они широко применяются в визуальной среде разработки интерфейсов Qt Designer.

Свойства задаются с помощью макроса Q_PROPERTY:
Q_PROPERTY(type name READ getter [WRITE setter RESET resetFn DESIGNABLE bool 
    SCRIPTABLE bool STORED bool])

class MyClass : public QObject 
{
Q_OBJECT
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

private:
    bool m_readOnly;

public:
    MyClass(QObject* pobj = 0) : QObject(pobj), m_readOnly(false)

public:
    bool isReadOnly() { return m_readOnly; }
    void setReadOnly(bool value) { m_readOnly = value; }
};

pobj->setProperty("readOnly", true);
bool readyOnly = pobj->property("readOnly").toBool();

Механизм сигналов и слотов необходим для обработки событий от GUI, а также для связи
виджетом. Раньше, вместо них использовались колбеки. Концепция колбеков устарешая, 
но она лежит в основе WinAPI, который построен на процедурном стиле. 

Многие разработчики, при разработке под Windows, используют библиотеку MFC. 
Она немного облегчает разработку, добавляя классы.

Сигналы и слоты можно соединять в любой точке приложения. Сигнал можно соединять с
любым кол-во слотов и наоборот, слот может получ. сообщения от любого кол-ва сигналов.

Сигналы определяются в классе как обычные методы, но без реализации. Реализацию берет
на себя MOC. Также методы сигналов должны возвращать void. Послать сигнал можно 
с помощью ключевого слова emit.

class MyClass1 : public QObject
{
    Q_OBJECT
    
public:
    void sendMessage() { 
        emit mySignal("hello"); 
    }

signals:
    void mySignal(QString&);
};

Слоты - это методы, обрабатывающие сигналы. Если требуется, чтобы слот реагировал
только на сигналы, но при этом был не доступен для вызова как обычный метод, 
то его нужно объявлять с модификатором private либо protected.

Слоты могут быть виртуальными, но соединение таких слотов с сигналами медленное.
В слотах нельзя использовать параметры по умолчанию или определять их статическими.
Внутри слота вызовом метода sender() можно узнать, от какого объекта был вызван сигнал.

class MyClass2 : public QObject
{
    Q_OBJECT

public slots:
    void mySlot(QString& msg) {
        cout << msg << sender()->objectName();
    }
};

Соединение сигналов со слотами осуществл. с пом. статич. метода connect().
Методу connect() передаются следующие параметры:

* sender - объект, отправляющий сигнал;
* signal - прототип сигнала, заключенный в макрос SIGNAL();
* receiver - объект, имеющий слот для обработки сигнала;
* slot - прототип слота, заключенный в макрос SLOT();
* type - режим обработки сигнала;

int main() 
{
    QApplication app();

    MyClass1 a;
    MyClass2 b;

    QObject::connect( 
        &a, SIGNAL(mySignal(QString&)),  -->  слот может игнорир. парам. сигнала
        &b, SLOT(mySlot(QString&))            т.е. можно так: SLOT(mySlot()) 
    );
    a.sendMessage();

    return app.exec();
}

Если слот не делает ничего, кроме проброски полученного сигнала дальше, то
можно вообще обойтись без него и просто соединить друг с другом только сигналы.

Метод connect возвращает объект Connection. Его можно привести к типу bool, если
требуется проверить, было ли соединение успешным.

При уничтожении объекта происходит автоматическое разъединение всех его сигнально-
слотовых связей. Но разъединение можно выполнить и вручную с пом. статического метода
QObject::disconnect(). Они принимает такие же параметры, что и connect().

Если нужно сократить кол-во слотов либо обрабатывать одним слотом разные сигналы, 
то можно воспользоваться классом QSignalMapper.

В Qt есть собственные примитивные типы данных: qint8, qlonglong и пр. (стр. 70).
Они нужны для того, чтобы абстрогироваться от особенностей той или иной архитектуры,
например qint64 где-то может быть __int64, а где-то long long.

В заголовочном файле <QtGlobal> содержатся полезные макросы и ф-ции:
* qMax(a, b) - максимальное число;
* qMin(a, b) - минимальное число;
* qAbs(value) - модуль числа;
* qRound(value) - округляет число;
* qBound(min, max, value) - значение между минимум и максимумом;
* qFuzzyCompare(a, b) - сравнивает вещественные значения. 

Компилятор ресурсов RCC внедряет сторонние ресурсы (картинки, файлы перевода и т.п.)
в иcполняемые модули, чтобы приложение могло обращаться к ним в рантайме.

Ресурсы описываются через XML, в специальных файлах с раширением ".qrc". Эти файлы 
добавляются в проект также, как и все остальные исходники (через CMake/QMake).
...
<!DOCTYPE RCC>
<qresource>
    <file>images/icon.png</file>
    <file>images/photo.jpg</file>
</qresource>
</RCC>

RCC парсит xml и создает на его основе cpp-файл, где данные представлены 
в виде одного большого массива. 

Получить доступ к ресурсу из кода, например к картинке, можно так:
plbl->setPixmap(QPixmap(":/images/photo.jpg"));

Структура Qt-проекта состоит из исходников в виде заголовочный файлов и файлов cpp.
Помимо исходников в нём также есть файл с расширением ".pro", из которого, 
через qmake, генерируется make-файл проекта. 

В make-файле содержится вызов MOC для создания доп. cpp-файлов с метаинформацией. 
Если в проекте есть qrc-файлы, то будут также созданы cpp-файлы с данными ресурсов. 
По итогу все исходники + доп. файлы компилируются в файлы объектного кода и
объединяются линковщиком в готовый испольняемый модуль (программу).

При отладке, полезно использовать методы dumpObjectInfo() и dumpObjectTree().
Они возвращают метаинформацию об объекте типа QObject или его иерархии.
Для облегчения отладки, всем объектам QObject нужно давать имена.

Помимо дамп-методов есть также методы для вывода форматированных сообщений: 
qDebug(), qWarning(), qFatal(). Они работают как cout, но учитывают особенности ОС.
А если нужно перенаправить их поток вывода, то здесь поможет qInstallMessageHandler().

Также, с помощью метода qInstallMessageHandler() можно сделать, чтобы сообщения 
выводились только в отладочной версии программы, а в релизной были скрыты (стр. 69).

Получить информацию о библиотеке (узнать версию или где наход. расширения plug-ins),
можно с помощью класса QLibraryInfo, который предоставляет ряд статич. методов.

------------------------

РАЗНОЕ

Qt Assistant - программа, предоставляющая документацию по Qt. Встроена в Qt Creator.
Утилита QMake - это генератор платформозависимых make-файлов (уже устарела).

Отладку приложения можно выполнить и без графического интерфеса в IDE. Для этого 
нужно скомпилировать программу с флагом -g и при запуске через консоль, использовать
команды: run, up, attach, where, break, next, step, continue, until и др. (стр. 64)

