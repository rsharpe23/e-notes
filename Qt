ОСНОВЫ QT

Приложение должно начинаться с подключения хотя бы одного их следующих модулей: 
QtCore, QtGui, QtWidgets. Но обычно подключают только QtWidgets.

Далее необходимо создать объект класса QApplication. Он осуществяет управление
приложением. Для каждого приложения этот объект должен создаваться только один раз 
и до любых операций, связанных с пользовательским интерфейсом.

После создания этого объекта, необходимо вызвать его метод exec(). Он запустит цикл
обработки событий. Этот цикл передает получаемые от системы события на обработку. 
По завершении работы приложения, метод exec() возвращает код завершения.

Виджеты (элементы управления) не отображаются сразу после создания. 
Для их отображения нужно использовать метод show().

Пример минимального приложения:
...
#include <QtWidgets>

int main(int argc, char** argv) 
{
    QApplication app(argc, argv);

    QLabel label("Hello!");  --> виджет
    label.show();

    return app.exec();  
}

Библиотека Qt разбита на модули:
* QtCore - модуль ядра, состоящий из классов, не связанных с GUI;
* QtGui - модуль базовых классов для работы с GUI и OpenGL; 
* QtWidgets - модуль, дополняющий QtGui виджетами и хранящий QApplication;
* QtQuick - модуль, содержащий фреймворк для быстрого создания GUI;
* QtQML - модуль, содержащий движок для языков QML и JS;
* QtNetwork - модуль для работы с сетью;
* QtSql - модуль для работы с базами данных;
* QtSvg - модуль для работы с SVG
* QtXml - модуль поддержки XML, с классами относящимися к SAX и DOM;
* QtXmlPatternts - модуль поддержки XPath, XQuery, XSLT и XmlShemaValidator;
* QtMultimedia - модуль классов для работы со звуком, видео, камерой, радио и т.п.;
* QtMultimediaWidgets - модуль виджетов для QtMultimedia;
* QPrintSupport - модуль для работы с принтером;
* QtTest - модуль для тестерования кода.

Модули подключаются отдельно, в pro-файлах. Для каждого модуля предоставляется
заголовочный файл. Название такого файла всегда соответсвует названию 
самого модуля, например: #include <QtGui>

Модуль QtCore является базовым для всех других модулей. Он позволяет реализовывать
приложения без GUI, например консольные приложения.

Модули QtQuick и QtQML - это альтернатива виджетам. Они предоставляют набор технологий
для быстрой и современной разработки графических приложений на QML и JS.

Допольнительные модули:
* QtWebEngineCore - интегрирует в приложение возможности веб;
* QtWebEngineWidgets - удобные виджеты для веб;
* Qt3D - модуль для упрощенной работы с 3d графикой;
* QtBluetooth - модуль для работы с Bluetooth;
* QtLocation - модуль для работы с геолокацией и местоположением;
* QtSensors - обеспечивает доступ к сенсорам моб. устройств и акселерометрам;
  поддерживает такие платформы, как: Android, iOS, SailFish, WinRT;
* QtCharts - модуль для отображения графиков;
* QtDataVisialization - модуль для отображения графиков в 3d;
* QtVirtualKeyboard - виртуальная клавиатура для настольных компьютеров;
* QtRemoteObjects - модуль для межпроцессного взаимодействия (IPC), 
  обеспечивающий обмен информацией между приложениями;

Пространство имен Qt содержит ряд перечислений и констант, которые часто применяются
при работе. Подключить его можно так: using namespace Qt.

Qt расширяет C++ дополнительными ключевыми словами. Делает он это с помощью MOC. 
MOC (метаобъектный компилятор) - это прероцессор, который анализирует классы на наличие
в них специального макроса Q_OBJECT и дополняет их отдельными cpp-файлами, содержащими
реализации по замене ключевых слов на понятный для компилятора код (метаинформация). 

Cpp-файлы с метаинформацией именуются так: moc_<filename>.cpp

Если классу не требуется метаинформация, то этот макрос можно не внедрять. 
А если он есть, тогда должен стоять в самом начале, раньше всех других макросов.

Qt полностью построен на классах. Базовым классом для всех объектов является QObject.
Объекты типа QObject и его наследники предоставляет поддержку:

* сигналов и слотов;
* таймера;
* механизма объединения объектов в иерархии;
* событий и их фильтрации;
* организации объектных иерархий;
* метаобъекной информации;
* приведения типов;
* свойств.

Объекты QObject в основном располагаются в иерархии. Такой подход позволяет не
беспокоится об освобождении памяти, после их создания. Механизмы Qt будут 
делать это автоматически. 

Конструктор класса QObject имеет вид: QObject(QObject* pobj = 0);
Это означает что каждый объект хранит указатель на своего предка в иерархии.

Все объекты QObject (особенно те, что имеют предков) должны создаваться через new,
иначе нарушится механизм автоматического освобождения памяти.
...
QObject* pobj1 = new QObject();
QObject* pobj2 = new QObject(pobj1);
QObject* pobj3 = new QObject(pobj2);

При множественном наследовании нужно помнить, что QObject должен всегда стоять первым,
иначе MOC неправильно распознает класс и будет ошибка компиляции. Кроме того, нельзя
наследоваться сразу от нескольких классов, которые наследуют QObject.

Все объекты типа QObject и их наследники хранят метаобъектную информацию (см. выше). 
В ней хранится информация о сигналах и слотах, о классе и о наследовании. 
Получить доступ к ней можно с помощью метода metaObject().
...
pobj->metaObject()->className();
pobj->inherits("QWidget");

Свойства в Qt - это поля, у которых есть вспомогательные методы доступа.
Они широко применяются в визуальной среде разработки интерфейсов Qt Designer.

Свойства задаются с помощью макроса Q_PROPERTY:
Q_PROPERTY(type name READ getter [WRITE setter RESET resetFn DESIGNABLE bool 
    SCRIPTABLE bool STORED bool])

class MyClass : public QObject 
{
Q_OBJECT
Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

private:
    bool m_readOnly;

public:
    MyClass(QObject* pobj = 0) : QObject(pobj), m_readOnly(false)

public:
    bool isReadOnly() { return m_readOnly; }
    void setReadOnly(bool value) { m_readOnly = value; }
};

pobj->setProperty("readOnly", true);
bool readyOnly = pobj->property("readOnly").toBool();

Механизм сигналов и слотов необходим для обработки событий от GUI, а также для связи
виджетом. Раньше, вместо них использовались колбеки. Концепция колбеков устарешая, 
но она лежит в основе WinAPI, который построен на процедурном стиле. 

Многие разработчики, при разработке под Windows, используют библиотеку MFC. 
Она немного облегчает разработку, добавляя классы.

Сигналы и слоты можно соединять в любой точке приложения. Сигнал можно соединять с
любым кол-во слотов и наоборот, слот может получ. сообщения от любого кол-ва сигналов.

Сигналы определяются в классе как обычные методы, но без реализации. Реализацию берет
на себя MOC. Также методы сигналов должны возвращать void. Послать сигнал можно 
с помощью ключевого слова emit.

class MyClass1 : public QObject
{
    Q_OBJECT
    
public:
    void sendMessage() { 
        emit mySignal("hello"); 
    }

signals:
    void mySignal(QString&);
};

Слоты - это методы, обрабатывающие сигналы. Если требуется, чтобы слот реагировал
только на сигналы, но при этом был не доступен для вызова как обычный метод, 
то его нужно объявлять с модификатором private либо protected.

Слоты могут быть виртуальными, но соединение таких слотов с сигналами медленное.
В слотах нельзя использовать параметры по умолчанию или определять их статическими.
Внутри слота вызовом метода sender() можно узнать, от какого объекта был вызван сигнал.

class MyClass2 : public QObject
{
    Q_OBJECT

public slots:
    void mySlot(QString& msg) {
        cout << msg << sender()->objectName();
    }
};

Соединение сигналов со слотами осуществл. с пом. статич. метода connect().
Методу connect() передаются следующие параметры:

* sender - объект, отправляющий сигнал;
* signal - прототип сигнала, заключенный в макрос SIGNAL();
* receiver - объект, имеющий слот для обработки сигнала;
* slot - прототип слота, заключенный в макрос SLOT();
* type - режим обработки сигнала;

int main() 
{
    QApplication app();

    MyClass1 a;
    MyClass2 b;

    QObject::connect( 
        &a, SIGNAL(mySignal(QString&)),  -->  слот может игнорир. парам. сигнала
        &b, SLOT(mySlot(QString&))            т.е. можно так: SLOT(mySlot()) 
    );
    a.sendMessage();

    return app.exec();
}

Если слот не делает ничего, кроме проброски полученного сигнала дальше, то
можно вообще обойтись без него и просто соединить друг с другом только сигналы.

Метод connect возвращает объект Connection. Его можно привести к типу bool, если
требуется проверить, было ли соединение успешным.

При уничтожении объекта происходит автоматическое разъединение всех его сигнально-
слотовых связей. Но разъединение можно выполнить и вручную с пом. статического метода
QObject::disconnect(). Они принимает такие же параметры, что и connect().

Если нужно сократить кол-во слотов либо обрабатывать одним слотом разные сигналы, 
то можно воспользоваться классом QSignalMapper.

В Qt есть собственные примитивные типы данных: qint8, qlonglong и пр. (стр. 70).
Они нужны для того, чтобы абстрогироваться от особенностей той или иной архитектуры,
например qint64 где-то может быть __int64, а где-то long long.

В заголовочном файле <QtGlobal> содержатся полезные макросы и ф-ции:
* qMax(a, b) - максимальное число;
* qMin(a, b) - минимальное число;
* qAbs(value) - модуль числа;
* qRound(value) - округляет число;
* qBound(min, max, value) - значение между минимум и максимумом;
* qFuzzyCompare(a, b) - сравнивает вещественные значения. 

Компилятор ресурсов RCC внедряет сторонние ресурсы (картинки, файлы перевода и т.п.)
в иcполняемые модули, чтобы приложение могло обращаться к ним в рантайме.

Ресурсы описываются через XML, в специальных файлах с раширением ".qrc". Эти файлы 
добавляются в проект также, как и все остальные исходники (через CMake/QMake).
...
<!DOCTYPE RCC>
<qresource>
    <file>images/icon.png</file>
    <file>images/photo.jpg</file>
</qresource>
</RCC>

RCC парсит xml и создает на его основе cpp-файл, где данные представлены 
в виде одного большого массива. 

Получить доступ к ресурсу из кода, например к картинке, можно так:
plbl->setPixmap(QPixmap(":/images/photo.jpg"));

Структура Qt-проекта состоит из исходников в виде заголовочный файлов и файлов cpp.
Помимо исходников в нём также есть файл с расширением ".pro", из которого, 
через qmake, генерируется make-файл проекта. 

В make-файле содержится вызов MOC для создания доп. cpp-файлов с метаинформацией. 
Если в проекте есть qrc-файлы, то будут также созданы cpp-файлы с данными ресурсов. 
По итогу все исходники + доп. файлы компилируются в файлы объектного кода и
объединяются линковщиком в готовый испольняемый модуль (программу).

При отладке, полезно использовать методы dumpObjectInfo() и dumpObjectTree().
Они возвращают метаинформацию об объекте типа QObject или его иерархии.
Для облегчения отладки, всем объектам QObject нужно давать имена.

Помимо дамп-методов есть также методы для вывода форматированных сообщений: 
qDebug(), qWarning(), qFatal(). Они работают как cout, но учитывают особенности ОС.
А если нужно перенаправить их поток вывода, то здесь поможет qInstallMessageHandler().

Также, с помощью метода qInstallMessageHandler() можно сделать, чтобы сообщения 
выводились только в отладочной версии программы, а в релизной были скрыты (стр. 69).

Получить информацию о библиотеке (узнать версию или где наход. расширения plug-ins),
можно с помощью класса QLibraryInfo, который предоставляет ряд статич. методов.

---------------------------

КОНТЕЙНЕРЫ

Tulip - это встроенная в Qt библиотека контейнеров. Она похожа на STL, и даже
совместима с ней. Обычный STL также можно использовать, хотя Tulip считается более
оптимизированной и занимает меньше места в билде.

Последовательные контейнеры - это упорядоченные коллекции, где позиция элемента 
зависит от места его вставки. Qt содержит 5 классов этой категории:

* QVector<T> - ветор;
* QList<T> - список;
* QLinkedList<T> - двусвязаный список;
* QStack<T> - стек;
* QQueue<T> - очередь.

Ассоциативные контейнера - это коллекции, в которых позиция элемента 
от его значения. Классы этой категории:

* QSet<T> - множество;
* QMap<K, V> - словарь;
* QMultiMap<K, V> - мультисловарь;
* QHash<K, V> - хэш;
* QMultiHash<K, V> - мультихэш.

Объекты QObject и потомки не могут храниться в этих контейнерах, т.к. у этого типа
конструктор копирования и опиратор присвоения находятся в секции private. 
Но указатели на них сохранять можно!

Qt предоставляет 2 стиля итераторов:
* итераторы в стиле Java;
* итераторы в стиле STL;

Итераторы в стиле Java компактнее при записи, но занимают больше места в билде.
...
QList<QString> list;
list << "hello" << "world";
QListIterator<QString> it(list);
while (it.hasNext()) {
    qDebug() << "element:" << it.next();
}

Итераторы типа QListIterator являются константными. Чтобы была возможность для
изменения элементов, необходимо использовать такие же, но с приставкой "Mutable":
QMutableListIterator, QMutableHashIterator, QMutableMapIterator и т.д. 

Итераторы в стиле C++ эффективнее и могут использоваться с STL:
...
QVector<QString> vect;
vect << "hello" << "world";
QVector<QString>::iterator it vect.begin();
for (; it != vect.end(); it++) {
    qDebug() << "element:" << *it;
}

В Qt также имеется макрос foreach, являющийся альтернативой для перебора.
...
QList<QString> list({ "hello", "world" });
foreach(QString str, list) {
    qDebug() << "element:" << str;
}

Скорость выполнения операций для последовательных контейнеров:
------------------------------------------------------------------------------
    КОНТЕЙНЕР    |  ДОСТУП  | ВСТАВКА/УДАЛЕНИЕ | ДОБ. В КОНЕЦ | ДОБ. В НАЧАЛО
------------------------------------------------------------------------------
  QList, QQueue  |  быстро  |    медленно      |    быстро    |    быстро
------------------------------------------------------------------------------
 QVector, QStack |  быстро  |    медленно      |    быстро    |   медленно
------------------------------------------------------------------------------
   QLinkedList   | медленно |     быстро       |    быстро    |    быстро
------------------------------------------------------------------------------

Специфические методы QVector:
* data() - возвращает указатель на обычный массив;
* toList() - возвращает объект QList;
* toStdVector() - возвращает объект std::vector.

Массив байтов QByteArray - контейнер, похожий на вектор, элементы которого могут
хранить только один байт. Подходит для хранения промежуточных данных.

К QByteArray можно применять операции сжатия и распаковки:
...
QByteArray arr = "Test Data";
QByteArray arr2 = qCompress(arr);
qDebug() << qDecompress(arr2);

Чтобы представить бинарные данные в виде текста, можно воспользоваться 
методами: toBase64() и fromBase64().
...
QByteArray arr3 = arr.toBase64();  -->  VGVzdCBEYXRh
QByteArray::fromBase64(arr3);  -->  Test Data

Перед кодированием в base64, данные можно дополнительно сжать.

Также, существует ещё и массив битов QBitArray. Его элементы занимают всего по одному
биту. Этот тип можно использовать для хранения большого кол-ва булевых переменных.

Специфические методы QList:
* move() - перемещает элемент с одной позиции на другую;
* swap() - меняет местами два элемента на указанных позициях;
* toSet() - возвращает объект QSet;
* toVector() - возвращает объект QVector;
* toStdList() - возвращает объект std::list.

Если, при получении эл-та, нет необходимости его изменять, то вместо индексатора []
лучше использовать at(), т.к. он возвращает константную ссылку на элемент.

При работе с большими списками или если требуется часто вставлять эл-ты, лучше
использовать QLinkedList. Но у него нет индексатора и метода at().

Класс QStack представляет собой реализацию стековой структуры. 
QStack унаследован от QVector, а QQueue - от QList.

Пример работы с QMap:
...
QMap<QString, QString> phonebook;
phonebook["Piggy"] = "+49 (631) 242391";
phonebook["Kemit"] = "+49 (631) 852331";
phonebook["Gonzo"] = "+49 (347) 123563";

QMap<QString, QString>::iterator it = phonebook.begin();
for (; it != phonebook.end(); it++) {
    qDebug() << "name:" << it.key() << "phone": << it.value();
}

Если обратиться к эл-ту которого нет в словаре, то он создастся c пустым значением. 
Посему, перед обращением, надо проверять их наличие с пом. метода contains():
Это правило относится ко всем ассоциативным контейнерам.
...
if (phonebook.contains("Gonzo")) {
    qDebug() << "phone:" << phonebook["Gonzo"];
}

Специфические методы QMap:
* lowerBound() - итератор первого эл-та с заданным ключом;
* upperBound() - итератор последнего эл-та с заданным ключом;
* toStdMap() - возвращает стандартный словарь STL.

Специфические методы QHash:
* capacity() - возвращает размер хэш-таблицы;
* reserve() - задает размер хэш-таблицы;
* squeeze() - уменьшает объем хэш-таблицы, для уменьшения памяти.

Специфические методы QSet:
* unit() - объединяет эл-ты множеств;
* intersect() - пересечение эл-тов множеств 
  (удаляет эл-ты, которых нет в обоих множествах);
* substract() - разность эл-тов множеств
  (удаляет эл-ты, которые есть в обоих множествах);

Алгоритмы определены в заголовочном файле QtAlgorithms, в виде шаблонных ф-ций.
Но если их окажется недостаточно, можно воспользоваться алгоритмами SLT.

* qBinaryFind() - бинарный поиск элементов;
* qCopy() - копирование эл-тов, начиная с первого;
* qCopyBackward() - копирование эл-тов, начиная с последнего;
* qCount() - количество элементов;
* qDeleteAll() - удаление всех элементов;
* qEqual() - сравнение элементов;
* qFill() - присваивает всем эл-там заданное значение;
* qFind() - поиск элементов;
* qLowerBound() - нахожден. эл-та, со значен. большим либо равным заданному;
* qUpperBound() - нахожден. эл-та, со значен. строго большим заданного;
* qSort() - сортировка элементов;
* qStableSort() - сортировка, с сохранен. порядка следования равных эл-тов;
* qSwap() - обмен значений между двумя эл-тами.

При использовании ф-ций сравнения и сортировки необходимо чтобы передаваемые 
объекты определяли оператор ==.

Строки представлены контейнером QString. Строки хранятся в формате Unicode, 
где каждый символ занимает 2 байта. Элементы относятся к типу QChar.

Методы QString:
* isEmpty() - проверяет, пуста ли строка;
* append() - конкатенация строк (либо оператор +);
* replace() - заменяет часть строки;
* toLower/Upper() - перевод символов в нижний/верхний регистр;
* setNum() - конвертация числа в строку; 
* toInt/Double() - конвертация строки в число;
* split() - разбивает строку на список строк (QStringList);
* join() - объединяет список строк в одну строку;
* starts/endsWith() - проверяет, начин./заканч. ли строка на заданное значение;
* contains() - проверяет, содержит ли строка подстроку;
* indexOf() - индекс найденной подстроки, поиск с начала;
* lastIndexOf() - индекс найденной подстроки, поиск с конца;
* left/right() - часть строки с указанным кол-вом символов слева/справа;
* mid() - часть строки, начиная с указанной позиции;
* simplified() - удаляет повторяющиеся знаки пробелов;
* left/rightJustified() - дополняет строку заданным символов слева/справа;

Некоторые из этих методов работают с регулярными выражениями, например: 
contains(), indexOf(), lastIndexOf(),

Другие варианты конвертации числа в строку:
...
QString str = QString::number(35.123);
QTextStream(&str2);  -->  с пом. текстового потока

Если требуются строки в кодировке UTF-16, то вместо QString использ. QStringView.

Для работы с регулярными выражениями используется объект класса QRegExp. 
Рег. выр-я работают медленнее, чем методы в QString. 
...
QRegExp reg("[0-9]{1,3}");
QString str = "Serial number: 123-234-12";
str.contains(reg) > 0;  -->  true;

Пример фильтрации списка строк:
...
QStringList list({ "576", "3GH", "010" });
QStringList result = list.filter(QRegExp("^\\d+?"));

Методы QRegExp:
* indexIn() - индекс найденного совпадения;
* exactMatch() - определение совпадения (true/false);

Объекты класса QVariant могут содержать данные разного типа, включая контейнеры.
Но его частое применение снижает скорость работы программы.
...
QVariant var(34);
QVariant var2("hello world!");
int num = var.toInt() + 6;
QString str = var.value<QString>();

В Qt используется модель общего использования данных, для увеличения эффективности 
при инициализац. и присвоен. объектов (напоминает паттерн Flyweight, стр. 101).

---------------------------

ВИДЖЕТЫ

Класс QWidget является базовым для всех остальных виджетов. Он унаследован от QObject.
Помимо встроенного набора виджетов, можно также создавать и пользовательские.

Каждый виджет может быть контейнером для других виджетов. Если виджет-предок станет
недоступным, то все его виджеты-потомки также станут недоступны. 

Задать предка виджету можно через его конструктор. Если у виджета нет предка, тогда 
он будет виджетом верхнего уровня. Они имеют собственные окна.

Метод setWindowFlags() позволяет задать настройки окна виджета. Например, флаг
Qt::WindowStaysOnTopHint позволит окну всегда находится на переднем плане, 
чтобы его не перекрывали другие окна.

Слот-метод setWindowTitle() - задает надпись заголовка окна. Это имеет смысл 
только для виджетов верхнего уровня.

Слот setEnabled() устанавливает виджет в доступное/недоступное состояние.
А чтобы узнать стостояние, нужно использовать метод isEnabled().

При создании пользовательских виджетов важно, чтобы они обрабатывали события.
Например, для обработки событий мыши необходимо переопределить один из их методов:
mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), mouseDoubleClickEvent().

Виджет представляет собой прямоугольную область. Методы size(), height() и width()
возвращают размеры виджета. А методы pos(), x() и y() - координаты.

Положение и размеры виджета можно изменять c помомщью методов move() и resize().
А для того, чтобы делать это одновременно, используется метод setGeometry().
Также это может задаваться и автоматически, с пом. классов компоноки.

Для отображения/скрытия виджета, используются методы show() и hide().
Отрисовка виджетов кешируется в памяти. Они перерисовываются только тогда, 
когда это действительно необходимо, что повышает производительность отображения.

Виджеты имеют важное свойство autoFillBackground, которое позволяет им автоматически
заполняться фоном и быть видимыми (по умолчанию оно false). Но перед заполнением 
нужно сначала создать палитру и установить её через setPalette().

Пример добавления виджетов:
...
#include <QtWidgets>

int main(int argc, char** argv)
{
    QApplication app(argc, argv);

    QWidget wgt;  -->  самый верхний виджет будет окном
    QWidget* wgt2 = new QWidget(&wgt);

    QPalette palette;
    palette.setColor(wgt2->backgroundRole(), Qt::blue);

    wgt2->setPalette(palette);
    wgt2->resize(100, 100);
    wgt2->move(25, 25);
    wgt2->setAutoFillBackground(true);

    wgt.resize(200, 200);
    wgt.show();

    return app.exec();
}

Изменить указатель мыши для виджета можно с помощью метода setCursor(). Он может
принимать как уже готовые значения типа CursorShape (ArrowCursor, WaitCursor,
CrossCursor и т.п.), так и пользовательские изображения типа QBitmap.
...
QPixmap pix(":/clock.png");
QCursor cursor(pix);
wgt.setCursor(cursor);

Ччтобы изменить курсор для всего приложения, нужно использовать статический метод
QGuuApplication::setOverrideCursor(). Это полезно, когда к примеру, выполняется долгая
фоновая операции. В этом случае обычная стрелка меняется на песочные часы.

Получить/изменить позацию курсора можно методами pos() и setPos(), класса QCursor.

QFrame - это виджет рамки. Стиль рамки устанавливается с пом. setFrameStyle().
Методы setLineWidth() и setMidLineWidth() задают толщину рамки.

QStackedWidget - стековый виджет, показывающий в отдельно взятый промежуток 
времени только одного из своих потомков. Унаследован от QFrame.

QScrollArea - виджет видовой прокрутки. Он отображает окно с полосой прокрутки, 
в котором распологается часть содержимого. Также унаследован от QFrame.
Этот виджет является совокупностью сразу нескольих виджетов.

Метод viewport() дает доступ к виджету области просмотра. Методы verticalScrollBar() 
и horizontalScrollBar() дают доступ к виджетам полос прокрутки. А cornerWidget() 
- доступ к виджету из правого нижнего угла.

Чтобы установить какой-то виджет как видимую область для QScrollArea, 
нужно использовать метод setWidget(), а чтобы получить его - метод widget().
Удаление виджета из QScrollArea выполняется через removeChild().

Пример создания картинки с прокруткой:
...
QScrollArea sa;
QWidget* wgt = new QWidget();

QPixmap pix(":/picture.jpg");

QPalette palette;
palette.setBrush(wgt->bachgroundRole(), QBrush(pix));

wgt->setPalette(palette);
wgt->setAutoFillBackground(true);
wgt->setFixedSize(pix.width(), pix.height());

sa.setWidget(wgt);
sa.resize(350, 150);
sa.show();

Классы компоновки изменяют размеры и позиции виджетов автоматически, после изменения
окна программы. Также, они задают расположение виджетов относительно друг друга 
и удаляют выделенную память, связанных виджетов верхнего уровня. 

Менеджеры компоновки (layout managers). 
* QBoxLayout - для размещения по горизонтали и вертикали;
* QHBoxLayout - размещение только по горизонтали;
* QVBoxLayout - размещение только по вертикали;
* QGridLayout - для табличного размещения;
* QFormLayout - таблица из 2х столбцов.

Они имеют такие методы (дописать):
* addWidget() - добавление виджета в компоновку;
* removeWidget() - удаление виджета из компоновки;
* setSpacing() - задает расстояние между виджетами, для их разделения;
* setContentsMargins() - устанавливает отступы от границ виджета до содержимого;
* addLayout() - добавляет дополнительный менеджер компоновки;
* addStretch() - добавляет фактор растяжения.

Конструктор QBoxLayout принимает один из параметров собственного перечисления:
LeftToRight, RightToLeft, TopToBottom, BottomToTop.

Виджеты установливают компоновку с помощью метода setLayout():
...
QWidget wgt;  -->  виджет верхнего уровня

QPushButton btn1 = new QPushButton("A");
QPushButton btn2 = new QPushButton("B");

QBoxLayout* layout = new QBoxLayout(QBoxLayout::LeftToRight);
layout->addWidget(btn1, 1);  
layout->addWidget(btn2, 2);  -->  второй параметр - это фактор растяжения

wgt.setLayout(layout);
wgt.resize(450, 40);
wgt.show();

Комбинируя между собой разные менеждеры компоновок, можно добиться практически 
любой сложности размещения виджетов (метод addLayout()).

Класс QGridLayout позволяет быстро создавать сложные размещения.
Таблица состоит из ячеек, позиции которых задаются строками и столбцами.

Фактор растяжения для строк и столбцов, устанавливается методами 
setRowStretch() и setColumnStretch().

Класс QFormLayout подойдет для маленьких виджетов, например для диалоговых окон.
Добавление виджетов здесь осуществяется с пом. метода addRow().

Пример калькулятора, построенного на QGridLayout (стр. 125).

При нажатии на Tab просходит перевод фокуса с одного виджета на другой.
Порядок при переводе соответсвует очередности установки дочерних виджетов.

Если требуется, чтобы порядок был более логичным, то его можно изменить 
с помощью статического метода QWidget::setTabOrder().

Класс QSplitter задает разделить. Он полезн, когда к примеру, нужно разделить 
текстовое и графическое содержимое виджета. Черту разделителя можно двигать мышью.

Если необходимо, чтобы виджеты разделителя были проинформированы об изменении 
размеров, то тогда нужно вызвать метод setOpaqueResize(true).

QLabel - это виджет надписи. Унаследован от QFrame и может иметь рамку. 
Выводит: текст, html, картинку, анимацию с пом.: setText(), setPixmap(), setMovie(). 
...
QLabel label("<h1>Title</h1><p>text</p>");
label.show();

Выравниваение текста задается через метод setAlignment(), принимающий флаги. 
Флаги выравнивания можно комбинировать, например: AlignCenter тоже самое, 
что и AlignVCenter | AlignHCenter.

Метод setBuddy() привязывает виджет к QLabel. Если текст содержит амперсанд,
то символ, перед которым он стоит, будет подчернутыми. При нажатии клавиши этого
символа вместе с Alt, фокус перейдет к привязанному виджету.
...
QLabel* label = new QLabel("&Name");
QLineEdit* input = new QLineEdit();
input->setBuddy(label);  -->  при нажатии "N", фокус перейдёт к input'у

Чтобы геперссылки, внутри QLabel, могли открываться через браузере, нужно
воспользоваться методом setOpenExternalLinks(true):

QProgressBar - виджет индикитора выполнения. Метод setRange() задает кол-во шагов.
Метод setMinimumWidth() - длину виджета в пикселях. А setValue() - текущий шаг.

QLCDNumber - виджет элекронного дисплея чисел. Стиль дисплея можно изменять, а также
использовать разные режимы отображения чисел: в двоичной, восьмеричной, десятеричной
и шестнадцатеричной сестемах счисления. Кроме того, допускается использование точки
между позициями сегментов, с помощью метода setSmallDecimalPoint().

Кнопками являются классы: 
* QPushButton - обычная кнопка; 
* QCheckBox - флажок;
* QRadionButton - переключатель.

Для получения и установки текста кнопки, использ. методы text() и setText().
Для получения и установки изображения - методы icon() и setIcon(). 
Для размеров изоборажения - методы iconSize() и setIconSize().

Кнопки имеют следующие сигналы:
* pressed() - отправляется при нажатии на кнопку мыши;
* released() - отправляется при отпускании кнопки мыши;
* clicked() - когда пользователь нажал и отпустил кнопку мыши;
* toggled() - при изменении переключателя.

Методы опроса состояния кнопки:
* isDown() - возвращает true, если кнопка находится в нажатом состоянии;
* isChecked() - возвращает true, если кнопка находится в выбранном состоянии;
* isEnabled() - кнопка доступна, т.е. может реагировать на действия пользователя.

Метод setCheckable() позволяет кнопке работать как флажок (toggle button).
Метод setFlat() делает кнопку без видимых контуров (секретная кнопка).

Метод setMenu() позволяет кнопке вызывать выпадающее меню, которое задается с пом.
класса QMenu. Чтобы добавить в QMenu элементы, используется метод addAction().
...
QPushButton btn("Menu");

QMenu* menu = new QMenu(&btn);
menu->addAction("Item 1");
menu->addAction("Item 2");

btn.setMenu(menu);
btn.show();

Флажки применяются, когда нужны какие-то опции. В отличии от toggle button, они 
могут иметь третье состояние - неопределенное. Это когда в рамке, вместо галочки,
находится маленький квадратик (как в инсталляторах).

Чтобы изменить состояние обычного флажка, используется метод setChecked().
А чтобы изменить состояние "tristate" флажка - метод setCeckState(), но перед этим 
его нужно перевести в этот режим, с пом. setTristate().

Переключатели, как и флажки, изменяют своё состояние с помощью setChecked().
Переключатели не могут использоваться по отдельности и должны быть сгруппированы.

Группируются они с пом. класса QGroupBox. Если кол-во переключателей больше пяти, 
то лучше использовать выпадающий список QComboBox.
...
QGroupBox gbx("&Colors");

QRadioButton* red = new QRadioButton("&Red");
QRadioButton* blue = new QRadioButton("&Blue");
red->setChecked(true);

QVBoxLayout* layout = new QVBoxLayout();
layout->addWidget(red);
layout->addWidget(blue);

gbx.setLayout(layout);
gbx.show();

Группироваться могут не только переключатели но и другие виджеты, которые объединены 
между собой логически (для лучшего визуального восприятия).

Виджеты, относящиеся к элементам настройки, используются для установки значений, не
требующих большой точности, например: настройка громкости, скроллинга окна и т.п.

Они определены такими классами: 
* QSlider - ползунок; 
* QScrollBar - полоса прокрутки; 
* QDial - установщик (кружок, как в стиралке).

Обычно, полоса прокрутки встроена в виджет QAbstractScrollArea, и сама по себе
используется редко (т.е. вместо QScrollBar лучше использовать виджеты, 
производные от QAbstractScrollArea).

Большая часть виджетов ввода поддерживает операцию Drag&Drop.

Виджет QLineEdit представляет собой однострочное текстовое поле. А для ввода
многострочного текста, используется QTextEdit.

Сигнал textChanged() вызывается при изменении текста. Если текст был изменен 
не программно, а пользователем, то вызывается textEdited(). Сигнал returnPressed()
вызывается, когда пользователь нажимает на Enter.

Для QLineEdit можно включить режим ввода пароля, с помощью метода
setEchoMode(QLineEdit::Password);

В QLineEdit есть слоты для работы с буфером обмена:
* copy() - копирует выделенный текст;
* cut() - копирует выделенный текст и удаляет его из поля ввода;
* paste() - вставляет текст, стирая выделенное.

Методы undo() и redo() отменяют/повторяют последнюю операцию. Проверить возможность
использования этих операций можно c пом. isUndoAvailable() и isRedoAvailable().

Класс QTextEdit также поддерживает редактирование html. Но если требуется только
отобразить текст в html, без редактирования, то лучше использовать QLabel.

Некоторые методы QTextEdit:
* text() - получение текущего текста;
* setPlainText() - установка обычного текста;
* setHtml() - установка текста в html;
* selectAll(), deselect() - выделение и снятие выделения всего текста.
* append() - добавляет текст, на который не действуют операции undo/redo;
  благодаря чему, работает быстрее;
* find() - ищет и выделяет строку в тексте.

Если нужен редактор обычного текста, то лучше использовать виджет QPlainTextEdit, 
т.к. он более легковесный и занимает меньше памяти.

Виджеты QTextEdit и QLineEdit имеют похожие методы и сигналы. QTextEdit можно
использовать совместно с QSyntaxHighlighter для подсветки синтаксиса.
Пример реализации редактора кода, стр. 165.

Для работы с выделенным текстом используется класс QTextCursor, объект которого
хранится в самом виджете QTextEdit. А для управления документом - методы: 
document() и setDocument().

Документ представлен классом QTextDocument. Класс QTextDocumentWriter позволяет
записать его текст в файлы 3х форматов: PlainText, HTML, ODF.
...
QTextEdit* txt = new QTextEdit("This is a <h2>TEST</h2>");
QTextDocumentWriter writer;
writer.setFormat("odf");
writer.setFileName("output.odf");
writer.write(txt->document());

QTextDocumentWriter не поддерживает запись в PDF, но это можно реализовать путём
рисования в контексте QPrinter (из модуля QtPrintSupport), либо с помощью QPdfWriter.

Виджеты счетчиков:
* QSpinBox - счетчик (числовое поле, как <input type="number">);
* QDoubleSpinBox - счетчик для значений типа double;
* QDateTimeEdit - виджет ввода даты и времени.

Метод setWrapping() устанвливает циклический режим, когда за максимальным 
значением следует минимальное, и наоборот.

Методы setPrefix() и setSuffix() изменяют отображение чисел, например с помощью 
них можно добавить числам скобки и т.п.

Контроллер QValidator реализует правильность ввода текста. Установить объект
контроллера можно с помощью метода setValidator(), который содержатся
в QComboBox и QLineEdit. 

Для проверки ввода чисел используются встроенные валидаторы: 
QIntValidator и QDoubleValidator.

Для создания собственного валидатора, нужно наследоваться от QValidator 
и перезаписать метод validate().
...
class NameValidator : public QValidator 
{
public:
    virtual State validate(QString& str, int& pos) const
    {
        QRegExp rxp = QRegExp("[0-9]");
        return str.contains(rxp) ? QValidator::Invalid 
            : QValidator::Acceptable;
    }
}

QLineEdit* txt = QLineEdit();
NameValidator* validator = new NameValidator(txt);
txt->setValidator(validator);

Элементы выбора представлены виджетами: QListWidget, QTreeWidget, QTableWidget,
QTabWidget, QComboBox и QToolBox. Их item'ы, помимо текста и картинок, могут быть
также виджетами. Но это снижает быстродействие.

QListWidget - виджет списка. Элементы списка представлены классом QListWidgetItem.
Элементы-виджеты задаются такие с помощью метода setItemWidget().

Пример создания списка:
...
QListWidget list;
QListWidgetItem* item = 0;

foreach(QString str, strArr) {
    item = new QListWidgetItem(str, &list);
    item->setIcon(QPixmap(":/" + str + ".jpg"));
}

list.resize(125, 175);
list.show();

Узнать, какой элемент выбрал пользователь, можно с пом. метода currentItem().
Если выбранных элементов несколько, то надо использовать selectedItems(). Режим
множествен. выделения задается: setSelectionMode(QAbstractItemView::MultiSelection);

C пом. метода setFlags(Qt::ItemIsEditable) можно предоставить пользователю 
возможность редактирования текста элемента.

Также, список можно перевести в режим пиктограмм (когда эл-ты в виде значков).
Это позволит проводить операцию перетаскивания Drag&Drop.
...
list.setSelectionMode(QAbstractItemView::MultiSelection);
list.setViewMode(QListView::IconMode);  -->  задается режим пиктограмм

foreach(QString str, strArr) {
    item->setFlags(Qt::ItemIsSelectable | Qt::ItemIsDragEnabled);
}

QTreeWidget - виджет древовидного списка. Поддерживает возможность выбора одного 
или нескольких значений, а также Drag&Drop.

Элементы будут с флажками, если задать Qt::ItemIsUserCheckable.
...
QTreeWidgetItem* item = new QTreeWidgetItem(treeWgt);
item->setFlags(Qt::ItemIsUserCheckable);
item->setCheckState(0, Qt::Checked);

Узнать состояние флажка элемента, можно с пом. checkState(номер_столбца):
if (item->checkState(0) == Qt::Checked) { }

Элементы QTreeWidget и могут иметь несколько столбоц с данными. Добавить столбцы 
можно с пом. метода addChildren(). Метод setExpanded() разворачивает эл-нт.

С помощью итератора QTreeWidgetIterator можно пройтись по элементам списка, 
а чтобы пройтись только по выделенным, нужно передать в конструктор флаг Selected.

Метод sortItems() позволяет сортировать эл-ты у обоих списков. Для сортировки по 
датам, нужно создать новый виджет эл-та, и перезаписать в нём operator<().

QTableWidget - виджет таблицы. Элементы таблицы представлены через QTableWidgetItem.
Задать элемент в таблице можно с пом. метода setItem(rowNum, colNum).

QComboBox - виджет выпадающего списка. Он предоставляет возможность выбора только
одного элемента. По ф-циональному назначению совпадает с QListWidget.

Вызов метода setDuplicatesEnabled(false), исключает попадание повторяющихся эл-тов.
Чтобы узнать текущий элемент, используется метод currentIndex(). Если вызвать
setEditable(true), то пользователь сам сможет добавлять элементы в список.

QTabWidget - виджет вкладок (по горизонтали). 
QToolBox - виджет панели инстументов (вертикальные вкладки).

Интервью, или модель-представление - это паттерн, который используется в Qt 
для разделения логики и визуализации данных.

Модель отвечает за управление данными. Чтобы создать модель, нужно унаследоваться 
от класса QAbstractItemModel или его потомков. Список некоторых потомков:

* QAbstractListModel - модель, представляющая одномерный список;
  * QStringListModel - модель, для работы со списком строк;

* QAbstractTableModel - модель, представляющая таблицу;
  * QSqlQueryModel - модель, для работы с sql-запросами;

* QStandartItemModel - позволяет напрямую сохранять данные в модели; 
  удобно использовать в маленьких приложениях, с небольшим набором данных;

* QAbstractProxyModel - модель, для промежуточной обработки данных;
* QFileSystemModel - модель, для работы с файловой системой.

Представление отвечает за отображение данных. Чтобы создать представление, нужно
унаследоваться от класса QAbstractItemView или его потомков. Метод setModel()
устанавливает представлению модель, а setItemDelegate() - делегат.

Основные потомки QAbstractItemView:
* QListView - одномерный список; располагает режимом пиктограмм;
* QTreeView - древовидный список, отображающий столбцы данных;
* QTableView - отображает данные в виде таблицы.

Пример работы с данными, через модель-представление:
...
QWidget wgt;

QStringListModel model;
model.setStringList(QStringList() << "Item1" << "Item2");

QListView* listView = new QListView();
listView->setModel(&model);

QTableView* tableView = new QTableView();
tableView->setModel(&model);

QItemSelectionModel sModel(&model);
listView->setSelectionModel(&sModel);
tableView->setSelectionModel(&sModel);

QHBoxLayout* layout = new QHBoxLayout();
layout->addWidget(listView);
layout->addWidget(tableView);

wgt.setLayout(layout);
wgt.show();

Делегат отвечает за отрисовку элементов представления. Чтобы создать делегат, нужно
унаследоваться от классов QStyledItemDelegat или QAbstractItemDelegat.

Пример делегата, выделяющего виджет при наведении курсора:
...
class MyDelegate : public QStyledItemDelegate
{
public:
    void paint(QPainter* painter, QStyleOptionViewItem& option, 
               QModelIndex& index)
    {
        if (option.state & QStyle::State_MouseOver) {
            QRect rect = option.rect;

            QLinearGradient gradient(0, 0, rect.width(), rect.height());
            gradient.setColorAt(0, Qt::red);
            gradient.setColorAt(1, Qt::green);

            painter.setBrush(gradient);
            painter.drawRect(rect);
        }

        QStyledItemDelegate::paint(painter, option, index);
    }
}

QListView listView;
listView.setModel(&model);
listView.setItemDelegate(new MyDelegate(&listView));
listView.viewport()->setAttribute(Qt::WA_Hover);
listView.show();

Флаг WA_Hover задается, чтобы QListView мог реагировать на перемещение 
курсора мыши над собой. 

Чтобы получить данные из ячейки таблицы, используют индекс модели.
Проверить данные по заданным координатам можно с помощью метода isValid().
...
QModelIndex index = tableModel->index(2, 5, QModelIndex());
if (index->isValid()) {
    QVariant value = tableModel->data(index);
}

Чтобы правильно отображать данные, представления используют роли.
* DisplayRole - текст для показа;
* DecorationRole - растровое изображение;
* FontRole - шрифт для текста;
* ToolTipRole - текст для подсказки;
* WhatThisRole - текст для подсказки "что это?";
* TextColorRole - цвет текста;
* BackgroundColorRole - цвет фона.

Роли связаны с индексами модели, а те, в свою очередь, являются как бы идентификаторами
данных. Для пользовательских моделей можно создавать свои собственные роли. 

Пример списка, где каждый item выводит: текст, картинку и подсказку.
...
QStringList list;
list << "Linux" << "Windows" << "MacOS";

QStandartItemModel model(list.size(), 1);  -->  индексы есть не только у таблиц

for (int i = 0; i < model.rowCount(); i++) {
    QModelIndex index = model.index(i, 0);
    QString str = list.at(i);
    model.setData(index, str, Qt::DisplayRole);
    model.setData(index, "Tooltip:" + str, Qt::ToolTipRole);
    model.setData(index, QIcon(str + ".jpg"), Qt::DecorationRole);
}

QListView listView;
listView.setViewMode(QListView::IconMode);
listView.setModel(&model);
listView.show();

Виджеты: QListWidget, QTreeWidget и QTableWidget построены на основе элементно
ориентированного подхода, т.е. они унаследованы от представлений QListView 
и т.д., и имеют внутренние модели данных.

При этом, их модели можно разделять с отдельными представлениями:
...
QListWidget wgt;
wgt.setWindowTitle("List Widget");
wgt.show();

QListView view;
view.setModel(wgt.model());  -->  отобразит данные из виджета по своему
view.setWindowTitle("List View");
view.show();

Все цвета виджета хранятся в цветовой палитре. Чтобы получить доступ к объекту 
палитры, используется метод palette(), класса QWidget. 

Объект QPalette имеет 3 группы, которые отвечают за 3 состояния виджета: активное,
неактивное и недоступное. Каждая группа состоит из цветовых ролей, а каждая роль 
имеет кисть QBrush (заливка по паттерну), и цвет QColor (сплошная заливка). 

Цветовые роли (полный список на стр. 218):
* Text - цвет текста;
* ButtonText - цвет текста на кнопках;
* Highlight - цвет фона, когда элемент активен (выделен);
* HighlightText - цвет текста, когда элемент активен;
* Window - основной цвет фона;
* Button - цвет кнопки;
* Link - цвет гиперссылки.

Пример переопределения цветов виджета:
...
QSpinBox spinBox;

QPalette palette = spinBox.palette();
// Кнопки будут залиты красными точками и иметь синий текст
palette.setBrush(QPalette::Button, QBrush(Qt::red, Qt::Dense3Pattern));
palette.setColor(QPalette::ButtonText, Qt::blue);

spinBox.setPalette(palette);
spinBox.resize(150, 74);
spinBox.show();

Чтобы переопределить цвета для всех виджетов (глобально), нужно использзовать
статический метод QApplication::setPalette().

При создании объекта палитры, можно указать только 2 цвета: цвет для кнопок и основной
цвет. А все остальные цвета будут вычеслены автоматически, на основе них.

---------------------------

СОБЫТИЯ

Цикл событий начинает обрабатывается с момента вызова exec(); События обрабатываются
всеми классами, унаследованными от QObject, т.е. для их обработки, нужно просто
переопределить нужные методы в пользовательских классах. 

Сигналы и слоты, отличается от событий тем, что является более высокоуровневым
механизмом, предназначенным именно для связи объектов (вызов метода из одного объекта,
дергает методы из других объектов, которые как бы забиндены на него).

Обычно, события используются когда нужно получить какую-то информацию о происходящем,
например, получить координаты мыши, а сигналы и слоты - для оповещения, что было 
просто сделано какое-то действие.

Некоторые события вызываются ОС, например события таймера. Одни события вызываются
сразу, а другие ставятся в очередь и вызываются, когда программа получает управление.

Класс QEvent является базовым для всех событий. Список всех событий на стр. 223.
У каждого типа событий есть идентификатор, который можно получить с пом. метода type().
Методы accept() и ignore() регулируют дальнейшую обработку события.

QInputEvent - базовый класс события ввода. Узнать клавишу ввода (модификатора), 
можно с помощью метода modifiers().

QKeyEvent - класс события клавиатуры. Передается в методы виджета keyPressEvent() 
и keyReleaseEvent(). Первый вызывается при нажатии клавиши, а второй - при отпускании. 

Информацию о нажатых клавишах получает только тот виджет, который находится в фокусе.
Метод key(), класса QKeyEvent, возвращает код клавиши, а text() - текст клавиши.

Коды от 20 до 3F соответсвуют значениям ASCII-кодов.
Коды от 30 до 39 - соответсвуют цифровым клавишам (возле букв).
Коды от 41 до 5A - идентификаторы букв.

Коды обозначаются константами (полный список на стр. 226):
* Qt::Key_Space - 20;
* Qt::Key_Percent - 25;
* Qt::Key_Plus - 2B;

Когда виджет получает/теряет фокус, у него вызываются методы: focusInEvent() 
и focusOutEvent(). Им передается объект QFocusEvent.

QMouseEvent - класс события мыши. Передается в следующие методы:
* mousePressEvent() - вызывается при нажатии кнопок мыши по области виджета;
* mouseMoveEvent() - вызывается при движении мыши, когда одна из её кнопок нажата;
* mouseReleaseEvent() - вызывается при отпускании кнопок мыши;
* mouseDoubleClickEvent() - вызывается при двойном щелчке.

Для определения позиции указателя мыши, используются методы pos() и globalPos().
Первый возвращает координаты, относительно верхнего левого угла виджета, а второй -
относительно верхнего левого угла экрана.

Метод button() позволяет узнать, какая из кнопок была нажата, в момент наступления
события. Возвращает битовую комбинацию.

QWheelEvent - класс события колёсика мыши. Передается в wheelEvent(). Содержит
специфический метод angleDelta(), позволяющий узнать угол поворота колёсика, а также
pixelDelta(), возвращающий дельту, при прокрутке через тачпад.

Когда указатель мыши попадает/покидает область виджета, вызываются методы:
enterEvent() и leaveEvent() соответственно.

QPaintEvent вызывается при перерисовке. События перерисовки возникают при вызове
методов: show(), repaint(), update(). Передается в paintEvent(), в котором 
реализуется отображение виджетов.

Полную перерисовку можно делать в маленьких виджетах. В больших виджетах, лучше
перерисовывать только отдельную область. Координаты и размеры области можно получить
с пом. метода region(), а contains() проверяет, находится ли объект в заданной области.
...
MyClass::paintEvent(QPaintEvent* e)
{
    QPainter painter(this);
    QRect rect(40, 40, 100, 100);

    if (e->region().contains(rect)) {
        painter.drawRect(rect);
    }
}

QTimerEvent - класс события таймера. Передается в метод timerEvent().
Метод timerId() возвращает идентификатор таймера.

Классы событий Drag&Drop:
* QDragEnterEvent - передается в dragEnterEvent(), когда объект, 
  при перетаскивании, попадает в область;
* QDragLeaveEvent - передается в dragLeaveEvent(), когда объект, 
  при перетаскивании, выходит за область;
* QDragMoveEvent - передается в dragMoveEvent(), когда объект, 
  при перетаскивании, находится в области.
* QDropEvent - передается в dropEvent() при отпускании объекта в области.

QChildEvent - класс события создания или удаления объекта-потомка. Передается в
childEvent(). Метод child() возвращает указатель на объект-потомок, а методы added() 
и removed() позволяют узнать о создании и удалении объекта-потомка.

QCloseEvent - класс события закрытия окна. Возникает также при вызове метода 
виджета close(). Передается в closeEvent(), в котором можно запросить подтвержение.
Методы accept() и ignore() сообщают о согласии или игнорировании запроса.

QHideEvent - класс события свертывания окна. Возникает также при вызове метода 
виджета hide(). Передается в hideEvent().

QMoveEvent - класс события перемежения окна или виджета. Передается в moveEvent().
Методы pos() и oldPos() возвращают новые/старые координаты.

QShowEvent - класс события, возникающего при создании виджета или при вызове 
метода show(). Передается в showEvent().

QResizeEvent - класс события, возникающего при изменении размеров окна или виджета.
Передаётся в resizeEvent(). Методы size() и oldSize() возвращают новые/старые размеры.

Чтобы реализовать пользовательское событие, нужно создать класс, унаследованный от
QEvent; в конструктор передать идентификатор типа события, который должен быть больше
значения QEvent::User (равен 1000) и определить необходимые методы.

Пользоват. события отсылаются с пом. статич. методов QCoreApplication::sendEvent() 
и postEvent(), а обрабатываются - методами QObject: event() и customEvent().

Разница между sendEvent() и postEvent() в том, что первый отсылает события сразу,
а второй, помещает их в системную очередь для дальнейшей обработки.

Метод event() напоминает роутер. Он определяет тип события и вызывает соответсвующий
обработчик, например, для событий клика мыши, он вызовет mousePressEvent().
...
bool MyClass::event(QEvent* e)
{
    if (e->type() == QEvent::KeyPress) {
        ...
        return true;  -->  если вернуть false, то событие будет 
    }                      передано дальше, виджету-предку.

    return QWidget::event(e);
}

Некоторые типы событий (полный список на стр. 237):
* QEvent::None - 0;
* QEvent::Timer - 1;
* QEvent::MouseMove - 5;
* QEvent::KeyPress - 6;

Мультитач-события (одновременное касание к двум и более точкам) представлены классом
QTouchEvent и обрабатываются методом event(). По умолчанию они игнорируются. Чтобы
включить их обработку, нужно вызвать setAttribute(Qt::WA_AcceptsTouchEvents).

Метод touchPoints() возвращает список точек касания, которые представлены классом
TouchPoint. Метод device() позволяет узнать тип устройства.

Объекты QGraphicsItem, как и виджеты, способны получать и обрабатывать эти события.

Для установки мультитач в QAbastractSrollArea, атрибут WA_AcceptsTouchEvents нужно
установливать виджету, который возвращается методом viewPort(). А для обработки,
переопределить метод viewportEvent().

Типы мультитач-событий:
* QEvent::TouchBegin - открывает цепочку событий;
* QEvent::TouchUpdate - сигнализирует об активности пользователя;
* QEvent::TouchEnd - сообщает, что прошло последнее событие цепочки.

Пример реализации мультитач приложения на стр. 241.

Если запустить ресурсоемкую операцию в основном потоке, то она заблокирует обработку
всех событий, а также перерисовку интерфейса. Чтобы этого избежать, нужно 
запускать такие операции в отдельных потоках.

Альтернативным вариантом, для выполнения всех накопившихся событий, является
использование метода QCoreApplication - processEvents().
...
for (int i = 0; i < 1000; i++) {
    // Выполнить ресурсоемкие вычисления

    app->processEvents();  -->  вставить накопившиеся события 
}                               в промежуток выполения

В Qt существует механизм перехвата событий, который позволяет обрабатывать события, 
без реализации их классов. Этим механизмом являются фильтры.

Чтобы реализовать фильтр событий, нужно создать потомка от QObject и переопределить 
в нём метод eventFilter(). Этот метод вызывается при каждом событии. Если событие 
не должно передаваться дальше, то метод должен возвращать true. 

Обычно, в конструктор фильтра передается виджет, которому он необходим. 
Это позволяет при уничтожении виджета автоматически уничтожать и объект фильтра. 
Привязать фильтр к виджету можно с помощью метода installEventFilter().
...
class MyFilter : public QObject
{
public:
    MyFilter(QObject* parent) : QObject(parent) {}

protected:
    virtual void eventFilter(QObject parent, QEvent* e)
    {
        if (e->type() == QEvent::MouseButtonPress) {
            if (static_cast<QMouseEvent*>(e)->button() == Qt::LeftButton) {
                QMessageBox::information(0, "ЛКМ");
                return true;
            }
        }

        return false;
    }
}

QLabel label("My label");
label.installEventFilter(new MyFilter(&label));
label.show();

Виджетам можно привязывать сразу несколько фильтров, при этом последний фильтр 
будет применятся самым первым.

---------------------------

РИСОВАНИЕ В QT

Рисование выполняется с помощью классов: QPainter, QPaintEngine, и QPaintDevice. 
Первый класс управляет отрисовкой, создает фигуры и т.п. Второй класс создает контекст
рисования. А третий - это и есть контекст (область вывода графики).

Классы, которые хоть что-то выводят на экран, наследуются от QPaintDevice
(QWidget, QPixmap, QOpenGLWindow и т.д.).

Рисование выполняется в обработчике paintEvent(). Класс QPaintEvent содержит метод
region(), который возвращает область перерисовки, а метод rect() возвращает
прямоугольник, охватывающий эту область.

Объекту QPainter принимает контекст. Передать его можно, либо через конструктор, 
либо через метод begin(). Если используется метод, то вся отрисовка должна быть между
begin() и end(). Их смысл в том, чтобы рисовать в одном контексте разными объектами
QPainter, но чаще всего используется один QPainter для разных контекстов.
...
void MyWidget::paintEvent(QPaintEvent*)
{
    QPainter painter;  -->  один, для разных контекстов
    QPixmap pixmap(rect());

    painter.begin(this);
    // Рисование в контексте виджета
    painter.end();

    painter.begin(&pixmap);
    // Рисование в контексте растрового изображения
    painter.end();
}

Перед отрисовкой каждого эл-та, рекомендуется сохранять базовые настройки QPainter 
методом save(), а по окончанию - восстанавливать их через restore().

Чтобы задать контур линии, используется перо. Оно представлено классом QPen.
Для заполнения контуров фоном, используется кисть. Представлена классом QBrush.
Градиенты представлены классами: QLinearGradient, QConicalGradient и QRadialGradient.
Сглаживание задается с помощью метода setRenderHint(QPainter::Antialiasing, true).
...
QPainter painter(this);
painter.setPen(QPen(Qt::red, 3, Qt::DashLine));  -->  цвет, толщина и стиль

QLinearGradient gradient(0, 0, width(), height());
gradient.setColor(0, Qt::red);
gradient.setColor(0.5, Qt::green);
gradient.setColor(1, Qt::blue);

painter.setBrush(QBrush(Qt::red, Qt::HorPattern));
painter.setBrush(gradient);  -->  вместо кисти градиент

Для создания точек используются классы QPoint и QPointF. Первый описывает точку 
с целочисленными координатами, а второй - с вещественными.

Двумерный размер определяется классами QSize и QSizeF.

Прямоугольная область создается через QRect и QRectF. Методы dx() и dy() возвращают
проекции на оси X и Y. Многоугольник создается через QPolygon и QPolygonF.
Многоугольник - это по сути массив точек QVector<QPoint>.

При установке координат, следует учитывать что ось Y направлена вниз.
Объекты точек можно складывать и вычитать, а также умножать и делить на числа.

Класс QColor хранит цвета различных цветовых моделей (RGB, HSV, CMYK). Модель CMYK
распростран. в полиграфии. Методы lighter() и darker() делают цвет светлее или темнее.

Структуры QRgb/QRgba хранят цветовые значения. Им также можно присваивать
шестнадцатиричные коды: QRgb rgb = 0x000000FF; 

Методы рисования:
* drawPoint() - рисует точку;
* drawLine() - риует линию;
* drawPolyLine() - соединяет точки линиями; первая и последняя 
  точки не соединяются;
* fillRect() и eraseRect() - рисуют прямоугольники без контуров; 
  второй метод отличается тем, что использует фон фиджета;
* drawPath() - рисует грифическую траекторию.

Методы рис. заполненных фигур:
* drawRect() - рисует прямоугольник;
* drawRoundRect() - рисует прямоугольник с закруглёнными углами;
* drawEllipse() - рисует заполненный эллипс;
* drawChord() - рисует хорду, отсукающую часть эллипса;
* drawPie() - рисует круговую диаграмму;
* drawPolygon() - рисует заполненный многоугольник.

Другие методы рисования:
* drawImage() - рисует картинку из QImage;
* drawPixmap() - рисует картинку из QPixmap;
* drawText() - рисует текст.

Если требуется нарисовать только контур фигуры, без фона, то нужно установить
setBrush(QBrush::NoBrush). А если треб. фигуры без контура, то setPen(QPen::NoPen).

Пример рисования прямоугольника:
...
QPainter painter(this);
painter.setRenderHint(QPainter::Antialiasing, true);
painter.setBrush(QBrush(Qt::red, Qt::DiagCrossPattern));
painter.setPen(QPen(Qt::blue, 3, Qt::DashLine));
painter.drawRect(QRect(10, 10, 110, 70));

С пом. класса QPicture можно записывать команды рисования в файлы, 
а потом их воспроизводить:
...
QPicture picture;
QPainter painter;
painter.begin(&picture);
painter.drawLine(20, 20, 50, 50);
painter.end();
pictire.save("figure.dat");

QPicture picture2;
picture2.load("figure.date");
QPainter painter2;
painter2.begin(this);
painter2.drawPicture(QPoint(0, 0), picture2);
painter2.end();

Методы трансформации:
* translate() - перемещение; положительные значения перемещают фигуру
  вправо и вниз, а отрицательные - влево и вверх;
* rotate() - поворот в градусах; положительные значения поворачивают фигуру 
  по часовой стрелке, а отрицательные - против неё.
* scale() - масштабирование; значение меньше единицы уменьшают фигуру, 
  а больше единицы - увеличивают;
* shear() - сдвиг по вертикали и горизонтали.

Порядок трансформаций имеет значение. Если фигуру сначала повернуть, а затем сдвинуть,
то она будет повернута локально и помещена в нужное место. Если сначала сдвинуть, 
а затем повернуть, то она будет повернута глобально, идя по кругу.

Трансфорамации можно задать одновременно с пом. метода setTransform().
Он принимает матрицу, размером 3х3.
...
QTransform matrix(1, 0, 0, 1, 20, 10);
painter.setTransform(matrix);  -->  перемещение по коорд. 20, 10

Трансформационная матрица:
--------------------------------------------------    
 ЭЛЕМЕНТ | ПЕРЕМЕЩ. | ПОВОРОТ | СКОС | МАСШТАБИР.        a11 a12 0
--------------------------------------------------       a21 a22 0
   a11   |    1     |  cos(α) |   1  |     x             dx  dy  0
--------------------------------------------------
   a12   |    0     |  sin(α) |   x  |     0      
--------------------------------------------------
   a21   |    0     | -sin(α) |   y  |     0
--------------------------------------------------
   a22   |    1     |  cos(α) |   1  |     y
--------------------------------------------------
    dx   |    x     |    0    |   0  |     0
-------- -----------------------------------------
    dy   |    y     |    0    |   0  |     0
--------------------------------------------------

Графическая траектория позволяет создавать произвольные формы, соединяя между собой
разные фигуры. Сначала она заполняется, а затем, рисует всё вместе одним методом. 

Отсечения ограничивают вывод графики определенной фигурой (как наложение маски).
Установка области отсечения выполняется с помощью метода setClipRect().

Сложные области устанавливаются методом setClipRegion(), в который передается 
объект QRegion. Он имеет методы, позволяющие ему комбинироваться с другими QRegion.

Режим совмещения задается с помощью метода setCompositionMode(). Это что-то вроде
буфера глубины. По умолчанию используется режим, при котор. каждая последующая фигура
перекрывает предыдущие. Есть также и режимы, когда фигура вырезает собой дырку и пр.

В Qt есть высокоуровневая реализация для рисования - графическое представление. 
Она состоит из классов: QGraphicsScene, QGraphicsView, QGraphicsItem.

QGraphicsScene - это сцена (модель), содержащая элементы QGraphicsItem.
Методы: addItem(), addLine(), addRect() и др. - добавляют элементы в сцену.
Получить элемент можно с помощью метода itemAt(), все элементы - через items().

QGraphicsView - это виджет сцены, отображающий её содержимое. Область просмотра
задается с пом. setViewPort(), а setMatrix() устанавл. матрицу трансформации сцены.

QGraphicsItem - это элемент сцены. Он может обрабатывать различные события, например
события мыши, клавиатуры, перетаскивания и даже столкновений.

Чтобы создать элемент, нужно унаследоваться от QGraphicsItem и переопределить методы
paint() и boundingRect(). Фигуры наследуются от QAbstractGraphicsShapeItem. 
Класс QGraphicsItemGroup позволяет группировать элементы.

Встроенные элементы: QGraphicsLineItem, QGraphicsEllipseItem, QGraphicsPoligonItem,
QGraphicsRectItem, QGraphicsSimpleTextItem, QGraphicsPixmapItem, QGraphicsSvgItem.

Если нужно отобразить форматированный текст, то нужно использовать QGraphicsTextItem.
Он имеет много возможностей по управлению текстом, вплоть до редактирования.

Пример сцены с прямоугольником, который можно перемещать:
...
QGraphicsScene scene(QRectF(-100, -100, 300, 300));
QGraphicsView view(&scene);

QGraphicsRectItem* rectItem = scene
    .addRect(QRectF(-30, -30, 120, 80), 
             QPen(Qt::black), 
             QBrush(Qt::green)
            );
rectItem->setFlags(QGraphicsItem::ItemIsMovable);

view.show();

Метод setParentItem() позволяет задать предка элементу. В этом случае расположение 
эл-та будет вычисляться относительно него. Если предок подвергся трансформации, 
то вметсе с ним будут трансформированы и его потомки.

Элементы имеют локальную систему координат.
...
QGraphicsTextItem* textItem = scene.addText("Hello!");
textItem->setTransform(QTransform().shear(-0.5, 0.0), true);

Чтобы задать столкновения для своего элемента, нужно переопределить метод shape().
Он возвращает форму элемента в локальных координатах.

События сцены также передаются и в элементы, находящиеся в ней.
Пример реализации сцены с элементами на стр. 322.

В сцену, помимо элементов, можно помещать и обычные виджеты. Это позволит проводить 
с ними различные геометрические преоразования, определять столкновения и т.д.

---------------------------

РАБОТА С OPENGL

Имена ф-ций OpenGL начинаются с префикса gl и заканчиваются на суффиксы, говорящие 
о количестве и типе передаваемых параметров. Поэтому, при описании ф-ций, чтобы не
повторяться, принято вместо суффикса ставить звёздочку: glColor3f()  -->  glColor*().

Таблица типов OpenGL:
---------------------------------------  
 ТИП OPENGL | ЭКВИВАЛЕНТ С++ | СУФФИКС
---------------------------------------
   GLbyte   |    char        |   b         
---------------------------------------
   GLshort  |    short       |   s    
---------------------------------------
   GLint    |    int         |   i
---------------------------------------
   GLfloat  |    float       |   f
---------------------------------------
   GLdouble |    double      |   d
-------- ------------------------------
   GLenum   |    enum        |   GL_
---------------------------------------

Если в суффексе есть символ "u", тогда тип является unsigned. А "v" говорит 
о том, что ф-ция принимает массив, например:
...
GLfloat arr[] = { 1.0f, 0.0f, 0.0f };
glColor3fv(arr);

Чтобы использовать в своём виджете OpenGL, нужно унаследоваться от 
QOpenGLWidget и переопределить следующие методы: 

* initializeGL() - вызывается сразу после создания объекта; вызывается если объекту
  присваивается контекст OpenGL; необходим для инициализаций OpenGL
* resizeGL() - вызывается при изменении размеров объекта; схож с resizeEvent();
* paintGL() - вызывается при перерисовке виджета; схож с paintEvent().

Такие виджеты могут использоваться в качестве контекста рисования для QPainter.
Контекст OpenGL - это набор переменных состояния, которые создаются автоматически.

Пример виджета OpenGL:
...
class MyWidget : public QOpenGLWidget
{
public:
    MyWidget(QWidget* wgt) : QOpenGLWidget(wgt) {}

protected:
    virtual void initializeGL()
    {
        QOpenGLFunctions* func =                -->  получаем все ф-ции OpenGL  
            QOpenGLContext::currentContext()->functions();  

        func->glClearColor(0.0f, 0.0f, 0.0f, 1.0f);  -->  установка цвета для 
    }                                                   очистки буфера изображения

    virtual void resizeGL(int width, int height)
    {
        glMatrixMode(GL_PROJECTION);  -->  установка ортогональной матрицы
        glLoadIdentity();  -->  матрица переведется в единичную
        glViewport(0, 0, (GLint)width, (GLint)height);  -->  установка видимого окна
        glOrtho(0, 100, 100, 0, -1, 1);  -->  соотношение сторон окна
    }

    virtual void paintGL()
    {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  -->  перед формированием
                         изображения нужно очистить буферы изображения и глубины
        
        glBegin(GL_QUADS);  -->  устанвл. способ соединения вершин

            glColor3f(1, 0, 0);   -->  цвет для след. вызовов glVertex*()
            glVertex2f(0, 0);

            glColor3f(0, 1, 0);
            glVertex2f(0, 100);

            ...

        glEnd();
    }
};

MyWidget wgt;
wgt.resize(200, 200);
wgt.show();  -->  showFullScreen() запустит в полноэкранном режиме

В OpenGL есть две матрицы для преобразования координат: 
* projection matrix - отвечает за выбранный способ проектирования.
* modelview matrix - служит для задания положения объекта и его ориентации;

Способ проектирования может быть либо ортогональным, либо перспективным.
Буфер глубины необходим для удаления невидимых поверхностей.

Типы фигур в OpenGL:
* GL_POINTS - отображаются только точки;
* GL_LINES - задает отрезки, которые не соединяюются;
* GL_LINE_STRIP - ломаная линия (отрезки, которые соединяются);
* GL_LINE_LOOP - ломаная линия, где последняя точка соединяется с первой;
* GL_TRIANGLES - каждые три вершины задают треугольник;
* GL_TRIANGLE_STRIP - треугольники, комбинированные между собой;
* GL_TRIANGLE_FAN - треугольники, у которых есть одна общая вершина;
* GL_QUADS - каждые четыре вершины задают четырехугольник;
* GL_POLYGIN - задает многоугольник.

Пример работы с 3D и цикла обновления графики на стр. 354.

---------------------------

МУЛЬТИМЕДИА

QImage - класс растрового изображения. Изображения состоят из набора символов. 
Каждый символ представляет собой отдельный пиксель.

@@@$$@@@   Вот так, примерно, устроено изображение крестика. Символ @ - это пиксель
@@@$$@@@   серого цвета, а $ - пиксель белого цвета, но могут встречаться и 
$$$$$$$$   другие обозначения для пикселей (точка, пробел и пр.).
$$$$$$$$   
@@@$$@@@   Для черно-белых изображений каждый пиксель может быть представлен 
@@@$$@@@   одним битом, у цветных - может занимать 8 бит и более.

QImage является классом контекстно-независимого представления. Это означает, что он 
не использует возможности видеокарты. Он помещает пиксели изображения в обычный
массив и позволяет выполнять над ними операции считывания и записи.

QImage может быть контекстом рисования когда нужно качественное отображение.
Но при этом, оно будет медленным.

Контекстно-зависимое представление отображает изображения быстро за счет видеокарты.
Классы контекстно-зависомого представления: QPixmap, QPixmapCahce, QBitmap.

QPixmap - класс растрового изображения, которое не отображается на экране. Его можно
использовать как промежуточный буфер для рисования и отображать через QPainter.

QPixmap содержит не сами данные, а их идентификаторы, с пом. которых он обращается 
к видеокарте и получает информацию. Из-за этого доступ к каждому пикселю по
отдельностости будет медленным и в этом случ. лучше использ. QImage.

QPixmapCache - реализует кэш для объектов QPixmap. В кэш имеет смысл помещать
изображения, часто используемые в программе, - чтобы избежать загрузки 
из файла при каждом обращении к ним.

QBitmap - наследник QPixmap. Используется для изображений с глубиной цвета в 1 бит.
Это могут быть различные маски либо примитивные черно-белые иконки.

QFont - класс для работы со шрифтом. Установить шрифт можно с пом. метода setFont(). 
label.setFont(QFont("Times", 25, QFont::Normal));

QFontDataBase - предоставляет информацию об установленных в системе шрифтах.
QFontInfo - предоставляет информации о конкретном шрифте.

QFontMetrics - предоставляет характеристики шрифта (ширина буквы, высота и пр.)
Метод boundingRect() позволяет определить геометрию текста.

Графические эффекты позволяют виджетам изменять свом цветовые параметры.
Из коробки доступно 4 эффетка: размытие, расцвечивание, тень и непрозрачность.
Устанавливаются эффекты с помощью метода setGraphicsEffect().
...
label.setGraphicsEffect(new GraphicsBlurEffect());

Если нужен свой эффект, то необходимо унаследоваться от QGraphicsEffect, 
и переопределить метод draw().

Графические эффекты хорошо сочетаются с анимациями. 

Анимации реализуются с пом. класса QMovie. Он также может возвращать отдельные кадры 
в объектах QPixmap и QImage. Анимацию проще всего показывать через виджет QLabel.
У него есть специальный метод setMovie(), принимающий объект анимации.

Для tween-анимаций используется подход кривых, основанный на мат. функциях. 
Базовым классом для tween-анимаций является QAbstractAnimation.
...
QGraphicsColorizeEffect effect;

QPropertyAnimation anim(&effect, "color");  -->  наследник QAbstractAnimation
anim.setStartValue(QColor(Qt::gray));
anim.serKeyValue(0.25f, QColor(Qt::green));
anim.setKeyValue(0.75f, QColor(Qt::blue));
anim.setEndValue(QColor(Qt::black));
anim.setLoopCount(-1);  -->  кол-во проигрований (-1 это бесконечное)
anim.setDuration(3000);
anim.setEasingCurve(QEasingCurve::OutBounce);
anim.start();

QLabel label;
label.setPixmap(QPixmap(":/logo.png"));
label.setGraphicsEffect(&effect);
label.show();

Анимации могут группироваться и работать через стейт-машину. За группировку отвечает
QAnimationGroup. Такие анимации работают как последовательно, так и параллельно.
...
QParallelAnimationGroup aGroup;
aGroup.addAnimation(anim1);
aGroup.addAnimation(anim2);
aGroup.start();

QStateMachine - это класс стейт-машины. QState - это класс состояния.
Пример работы со стейт-машиной на стр. 342. Таблица аним. кривых на стр. 337.

QSound - класс, для воспроизведения простых wav-файлов. 

Для продвинутых звуковых оформлений, а также для воспроизведения видео и 
интернет-радио, используется класс QMediaPlayer.

Короткий звуковой сигнал можно вызвать с пом. статич. метода QApplication::beep().

Пример создания музыкального проигрывателя на стр. 394. 
А на стр. 401 показан пример видеоплеера.

---------------------------

СТИЛИ ПРИЛОЖЕНИЯ

По умолчан. вид и поведение Qt-приложений определяется ОС. Но это можно изменить, 
с помощью метода setStyle(), объекта QApplication. Он принимает стиль и задает его
сразу для всего приложения. Например приложение может быть в стиле "QFusionStyle",
"QAndroidStyle", "QWindowsStyle", "QMacStyle" и пр.

Стиль можно задавать и отдельно для виджета, но лучше создавать одну общую тему 
для всего приложения, чтобы всё было однотипно.

Изменить встроенный стиль виджета можно через редактирование объекта QStyle.
Получить его можно с помощью метода style().

Чтобы создать свой стиль, можно унаследоваться от уже имеющегося потомка QStyle, 
или от него самого, но тогда придется переопределить много методов. Также,
рекомнедуется наследоваться не напрямую от QStyle, а от QCommonStyle.

Методы QStyle, для переопределения:
* drawPrimitive() - меняет стили простых виджетов (флажки, рамки и пр.);
* drawControl() - меняет стили виджетов (кнопка, прогрессбар и пр.);
* drawComplexControl() - меняет стили составных виджетов (из нескольх частей).

Пример создания своего стиля на стр. 379.

Помимо этого, стили можно задавать и через CSS. Для этого их нужно определить 
в отдельном файле и установить через метод setStyleSheet().
...
Файл widget.cpp:
namespace MyNameSpace {
    class MyClass : public QWidget { };
}

Файл style.css:
MyNameSpace-MyClass { 
    color: white; 
    background-color: black;
}

QFile file(":/css/style.css");
file.open(QFile::ReadOnly);
QString css = QString(file.readAll());
app.setStyleSheet(css);

Это метод может принимать также и строку:
app.setStyleSheet("QPushButton:hover { background-color: blue }").

Задать стиль подэлементу виджета: QComboBox::drop-down { image: url(icon.png);
Позиционирование подэлементов выполняется через селектор: subcontrol-position.

Список некоторых подэлементов:
::down-arrow - стрелка вниз, имеется у выпадающ. списка и у счетчика;
::down-button - ктопка вниз, имеется у счетчиков;
::drop-down - стрелка выпающего списка;
::indicator - индикатор флажка или переключателя;
::item - элемент меню, строки состояния;
::menu-indicator - индикатор кнопки меню (обычно это стрелка);
::title - лейбл группы; 
::up-arrow - стрелка вверх;
::up-button - кнопка вверх;

Cостояния виджетов можно объединять: QCheckBox:hover:checked { color: white }

Свойства виджетов также можно изменять прямо из CSS. Например, вместо вызова 
метода setSelectionRectVisible(true) из C++, можно написать так:
...
MyWidget { qproperty-selectionRectVisible: true }

---------------------------

СОЗДАНИЕ ПРИЛОЖЕНИЙ

Настройки приложений сохраняются в виде совокупности ключей и значений.
Ключи - это строки, состоящие из подстрок, резделенных символом /.

В Windows настройки сохраняются в реестре, в ветках: HKEY_LOCAL_MACHINE\Software или 
в HKEY_CURRENT_USER\Software. Системный реестр - это центральная база данных, 
хранящая настройки приложений и системы.

В Linux для хранения настроек используются каталоги $HOME/.qt или $QTDIR/etc.

Для работы с настройками приложения используется класс QSettings:
...
QSettings settings("MyCompany", "MyProgram");
settings.setValue("/Settings/MyKey", 123);

Имя компании и название программы можно задать глобально, с пом. статических методов
QCoreAppication. Это полезно, когда настройки используются в нескольких местах. 

Для установки и получения настроек используются методы setValue() и value().
Для удаления настроек используется метод remove().

Методы beginGroup() и endGroup() позволяют задать группу. Внутри группы можно не
указывать полные названия ключей. Группы могут быть вложенными.

Сохранять настройки удобно либо в деструкторе какого-нибудь класса, либо в методе
closeEvent(), который вызывается при закрытии окна виджета.

Буфер обмена представляет собой область памяти, к которой могут иметь доступ все
запущенные в системе приложения.

Для работы с буфером обмена используется класс QClipboard. Его объект создается сам,
при запуске приложения и доступен в виде синглтона. При манипуляции с данными
отправляется сигнал dataChanged().

Чтобы поместить данные в буфер, используются такие методы, как: setText(), 
setImage(), setMimeData() и др.
...
QClipboard* clipboard = QApplication::clipboard();
clipboard->setText("Hello!");

Более удобным способом обмена данными между приложениями и окнами является технология
Drag&Drop. В Qt, практически все виджеты поддерживают эту технологию. 

Для транспортировки данных используется класс QDrap. А для их размещения - QMimeData.
(Здесь немного не ясно, что значит "размещение". Возможно автор имел ввиду 
установку типа перетаскиваемых данных через этот класс...)

Чтобы из виджета можно было перетаскивать объекты, необходимо переопределить методы
mousePressEvent() и mouseMoveEvent() и реализовать там ф-ционал QDrag. 

Для получения объектов необходимо переопределить методы dragEnterEvent() и dropEvent(),
а также вызвать (обычно из конструктора) setAcceptDrops(true). 

MIME-типы определяют как данные должны интерпритироваться. Например "text/plain"
означает, что данные - это обычный текст, а "text/html" означает что это html, и он
должнен обрабатываться дополнительно, движком отображения веб-страниц.

Собственные MIME-типы должны называться так: "application/mytype".

Стоит отметить, что перетаскивание должно срабатывать не сразу, а только после того,
как пользователь преодолеет определенное расстояние (обычно 4 пикселя), которое
возвращается статич. методом QApplication::startDragDistance(). 

После этого можно считать, что перемещение указателя мыши было не случайным, 
и пользователь действительно хочет перетащить выбранный объект.

Пример реализации Drag&Drop на стр. 417.

Интернационализация сокращенно обозначается как "i18n", а локализация - как "l10n"
(первая и последня буквы и кол-во пропущенных букв в середине). 

Локалицазия - это часть интернационализации, когда помимо обычных строк переводятся
также и обозначения валют, дат, цифр, комбинаций горячих клавиш и т.д.

Интернационализация выполняется след. образом:

1. Все строки помещаются в статический метод tr(), как в WordPress. По умолчанию
   они должны быть на английском, даже если приложение русскоязычное.

2. После передачи всех нужных строк в метод tr(), нужно сгенерировать файлы 
   переводов с помощью утилиты lupdate.

3. Чтобы перевести тексты, можно воспользоваться программой Qt Linguist. В неё
   передаются сгенерированные ранее файлы (либо просто отредактировать их вручную).

4. Сконвертировать файлы переводов в двоичные файлы (с пом. одной из след. утилит:
   lupdate, Qt Linguist, lrelease) и загрузить их с пом. класса QTranslator.

Пример приложения с переводами, а также советы по смене перевода в процессе 
работы программы, на стр. 434 и 435.

Основное назначение меню это размещение команд. Каждая команда управляет действием,
которое представлено классом QAction. Команды могут соединяться со слотами.

Класс QAction необходим для централизации всех элементов GUI, связанных с конкретной
командой, в одном объекте. Это позволяет сократить время разработки. 
Имеет сигнал - triggered().

Виджет QMenuBar отвечает за меню верхнего уровня. Всплывающее меню созд. через QMenu
Команды для всех меню добавляются с помощью метода addAction().

Чтобы создать полноценное меню, нужно к каждой команде верхнего уровня присоединить
соответствующее всплывающее меню. Отобразить QMenuBar можно также, как и любой 
другой виджет, с помощью метода show().

Если команда меню вызывает диалоговое окно, то в конец её названия принято 
добавлять троеточие. 

Таблица стандартных горячих клавиш для команд меню на стр. 440.
Пример создания меню c разными командами на стр. 441.

Контекстное меню - это меню, которое открывается при нажатии ПКМ. Для его реализации
также используется класс QMenu. Но оно не присоединяется к виджету QMenuBar.

Чтобы показать контекстное меню нужно вызвать метод exec(), класса QMenu.
Показать его можно в переопределенном методе contextMenuEvent() из любого виджета.

Диалоговые окна - это всегда виджеты верхнего уровня с собственными заголовками.
Они делятся на 3 категории: собственные, стандартные, окна сообщений.

При создании диалового окна, нужно избегать того, чтобы его содержимое прокручивалось.
Также в нём не должно быть меню и много кнопок. В основном хорошо, когда у окна 
всего 2-3 кнопки: Ok, Apply, Cancel и т.п.

Диалоговые окна создается с пом. класса QDialog. Они бывают модельными и немодальными.
Режим модальности устанавливается вызовом setModal(true).

Модальные окна используются для вывода важных сообщений. Они прерывают работу приложен.
Чтобы заблокировать приложение, нужно вызвать метод exec() у модального окна.
Чтобы возобновить работу приложения, нужно закрыть модальное окно.

Метод exec(), после закрытия окна, возвращает целочисленное значения, которое
информирует о выбранной команде пользователя (Ok или Cancel).
...
MyDialog* dialog = new MyDialog(&data);
if (dialog->exec() == QDialog::Accepted) {
    // Пользователь нажал на Ok
}

Немодальные окна отображаются также, как и обычные виджеты, через метод show().
Пример создания собственного диалогового окна на стр. 448.

Стандартные диалоговые окна:
* QFileDialog - окно выбора файлов;
* QPrintDialog - окно настройки принтера;
* QColorDialog - окно выбора цвета;
* QFontDialog - окно выбора шрифта;
* QInputDialog - окно ввода данных;
* QProcessDialog - окно шкалы процесса; должно отображаться 
если длительность всей работы больше 3х секунд;
* QWizard - окно мастера (напоминает окно установки);

Диалоговые окна сообщений создаются с пом. класса QMessageBox. Такие окна отображают
сообщения 3х уровней важности: информационные, предупреждающие и критические. 
Они являются модальными и могут содержать до 3х кнопок.
...
QMessageBox* msgBox = new QMessageBox(
    QMessageBox::Information, "My Message", "<b>Simple</b> Message", 
    QMessageBox::Ok | QMessageBox::Cancel
);
int result = msgBox->exec();

Таблицы иконок и кнопок, задаваемых для диалового окна сообщений на стр. 463.

Статические методы information(), warning(), critical(), about(), предоставляют
упрощенный вариант вызова окон. Последний метод вызвает окно сообщения о программе.
...
int result = QMessageBox::informaton(0, "Title", "Text");

Окно сообщения об ошибке реализуется с пом. класса QErrorMessage. 
Это окно не является модальным. Вызов осуществляется методом showMessage().

Всплывающие подзсказки для виджета задаются с пом. метода setToolTip().
Класс QTextBrowser позволяет выводить html. Применяется для реализации окна помощи.

QMainWindow - это класс главного окна приложения. Он содержит в себе уже готовый набор
виджетов, таких как: меню, панель инструментов, рабочая область, строка состояния.

Меню можно получить с пом. метода menuBar(). Рабочую область - с пом. centralWidget(). 
Метод setCentralWidget() устанавливает рабочую область. А метод statusBar()
возвращает виджет строки состояния.

Панель инструментов реализуется с пом. класса QToolBar. Метод addAction() добавляет 
на панель кнопку. Вместо кнопки можно добавить произвольный виджет вызовом addWidget().

Панель инструментов не предназначена для работы со сложными виджетами. Для этого
существует виджет дока - QDockWidget. Доки можно отрывать от основного окна, 
делая их самостоятельными окнами.

Строка состояния реализуется с пом. класса QStatusBar. Строки состояния бывают:

* Промежуточными - выводят поясняющий текст для команд меню, 
  который через какое-то время сам очищается;

* Нормальными - служат для отображания часто изменяющейся информации, 
  например координат мыши или индикатора выполнения;

* Постоянными - отображают информац., необход для работы с приложением, 
  напрмер отображение горячих клавиш;

Окно заставки (прелоадер) реализуется с пом. класса QSplashScreen. Его объект должен
создаваться в ф-ции main() до вызова метода exec(). Окно нужно закрывать вызовом метода
finish(), иначе оно будет видимым, пока пользователь не щелкнет по нему мышью.

Существует 2 типа приложений: SDI и MDI (Single/Miltiple Document Interface). 

В SDI-приложениях рабочая область состоит только из одного окна (виджета). 
Типичным примером SDI-приложения является блокнот. Создание блокнота на стр. 484.

В MDI-приложениях рабочая область может содержать в себе множество разных окон. 
Это напоминает то, как устроен движок Unity (из набора панелек/окон собранных вместе).

Рабочая область MDI-приложения реализуется классом QMdiArea. Добавить виджет в рабочую
область можно с пом. метода addSubWindow(). Метод subWindowList() возвращает список
всех содержащихся в ней окон. Пример MDI-приложения на стр. 489.

Для работы с системным трейем (панелью задач) используется класс QSystemTrayIcon.
Установить значок приложения можно с пом. метода setIcon(), а чтобы его отобразить -
метод show(). Отобразить сообщение для пользователя можно с пом. метода showMessage().

Всплывающая подсказка для значка задается методом setToolTip(). Контекстное меню -
методом setContextMenu(). Пример реализации программы с системным трейем на стр. 498.

Приложения, которые используют системный трей, при закрытии окна не закрываются
полностью, а как бы скрываются от показа с пом. метода hide().

За доступ к содержимому экрана отвечает класс QDesktopWidget. Он также хранит информац,
связанную с экраном (длину, ширину, кол-во мониторов в системе, их разрешения; это
можно использовать в целях правильного позиционирования приложения на экране). 
Получить его объект можно с пом. статич. метода QApplication::desktop().

Пример программы, которая делает снимок с экрана на стр. 503.

Класс QDesktopServices отвечает за вызов веб-браузера, почтового клиента и т.п.
А также за открытие заданных типов файлов программами по умолчанию.
...
QDesktopServices::openUrl(QUrl::fromLocalFile("C:\\myfile.txt"));

---------------------------

QT DESIGNER И ФОРМЫ

Qt Designer - это что-то вроде WinForms. Он может дополнятся кастомными виджетами.
Слева, в окне Widget Box, располагаются виджеты и менеджеры компоновки. 

Справа расположены сразу 5 окон:
* Object Inspector - окно иерархии используемых виджетов;
* Property Editor - окно свойств выбранного виджета;
* Signal/Slot Editor - окно соединений сигналов со слотами;
* Resource Browser - окно браузера ресурсов;
* Action Editor - окно для создания действий команд и управления ими;

Режимы Qt Designer:
* Edit Widgets - изменение внешнего вида формы, редактирование свойств;
* Edit Signals/Slots - соединение виджетов между собой;
* Edit Buddies - связывание виджета с виджетом надписи для получения фокуса;
* Edit Tab Order - установка порядка, в кот. виджеты будут получать фокус;

Чтобы задать компоновку, нужно выделить часть виджетов и нажать ПКМ. Далее в
контекстном меню, выбрать Lay out Vertically и пр. Тоже самое можно сделать и в
отношении всей формы (компоновка применится для оставшихся виджетов).

В места, которые должны оставаться свободными, следует поместить заполнитель
Заполнители находятся во вкладке Spacers.

Чтобы выполнить сигнально-слотовое соединение, нужно задержать указатель мыши на одном
из виджетов, чтобы он выделился, и нажать ЛКМ. После этого нужно переместится к другому
виджету. После отпускания ЛКМ появится окно в котором можно выбрать соединяемые методы.

Чтобы добавить на форму собственный виджет, нужно сначала добавить туда любой из
стандарных виджетов, например QWidget, а затем, выделив его, вызвать контекстное меню 
и выбрать пункт Promote to. В окрывшемся окне вписать имя класса своего виджета и
нажать на кнопки Add и Promote. Пример использ. собств. виджетов на стр 648.

Формы хранятся в файлах с форматом .ui (хранит XML). 
Чтобы использовать форму, её необходимо установить методом setupUi().
...
QWidget* form = new QWidget();
Ui::MyForm ui;
ui.setupUi(form);
form->show();

Но обычно ипользуется подход с множественным наследованием:
...
class MyForm : public QWidget, public Ui::MyForm 
{
    Q_OBJECT
public:
    MyForm(QWidget* wgt = 0) : QWidget(wgt)
    {
        setupUi(this);
    }
}

Также, формы можно загружать и динамически. Это напоминает то, как устроено в
разработке под android, когда используется XML (стр. 651).

---------------------------

РАЗНОЕ

Qt Assistant - программа, предоставляющая документацию по Qt. Встроена в Qt Creator.
Утилита QMake - это генератор платформозависимых make-файлов (уже устарела).

Отладку приложения можно выполнить и без графического интерфеса в IDE. Для этого 
нужно скомпилировать программу с флагом -g и при запуске через консоль, использовать
команды: run, up, attach, where, break, next, step, continue, until и др. (стр. 64)

Текущую дату и время можно получить с помощью QDateTime::currentDateTime().
Url файла можно получить с помощью QUrl::fromLocalFile(":/song.mp3");

Бывает так, что при перерисовке возникает эффект мерцания. Это происходит потому, 
что пиксели за короткие промежутки времени перерисовываются разными цветами.
Также бывает баг, когда при изменении размеров окна или при его перекрытии другим
окном, пропадает картинка. Избавиться от этого позволяет двойная буферизация. 
В Qt, по умолчанию, она уже включена. Чтобы её отключить, нужно вызвать
setAttribute(Qt::WA_PaintOnScreen).

При создании своего виджета полезно переопределять методы sizeHint() и sizePolice(),
чтобы он мог использоваться компоновщиками. Первый метод задает рекомендуемый размер.
Второй задает, будет ли виджет больше/меньше, значения из sizeHint() при изменен. окна.

Чтобы виджеты отображались справо-налево (для арабский стран), нужно вызвать метод
qApp->setLayoutDirection(Qt::RightToLeft);

Скорость разработки своего виджета зависит от удачного подбора базового виджета,
на основе которого он будет создаваться.

