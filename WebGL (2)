ПРО МАТРИЦЫ

Матрицы в основном используются для взаимосвязи между двумя координатами.

Определитель матрицы - это её число (результирующее).

Транспонирование матрицы - это операция, при которой строки становятся 
столбцами, а столбцы - строками.

Преобразования матриц бывают линейными и аффинными.

Линейные преобразования - это повороты и масшабирования. Они сохраняют состояние 
и могут приминяться в любой последовательности. Например если применить масштабирован,
а затем поворот, то результат будет таким же, как если бы сначала применить 
поворот, а затем масштабирование.

Преобразование считается линейным, если оно сохраняет базовые операции 
сложения и умножения на скаляр.

Аффинное преобразование - это линейное преобразование, за которым следует сдвиг.

Матрицы 3x3 используются для линейных преобразований и они не содержат сдвига.
Любое преобразование которое выполняется через матричное умножение не может содержать
сдвига. Для выполнения преобразований со сдвигом, нужно использовать матрицы 4x4.

Если объект необходимо двигать или поворачивать, то нужно преобразовать его вершины
(из локальных?) в экранные/мировые координаты с пом. матрицы модели (ModelView).

Чтобы преобразовать вершину, нужно умножить её на матрицу модели (с пом. векторного
произведения): Vf = Mv * V, где Mv - матрица модели 4х4, а V - вектор вершины. 
Каждая вершина должна определяться как: [x, y, z, w]. 

Матрица проекции преобразов. вершины относительно их расстояния к зрителю: 
Vp = P * V, где P - матрица проекции 4х4, V - вектор.

Параметры при установке матрицы проекции:

* fieldOfView - поле зрения; чем больше значение, тем больше объектов 
  будет охвачено на сцене;

* Near, Far - ближняя и дальняя плоскости для создания области отсечения;

----------------------

ОСНОВЫ 3D-ГРАФИКИ

Модель в 3D-игре называется мешом. Каждая грань меша называется полигоном. 
Полигон состоит из 3х и более вершин. Каждая вершина обозначается местоположением 
на экране. Местоположение определяется с помощью векторов.

Каждой вершине, которая определяется, даётся числовая метка; например, вершина 0
помечается нулём, вершина 1 - единицей и т.д. Эти метки называются индексами.

Индексы информируют WebGL о том, как соединять вершины, чтобы 
сформировался полигон или поверхность.

Чтобы получить наиболее гладкую поверхность, с минимальным кол-вом полигонов, нужно
использовать полигоны с наименьшим кол-во сторон, т.е. треугольники. Если вместо
треугольников использовать квадраты, то их придется задать намного больше. Также 
у треугольников 2 из 3х сторон общие, тогда как у квадратов 2 из 4х.

------------------------

КОНВЕЙЕР ОТРИСОВКИ (RENDERING PIPELINE)

Старые видеокарты не позволяли напрямую изменять или манипулировать вершинами, 
но имели встроенный ф-ционал для их поворорота или масштабирования.

Современный конвейер отрисовки даёт полную гибкость в изменении вершины 
и отрисовки объектов с пом. шейдеров.

Этапы конвейера отрисовки (стр. 19):

  JavaScript > Вершинный шейдер > Сборка примитивов и Растеризация 
                                                V
  Фреймбуфер < Pre-fragment шейдер < Фрагментный шейдер

Графические ускоритель (graphics accelerator) - это аппаратное обеспечение 
(hardware), предназначенное для рисования графики. 

Он имеет область памяти для хранения содержимого отображения. Каждый видимый пиксель
представлен несколькими байтами памяти (display memory); Эта память обновляется
определенное кол-во раз в секунду для обеспечения отсутствия мерцания.

Граический ускоритель также предоставляет внеэкранную память (offscreen momory),
которая используется только для хранения данных.

Распределение памяти отображения и внеэкранной памяти управляется оконной системой.

Область графической памяти, которая изменяется в результате рендеринга называется
фреймбуфером. Фреймбуфер по умолчан. предоставляется оконной системой.

Если необходимо выполнить рендеринг в текстуру, то нужно создавать 
закадровый (внеэкранный) фреймбуфер.

--------------------

ОСНОВЫ WEBGL

Буферный объект предоставляет методы для загрузки атрибутов на видеокарту. Он даёт
существенный прирост производительности при рендеринге, поскольку его данные находятся
в видеопамяти: const bufferObj = gl.createBuffer();

Буферных объектов может быть много. Метод bindBuffer() вызывается, чтобы сообщить, 
на каком из объектов буфера будут работать последующие операции (WebGL).

Буферный объект может быть вершинным (VBO - Vertex Buffer Object) и индексным (IBO).

Тип ELEMENT_ARRAY_BUFFER используется только для хранения индексов. Для остальных
данных, используется ARRAY_BUFFER (позиции, цвета, нормали и т.п.).

Метод bufferData() выделяет память для буферного объекта. Третий параметр указывает,
как его использовать. Обычно передается значение STATIC_DRAW.

Все значения 3го параметра:

* STATIC_DRAW - данные объекта указаны приложением один раз и используются
  много раз для рисования примитивов;

* DYNAMIC_DRAW - данные объекта указаны приложением неоднократно и используются 
  много раз для рисования примитивов; используется для анимации отдельных вершин;

* STREAM_DRAW - данные объекта указаны приложением один раз и используются 
  всего несколько раз для рисования примитивов;

Программа WebGL разделена на два компонента; управляющий код JS и шейдеры.
Управляющий код выполняется на CPU, а шейдеры на GPU. Поскольку управляющий код
связывает данные с памятью GPU, он доступен для обработки в шейдере.

Вершинный шейдер - это программируемый модуль, который работает с входящими значениями
вершин и связанными с ними данными (позиции вершин, их цвета, нормали и пр.).

Обычно в нём выполняются след. операции:
* вершинные преобразования;
* преобразования нормалей и нормализация;
* генерация текстурных координат и их преобразования;
* применение материала и освещения;

Данные, которые передаются в вершинный шейдер:
* атрибуты - поэтапные данные вершин, поставляемые из вершинных буферов.
* униформы - константные данные сразу для всего шейдера; вершинный и фрагментный 
  шейдеры имеют общее глобальное пространство для униформ.

gl_Position - это varying-переменная, которая объявляется автоматически.

После того, как вершинный шейдер отработает с атрибутами вершин, следующая фаза - это
сборка примитивов (Primitive Assembly). На этой фазе, если примитив лежит частично 
за пределами усеченной пирамиды вида (frustum view) то он обрезается, а если он 
вне её пределов, то полностью отсекается. 

После этого идёт фаза растеризации. На этой фазе все примитивы преобразуются в
двумерные фрагменты, также называемые пикселями. Эти фрагменты затем 
обрабатываются фрагментным шейдером.

Во фрагментном шейдере выполняются след.:
* операции над интерполированными значениями;
* доступ к текстурам;
* применение текстур;
* сумма цветов;
* туман;

Данные, которые передаются во фрагментный шейдер:

* varying-переменные - выходные данные вершинного шейдера, генерируемые при
  растеризации для каждого фрагмента, с помощью интерполяции.

* униформы - константные данные сразу для всего шейдера.

* семплеры - это особые типы, используемые фрагментным шейдером, 
  которые представляют текстуры.

Атрибуты, объявленные в шейдере, инициализируются в основном управляющем коде.
Чтобы их инициализировать, необходимо получить на них ссылки через метод
getAttribLocation(). Он как бы запрашивает местоположение атрибута.

Атрибутами могут быть только вещественные числа, а также векторы 
или матрицы (с вещественными числами).

Чтобы получить ссылку на униформу, используется метод getUniformLocation(). 
А метод uniform*() загружает данные в униформу.

Метод vertexAttribPointer() соединяет текущий активный буфер с атрибутом шейдера.
Его 4й параметр (norm) это индикатор, указывающий, используются ли невещественные
данные, которые должны быть нормализованы, перед конвертацией во float.

Метод drawArrays() эффективен, когда нужно отрисовать простую геометрию.
Для сложной геометрии используется метод drawElements(). Он использует IBO и метод
drawArrays(), который в свою очередь использует VBO для чтения данных.

Этапы построения WebGL-приложений:
* создать контекст WebGL;
* загрузить, скомпилировать и линкануть шейдеры;
* инициализировать буферные объекты;
* применить преобразования и соединить буферные объект с атрибутами;
* вызвать drawArrays() или drawElements();

Управляющий код отлаживается по обычному, через console.log() и интструменты отладчика.
Отладка шейдеров происходит с помощью браузерного плагина - WebGL Inspector.

------------------------

НОРМАЛИ И ОСВЕЩЕНИЕ

Точность для типа float в вершинном шейдере может быть низкой, а во фрагметном -
высокой, поскольку вершинам, в основном, передаются конкертные значения, а пикселям - 
промежуточные (интерполируемые), требующие более точного рассчета.

Нормали также необходимо преобразовывать в мировое пространство; поскольку после
поворота или сдвига объекта они, как и вершины, поменяют свои значения. 

Чтобы преобразовать нормаль, нужно сначала найти транспонирование 
обратной ModelView-матрицы:
...
const nMatrix = mat3.create();
mat4.toInverseMat3(mvMatrix, nMatrix);  -->  Матрица нормалей - это обратная 
mat3.transpose(nMatrix);                     ModelView-матрица

gl.uniformMatrix3fv(u_NMatrix, false, nMatrix);

Затем, в шейдере, умножить сырую нормаль на транспонированную матрицу:
const tNormal = u_NMatrix * a_Normal;

Типы источников света:
* Направленный свет (directional lights) - солнечный свет;
* Точечный свет (point lights) - свет лампы;
* Прожектор (spotlights) - фонарь;

Окрущающее освещение (Ambient lighting) создает равномерный свет. Вычисляется по
формуле: I = Ia Ka, где Ia - интенсивность фонового света, Ka - коэффициент фонового
отражения объектов, от 0.0 до 1.0 для каждого RGB-компонента. Его свойства:

* генерируется направленным источником света;
* имитирует свет, который отражается от разных поверхностей;
* его интенсивность не меняется от положения полигонов в пространстве;
* позиция зрителя не важна;

Диффузное (рассеянное) отражение (Diffuse reflection) - это отражение света от
поверхности, при котором падающий луч отражается под многими углами. 

Вычисляется по формуле: I = Ip Kd (N'.L'), где Ip - интенсивность точечного света, 
Kd - коэффициент диффузного отражения объектов, от 0.0 до 1.0 для каждого RGB-компонен.
N' - нормализованная нормаль поверхности/вершины, L' нормализованное направление
источника света, точка - это скалярное произведение 2х векторов.

Свойства диффузного отражения:

* яркость полигона зависит от теты - угла между нормалью поверхности (N) 
  и направлением источника света (L);

* позиция зрителя зависит от того, используется ли направленный свет или точечный;

Материал - это описание поверхности объекта. Свойства материала описывают то, как он
отражает фоновый и диффузный свет, а также характеристики зеркального блеска.

Фоновое и диффузное отражения работают вместе, чтобы определить воспринимаемый цвет
объекта и обычно задаются одинаковым цветом. Например, если материал отражает только
зеленый цвет, фонового и диффузного света, то находясь в сцене с белым светом, 
объект будет зелёным. Но если свет станет синим, то объект почернеет, 
т.к. материал не отражает синего.

Зеркальное отражение задаёт блики на объектах, делая их блестящими. Оно определяется
двумя свойствами: цветом блика и общим блеском материала.

------------------

МОДЕЛИ ОСВЕЩЕНИЯ/ОТРАЖЕНИЯ

Алгоритмы, используемые для рассчета направления, интенсивности и цвета 
отраженного света называются моделями отражения.

Модели отражения используют цветовые компоненты (фоновый, диффузный и зеркальный)
источника света, а также материал объекта для вычисления цвета фрагмента.

Рендеринг изображений с реалистичной моделью отражения называется BRDF 
(Bidirectional Reflectance Distribution Functions). Распространенные модели BRDF:

* Модель Ламберта - самая простая модель; используется для рендеринга объектов 
  с диффузным материалом и рассеянным светом.

* Модель Фонга - модель, подобная пластиковой зеркальности; но она не работает
  когда угол между вектором обзора (V) и вектором отражения (R) больше 90 градусов.

* Модель Блинна-Фонга - модифицир. модель Фонга, которая допускает определенные
  интерполяции и снижает вычислительные затраты; используется для рендеринга 
  объектов с зеркальным материалом.

* Модель Торренса-Спарроу - общая модель, кот. представляет поверхности как
  распределения идеальных зекральных микрограней;

* Модель Кука-Торренса - модель Торренса-Спарроу, кот. учитывает длину волны 
  и, следовательно, изменение цвета.

* Анизитропная модель Уорда - модель зеркальных микрограней с 
  эллиптической ф-цией распределения по Гауссу.

В играх, в основном, используются модели Ламберта и Блинна-Фонга, 
т.к. они требуют наименьших вычислений.

------------------

МОДЕЛИ ЗАТЕНЕНИЯ/ИНТЕРПОЛЯЦИИ

Модель затенения определяет, будем ли мы вычислять освещение только для вершин или 
для каждого пикселя грани. Если вычислять освещение для вершин, то значения пикселей
между вершинами линейно интерполируются. При этом вычисления придётся делать 
в вершинном шейдере.

Вершинный шейдер выполняется для каждой вершины. Следовательно, это дорого. Посему
предпочтительнее это делать попиксельно, во фрагментном шейдере (возможно тут имеется
ввиду, что расчет освещения, отдельно для каждого пикселя, дешевле интерполяции).

Наиболее распространенные модели затенения:

* Плоское затенение (Flat shading) - используется для высокоскоростного рендеринга;

* Затенение Гуро (Gouraud shading) - сила и слабость этого затенения заключается 
  в его интерполяции; если полигон охватывает больше пикселей на экранне чем число
  собсвтенных вершин, то значения интерполируемых цветов из дорогостоящих рассчетов
  освещения в вершинах менее загружают процессор, чем выполнение расчета для каждого
  пикселя; однако зеркальные блики могут отображаться неправильно;

* Затенение Фонга (Phong shading) - работает лучше, чем затенение Гуро, когда
  применяется к модели отражения с небольшими зеркальными бликами, например к Фонгу.

Затенение Гуро для модели отражения Ламберта на стр. 75. 
Расчет освещения выполняется в вершинном шейдере.

Затенение Гуро для модели отражения Блинна-Фонга на стр. 80.
Расчет освещения выполняется в вершинном шейдере.

Затенение Фонга для модели отражения Блинна-Фонга на стр. 82.
Основной расчет освещения выполняется во фграгментном шейдере. 
Вершинный шейдер только подготавливает некоторые переменные.

------------------

НЕСКОЛЬКИХ ОБЪКТОВ И ИСТОЧНИКОВ СВЕТА

Каждая 3D-модель может быть представлена классом Geometry. Объект Geometry может
содержать след. информацию: вершины, цвета вершин, нормали, UV-map, материалы, индексы
(сгенерированные из массива Faces), массив Faces (Face - представляет полигон фигуры).

Похожая архитектура представления модели используется в библиотеке Tree.js.
Пример реализации классов Geometry, Face и т.п. на стр. 86.

Класс StageObject содержит информацию для рендеринга геометрии на сцене. Он
инициализирует объект Geometry, а также буферные объекты и дефолтный материал для
Geometry. Также он сожержит местоположение и поворот объекта относительно сцены.

Класс Stage содержит массив объектов сцены - StageObject, а также 
инициализированный контекст WebGL (в переменной gl).

Пример реализации классов Stage и StageObject на стр. 92.

Чтобы отобразить несколько объектов на сцене, в главном коде нужно последовательно
проинициализировать все StageObject, предварительно связав их со Stage, 
и вызывать метод drawScene() для каждого объекта сцены. 
...
initGL(canvas)
initShaders();
initScene();

const stage = new Stage(gl);

const stageObject1 = new StageObject();
stage.addModel(stageObject1);
drawObject();

const stageObject2 = new StageObject();
stage.addModel(stageObject2);
drawObject();

Если для рендеринга всех объектов используется одна пара шейдеров, то униформы
материала и света, для каждого из объектов, должны устанавливаться 
внутри метода drawObject().

WebGL не выполняет рендеринг нескольких буферов в один момент времени. При загрузке
нескольких объектов у нас будет несколько буферов. Чтобы отрендерить все эти 
буферы, придется сначала активировать каждый из них по очереди.

Чтобы получить информацию об активном буфере и состоянии конвейера рендеринга, нужно
использовать следующие методы (использ. для ARRAY_BUFFER и ELEMENT_ARRAY_BUFFER):
...
gl.getParameter(gl.ARRAY_BUFFER_BINDING);  -->  получить ссылку на привязанный 
                                                на данный момент VBO

gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_SIZE);  -->  размер получ. буфера
gl.getBufferParameter(gl.ARRAY_BUFFER, gl.BUFFER_STATUS);  -->  статус получ. буфера

gl.isBuffer(...);

Перед тем, как трансформировать объект, нужно сохранить исходную матрицу mvMatrix 
в матричном стеке, а после рендерига объекта - восстановить её. Иначе преобразования
объектов будут относительно друг-друга, а не относительно сцены.
...
const mStack = [];

function pushMatrix() {
  const temp = mat4.create();
  mat4.copy(temp, mvMatrix);
  mStack.push(temp);
}

function popMatrix() {
  if (mStack.length > 0) {
    mvMatrix = mStack.pop();
  }  
}

function drawObject(index) {
  pushMatrix();
    mat4.translate(mvMatrix, mvMatrix, stage.stageObjects[index].location);
    mat4.rotateX(mvMatrix, mvMatrix, stage.stageObjects[index].rotationX);
    // Активация буферов и вызов drawElements(...)
  popMatrix();
}

У WebGL ограничено кол-во создаваемых униформ. Если привысить лимит, то будет ошибка
компиляции шейдеров. Чтобы запросить разрешенно кол-во униформ, использ. вызовы:
...
gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

Это ограничение не позволяет реализовать множество источников освещения. 
Но чтобы его обойти, можно использовать массивы: 
...
const int LIGHTS_COUNT = 2;
uniform vec3 u_LightPositions[LIGHTS_COUNT];
varying vec3 u_LightRays[LIGHTS_COUNT];

for (int i = 0; i < LIGHTS_COUNT; i++) {
  vec4 lightPos = mvMatrix * vec4(u_LightPositions[i], 1.0);
  u_LightRays[i] = vertexPos - lightPos.xyz;
}

gl.uniform3fv(u_LightPositions, [4, 10, -10, -4, 10, -10]);  -->  массив 2х векторов

Окружающий (ambient) цвет не нужно рассчитывать в шейдерах, поскольку он не зависит 
от расстояния и ориентации объекта. Вместо этого можно суммировать его от всех
источников света и передать эту сумму в шейдер.

Пример реализации множественного освещения (с точечным светом) на стр. 110.
Отражение по Блинн-Фонгу. Затениние по Фонгу.

Для реализации источника света используется класс Light.js. Он хранит его цвета,
направление и позицию. Для реализации всего освещения в целом использ. класс Lights.

------------------

РАЗНОЕ

Кол-во источников света и выбор алгоритмов затенения влияют на производительность.
Нужно стараться чтобы кол-во источников света было минимальным, подменяя их запеканием
теней и лайтмапами. А еще нужно избегать зеркальных отражений, т.к. они нагружают GPU.

materialDiffuseColor - одно из названий для свойства материала.
lamberdTerm - член Ламберта: max(dot(normal, -lightDir), 0.0);
specular - член Блинна: pow(specAngle, 16.0);

Обозначение суффиксов у некоторых методов:
...
funcName[1234][fi][v]() - означает ф-цию/метод с 1,2,3,4-параметрами типа float 
или int; если в конце стоит символ v, то вместо чисел нужно передавать 
вектор с 1,2,3,4-размерностью (т.е. массив).

Обзор форматов .obj и .mtl на стр. 55.
Конвертация файлов в JSON-файл на стр. 57.

Модели объектов (и другие ресурсы) обычно подгружаются через Ajax.

Метод requestAnimationFrame() вызывается только тогда, когда вкладка браузера находится
в фокусе. Это экономит ресурсы GPU. С помощью него можно получить цикл рендеринга,
который будет выполнятся настолько быстро, насколько позволяют браузеры.

