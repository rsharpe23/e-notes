ОСНОВЫ

Dart - это объектно-ориентированный язык. Все значения, которые используются в программе,
представляют объекты (УТОЧНИТЬ). Если Dart применяется для работы с Flutter, то его 
можно не устанавливать отдельно, поскольку установочный пакет Flutter уже содержит все
инструменты для работы с этим языком.

Входной точкой программы является ф-ция main().
Комментарии определяются также, как и в JS (// и /**/).
Переменная определяется следующим образом: String name = "Tom";

Вместо типа переменной можно указывать ключевые слова: var и dynamyc. Они позволяют задать
тип динамически. Переменная с dynamic может принимать (после присвоения) значение с любым
другим типом, а с var - только с тем типом, который был задан изначально.

 var name = "Tom";
 name = 45;  // ошибка

 dynamic name = "Tom";
 name = 45;  // допустимо

Ключевые слова const и final определяют константы. Отличие между ними в том, что значение
const должно быть известно на момент компиляции, а значение final может определятся во время
выполнения программы (т.е. при каждом новом запуске программы, значения final может быть
разным.) const и final можно указывать вместо типа переменной, а также рядом с типом.

Примитивные типы данных: 
 bool - true/false; 
 int - целые числа не более 64 бит (точный размер зависит от платформы); 
 double - вещественные числа, занимающие 64 бита; 
 String - строки (в кодировке UTF-16);

Если типу double присвоить значение типа int, то оно автоматически станет double.
Строки можно объявлять как в одинарных, так и в двойных кавычках.
Многострочная строка объявляется в тройных кавычках.

Интерполяция строк реализуется с помощью знака $:

 int age = 35;
 String info = "Age: $name";  -->  "Age: 35"

Если переменная не имеет никакого значения, то она равняется null. По умолчанию, все
переменные являются null-safety. Это означает что им нельзя задать null. Чтобы сделать
nullable-переменную, нужно к типу добавить знак вопроса.

 String? name;  name = null;  // Допустимо

Для работы с nullable-переменными можно использовать операторы ?? и ??= 
(работают точно также, как в JS). 

 value1 ?? value2  // если value1 не равно null, то оператор возвращает его, иначе value2
 value ??= 23  // если value равно null, то ему присваивается 23

Доступные арифметические операции: +, -, *, /, ~/, %
При обычном делении, результатом всегда будет double, даже если делятся целые числа.
Операция ~/ позволяет выполнить деление целых чисел с целочисленным результатом.

Dart поддерживает префиксный и постфиксный инкремент/декремент.
Операции инкремента/декремента имеют больше приоритет, чем арифметические.

Доступные побитовые операции: &, |, ^, ~ 
Доступные операции сдвига: <<, >>

Условные выражения возвращают значение типа bool. К ним относятся операции сравнения 
и логические операции. Операции сравнения: ==, !=, <, >, <=, >=

Логические операции: 
 | - true если или А, или B, или A и B равны true;
 & - true если и A, и B равны true; 
 ! - true если значение равно false; 
 ^ - true если или A, или B равны true, но неодновременно; 

Для операций | и & есть аналоги || и &&. Они работают также, но отличаются тем, что
ориентируются по результату первого операнда и прекращают дальнейшее вычисление, если оно 
уже не имеет смысла, тогда как операции | и & будут всегда вычислять значения двух операндов.

Операции присвоения: =, +=, -=, *=, /=, ~/=, %=, &=, |=, ^=, <<=, >>=, ??=

 int a = 5;
 int b = 10;
 a &= b;  // переменной a присваивается значение a & b

Условные конструкции: if..else, switch..case и ?: (тернарный оператор).

Оператор if в качестве условия может принимать любое булевое выражение. Для блока case,
оператора switch, можно не указывать break (при этом будет работать как с break). 
Также внутри case можно использовать continue для перехода на конкретный case.

 switch(num) {
  case 1: 
    print("число равно 1");
  case 2: 
    print("число равно 2");
    num++;
    continue N3;
  N3: case 3:                 // название метки N3 произвольное
    print("число равно 3");
  default:
    print("число не равно 1, 2, 3");
 }

Тернарный оператор не обязательно должен возвращать значения. 
Он может просто выполнять некоторые действия.

 a > b ? print(a - b) : print(a + b);

Доступные циклы: for, while, do...while, for..in. Каждый проход цикла называется итерацией.
Цикл может задаваться без фигурных скобок. Например ниже, с пом. for, вычисляется сумма.

 int sum = 0;
 for (int i = 1; i < 10; sum += i, i++);  // цикл без тела
 print(sum);

Чтобы вывести информацию на консоль, используется ф-ция print(). Она принимает один аргумент
и выводит его текстовое представление, автоматически добавляя перевод строки. Чтобы вывести
несколько результатов, можно использовать интерполяцию строки.

Еще одним способом вывода информации является ф-ция stdout.write() из библиотеки dart:io. 
Но она не добавлят перевод строки. 

Чтобы выполнить консольный ввод, используется ф-ция stdin.readLineSync() из той же библиотеки.
Она приостанавливает выполнение программы и ждет, пока пользователь введет строку текста 
и нажмет Enter.

 import "dart:io";
 
 void main() {
   stdout.write("Введите ваше имя: ");
   String? name = stdin.readLineSync();
   if(name != null) {
     print("Привет, $name!");
   }
 }

------------------

ФУНКЦИИ

Ф-ция определяется следующим образом: void myFn(int a, String b) { }
Если ф-ция состоит из одного выр-я, то ее можно сократить: void myFn() => print("hello");
Область видимости переменных ограничивается блоком кода.

Типы параметров можно не указывать. В этом случае Dart сам выведет их, исходя из 
передаваемых значений (это будет аналогично параметрам с dynamic).

 printPerson("Tom", 35);
 printPerson(29, "Alice");

 void printPerson(name, age) { }  

Необязательные параметры задаются так:

 // Необязательные параметры должны идти после обязательных
 void printPerson(String name, [int age = 22, String company = ""]) { }

Если необязательный параметр является nullable, то он может быть без значения по умолчанию.

Именованные параметры задаются через фигурные скобки. По умолчанию они являются
необязательными, поэтому требуют значений по умолчанию (кроме nullable). Чтобы передать таким
параметрам значения, нужно вызвать их по имени, через двоеточие. Вызывать можно в любой
последовательности либо не вызывать вовсе.

 printPerson(name: "Tom", age: 35);
 printPerson(age: 29, name: "Alice");
 printPerson(name: "Kate");

 void printPerson({ String name = "undefined", int age = 0 }) { }

Именованные параметры можно сделать обязательным через оператор required. В этом случае,
значения по умолчанию можно не указывать.

 void printPerson({ required String name, int age }) { }

Возвращаемый тип ф-ции можно также не указывать. В этом случае он будет определяться 
исходя из значения, возвращаемого оператором return.

 sum(int a, int b) {
   return a + b;
 }

Если ф-ция не имеет оператора return, то в ее тело неявно добавляется return null;

Любая ф-ция в Dart является объектом типа Function (callable-объектом).
Такому типу можно присваивать ф-ций любых сигнатур.

 Function f = myFunc;
 f();

 void myFunc() => print("hello");

Анонимная ф-ция - это ф-ция без имени, которая присваивается переменной с типом Function.

 Function sum = (a, b) => a + b;  // ф-ция из одного действия

 Function sum = (int a, int b) {
   print("Сумма $a и $b");
   return a + b;
 };

В Dart также можно определять вложенные ф-ции. Но их нужно определять до вызова.

 void showMessage() {
   void hello() {
     print("Hello!");
   }

   hello();
   hello();
 }
 
------------------

ООП

Класс определяется следующим образом: class MyClass { }

Если в классе не определено ни одного конструктора, то для него будет автоматически 
создан конструктор без параметров.

Объект класса создается так: MyClass obj = MyClass();

Поля - это переменные класса, а методы - ф-ции класса. Доступ к полям и методам
осуществляется через точку.

 class Person {
   String name = "Serg";
   int age = 0;

   void display() {
     print("Имя: $name \tВозраст: $age");
   }
 }

 Person person = Person();
 person.age = 38;
 person.display();

Чтобы выполнить цепочку операций над объектом, используется оператор ..

 Person person = Person();
   ..age = 38;
   ..dislpay();

Конструктор класса определяется так:

 // Для установки полей можно также использовать this
 Person(String n, int a) {
   name = n;                 
   age = a;                       
 }

Сокращенный вариант конструктора: Person(this.name, this.age);

Чтобы определить несколько конструкторов, нужно использовать именованные конструкторы:

 Person.undefined() { }
 Person.withName(String name) { }
 Person(String name, int age) { }

 ...

 Person p1 = Person.undefined();
 Person p2 = Person.withName("Ivan");
 Person p3 = Person("Sam", 25);

Чтобы вызвать из одного конструктора другой конструктор используется такая запись:
 Person.withName(String name): this(name, 18);

Конструктор, как и ф-ция, может иметь обязательные и необязательные пар-ры:
 Person({ required this.name, this.age = 18 }); 

Если конструктор, помимо инициализации полей, имеет еще какую-то логику, то поля 
можно вынести отдельно, в инициализаторы:

 Person(String name, int age): this.name = name, this.age = age {
   print("Персона $name создана!");
 }

Чтобы сделать приватными поля или методы класса, нужно объявить их с нижнем подчеркиванием.
Но приватность будет работать только в том случае, если сам класс находится в отдельном 
файле или библиотеке. Точно также можно сделать приватными и конструкторы.

 Файл person.dart

  class Person {
    String _name = "";

    Person(String name) {
   	  _name = name;
    }
  
    void display() => _print(); 
    void _print() => print("Имя: $_name");
  }

 Файл main.dart 

  import "person.dart";
  
  void main() {
    Person p = Person("Tom");
    p.display();
  } 

Геттеры и сеттеры определяются так:

 String get name { return _name; }
 String get name => _name;  // сокращенный вариант

 set name(String value) {
   _name = value;
 }

Если поля требуется инициализировать не сразу, а в процессе работы с объектом, то можно
использовать отложенную инициализацию (вместо nullable-типов).

 late String name;  // теперь начальное значение можно не указывать
 late int age;

Late-поля инициализируются только при первом обращении к ним. Поэтому их также можно
использовать, когда нужна оптимизация кода.

Как и в JS, в Dart есть специальный оператор ?. (null-aware access operator) 
для обращения к членам nullable-объекта:

 Person? p;
 p?.age = 23;

Но после инициализации объекта, оператор ?. можно не использовать:

 p = Person();
 p.display();

Точно также можно использовать и каскадную нотацию с этим оператором:

 void myFn(Person? person) {
   person
     ?..name = "Tom"
      ..age = 38
 }

Если есть уверенность в том, что nullable-переменная точно не будет иметь null, то к ней
можно применять оператор ! (null assertion operator), как в TS.

 String? name;
 String getName() => name!;

Оператор !. используется для обращения к полям nullable-объекта, который не равен null

 String? name;
 bool isValid() => name!.length > 6;  // без знака ! была бы ошибка

Чтобы сделать поля класса константными, нужно использовать ключевое слово final. Но константы
можно установить только до вызова тела конструктора, поэтому чтобы передать им значения из
вне, можно использовать либо инициализаторы, либо сокращенный вариант конструктора.

Конструкторы также могут быть константными, для этого они должны предваряться ключевым 
словом const. Такие конструкторы не имеют тела. Класс, с константным конструктором должен
содержать только константные поля. 

 class Person {
   final String name;
   final int age;
   const Person(this.name, this.age);
 }

 const Person p = Person("Tom", 38);

Использование подобных классов увеличивает производительность программы. Например Flutter
часто использует константные виджеты, что позволяет ему не тратить время на лишние
пересчеты и отрисовку макета.

Чтобы сделать поля или методы класса статичискими, используется ключевое слово static.
Статическими могут быть также геттеры, сеттеры и константы.

 static const int commonPrice = 65; 
 static int get count => _count;

В Dart можно сделать фабричный конструктор. Такой конструктор полезен при создании
сложносоставных объектов, а также тогда, когда вместо нового экзепляра требуется возвращать
уже имеющийся (т.е. синглтон). Фабричный конструктор может быть именованным. 
Но this в таком конструкторе недоступен.

 class Person {                               class Person {
   String _name;                                Person._();
                                                static Person _instance = Person._();
   factory Person.create(String name) {         factory Person() => _instance;
     if (name.length < 3) {                   }
       name = "Serg";                            
     }                                        Person p = Person();  // синглтон
     return Person._create(name);
   }

   Person._create(this._name);
 }

 Person p = Person.create("Jo");



