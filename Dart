ОСНОВЫ

Dart - это объектно-ориентированный язык. Все типы, которые используются в Dart, являются
объектами, даже примитивные (УТОЧНИТЬ). Если Dart применяется для работы с Flutter, то его
можно не устанавливать отдельно, поскольку установочный пакет Flutter уже содержит все
необходимые инструменты для работы с этим языком.

Входной точкой программы является ф-ция main().
Комментарии определяются также, как и в JS (// и /**/).
Переменная определяется следующим образом: String name = "Tom";

Вместо типа переменной можно указывать ключевые слова: var и dynamyc. Они позволяют задать
тип динамически. Переменная с dynamic может принимать (после присвоения) значение с любым
другим типом, а с var - только с тем типом, который был задан изначально.

 var name = "Tom";
 name = 45;  // ошибка

 dynamic name = "Tom";
 name = 45;  // допустимо

Ключевые слова const и final определяют константы. Отличие между ними в том, что значение
const должно быть известно на момент компиляции, а значение final может определятся во время
выполнения программы (т.е. при каждом новом запуске программы, значения final может быть
разным) const и final можно указывать вместо типа переменной, а также рядом с типом.

Примитивные типы данных: 
 bool - true/false; 
 int - целое число не более 64 бит (точный размер зависит от платформы); 
 double - вещественное число, занимающее 64 бита; 
 String - строка в кодировке UTF-16;

Строки являются неизменяемыми, поэтому вместо String часто используют StringBuffer.
Символы строк фактически являются числами. 

Если типу double присвоить значение типа int, то оно автоматически станет double.
Строки можно объявлять как в одинарных, так и в двойных кавычках.
Многострочная строка объявляется в тройных кавычках.

Интерполяция строк реализуется с помощью знака $:

 int age = 35;
 String info = "Age: $name";  -->  "Age: 35"

Если переменная не имеет никакого значения, то она равняется null. По умолчанию, все
переменные являются null-safety. Это означает что им нельзя задать null. Чтобы сделать
nullable-переменную, нужно к типу добавить знак вопроса.

 String? name;  name = null;  // Допустимо

Для работы с nullable-переменными можно использовать операторы ?? и ??= 
(работают точно также, как в JS). 

 value1 ?? value2  // если value1 не равно null, то оператор возвращает его, иначе value2
 value ??= 23  // если value равно null, то ему присваивается 23

Доступные арифметические операции: + - * / ~/ %
При обычном делении, результатом всегда будет double, даже если делятся целые числа.
Операция ~/ позволяет выполнить деление целых чисел с целочисленным результатом.

Dart поддерживает префиксный и постфиксный инкремент/декремент.
Операции инкремента/декремента имеют больше приоритет, чем арифметические.

Доступные побитовые операции: & | ^ ~ 
Доступные операции сдвига: << >>

Условные выражения возвращают значение типа bool. К ним относятся операции сравнения 
и логические операции. Операции сравнения: == != < > <= >=

Логические операции: 
 | - true если или А, или B, или A и B равны true;
 & - true если и A, и B равны true; 
 ! - true если значение равно false; 
 ^ - true если или A, или B равны true, но неодновременно; 

Для операций | и & есть аналоги || и &&. Они работают также, но отличаются тем, что
ориентируются по результату первого операнда и прекращают дальнейшее вычисление, если оно 
уже не имеет смысла, тогда как операции | и & будут всегда вычислять значения двух операндов.

Операции присвоения: = += -= *= /= ~/= %= &= |= ^= <<= >>= ??=

 int a = 5;
 int b = 10;
 a &= b;  // переменной a присваивается значение a & b

Условные конструкции: if..else, switch..case и ?: (тернарный оператор).

Оператор if в качестве условия может принимать любое булевое выражение. Для блока case,
оператора switch, можно не указывать break (при этом будет работать как с break). 
Также внутри case можно использовать continue для перехода на конкретный case.

 switch(num) {
  case 1: 
    print("число равно 1");
  case 2: 
    print("число равно 2");
    num++;
    continue N3;
  N3: case 3:                 // название метки N3 произвольное
    print("число равно 3");
  default:
    print("число не равно 1, 2, 3");
 }

Тернарный оператор не обязательно должен возвращать значения. 
Он может просто выполнять некоторые действия.

 a > b ? print(a - b) : print(a + b);

Доступные циклы: for, while, do...while, for..in. Каждый проход цикла называется итерацией.
Цикл может задаваться без фигурных скобок. Например ниже, с пом. for, вычисляется сумма.

 int sum = 0;
 for (int i = 1; i < 10; sum += i, i++);  // цикл без тела
 print(sum);

Чтобы вывести информацию на консоль, используется ф-ция print(). Она принимает один аргумент
и выводит его текстовое представление, автоматически добавляя перевод строки. Чтобы вывести
несколько результатов, можно использовать интерполяцию строки.

Еще одним способом вывода информации является ф-ция stdout.write() из библиотеки dart:io. 
Но она не добавлят перевод строки. 

Чтобы выполнить консольный ввод, используется ф-ция stdin.readLineSync() из той же библиотеки.
Она приостанавливает выполнение программы и ждет, пока пользователь введет строку текста 
и нажмет Enter.

 import "dart:io";
 
 void main() {
   stdout.write("Введите ваше имя: ");
   String? name = stdin.readLineSync();
   if(name != null) {
     print("Привет, $name!");
   }
 }

------------------

ФУНКЦИИ

Ф-ция определяется следующим образом: void myFn(int a, String b) { }
Если ф-ция состоит из одного выр-я, то ее можно сократить: void myFn() => print("hello");
Область видимости переменных ограничивается блоком кода.

Типы параметров можно не указывать. В этом случае Dart сам выведет их, исходя из 
передаваемых значений (это будет аналогично параметрам с dynamic).

 printPerson("Tom", 35);
 printPerson(29, "Alice");

 void printPerson(name, age) { }  

Необязательные параметры задаются так:

 // Необязательные параметры должны идти после обязательных
 void printPerson(String name, [int age = 22, String company = ""]) { }

Если необязательный параметр является nullable, то он может быть без значения по умолчанию.

Именованные параметры задаются через фигурные скобки. По умолчанию они являются
необязательными, поэтому требуют значений по умолчанию (кроме nullable). Чтобы передать таким
параметрам значения, нужно вызвать их по имени, через двоеточие. Вызывать можно в любой
последовательности либо не вызывать вовсе.

 printPerson(name: "Tom", age: 35);
 printPerson(age: 29, name: "Alice");
 printPerson(name: "Kate");

 void printPerson({ String name = "undefined", int age = 0 }) { }

Именованные параметры можно сделать обязательным через оператор required. В этом случае,
значения по умолчанию можно не указывать.

 void printPerson({ required String name, int age }) { }

Возвращаемый тип ф-ции можно также не указывать. В этом случае он будет определяться 
исходя из значения, возвращаемого оператором return.

 sum(int a, int b) {
   return a + b;
 }

Если ф-ция не имеет оператора return, то в ее тело неявно добавляется return null;

Любая ф-ция в Dart является объектом типа Function (callable-объектом).
Такому типу можно присваивать ф-ций любых сигнатур.

 Function f = myFunc;
 f();

 void myFunc() => print("hello");

Анонимная ф-ция - это ф-ция без имени, которая присваивается переменной с типом Function.

 Function sum = (a, b) => a + b;  // ф-ция из одного действия

 Function sum = (int a, int b) {
   print("Сумма $a и $b");
   return a + b;
 };

В Dart также можно определять вложенные ф-ции. Но их нужно определять до вызова.

 void showMessage() {
   void hello() {
     print("Hello!");
   }

   hello();
   hello();
 }
 
------------------

ООП

Класс определяется следующим образом: class MyClass { }

Если в классе не определено ни одного конструктора, то для него будет автоматически 
создан конструктор без параметров.

Объект класса создается так: MyClass obj = MyClass();

Поля - это переменные класса, а методы - ф-ции класса. Доступ к полям и методам
осуществляется через точку.

 class Person {
   String name = "Serg";
   int age = 0;

   void display() {
     print("Имя: $name \tВозраст: $age");
   }
 }

 Person person = Person();
 person.age = 38;
 person.display();

Чтобы выполнить цепочку операций над объектом, используется оператор ..

 Person person = Person();
   ..age = 38;
   ..dislpay();

Конструктор класса определяется так:

 // Для установки полей можно также использовать this
 Person(String n, int a) {
   name = n;                 
   age = a;                       
 }

Сокращенный вариант конструктора: Person(this.name, this.age);

Чтобы определить несколько конструкторов, нужно использовать именованные конструкторы:

 Person.undefined() { }
 Person.withName(String name) { }
 Person(String name, int age) { }

 ...

 Person p1 = Person.undefined();
 Person p2 = Person.withName("Ivan");
 Person p3 = Person("Sam", 25);

Чтобы вызвать из одного конструктора другой конструктор используется такая запись:
 Person.withName(String name): this(name, 18);

Конструктор, как и ф-ция, может иметь обязательные и необязательные пар-ры:
 Person({ required this.name, this.age = 18 }); 

Если конструктор, помимо инициализации полей, имеет еще какую-то логику, то поля 
можно вынести отдельно, в инициализаторы:

 Person(String name, int age): this.name = name, this.age = age {
   print("Персона $name создана!");
 }

Чтобы сделать приватными поля или методы класса, нужно объявить их с нижнем подчеркиванием.
Но приватность будет работать только в том случае, если сам класс находится в отдельном 
файле или библиотеке. Точно также можно сделать приватными и конструкторы.

 Файл person.dart

  class Person {
    String _name = "";

    Person(String name) {
   	  _name = name;
    }
  
    void display() => _print(); 
    void _print() => print("Имя: $_name");
  }

 Файл main.dart 

  import "person.dart";
  
  void main() {
    Person p = Person("Tom");
    p.display();
  } 

Геттеры и сеттеры определяются так:

 String get name { return _name; }
 String get name => _name;  // сокращенный вариант

 set name(String value) {
   _name = value;
 }

Если поля требуется инициализировать не сразу, а в процессе работы с объектом, то можно
использовать отложенную инициализацию (вместо nullable-типов).

 late String name;  // теперь начальное значение можно не указывать
 late int age;

Late-поля инициализируются только при первом обращении к ним. Поэтому их также можно
использовать, когда нужна оптимизация кода.

Как и в JS, в Dart есть специальный оператор ?. (null-aware access operator) 
для обращения к членам nullable-объекта:

 Person? p;
 p?.age = 23;

Но после инициализации объекта, оператор ?. можно не использовать:

 p = Person();
 p.display();

Точно также можно использовать и каскадную нотацию с этим оператором:

 void myFn(Person? person) {
   person
     ?..name = "Tom"
      ..age = 38
 }

Если есть уверенность в том, что nullable-переменная точно не будет иметь null, то к ней
можно применять оператор ! (null assertion operator), как в TS.

 String? name;
 String getName() => name!;

Оператор !. используется для обращения к полям nullable-объекта, который не равен null

 String? name;
 bool isValid() => name!.length > 6;  // без знака ! была бы ошибка

Чтобы сделать поля класса константными, нужно использовать ключевое слово final. Но константы
можно установить только до вызова тела конструктора, поэтому чтобы передать им значения из
вне, можно использовать либо инициализаторы, либо сокращенный вариант конструктора.

Конструкторы также могут быть константными, для этого они должны предваряться ключевым 
словом const. Такие конструкторы не имеют тела. Класс, с константным конструктором должен
содержать только константные поля. 

 class Person {
   final String name;
   final int age;
   const Person(this.name, this.age);
 }

 const Person p = Person("Tom", 38);

Использование подобных классов увеличивает производительность программы. Например Flutter
часто использует константные виджеты, что позволяет ему не тратить время на лишние
пересчеты и отрисовку макета.

Чтобы сделать поля или методы класса статичискими, используется ключевое слово static.
Статическими могут быть также геттеры, сеттеры и константы.

 static const int commonPrice = 65; 
 static int get count => _count;

В Dart можно сделать фабричный конструктор. Такой конструктор полезен при создании
сложносоставных объектов, а также тогда, когда вместо нового экзепляра требуется возвращать
уже имеющийся (т.е. синглтон). Фабричный конструктор может быть именованным. 
Но this в таком конструкторе недоступен.

 class Person {                               class Person {
   String _name;                                Person._();
                                                static Person _instance = Person._();
   factory Person.create(String name) {         factory Person() => _instance;
     if (name.length < 3) {                   }
       name = "Serg";                            
     }                                        Person p = Person();  // синглтон
     return Person._create(name);
   }

   Person._create(this._name);
 }

 Person p = Person.create("Jo");

Наследование реализуется с пом. ключевого слова extends. При этом конструкторы не
наследуются. Если в базовом классе есть конструктор (кроме конструктора по умолчанию), 
то его необходимо всегда вызывать в конструкторе дочернего класса.

 class Employee extends Person {
   // С пом. super() вызываем базовый конструктор
   Employee(String name, int age, this.company): super(name, age)

   // Таже запись, что и выше, только в сокращенном виде
   Employee(super.name, super.age, this.company);

   // Переопределение именованного конструктора
   Employee.withName(String name): super.withName(name);
 }

Чтобы переопределить метод базового класса, используется аннотация @override

 @override
 void display() {
   super.display();
   print("Компания: $company");
 }
 
Dart может неявно преобразовать производный тип в базовый тип. Но если требуется
преобразовать базовый тип в производный, то это нужно делать явно с пом. оператора as.
А если требуется просто проверить тип, то используется оператор is либо is!.

 Person p = Employee("Tom", "Sun");  // неявное преобразование
 Employee e = p as Employee;         // явное преобразование
 
 if (p is Employee) { }   // true - если p типа Employee
 if (p is! Employee) { }  // true - если p не типа Employee
 
Абстрактные классы определяются с пом. ключевого слова abstract. Объекты абстрактных классов
создавать нельзя, но в них можно задавать какую-то базовую логику. 

Абстрактный метод - это метод без тела. Абстрактные методы могут определятся только в
абстрактный классах и они должны быть обязательно реализованы у наследников.

 abstract class Shape {
   int calcArea();
 } 

 class Rectangle extends Shape {
   Rectangle(this.width, this.height);

   @override
   int calcArea() {
     return width * height;
   }
 }

В Dart интерфейсы реализовываются через классы. Для реализации интерфейса класса 
используется ключевое слово implements.

 class Student implements Person { }  // Person - это класс

Если класс реализует интерфейс другого класса, то в отличие от наследования, он обязан
определить все его поля и методы (через @override), но не конструкторы.

Начиная с версии Dart 3.0, класс может определяться с ключевым словом interface. В этом
случае такой класс может быть унаследован только рамках своей библиотеки, а за ее
пределами использоваться только как интерфейс.

 interface class Worker { }

Интерфейсный класс может также быть абстрактным (т.е. быть интерфейсом в самом 
классическом понимании, без реализации какой-либо логики).

 abstract interface class Worker { }

Интерфейсов можно реализовать сколь угодно, но наследоваться можно только от одного класса.
К членам класса, который реализован как интерфейс, нельзя обратиться через super.

В Dart можно создавать миксины. Они используются для реализации множественного наследования.
Создавать можно как чистые миксины, так и классы-миксины. Миксины не могут содержать
конструкторов, не могут применять к себе другие миксины и не могут наследовать классы.
Применить миксин к классу можно с пом. ключевого слова with.

 mixin A { }             // чистый миксин (можно только подмешивать его логику) 
 mixin class B { }       // класс-миксин (можно доп. создать его объект)
 class C with A, B { }   // применение миксинов

Члены миксином можно также переопределять (через @override).

Дженерики определяются следующим образом:

 class Person<T> {
   T id;  // тип T - это универсальный параметр
 }

 Person<String> p = Person<String>("345");
 p.id.runtimeType  // runtimeType возвращает конкретный тип

 void log<T>(T arg) { }  // обобщенная ф-ция

Дженерикам можно задать ограничение. В этом случае тип T станет ограничивающим типом или
наследником ограничивающего типа. Но при этом у T появятся все его члены.

 class Transaction<T extends Account> { 
   T account;  // T будет либо Account либо наследником Account
 }

В Dart можно переопределять операторы. Выполняется это с пом. следующей записи:
 возвращаемый_тип operator переопределяемый_оператор(параметр) { }

Операторы, доступные для переопределения: < + | [] > / ^ []= <= ~/ & ~ >= * << == – % >>
Пример перегрузки оператора сложения для класса Counter:

 class Counter {
   int value;
   Counter(this.value);
   
   Counter operator +(Counter other) {
     return Counter(this.value + other.value);
   }
 }

 Counter c1 = Counter(5);
 Counter c2 = Counter(10);
 Counter c3 = c1 + c2;

Перечисления определяются следующим образом:

 enum Operation { add, sub, mul }

 Operation.mul        -->  "Operation.mul"
 Operation.mul.index  -->  2

 Operation op = Operation.add;
 op.index  -->  0

Dart поддерживает расширения типов. Реализуется это так: extension on Класс { }

 extension on int {
   int get square => this * this;

   double pow(int n) {
     double res = 1;
     for (int i = 0; i < n; i++) {
       res *= this;
     }
     return res;
   }
 }
 
 int num = 2;
 num.pow(3);  -->  8.0
 num.square;  -->  4.0

------------------

КОЛЛЕКЦИИ

Массив (список) представлен типом List. Определяется он с пом. квадратных скобок, как в JS.
Если массив определен с пом. const, то он полностью иммутабельный (нельзя ни добавить
элемент, ни удалить, ни изменить саму ссылку). Но если массив определен с пом. final, 
то нельзя изменить только ссылку, а добавить или удалить элементы можно.

 List<String> list = ["Tom", "Bob", "Sam"];
 
 const list2 = ["Tom", "Bob", "Sam"];
 var first = list2[0];  -->  "Tom"

 // Тоже иммутабельный массив (как const), но выбрасывающий ошибку 
 // времени выполнения, при попытке измененить элементы 
 var list3 = List.unmodifiable(["Tom", "Bob", "Sam"]);  

Для перебора списка хорошо подходит цикл for..in либо метод forEach().

 for (var name in list) {     list.forEach(print);
   print(name);               list.forEach((name) => print("Имя: $name"));
 }

Массив может быть фиксированным (т.е. статическим, без изменения размера) и нефексированным
(динамическим). Чтобы создать фиксированный массив, используется именованный конструктор
List.filled() или List.generate().

Массивы в Dart поддерживают оператор spread. Для работы с nullable-массивами есть специальная
версия этого оператора - ...? (т.е. если массив, при работе с ...? равен null, то ничего 
не произойдет; иначе он развернется по обычному).

 var list2 = ["Boo", ...list, "Bar"];

 List<String>? otherList;
 var list3 = [first, ...?otherList];

В Dart, коллекции поддерживают использование if и for..in при установке элементов:

 // Значение "JavaScript" добавится только, если web равен true
 var list = ["Dart", "Flutter", if(web) "JavaScript"];

 // Здесь в список добавляются элементы из employees (похоже на spread)
 var list2 = ["Bob", for(var emp in employees) "Employee " + emp];

Множество представлено типом Set. Определяется оно с пом. фигурных скобок, но с явным
указанием типа (иначе получится объект Map; см. далее).

 Set<String> set = {};
 var set2 = <String>{};

 var set3 = { "Tom", "Bob", "Sam" };
 var first = set3.elementAt(0);  -->  "Tom"

Уникальные методы для коллекции Set:

 difference(other) - возвращает разность текущего множества и множества other;
 intersection(other) - возвращает пересечение двух множеств;
 union(other) - возвращает объединение двух множеств;

Словарь представлен типом Map. Он также определяется с пом. фигурных скобок.

 Map<int, String> map = {};
 var map2 = <int, String>{};
 var map3 = Map();

 var map4 = {};  // Map<dynamic, dynamic>

 var map5 = { 1: "Tom", 2: "Bob", 3: "Sam" };  // ключи должны быть уникальными
 var first = map5[1];  // ключи используются для обращения к эл-там
 map[230] = "Alice";   // добавление нового эл-та

Уникальный метод словаря putIfAbsent() возвращает значение по ключу, если ключ есть 
или добавляет значение по ключу, если ключ отсутсвует.

Перебор словаря осуществяется примерно также, как в JS (либо по values, 
либо по keys, либо по entries).

 for (final key in map5.keys) { }
 for (final value in map5.values) { }
 for (final element in map.entries) { }

 map.forEach((key, value) => print("$key - $value"));

Другие типы коллекций можно реализовать с пом. Iterable. Он также предоставляет общие методы
для List и Set: where(), map(), reduce(), fold(), every(), any(), skip(), skipWhile(),
take(), takeWhile().

Метод fold() похож на reduce(), но отличается тем, что позволяет задать начальное значение.
Метод skip() пропускает некоторое кол-во элементов, а take() - берет первые N-элементов.

Методы, которые возвращают объект Iterable (map, where и др.) характеризуются отложенным
выполнением. Т.е. выполняются только тогда, когда происходит обращение к элементам.
Благодаря этому можно создавать цепочки методов с разными операциями.

 var newPeople = people.where((person) => person.name.length === 3)
                       .map((person) => person.name);

 print(newPeople);  // реалное выполнение where() и map() начнется именно здесь

Кортеж (record) - это неизменяемый тип, который объединяет несколько объектов в один. 
Кортежи имеют фиксированный размер и определяются с пом. круглых скобок.

 (String, int) person = ("Tom", 38);
 var person2 = ("Bob", 23);
 
Для обращения к элементу кортежа используется номер элемента с символом $

 person.$1  -->  "Tom"
 person.$2  -->  38

В именованных кортежах к элементу можно обращаться по его названию:

 ({ int age, String name }) person3 = (name: "Tom", age: 38);
 person.name  -->  "Tom"

Кортежи полезны, когда из ф-ции нужно возвращать сразу несколько значений:

 (String, int) getPerson() {
   return ("Tom", 22);
 }

------------------

ОБРАБОТКА ИСКЛЮЧЕНИЙ

Реализуется с пом. блоков try..on..catch..finally
Блок on обрабатывает конкретное исключение, а catch - все исключения.
Блок finally выполняется в любом случае, даже если исключение не произошло.

 try {
   int x = 9 / 0;
   print(x);
 } 
 catch (e, s) {
   print("Возникло исключение: $e");
   print("Стек: $s");
 } 
 finally {
   print("Освобождение ресурсов");
 }

В Dart исключения деляется на 2 типа: Exception и Error. Exception - представлюет собой
ситуации, которые нельзя обнаружить или спрогназировать на уровне кода. Ошибки, наоборот,
представляю собой ситуации, которые можно проверить на уровне кода.

Блок on может принимать либо Exception, либо Error.

 try {
   int x = 9 / 0;
   print(x);
 } 
 on IntegerDivisionByZeroException {
   print("Обработка исключения IntegerDivizionByZeroException");
 }
 catch (e) {
   print("Обработка всех остальный исключений");
 } 

Блок on и catch можно объединить:

 try {
   ...
 }
 on IntegerDivisionByZeroException catch(e) {
   ...
 }

Встроенные типы исключений: 

DeferredLoadException, FormatException, IntegerDivisionByZeroException, IOException,
FileSystemException, PathNotFoundException, HttpException, RedirectException,
ProcessException, SignalException, SocketException, StdinException, StdoutException
TlsException, CertificateException, HandshakeException, WebSocketException,
IsolateSpawnException, TimeoutException, NullRejectionException, OSError.

Встроенные типы ошибок:

ArgumentError, IndexError, RangeError, AssertionError, AsyncError, sonUnsupportedObjectError,
JsonCyclicError, NoSuchMethodError, OutOfMemoryError, RemoteError, StackOverflowError,
StateError, TypeError, UnimplementedError, UnsupportedError, ConcurrentModificationError.

Чтобы выпросить исключение, используется оператор throw:

 void setAge(int age) {
   if (age < 1 || age > 150) {
     throw Exception("Недопустимый возраст");
   }
   _age = age;
 }

Чтобы реализовать собсвенный класс исключения достаточно определить в нем
поле value и метод toString().

------------------

АСИНХРОННОСТЬ И МНОГОПОТОЧНОСТЬ

Приложение на Dart по умолчанию является однопоточным, но в нем есть асинхронность, 
которая реализуется за счет Event Loop.

Для определения асинхронной задачи используется класс Future. Он представляет собой результат
отложенного действия, которое может завершиться в будущем. Объект Future может находиться 
в 2х состояниях: завершенном и незавершенном (напоминает Promise из JS).

Примеры реализации асинхронных задач:

 // Создается объект Future, который с пом. Timer.run запускает колбек 
 // и возвращает его результат. Колбек может возвращать как тип T, 
 // так и Future<T>. Если колбек ничего не возвращает, 
 // то тип будет Future<void>

 Future<String> f = Future(() {
   return "hello";
 });

 // Создается объект Future, который запускается после задержки, 
 Future f2 = Future.delayed(Duration(seconds: 3), () => print(hello"));

 // Создается объект Future со значением 35
 Future f3 = Future.value(35);  

Чтобы получить результат колбека после завершения Future, используется метод then().

Для перехвата ошибок используется метод catchError(), который работает аналогично then().
Этот метод может принимать доп. колбек во втором параметре, который используется для проверки
ошибки и если та не соответсвует какому-то критерию, то можно вернуть false. 
В этом случае колбек из первого параметра не будет выполняться.

Кроме этого, у Future есть метод whenComplete(), который выполняется в любом случае,
произошла ли ошибка или нет.

 Future future = Future.delayed(Duration(seconds: 1), () => "hello");
 future
   .then((value) {
     print("Получено значение: $value");  // "hello"
     return 23;
   })
   .then((value) {
     print("Получено значение: $value");  // 23
   })
   .catchError((err) => print(err))
   .whenComplete(() => print("Очистка ресурсов"));

Когда Dart встречает асинхронную задачу, то он помещает ее в одну из двух очередей - 
MiscoTask Queue или Event Queue. 

Все задачи выполняются в основном потоке. Сначала выполняются все синхронные задачи, затем
очередь микротасков, а после - одна задача из очереди событий. Далее снова выполняется
очередь микротасков (если таковы имеются) и уже следующая задача из очереди событий.

Очередь событий содержит ресурсоемкие задачи. Например, туда попадает операции с файловой
системой, получение данные от сетевых ресурсов, события GUI и т.д. 

Чтобы вручную запустить микротаск можно использовать конструктор Future.microtask().

Для упрощения работы с Future, можно использовать операторы async и await.
Они позволяют работать с асинхронным кодом, как с синхронным.

Оператор await всегда работает с объектом Future (даже если используется другой тип, 
то совместно с await он будет обернут в Future) и возвращает Future.value. 
Он может использовать только в асинхронных ф-циях.

 void main() { 
   printMsg();  // асинхронная ф-ция может также вызываться из синхронной
 }

 void printMsg() {                                Future<void> printMsg() async {
   print("Начало работы");                          print("Начало работы");
   Future<String> future = getMessage();            String msg = await getMessage();
   future                                           print("Сообщение: $msg");
     .then((msg) => print("Сообщение: $msg"))       print("Окончание работы");
     .then((_) => print("Окончание работы"));     }
 }
 
 Future<String> getMessage() {
   return Future.delayed(Duration(seconds: 3), () => "hello");
 }
 
Перехват ошибок из Future в асинхронной ф-ции, выполняется с пом. try..catch.

Для реализации многопоточности используются изоляты (isolate). При создании изолята,
приложение получает новый поток, который будет работать параллельно основному потоку и иметь
собственную память. При этом изоляты не имеют доступа к памяти друг друга и могут
взаимодействовать только посредством сообщений.

 import 'dart:isolate';

 void main() async {
   print("Начало работы");

   final receivePort = ReceivePort();
   final isolate = await Isolate.spawn(myFn, receivePort.sendPort);
   reseivePort.listen((res)) {
     print(res);
     receivePort.close();   // после получения результата закрываем порт
     isolate.kill();        // и завершаем работу изолята
   });

   print("Выполнение работы...");
 }

 void myFn(SendPort sendPort) {
   var res = 0;
   for (var i = 1; i <= 10000000000; i++) {
     res = i;
   }
   sendPort.send(res);
 }

------------------

ФАЙЛОВАЯ СИСТЕМА


