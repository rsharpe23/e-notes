ОСНОВЫ

Dart - это объектно-ориентированный язык. Все типы, которые используются в Dart, являются
объектами, даже примитивные (УТОЧНИТЬ). Если Dart применяется для работы с Flutter, то его
можно не устанавливать отдельно, поскольку установочный пакет Flutter уже содержит все
необходимые инструменты для работы с этим языком.

Входной точкой программы является ф-ция main().
Комментарии определяются также, как и в JS (// и /**/).
Переменная определяется следующим образом: String name = "Tom";

Вместо типа переменной можно указывать ключевые слова: var и dynamyc. Они позволяют задать
тип динамически. Переменная с dynamic может принимать (после присвоения) значение с любым
другим типом, а с var - только с тем типом, который был задан изначально.

 var name = "Tom";
 name = 45;  // ошибка

 dynamic name = "Tom";
 name = 45;  // допустимо

Ключевые слова const и final определяют константы. Отличие между ними в том, что значение
const должно быть известно на момент компиляции, а значение final может определятся во время
выполнения программы (т.е. при каждом новом запуске программы, значения final может быть
разным) const и final можно указывать вместо типа переменной, а также рядом с типом.

Примитивные типы данных: 
 bool - true/false; 
 int - целое число не более 64 бит (точный размер зависит от платформы); 
 double - вещественное число, занимающее 64 бита; 
 String - строка в кодировке UTF-16;

Строки являются неизменяемыми, поэтому вместо String часто используют StringBuffer.
Символы строк фактически являются числами. 

Если типу double присвоить значение типа int, то оно автоматически станет double.
Строки можно объявлять как в одинарных, так и в двойных кавычках.
Многострочная строка объявляется в тройных кавычках.

Интерполяция строк реализуется с помощью знака $:

 int age = 35;
 String info = "Age: $name";  -->  "Age: 35"

Если переменная не имеет никакого значения, то она равняется null. По умолчанию, все
переменные являются null-safety. Это означает что им нельзя задать null. Чтобы сделать
nullable-переменную, нужно к типу добавить знак вопроса.

 String? name;  name = null;  // Допустимо

Для работы с nullable-переменными можно использовать операторы ?? и ??= 
(работают точно также, как в JS). 

 value1 ?? value2  // если value1 не равно null, то оператор возвращает его, иначе value2
 value ??= 23  // если value равно null, то ему присваивается 23

Доступные арифметические операции: + - * / ~/ %
При обычном делении, результатом всегда будет double, даже если делятся целые числа.
Операция ~/ позволяет выполнить деление целых чисел с целочисленным результатом.

Dart поддерживает префиксный и постфиксный инкремент/декремент.
Операции инкремента/декремента имеют больше приоритет, чем арифметические.

Доступные побитовые операции: & | ^ ~ 
Доступные операции сдвига: << >>

Условные выражения возвращают значение типа bool. К ним относятся операции сравнения 
и логические операции. Операции сравнения: == != < > <= >=

Логические операции: 
 | - true если или А, или B, или A и B равны true;
 & - true если и A, и B равны true; 
 ! - true если значение равно false; 
 ^ - true если или A, или B равны true, но неодновременно; 

Для операций | и & есть аналоги || и &&. Они работают также, но отличаются тем, что
ориентируются по результату первого операнда и прекращают дальнейшее вычисление, если оно 
уже не имеет смысла, тогда как операции | и & будут всегда вычислять значения двух операндов.

Операции присвоения: = += -= *= /= ~/= %= &= |= ^= <<= >>= ??=

 int a = 5;
 int b = 10;
 a &= b;  // переменной a присваивается значение a & b

Условные конструкции: if..else, switch..case и ?: (тернарный оператор).

Оператор if в качестве условия может принимать любое булевое выражение. Для блока case,
оператора switch, можно не указывать break (при этом будет работать как с break). 
Также внутри case можно использовать continue для перехода на конкретный case.

 switch(num) {
  case 1: 
    print("число равно 1");
  case 2: 
    print("число равно 2");
    num++;
    continue N3;
  N3: case 3:                 // название метки N3 произвольное
    print("число равно 3");
  default:
    print("число не равно 1, 2, 3");
 }

Тернарный оператор не обязательно должен возвращать значения. 
Он может просто выполнять некоторые действия.

 a > b ? print(a - b) : print(a + b);

Доступные циклы: for, while, do...while, for..in. Каждый проход цикла называется итерацией.
Цикл может задаваться без фигурных скобок. Например ниже, с пом. for, вычисляется сумма.

 int sum = 0;
 for (int i = 1; i < 10; sum += i, i++);  // цикл без тела
 print(sum);

Чтобы вывести информацию на консоль, используется ф-ция print(). Она принимает один аргумент
и выводит его текстовое представление, автоматически добавляя перевод строки. Чтобы вывести
несколько результатов, можно использовать интерполяцию строки.

Еще одним способом вывода информации является ф-ция stdout.write() из библиотеки dart:io. 
Но она не добавлят перевод строки. 

Чтобы выполнить консольный ввод, используется ф-ция stdin.readLineSync() из той же библиотеки.
Она приостанавливает выполнение программы и ждет, пока пользователь введет строку текста 
и нажмет Enter.

 import "dart:io";
 
 void main() {
   stdout.write("Введите ваше имя: ");
   String? name = stdin.readLineSync();
   if(name != null) {
     print("Привет, $name!");
   }
 }

------------------

ФУНКЦИИ

Ф-ция определяется следующим образом: void myFn(int a, String b) { }
Если ф-ция состоит из одного выр-я, то ее можно сократить: void myFn() => print("hello");
Область видимости переменных ограничивается блоком кода.

Типы параметров можно не указывать. В этом случае Dart сам выведет их, исходя из 
передаваемых значений (это будет аналогично параметрам с dynamic).

 printPerson("Tom", 35);
 printPerson(29, "Alice");

 void printPerson(name, age) { }  

Необязательные параметры задаются так:

 // Необязательные параметры должны идти после обязательных
 void printPerson(String name, [int age = 22, String company = ""]) { }

Если необязательный параметр является nullable, то он может быть без значения по умолчанию.

Именованные параметры задаются через фигурные скобки. По умолчанию они являются
необязательными, поэтому требуют значений по умолчанию (кроме nullable). Чтобы передать таким
параметрам значения, нужно вызвать их по имени, через двоеточие. Вызывать можно в любой
последовательности либо не вызывать вовсе.

 printPerson(name: "Tom", age: 35);
 printPerson(age: 29, name: "Alice");
 printPerson(name: "Kate");

 void printPerson({ String name = "undefined", int age = 0 }) { }

Именованные параметры можно сделать обязательным через оператор required. В этом случае,
значения по умолчанию можно не указывать.

 void printPerson({ required String name, int age }) { }

Возвращаемый тип ф-ции можно также не указывать. В этом случае он будет определяться 
исходя из значения, возвращаемого оператором return.

 sum(int a, int b) {
   return a + b;
 }

Если ф-ция не имеет оператора return, то в ее тело неявно добавляется return null;

Любая ф-ция в Dart является объектом типа Function (callable-объектом).
Такому типу можно присваивать ф-ций любых сигнатур.

 Function f = myFunc;
 f();

 void myFunc() => print("hello");

Анонимная ф-ция - это ф-ция без имени, которая присваивается переменной с типом Function.

 Function sum = (a, b) => a + b;  // анонимная ф-ция из одной строки

 Function sum = (int a, int b) {  // анонимная ф-ция из нескольких строк
   print("Сумма $a и $b");
   return a + b;
 };

В Dart также можно определять вложенные ф-ции. Но их нужно определять до вызова.

 void showMessage() {
   void hello() {
     print("Hello!");
   }

   hello();
   hello();
 }
 
------------------

ООП

Класс определяется следующим образом: class MyClass { }

Если в классе не определено ни одного конструктора, то для него будет автоматически 
создан конструктор без параметров.

Объект класса создается так: MyClass obj = MyClass();

Поля - это переменные класса, а методы - ф-ции класса. Доступ к полям и методам
осуществляется через точку.

 class Person {
   String name = "Serg";
   int age = 0;

   void display() {
     print("Имя: $name \tВозраст: $age");
   }
 }

 Person person = Person();
 person.age = 38;
 person.display();

Чтобы выполнить цепочку операций, используется оператор .. При этом результатом будет 
всегда исходное значение, в отличие от каскада вызовов через одну точку.

 Person person = Person();
   ..age = 38;
   ..dislpay();

 'Hello'..toUpperCase()..toLowerCase();  -->  'Hello'
 'Hello'.toUpperCase().toLowerCase();    -->  'hello'

Конструктор класса определяется так:

 // Для установки полей можно также использовать this
 Person(String n, int a) {
   name = n;                 
   age = a;                       
 }

Сокращенный вариант конструктора: Person(this.name, this.age);

Чтобы определить несколько конструкторов, нужно использовать именованные конструкторы:

 Person.undefined() { }
 Person.withName(String name) { }
 Person(String name, int age) { }

 ...

 Person p1 = Person.undefined();
 Person p2 = Person.withName("Ivan");
 Person p3 = Person("Sam", 25);

Чтобы вызвать из одного конструктора другой конструктор используется такая запись:
 Person.withName(String name): this(name, 18);

Конструктор, как и ф-ция, может иметь обязательные и необязательные пар-ры:
 Person({ required this.name, this.age = 18 }); 

Если конструктор, помимо инициализации полей, имеет еще какую-то логику, то поля 
можно вынести отдельно, в инициализаторы:

 Person(String name, int age): this.name = name, this.age = age {
   print("Персона $name создана!");
 }

Чтобы сделать приватными: поля, методы, классы, ф-ции верхнего уровня (см. ниже) - 
нужно объявить их с нижнем подчеркиванием. Но приватность будет работать 
только за пределами их файлов.

 Файл person.dart

  class Person {
    String _name = "";

    Person(String name) {
   	  _name = name;
    }
  
    void display() => _print(); 
    void _print() => print("Имя: $_name");
  }

 Файл main.dart 

  import "person.dart";
  
  void main() {
    Person p = Person("Tom");
    p.display();
  } 

Геттеры и сеттеры определяются так:

 String get name { return _name; }
 String get name => _name;  // сокращенный вариант

 set name(String value) {
   _name = value;
 }

Если поля требуется инициализировать не сразу, а в процессе работы с объектом, то можно
использовать отложенную инициализацию (вместо nullable-типов).

 late String name;  // теперь начальное значение можно не указывать
 late int age;

Late-поля инициализируются только при первом обращении к ним. Поэтому их также можно
использовать, когда нужна оптимизация кода.

Как и в JS, в Dart есть специальный оператор ?. (null-aware access operator) 
для обращения к членам nullable-объекта:

 Person? p;
 p?.age = 23;

Но после инициализации объекта, оператор ?. можно не использовать:

 p = Person();
 p.display();

Точно также можно использовать и каскадную нотацию с этим оператором:

 void myFn(Person? person) {
   person
     ?..name = "Tom"
      ..age = 38
 }

Если есть уверенность в том, что nullable-переменная точно не будет иметь null, то к ней
можно применять оператор ! (null assertion operator), как в TS.

 String? name;
 String getName() => name!;

Оператор !. используется для обращения к полям nullable-объекта, который не равен null

 String? name;
 bool isValid() => name!.length > 6;  // без знака ! была бы ошибка

Чтобы сделать поля класса константными, нужно использовать ключевое слово final. Но константы
можно установить только до вызова тела конструктора, поэтому чтобы передать им значения из
вне, можно использовать либо инициализаторы, либо сокращенный вариант конструктора.

Конструкторы также могут быть константными, для этого они должны предваряться ключевым 
словом const. Такие конструкторы не имеют тела. Класс с константным конструктором должен
содержать только константные поля. 

 class Person {
   final String name;
   final int age;
   const Person(this.name, this.age);
 }

 // Константной переменной можно задать только константный объект
 const person = const Person("Tom", 38);

Константные объекты увеличивает производительность программы. Например Flutter
часто использует константные виджеты, что позволяет ему не тратить время на лишние
пересчеты и отрисовку макета.

Чтобы сделать поля или методы класса статичискими, используется ключевое слово static.
Статическими могут быть также геттеры, сеттеры и константы.

 static const int commonPrice = 65; 
 static int get count => _count;

В Dart можно сделать фабричный конструктор. Такой конструктор полезен при создании
сложносоставных объектов, а также тогда, когда вместо нового экзепляра требуется возвращать
уже имеющийся (т.е. синглтон). Фабричный конструктор может быть именованным. 
Но this в таком конструкторе недоступен.

 class Person {                               class Person {
   String _name;                                Person._();
                                                static Person _instance = Person._();
   factory Person.create(String name) {         factory Person() => _instance;
     if (name.length < 3) {                   }
       name = "Serg";                            
     }                                        Person p = Person();  // синглтон
     return Person._create(name);
   }

   Person._create(this._name);
 }

 Person p = Person.create("Jo");

Наследование реализуется с пом. ключевого слова extends. При этом конструкторы не
наследуются. Если в базовом классе есть конструктор (кроме конструктора по умолчанию), 
то его необходимо всегда вызывать в конструкторе дочернего класса.

 class Employee extends Person {
   // С пом. super() вызываем базовый конструктор
   Employee(String name, int age, this.company): super(name, age)

   // Таже запись, что и выше, только в сокращенном виде
   Employee(super.name, super.age, this.company);

   // Переопределение именованного конструктора
   Employee.withName(String name): super.withName(name);
 }

Чтобы переопределить метод базового класса, используется аннотация @override

 @override
 void display() {
   super.display();
   print("Компания: $company");
 }
 
Dart может неявно преобразовать производный тип в базовый тип. Но если требуется
преобразовать базовый тип в производный, то это нужно делать явно с пом. оператора as.
А если требуется просто проверить тип, то используется оператор is либо is!.

 Person p = Employee("Tom", "Sun");  // неявное преобразование
 Employee e = p as Employee;         // явное преобразование
 
 if (p is Employee) { }   // true - если p типа Employee
 if (p is! Employee) { }  // true - если p не типа Employee
 
Абстрактные классы определяются с пом. ключевого слова abstract. Объекты абстрактных классов
создавать нельзя, но в них можно задавать какую-то базовую логику. 

Абстрактный метод - это метод без тела. Абстрактные методы могут определятся только в
абстрактный классах и они должны быть обязательно реализованы у наследников.

 abstract class Shape {
   int calcArea();
 } 

 class Rectangle extends Shape {
   Rectangle(this.width, this.height);

   @override
   int calcArea() {
     return width * height;
   }
 }

В Dart интерфейсы реализовываются через классы. Для реализации интерфейса класса 
используется ключевое слово implements.

 class Student implements Person { }  // Person - это класс

Если класс реализует интерфейс другого класса, то в отличие от наследования, он обязан
определить все его поля и методы (через @override), но не конструкторы.

Начиная с версии Dart 3.0, класс может определяться с ключевым словом interface. В этом
случае такой класс может быть унаследован только рамках своей библиотеки, а за ее
пределами использоваться только как интерфейс.

 interface class Worker { }

Интерфейсный класс может также быть абстрактным (т.е. быть интерфейсом в самом 
классическом понимании, без реализации какой-либо логики).

 abstract interface class Worker { }

Интерфейсов можно реализовать сколь угодно, но наследоваться можно только от одного класса.
К членам класса, который реализован как интерфейс, нельзя обратиться через super.

В Dart можно создавать миксины. Они используются для реализации множественного наследования.
Создавать можно как чистые миксины, так и классы-миксины. Миксины не могут содержать
конструкторов, не могут применять к себе другие миксины и не могут наследовать классы.
Применить миксин к классу можно с пом. ключевого слова with.

 mixin A { }             // чистый миксин (можно только подмешивать его логику) 
 mixin class B { }       // класс-миксин (можно доп. создать его объект)
 class C with A, B { }   // применение миксинов

Члены миксином можно также переопределять (через @override).

Дженерики определяются следующим образом:

 class Person<T> {
   T id;  // тип T - это универсальный параметр
 }

 Person<String> p = Person<String>("345");
 p.id.runtimeType  // runtimeType возвращает конкретный тип

 void log<T>(T arg) { }  // обобщенная ф-ция

Дженерикам можно задать ограничение. В этом случае тип T станет ограничивающим типом или
наследником ограничивающего типа. Но при этом у T появятся все его члены.

 class Transaction<T extends Account> { 
   T account;  // T будет либо Account либо наследником Account
 }

В Dart можно переопределять операторы. Выполняется это с пом. следующей записи:
 возвращаемый_тип operator переопределяемый_оператор(параметр) { }

Операторы, доступные для переопределения: < + | [] > / ^ []= <= ~/ & ~ >= * << == – % >>
Пример перегрузки оператора сложения для класса Counter:

 class Counter {
   int value;
   Counter(this.value);
   
   Counter operator +(Counter other) {
     return Counter(this.value + other.value);
   }
 }

 Counter c1 = Counter(5);
 Counter c2 = Counter(10);
 Counter c3 = c1 + c2;

Перечисления определяются следующим образом:

 enum Operation { add, sub, mul }

 Operation.mul        -->  "Operation.mul"
 Operation.mul.index  -->  2

 Operation op = Operation.add;
 op.index  -->  0

Dart поддерживает расширения типов. Реализуется это так: extension on Класс { }

 extension on int {
   int get square => this * this;

   double pow(int n) {
     double res = 1;
     for (int i = 0; i < n; i++) {
       res *= this;
     }
     return res;
   }
 }
 
 int num = 2;
 num.pow(3);  -->  8.0
 num.square;  -->  4.0

------------------

КОЛЛЕКЦИИ

Массив (список) представлен типом List. Определяется он с пом. квадратных скобок, как в JS.
Если массив определен с пом. const, то он полностью иммутабельный (нельзя ни добавить
элемент, ни удалить, ни изменить саму ссылку). Но если массив определен с пом. final, 
то нельзя изменить только ссылку, а добавить или удалить элементы можно.

 List<String> list = ["Tom", "Bob", "Sam"];
 
 const list2 = ["Tom", "Bob", "Sam"];
 var first = list2[0];  -->  "Tom"

 // Тоже иммутабельный массив (как const), но выбрасывающий ошибку 
 // времени выполнения, при попытке измененить элементы 
 var list3 = List.unmodifiable(["Tom", "Bob", "Sam"]);  

Для перебора списка хорошо подходит цикл for..in либо метод forEach().

 for (var name in list) {     list.forEach(print);
   print(name);               list.forEach((name) => print("Имя: $name"));
 }

Массив может быть фиксированным (т.е. статическим, без изменения размера) и нефексированным
(динамическим). Чтобы создать фиксированный массив, используется именованный конструктор
List.filled() или List.generate().

Массивы в Dart поддерживают оператор spread. Для работы с nullable-массивами есть специальная
версия этого оператора - ...? (т.е. если массив, при работе с ...? равен null, то ничего 
не произойдет; иначе он развернется по обычному).

 var list2 = ["Boo", ...list, "Bar"];

 List<String>? otherList;
 var list3 = [first, ...?otherList];

В Dart, коллекции поддерживают использование if и for..in при установке элементов:

 // Значение "JavaScript" добавится только, если web равен true
 var list = ["Dart", "Flutter", if(web) "JavaScript"];

 // Здесь в список добавляются элементы из employees (похоже на spread)
 var list2 = ["Bob", for(var emp in employees) "Employee " + emp];

Множество представлено типом Set. Определяется оно с пом. фигурных скобок, но с явным
указанием типа (иначе получится объект Map; см. далее).

 Set<String> set = {};
 var set2 = <String>{};

 var set3 = { "Tom", "Bob", "Sam" };
 var first = set3.elementAt(0);  -->  "Tom"

Уникальные методы для коллекции Set:

 difference(other) - возвращает разность текущего множества и множества other;
 intersection(other) - возвращает пересечение двух множеств;
 union(other) - возвращает объединение двух множеств;

Словарь представлен типом Map. Он также определяется с пом. фигурных скобок.

 Map<int, String> map = {};
 var map2 = <int, String>{};
 var map3 = Map();

 var map4 = {};  // Map<dynamic, dynamic>

 var map5 = { 1: "Tom", 2: "Bob", 3: "Sam" };  // ключи должны быть уникальными
 var first = map5[1];  // ключи используются для обращения к эл-там
 map[230] = "Alice";   // добавление нового эл-та

Уникальный метод словаря putIfAbsent() возвращает значение по ключу, если ключ есть 
или добавляет значение по ключу, если ключ отсутсвует.

Перебор словаря осуществяется примерно также, как в JS (либо по values, 
либо по keys, либо по entries).

 for (final key in map5.keys) { }
 for (final value in map5.values) { }
 for (final element in map.entries) { }

 map.forEach((key, value) => print("$key - $value"));

Другие типы коллекций можно реализовать с пом. Iterable. Он также предоставляет общие методы
для List и Set: where(), map(), reduce(), fold(), every(), any(), skip(), skipWhile(),
take(), takeWhile().

Метод fold() похож на reduce(), но отличается тем, что позволяет задать начальное значение.
Метод skip() пропускает некоторое кол-во элементов, а take() - берет первые N-элементов.

Методы, которые возвращают объект Iterable (map, where и др.) характеризуются отложенным
выполнением. Т.е. выполняются только тогда, когда происходит обращение к элементам.
Благодаря этому можно создавать цепочки методов с разными операциями.

 var newPeople = people.where((person) => person.name.length === 3)
                       .map((person) => person.name);

 print(newPeople);  // реалное выполнение where() и map() начнется именно здесь

Кортеж (record) - это неизменяемый тип, который объединяет несколько объектов в один. 
Кортежи имеют фиксированный размер и определяются с пом. круглых скобок.

 (String, int) person = ("Tom", 38);
 var person2 = ("Bob", 23);
 
Для обращения к элементу кортежа используется номер элемента с символом $

 person.$1  -->  "Tom"
 person.$2  -->  38

В именованных кортежах к элементу можно обращаться по его названию:

 ({ int age, String name }) person3 = (name: "Tom", age: 38);
 person.name  -->  "Tom"

Кортежи полезны, когда из ф-ции нужно возвращать сразу несколько значений:

 (String, int) getPerson() {
   return ("Tom", 22);
 }

------------------

STREAM API

С пом. Streap API осуществляется реактивное программирование. Реактивность строится на
последовательности асинхронных событий. В Dart такой последовательностью называется Stream.

Примеры создания объекта Stream:

 // С пом. конструктора
 final stream = Stream.fromIterable([1, 2, 3]);
 
 // С пом. асинхронного генератора.
 Stream<int> generateStream() async* {
   int count = 1;
   while (count <= 5) {
     yield count++;
   }
 }
 
 // С пом. StreamController
 class StreamProvider {
   final _controller = StreamController<int>();
   Stream get stream => _controller.stream;

   void startPushingEvents() {
     for (int i = 0; i < 20; i++) {
       _controller.sink.add(i);
     }
   }

   void stopPushingEvents() {
     _controller.close();
   }
 }

StreamController напоминает Observable из RxJS. Стандартный конструктор создает контроллер,
который отдает Single-subscription Stream. Фабричный конструктор StreamController.broadcast()
создает контроллер, который отдает Broadcast Stream (широковещательный).

Single-subscription Stream характерен следующим:

 1. У него может быть только один подписчик.

 2. События складываются в буфер, так что подписчик гарантировано получает 
    всю очередь, даже если подпишется позже.

Broadcast Stream характерен следующим:

 1. У него может быть больше одного подписчика.

 2. События отправляются только активным слушателям в момент вызова методов add(), 
    addAll(), addError() у объекта Sink, т.к. у такого Steam нет буфера. 
    Посему события могут быть пропущены.

StreamController должен быть закрыт, если его никто не слушает, 
чтобы избежать утечек памяти. 

По умолчанию создаются асинхронные контроллеры. Это означает, что каждое событие проходит
через Event Loop как микротаск, что вызывает небольшую задержку.

Cинхронный контроллер создается с пом. параметра sync. Он отправляет события всем подписчиком
моментально, а не через микротаск. Это быстрее, но может привести проблеме, когда подписчик
еще не готов их получать. Из-за этого события могут теряться.

Обработка событий реализуется через метод stream.listen() или цикл for (await in).
Цикл будет итерироваться по событиям объекта Stream.

 // Обработка с пом. цикла

 Future<String> fn(Stream<Srtring> stream) async* {
   final sb = StringBuffer();
   await for (final str in stream) {
     sb.write(str);
   }
   return sb.toString();
 }

 // Обработка с пом. метода listen() с колбеками
 // Параметр cancelOrError = true закрывает подписку после первой ошибки
 // Колбек onData вызывается каждый раз, когда StreamSubscription 
 // обрабатывает событие Stream. Колбек onDone вызывается при закрытии Stream

 StreamSubscription<T> createStreamSubscr<T>(Stream<T> stream) {
   return steam.listen(onData, onError, onDone, cancelOnError: true);
 }

Объект StreamSubscription - это подписка. Ее можно поставить на паузу, восстановить 
и закрыть (методы pause(), resume(), cancel()).  

Для более сложных сценариев используйте пакет rxdart.

------------------

ОБРАБОТКА ИСКЛЮЧЕНИЙ

Реализуется с пом. блоков try..on..catch..finally
Блок on обрабатывает конкретное исключение, а catch - все исключения.
Блок finally выполняется в любом случае, даже если исключение не произошло.

 try {
   int x = 9 / 0;
   print(x);
 } 
 catch (e, s) {
   print("Возникло исключение: $e");
   print("Стек: $s");
 } 
 finally {
   print("Освобождение ресурсов");
 }

В Dart исключения деляется на 2 типа: Exception и Error. Exception - представлюет собой
ситуации, которые нельзя обнаружить или спрогназировать на уровне кода. Ошибки, наоборот,
представляю собой ситуации, которые можно проверить на уровне кода.

Блок on может принимать либо Exception, либо Error.

 try {
   int x = 9 / 0;
   print(x);
 } 
 on IntegerDivisionByZeroException {
   print("Обработка исключения IntegerDivizionByZeroException");
 }
 catch (e) {
   print("Обработка всех остальный исключений");
 } 

Блок on и catch можно объединить:

 try {
   ...
 }
 on IntegerDivisionByZeroException catch(e) {
   ...
 }

Встроенные типы исключений: 

DeferredLoadException, FormatException, IntegerDivisionByZeroException, IOException,
FileSystemException, PathNotFoundException, HttpException, RedirectException,
ProcessException, SignalException, SocketException, StdinException, StdoutException
TlsException, CertificateException, HandshakeException, WebSocketException,
IsolateSpawnException, TimeoutException, NullRejectionException, OSError.

Встроенные типы ошибок:

ArgumentError, IndexError, RangeError, AssertionError, AsyncError, sonUnsupportedObjectError,
JsonCyclicError, NoSuchMethodError, OutOfMemoryError, RemoteError, StackOverflowError,
StateError, TypeError, UnimplementedError, UnsupportedError, ConcurrentModificationError.

Чтобы выпросить исключение, используется оператор throw:

 void setAge(int age) {
   if (age < 1 || age > 150) {
     throw Exception("Недопустимый возраст");
   }
   _age = age;
 }

Чтобы реализовать собсвенный класс исключения достаточно определить в нем
поле value и метод toString().

------------------

АСИНХРОННОСТЬ И МНОГОПОТОЧНОСТЬ

Dart по умолчанию является однопоточным, но в нем есть асинхронность, 
которая реализуется за счет Event Loop (это бесконечный цикл обработки событий).

Для определения асинхронной задачи используется класс Future. Он представляет собой результат
отложенного действия, которое может завершиться в будущем. Объект Future может находиться 
в 2х состояниях: завершенном и незавершенном (напоминает Promise из JS).

Примеры реализации асинхронных задач:

 // Создается объект Future, который с пом. Timer.run запускает колбек 
 // и возвращает его результат. Колбек может возвращать как тип T, 
 // так и Future<T>. Если колбек ничего не возвращает, 
 // то тип будет Future<void>

 Future<String> f = Future(() {
   return "hello";
 });

 // Создается объект Future, который запускается задержкой, 
 Future f2 = Future.delayed(Duration(seconds: 3), () => print(hello"));

 // Создается объект Future со значением 35
 Future f3 = Future.value(35);  

Чтобы получить результат колбека после завершения Future, используется метод then().

Для перехвата ошибок используется метод catchError(), либо колбек из второго параметр then().
Колбек then() имеет более высокий приоритет, чем catchError().

У Future есть также метод whenComplete(), который выполняется в любом случае,
произошла ли ошибка или нет.

 Future future = Future.delayed(Duration(seconds: 1), () => "hello");
 future
   .then((value) {
     print("Получено значение: $value");  // "hello"
     return 23;
   })
   .then((value) {
     print("Получено значение: $value");  // 23
   })
   .catchError((err) => print(err))
   .whenComplete(() => print("Очистка ресурсов"));

Event Loop работает следующим образом: 

 Когда Dart встречает асинхронную задачу, то он помещает ее либо в 
 MiscoTaskQueue, либо в EventQueue. 

 Все задачи выполняются в одном потоке. Сначала выполняются синхронные задачи, затем
 очередь микротасков, а после - одна задача из очереди событий. Далее снова выполняется
 очередь микротасков (если таковы имеются) и следующая задача из очереди событий. 

 И так продолжается до тех пор, пока не закончатся все задачи.

Очередь событий содержит ресурсоемкие задачи. Туда попадает операции с файловой системой,
таймеры, события отрисовки и другие внешние события. А также Future.
(колбек Future - это событие EventQueue)

Очередь микротасков содержит очень маленькие и дешевые по ресурсам задачи. Но ими не стоит
злоупотреблять, поскольку длинный MiscoTaskQueue заблокирует обработку EventQueue.

Создать микротаск можно либо с помощью ф-ции scheduleMicrotask(), 
либо через конструктор Future.microtask().

По сути, Event Loop - это просто некая имитация асинхронности. Любая ресурсоемкая 
задача (синхронная или асинхронна) может заблокировать его работу и приложение зависнет.
Future также не создает настоящую асинхронную операцию, т.к. реализован с пом. 
синхронных операций. 

Для упрощения работы с Future API, можно использовать операторы async и await.
Они позволяют работать с асинхронным кодом, как с синхронным.

Оператор async делает ф-цию асинхронной. Асинхронная ф-ция - это та, выполнение которой 
может быть приостановлено (оператором await) с передачей управления назад, в место вызова.
Как только блокирующая операция выполнется, ф-ция продолжит свою работу с того места, 
где она была приостановлена.

Типом возвращаемого значением асинхронной ф-ции может быть только Future или void. 
Но в случае с void, дождаться выполнения такой ф-ции не получится. 

Оператор await всегда работает с Future (даже если используется другой тип, то совместно 
с await он будет обернут в Future) и возвращает Future.value. Он может использоваться 
только внутри асинхронных ф-ций.

 void main() { 

   // Асинхронная ф-ция может вызываться из синхронной. 
   // Она работает как синхронная пока не встретит первый await,
   // после чего ее выполнение приостанавливается 
   // и она начинает работать асинхронно

   printMsg();  
 }

 void printMsg() {                                Future<void> printMsg() async {
   print("Начало работы");                          print("Начало работы");
   Future<String> future = getMessage();            String msg = await getMessage();
   future                                           print("Сообщение: $msg");
     .then((msg) => print("Сообщение: $msg"))       print("Окончание работы");
     .then((_) => print("Окончание работы"));     }
 }
 
 Future<String> getMessage() {
   return Future.delayed(Duration(seconds: 3), () => "hello");
 }

Перехват ошибок из асинхронной ф-ции, выполняется с пом. try..catch. Но если результат
асинхронной ф-ции не ожидается, то try..catch не сможет отловить ошибку.

Примеры работы с таймером:

 // Одиночное выполнение с секундной задержкой
 final timer = Timer(Duration(seconds: 1), () => print('hello'));

 // Если нужно отменить выполнение
 timer.cancel();

 // Каждую секунду будет выводиться сообщение
 Timer.periodic(Duration(seconds: 1), (t) => print('tick'));  

Под капотом Future.delayed() использует Timer. Его отличие в том, что он возвращает объект
Future, а не Timer и позволяет использовать await. Но его нельзя отменить.

Для реализации многопоточности используются изоляты (isolate). При создании изолята,
приложение получает новый поток, который будет работать параллельно основному потоку и иметь
собственную память. При этом изоляты не имеют доступа к памяти друг друга и могут
взаимодействовать только посредством сообщений.

 import 'dart:isolate';

 void main() async {
   print("Начало работы");

   final receivePort = ReceivePort();
   final isolate = await Isolate.spawn(myFn, receivePort.sendPort);
   reseivePort.listen((res)) {
     print(res);
     receivePort.close();   // после получения результата закрываем порт
     isolate.kill();        // и завершаем работу изолята
   });

   print("Выполнение работы...");
 }

 void myFn(SendPort sendPort) {
   var res = 0;
   for (var i = 1; i <= 10000000000; i++) {
     res = i;
   }
   sendPort.send(res);
 }

------------------

ФАЙЛОВАЯ СИСТЕМА

Работа с файловой системой, а также с системой ввода/вывода становится доступной 
после подключения пакета dart:io

Для работы с каталогами используется класс Directory:

 var dir = Directory("hello");
 dir.path -->  "hello"

 Directory.current     // путь к текущей папке
 Directory.systemTemp  // каталог для временных файлов в текущей ОС

 dir.create()                 // создает каталог hello
 dir.create(recursive: true)  // создает вложенный каталог, например: hello/world

 dir.list()          // возвращает содержимое папки
 dir.exist()         // возращает true если папка существует
 dir.rename("work")  // переименование папки  

 dir.delete()  // удаляет папку (если передать true, то удалятся и вложенные папки)
 dir.stat()    // информацию о папке (размер, время изменения и пр.)

Для работы с файлами используется класс File:

 var file = File("hello.txt");
 file.path           -->  "hello.txt"
 file.absolute.path  -->  "C:\dart\hello.txt"

 file.create()                 // создает файл hello.txt
 file.create(recursive: true)  // создает файл с указанными вложенными каталогами

 file.copy("world.txt")     // копирует hello.txt в world.txt
 file.rename("hello2.txt")  // переименование файла

 file.exists()  // возращает true если файл существует
 file.delete()  // удаляет файл (результатом является удаленный файл)
 file.stat()    // информация о файле
 file.length()  // размер файла в байтах

Методы Directory и File (create, delete и пр.) возвращают объект Future или Stream, 
поэтому с ними можно работать через await.

Примеры чтения и записи в файл:

 import "dart:io";

 void main() async {
   var file = File("hello.txt");

   await file.writeAsString("hello");  
   await file.writeAsString("world", mode: FileMode.append);  // дозапись

   var lines = await file.readAsLines();  // асинхронно считывает файл и возвращает
   for (var line in lines) {              // список строк (кот. заканчиваются символом \n)
     print(line);
   }
   
   String content = await file.readAsString();      // считывает файл в одну строку
   String content = await file.readAsStringSync();  // синхронно считывает файл в строку
 } 

Чтение и запись в файл бинарных данных:

 File file = File("data.bin");

 List<int> bytes = utf8.encode("hello world");
 await file.writeAsBytes(bytes);

 List<int> content = await file.readAsBytes();
 print(utf8.decode(content));

Если нужно работать с большими файлами, то это лучше делать по кусочкам, используя потоки.
Размер каждого кусочка зависит от конкретной системы, но обычно это 65536 байт.

Для работы с файловым потоком, его нужно сначала открыть, а после окончания работы - 
закрыть (чтобы освободить все связанные ресурсы системы).

 var file = File("hello.txt");

 IOSink sink = file.openWrite();  // открывает поток для записи (если нужна дозапись, 
 sink.write("hello world\n");     // то нужно передать параметр mode: FileMode.append)

 await sink.close();              // закрывает поток

При записи объектов, будет записываться их строковое представление, 
определяемое методом toString().

Пример чтения данных по кускам из файлового потока:

 Stream<List<int>> stream = file.openRead();  // открывает поток для чтения
 stream.listen((data) => print(data))  		  // получение порции данных (в байтах)

Метод listen() может принимать 3 колбека: для чтения данных, для обработки ошибок 
и для действия по завершению ф-ции:

 stream.listen(onData, onError, onDone);

Вместо метода listen() можно использовать цикл for..in.
Чтобы преобразовать порцию данных в строку используется метод utf8.decode().

 try {
   await for (var data in stream) {
     print(utf8.decode(data));
   }
 } on Exception catch (error) {
   print(error);
 }

Для автоматического преобразования данных можно использовать метод stream.transform():

 await for (var data in stream.transform(utf8.decoder)) {
   print(data);
 }

 // Альтернативный вариант
 stream.transform(utf8.decoder).listen((data) => print(data));

Чтобы считывать или записывать пользовательский объект в формате JSON, нужно чтобы его класс
имел методы toJson() и/или fromJson(). После этого, такой объект можно передавать в ф-цию
json.encode() и json.decode() (доступны после подключения пакета dart:convert) 
и получать строковое представление в этом формате.

 class Person {
   String name;
   int age;

   Person(this.name, this.age);
   factory Person.fromJson(Map<String, Object?> json) {
     return Person(json["name"] as String, json["age"] as int);
   }

   Map toJson() => { "name": name, "age": age };
 }

 File file = File("person.json");

 Person p = Person("Tom", 38);
 await file.writeAsString(json.encode(p));
 
 var data = await file.readAsString();
 var jsonMap = json.decode(data);
 Person p2 = Person.fromJson(jsonMap);

Пример работы со списком json-данных:

 var people = [Person("Tom", 38), Person("Bob", 42), Person("Sam", 25)];
 await file.writeAsString(json.encode(people));

 var data = await file.readAsString();
 var jsonArr = json.decode(data);

 var people2 = [];
 for (var item in jsonArr) {
   people.add(Person.fromJson(item));
 }

------------------

HTTP

Для работы с http, используется также пакет dart:io

Http-сервер - это программа, которая принимает запросы и возвращает ответы по протоколу http.
Для создания сервера используется метод bind(), класса HttpServer. Он принимает 2 пар-ра:
адрес и порт (на которых будет запущен сервер). 

Адрес может быть либо строкой, либо объектом класса InternetAdress.
Этот класс имеет 4 статич. свойства:

 anyIPv4 - любой IP-адрес версии 4;
 anyIPv6 - любой IP-адрес версии 6;

 loopbackIPv4 - любой локальный IP-адрес 4й версии, доступный только 
  для запросов с текущ. компьютера;

 loopbackIPv6 - такой же адрес, но 6й версии;

Каждая сетевая программа, прослушивающая запросы, запускается на определенном порту. Порт -
это адрес программы на компьютере. Он принимает значение от 0 до 65653. Если задан 0, 
то система выбирает временный порт.

 // Сервер будет доступен по адресу http://localhost:8888
 // Запросы прослушиваются через метод forEach(void action(HttpRequest req)) 
 // либо в цикле await for (var req in server) { }

 var server = await HttpServer.bind(InternetAddress.anyIPv6, 8888)

 await server.forEach((HttpRequest req) {     
   var res = req.response; 
   res.headers.add("secret", "23");  // добавление заголовков в ответ  
   res.write("hello");               // запись некоторых данных в ответ
   res.close();                      // закрытие и отправка ответа
 });

Для установки заголовком можно также использовать метод set(). А для установки самых частых
заголовком определены отдельные свойства: contentType, contentLength, expires, date и др.

 res.headers.set("My secret", 23);

 // Здесь text - это основной тип содержимого, 
 // а plain - второстепенный тип содержимого

 res.headers.contentType = ContentType("text", "plain");  

Названия стандартных заголовком можно брать из класса HttpHeaders:

 res.headers.add(HttpHeaders.contentTypeHeader, "text/plain; charset=utf-8");
 res.headers.add(HttpHeaders.dateHeader, DateTime.now());

Заголовки - это метаинформация для сетевых данных. Они нужны принимающей стороне для
правильной интерпритации того, что ей приходит. Когда клиент создает запрос, то он
устанавливает в нем заголовки запроса. А когда сервер создает ответ, то он устанавливает 
в нем заголовки ответа (ответ - это часть запроса, которая на сервере просто заполняется).

 var res = req.response;

 // Чтобы клиент (т.е. браузер) мог интепритировать полученные данные 
 // как код html, устанавливает соответсвующий contentType.

 res.headers.contentType = ContentType("text", "html");
 res.write("<h1>hello world</h1>");

 res.close();

Класс HttpRequest имеет следующие свойства:
 headers - заголовки запроса;
 contentLength - длина тела запроса (тело - это данные от клиента);
 method - метод запроса: GET, POST, PUT, PATCH, DELETE;
 cookies - куки клиента (временная информация, связанная с тем или иным доменом);
 requestedUri - запрошенный адрес;
 response - ответ, который должен заполниться на сервере;
 uri - запрошенный путь;

Для взаимодействия с http-сервером со стороны клиента, используется класс HttpClient.
Для создания запроса (объекта HttpClientRequest) используются методы клиента: get(), post() 
и др. Отправка запроса происходит при вызове его метода close(), который также возвращает
ответ (объект HttpClientRespone, представляющий из себя поток для чтение набора байтов).

 var client = HttpClient();

 try {
   HttpClientRequest req = await client.get("localhost", 8888, "/");

   HttpClientResponse res = await req.close();    // отправка запроса
   var data = await res.transform(utf8.decoder);  // преобразование байтов в символы

   print(data.join());  // объединение символов в строку
 }
 finally {
   client.close();  // завершение работы клиента
 }

------------------

PATTERN MATCHING

Оператору switch можно передавать константы в качестве ключей:

 сonst int a = 1, b = 2;
 
 switch (num) {   
   case a: 
     print("num = a");
   case b: 
     print("num = b");
   default:
     print("num is undefined");
 }

Если оператор switch возвращает значения, то его можно сократить:

 switch (lang) {             return switch (lang) {
   case "en":                  "en" => "Hello",
     return "Hello";           "ru" => "Привет",
   case "ru":                  _ => "Hallo"
     return "Привет";        };
   default: 
     return "Hallo";
 };

Оператор switch позволяет удобно сравнивать свое значение. Поддерживаются все стандратные
операции сравнения: == != < > <= >=, а также логические операции: && и ||

 return switch (num) {
   <= 0 => 0,                    // если num <= 0, то вернет 0
   < 5000 => num * 0.5,          // если num < 5000, то вернет num * 0.5
   > 100 && < 200 => num * 0.1   // если num > 100 && num < 200, то вернет num * 0.1  
   _ => num * 2                  // в остальных случаях вернет num * 2 
 }

Оператор switch позволяет сопоставлять свое значение со списками, кортежами, 
объектами и словарями (можно в сокращенной форме):

 switch (value) {   

   case [1, 2, 3]: return 1;     // если value - это массив [1, 2, 3], то вернет 1
   case [1, 2]: return 2;        // если value - это массив [1, 2], то вернет 2

   case [2, _, 5] return 3;  // если value - это массив из 3х эл-тов, где первый и последний
                             // это 2 и 5, а между ними произвольное значение, то вернет 3

   case [_, _] return 4;     // value должен соответ. массиву из 2х произвольных значений 

   case [2, ..., 5] return 5;   // value должен соответ. массиву, где первый и последний
                                // эл-ты это 2 и 5, а между ними произвольное кол-во эл-тов

   case _: return 5;    // если value не соответ. ни одному кейсу.
 }                            

 switch (value) {
   case ("good", "morning"): return "good";
   case ("good", _): return "hello";  // второй элемент value не важен
   case _: return "hi";
 }

 switch (value) {
   case { "name": "admin" }: return "hello admin";   // если в value есть name = "admin"
   case { "name": var name }: return "hello $name";  // если в value есть ключ name
 }

 switch (value) {

   case Person(name: "Tom", age: > 18): return 1;  // если в value св-во name = "Tom"
                                                   // а св-во age больше 18
   case Person(name: "Tom"): return 2;
   case Person(name: var pName): return 3;  // просто извлекает св-во name в переменную pName
 }

 switch (value) {
   case String(length: > 10): return 1;  // если value - это строка более 10 символов
   case _: return 2;
 }

------------------

ДОПОЛНИТЕЛЬНО

Dart, как и JS, поддерживает деструктуризацию:

 // Деструктуризация кортежа

 var person = ("Sam", 29);
 var (name, age) = person; 
 
 var age = 0;
 (_, age) = person;

 var (name: myName, age: myAge) = (name: "Sam", age: 29)
 myName  -->  "Sam"

 int a = 25;
 int b = 50;
 (a, b) = (b, a);  -->  a = 50, b = 25

 // Деструктуризация списка

 var nums = [1, 2, 3, 4, 5, 6, 7, 8];
 var [a, b, _, c, ..., d] = nums;  -->  a = 1, b = 2, c = 4, d = 8
 vat [..., a, b] = nums;           -->  a = 7, b = 8

 // Деструктуризация объекта

 class Person {
   String name;
   int age;
   Person(this.name, this.age);
 }

 var person = Person("Tom", 38);
 var Person(name: userName, age: userAge) = person;
 userName  -->  "Tom"

Строку можно создать: через одинарные кавычки, через двойные кавычки, через тройные кавычки,
как сырую строку r'hello world' и через StringBuffer (когда нужны манипуляции со строкой).
Общепринятым является первый спобоб - через одинарные кавычки. 

Сырая строка игнорирует либые спецсимволы (например тот же $, из-за чего не выполнется
интерполяция). Экранировать спецсимволы можно также и в обычной строке, через обратный слэш.

Пример работы со StringBuffer:

 final sb = StringBuffer();
 sb.write('hello');
 sb.write(' world');
 String str = sb.toString();

Пример работы с регулярным выражением:

 final regExp = RegExp('world');
 final hasWorld = regExp.hasMatch('hello world');

В Dart 2.17 был добавлен новый enum - enhandec enum, который по сути является константным
классом, в котором можно задать свои поля, методы, конструкторы и пр.

 enum MyIcon {
   final String path;
   const MyIcon({ required this.path });
   ...
 }

Ключевое слово typedef позволяет задать псевдоним для типа:

 typedef JSON = Map<String, Object?>;
 String toString(JSON json) { }

Нотация part of позволяет разбить один файл на несколько частей, чтобы сделать для них общую
область видимости (видимыми станут приватные члены). Используется вместо импорта.

Вместо оператора !. можно делать так: 
 (obj as MyClass).foo();  // тоже, что и ob!.foo();  

Именованные параметры следует использовать только когда их много (от 3х и более). Если
необходимые именованные пар-ры имеют значения по умолчанию, то можно отказаться от required.

На уровне файла можно объявлять не только классы но и ф-ции. Такие ф-ции называют функциями
верхнего уровня. Они видны всем членам библиотеки, независимо от модификатора доступа
(возможно тоже самое и справедливо и для приватных классов).

Замыкание можно объяснить примерно также, как в JS. Т.е. - это ф-ция, которая возвращается 
из другой ф-ции и имеет доступ к ее локальным переменным, за счет того, что запоминает
контекст в котором была определена. При обращении к переменной, ф-ция сначала ищет ее 
в своем локальном контексте и если не находит, то начинает искать в контексте верхней ф-ции.
И так по цепочке, пока не дойдет до самого верхнего доступного контекста.

С помощью Iterable можно создавать синхронные и асинхронные генераторы:

 Iterable<int> generateCounter(int len) sync* {
   int counter = 0;
   while (counter < len) {
     yield counter++;
   }
 } 

 for (final value in generateCounter(10)) {
   print(value);
 }

Фабричных конструкторов в одном классе может быть несколько:

 class A {
   factory A.withB() { };
   factory A.withC() { };
 }

Mixin - это любой класс без конструктора, который также не наследуется от других классов 
За счет отсутсвия конструкторов у миксинов, решается проблема ромбовидного наследования 
(это когда несколько классов наследуются от одного класса, а затем другой класс наследуется
от тех нескольких и получается коллизия между унаследованными членами).

 // Это миксин                  // И это миксин
 class Foo {                    abstract class Bar {
   void printMsg() {              void printMsg() {
     print('hello world');      }
   }                        
 }

 class FooBar with Foo, Bar { }

Миксины могут реализовывать интерфейсы, но смысл миксинов в том, чтобы расширять функционал,
а не создавать объекты. Поэтому, при их определении, вместо ключевого слова class, лучше
использовать слово mixin. В этом случае не придется определять публичные члены интерфейсов.

 // Нет необходимости реализовывать метод printMsg()
 mixin Baz implements Bar {
   String getMsg() {
     return 'hello';
   }
 }

С пом. ключевого слова on можно ограничить классы, в которые можно подмешивать миксин.

 mixin Baz on A {
   String getMsg() { }
 }

 class B entextds A with Baz { }  // поскольку B наследует A, подмешать миксин можно
 class C with Baz { }  // здесь подмешать миксин нельзя

В примере выше, миксин Baz также становится наследником A. В нем можно переопределять члены
A, при этом появляется проблема ромбовидного наследования. Но Dart решает ее тем, 
что берет ту реализацию, которая объявлена последней.

В Dart 3 появлилось несколько доп. модификаторов для класса base class, abstract base class,
final class, sealed class. Базовый класс можно наследовать, но нельзя реализовывать (в других
библиотеках). Финальный класс неользя ни наследовать, ни реализовывать. Запечатанный класс
нельзя наследовать, но можно реализовывать в пределах библиотеки.

В Dart нет параллелизма в общепринятом понимании. Но можно реализовать 
псевдопараллелизм с помощью изолятов.

Изоляты - это аналоги потоков (Threads). Весь код на Dart по умолчанию выполняется в рамках
одного изолята (основного потока). Внутри каждого изолята есть свой Event Loop (механиз
обработки событий, который позволяет писать необлокирующий код) и свой участок памяти.
Изолятов можно создавать сколько угодно.

Как уже было сказано - даже асинхронная задача может заблокировать Event Loop. 
Изолят создает отдельный поток с собстенным Event Loop. Поэтому, если он и заблокируется, 
то это никак не повлияет на работу основного потока. В этом и заключается его главная фишка.

Изолят можно создать с пом. Isolate.run() или с пом. ф-ции compute()
Эти ф-ции самостоятельно очищают его в конце.

 Isolate.run(() => slowOperation(value));
 compute(slowOperation, value);

Экспорт функционала выполняется так (обычно из одного файла):

 export 'src/file.dart';               // экспорт всего ф-ционала из file.dart
 export 'src/file.dart' show MyClass;  // экспорт только класса MyClass   
 export 'src/file.dart' hide MyClass;  // экспорт всего, кроме класса MyClass

Импорт функционала осуществляется так:

 import 'scr/file.dart';               // импорт всего ф-ционала из file.dart
 import 'src/file.dart' show MyClass;  // импорт только класса MyClass
 import 'src/file.dart' hide MyClass;  // импорт всего, кроме класса MyClass

 import 'src/file.data' as ns;   // импорт ф-ционала, к которому потом можно обращаться
                                 // через префикс ns. ns.MyClass и т.д.
 
 import 'package:my_lib'             // импорт всего из библиотеки my_lib
 import 'package:my_lib/file.dart';  // импорт всего из file.dart, библиотеки my_lib

Библиотеки обычно содержат всего один файл экспорта, который находится в корневом каталоге.
Помимо экспорта, в этом файле также задается запись: library my_lib; Это своего рода тег 
или идентификатор библиотеки (название должно совпадать с названием файла). Благодаря нему 
к библиотеке можно обращаться через 'package:'
 
