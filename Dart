ОСНОВЫ

Dart - это объектно-ориентированный язык. Все типы, которые используются в Dart, являются
объектами, даже примитивные (УТОЧНИТЬ). Если Dart применяется для работы с Flutter, то его
можно не устанавливать отдельно, поскольку установочный пакет Flutter уже содержит все
необходимые инструменты для работы с этим языком.

Входной точкой программы является ф-ция main().
Комментарии определяются также, как и в JS (// и /**/).
Переменная определяется следующим образом: String name = "Tom";

Вместо типа переменной можно указывать ключевые слова: var и dynamyc. Они позволяют задать
тип динамически. Переменная с dynamic может принимать (после присвоения) значение с любым
другим типом, а с var - только с тем типом, который был задан изначально.

 var name = "Tom";
 name = 45;  // ошибка

 dynamic name = "Tom";
 name = 45;  // допустимо

Ключевые слова const и final определяют константы. Отличие между ними в том, что значение
const должно быть известно на момент компиляции, а значение final может определятся во время
выполнения программы (т.е. при каждом новом запуске программы, значения final может быть
разным) const и final можно указывать вместо типа переменной, а также рядом с типом.

Примитивные типы данных: 
 bool - true/false; 
 int - целое число не более 64 бит (точный размер зависит от платформы); 
 double - вещественное число, занимающее 64 бита; 
 String - строка в кодировке UTF-16;

Строки являются неизменяемыми, поэтому вместо String часто используют StringBuffer.
Символы строк фактически являются числами. 

Если типу double присвоить значение типа int, то оно автоматически станет double.
Строки можно объявлять как в одинарных, так и в двойных кавычках.
Многострочная строка объявляется в тройных кавычках.

Интерполяция строк реализуется с помощью знака $:

 int age = 35;
 String info = "Age: $name";  -->  "Age: 35"

Если переменная не имеет никакого значения, то она равняется null. По умолчанию, все
переменные являются null-safety. Это означает что им нельзя задать null. Чтобы сделать
nullable-переменную, нужно к типу добавить знак вопроса.

 String? name;  name = null;  // Допустимо

Для работы с nullable-переменными можно использовать операторы ?? и ??= 
(работают точно также, как в JS). 

 value1 ?? value2  // если value1 не равно null, то оператор возвращает его, иначе value2
 value ??= 23  // если value равно null, то ему присваивается 23

Доступные арифметические операции: + - * / ~/ %
При обычном делении, результатом всегда будет double, даже если делятся целые числа.
Операция ~/ позволяет выполнить деление целых чисел с целочисленным результатом.

Dart поддерживает префиксный и постфиксный инкремент/декремент.
Операции инкремента/декремента имеют больше приоритет, чем арифметические.

Доступные побитовые операции: & | ^ ~ 
Доступные операции сдвига: << >>

Условные выражения возвращают значение типа bool. К ним относятся операции сравнения 
и логические операции. Операции сравнения: == != < > <= >=

Логические операции: 
 | - true если или А, или B, или A и B равны true;
 & - true если и A, и B равны true; 
 ! - true если значение равно false; 
 ^ - true если или A, или B равны true, но неодновременно; 

Для операций | и & есть аналоги || и &&. Они работают также, но отличаются тем, что
ориентируются по результату первого операнда и прекращают дальнейшее вычисление, если оно 
уже не имеет смысла, тогда как операции | и & будут всегда вычислять значения двух операндов.

Операции присвоения: = += -= *= /= ~/= %= &= |= ^= <<= >>= ??=

 int a = 5;
 int b = 10;
 a &= b;  // переменной a присваивается значение a & b

Условные конструкции: if..else, switch..case и ?: (тернарный оператор).

Оператор if в качестве условия может принимать любое булевое выражение. Для блока case,
оператора switch, можно не указывать break (при этом будет работать как с break). 
Также внутри case можно использовать continue для перехода на конкретный case.

 switch(num) {
  case 1: 
    print("число равно 1");
  case 2: 
    print("число равно 2");
    num++;
    continue N3;
  N3: case 3:                 // название метки N3 произвольное
    print("число равно 3");
  default:
    print("число не равно 1, 2, 3");
 }

Тернарный оператор не обязательно должен возвращать значения. 
Он может просто выполнять некоторые действия.

 a > b ? print(a - b) : print(a + b);

Доступные циклы: for, while, do...while, for..in. Каждый проход цикла называется итерацией.
Цикл может задаваться без фигурных скобок. Например ниже, с пом. for, вычисляется сумма.

 int sum = 0;
 for (int i = 1; i < 10; sum += i, i++);  // цикл без тела
 print(sum);

Чтобы вывести информацию на консоль, используется ф-ция print(). Она принимает один аргумент
и выводит его текстовое представление, автоматически добавляя перевод строки. Чтобы вывести
несколько результатов, можно использовать интерполяцию строки.

Еще одним способом вывода информации является ф-ция stdout.write() из библиотеки dart:io. 
Но она не добавлят перевод строки. 

Чтобы выполнить консольный ввод, используется ф-ция stdin.readLineSync() из той же библиотеки.
Она приостанавливает выполнение программы и ждет, пока пользователь введет строку текста 
и нажмет Enter.

 import "dart:io";
 
 void main() {
   stdout.write("Введите ваше имя: ");
   String? name = stdin.readLineSync();
   if(name != null) {
     print("Привет, $name!");
   }
 }

------------------

ФУНКЦИИ

Ф-ция определяется следующим образом: void myFn(int a, String b) { }
Если ф-ция состоит из одного выр-я, то ее можно сократить: void myFn() => print("hello");
Область видимости переменных ограничивается блоком кода.

Типы параметров можно не указывать. В этом случае Dart сам выведет их, исходя из 
передаваемых значений (это будет аналогично параметрам с dynamic).

 printPerson("Tom", 35);
 printPerson(29, "Alice");

 void printPerson(name, age) { }  

Необязательные параметры задаются так:

 // Необязательные параметры должны идти после обязательных
 void printPerson(String name, [int age = 22, String company = ""]) { }

Если необязательный параметр является nullable, то он может быть без значения по умолчанию.

Именованные параметры задаются через фигурные скобки. По умолчанию они являются
необязательными, поэтому требуют значений по умолчанию (кроме nullable). Чтобы передать таким
параметрам значения, нужно вызвать их по имени, через двоеточие. Вызывать можно в любой
последовательности либо не вызывать вовсе.

 printPerson(name: "Tom", age: 35);
 printPerson(age: 29, name: "Alice");
 printPerson(name: "Kate");

 void printPerson({ String name = "undefined", int age = 0 }) { }

Именованные параметры можно сделать обязательным через оператор required. В этом случае,
значения по умолчанию можно не указывать.

 void printPerson({ required String name, int age }) { }

Возвращаемый тип ф-ции можно также не указывать. В этом случае он будет определяться 
исходя из значения, возвращаемого оператором return.

 sum(int a, int b) {
   return a + b;
 }

Если ф-ция не имеет оператора return, то в ее тело неявно добавляется return null;

Любая ф-ция в Dart является объектом типа Function (callable-объектом).
Такому типу можно присваивать ф-ций любых сигнатур.

 Function f = myFunc;
 f();

 void myFunc() => print("hello");

Анонимная ф-ция - это ф-ция без имени, которая присваивается переменной с типом Function.

 Function sum = (a, b) => a + b;  // ф-ция из одного действия

 Function sum = (int a, int b) {
   print("Сумма $a и $b");
   return a + b;
 };

В Dart также можно определять вложенные ф-ции. Но их нужно определять до вызова.

 void showMessage() {
   void hello() {
     print("Hello!");
   }

   hello();
   hello();
 }
 
------------------

ООП

Класс определяется следующим образом: class MyClass { }

Если в классе не определено ни одного конструктора, то для него будет автоматически 
создан конструктор без параметров.

Объект класса создается так: MyClass obj = MyClass();

Поля - это переменные класса, а методы - ф-ции класса. Доступ к полям и методам
осуществляется через точку.

 class Person {
   String name = "Serg";
   int age = 0;

   void display() {
     print("Имя: $name \tВозраст: $age");
   }
 }

 Person person = Person();
 person.age = 38;
 person.display();

Чтобы выполнить цепочку операций над объектом, используется оператор ..

 Person person = Person();
   ..age = 38;
   ..dislpay();

Конструктор класса определяется так:

 // Для установки полей можно также использовать this
 Person(String n, int a) {
   name = n;                 
   age = a;                       
 }

Сокращенный вариант конструктора: Person(this.name, this.age);

Чтобы определить несколько конструкторов, нужно использовать именованные конструкторы:

 Person.undefined() { }
 Person.withName(String name) { }
 Person(String name, int age) { }

 ...

 Person p1 = Person.undefined();
 Person p2 = Person.withName("Ivan");
 Person p3 = Person("Sam", 25);

Чтобы вызвать из одного конструктора другой конструктор используется такая запись:
 Person.withName(String name): this(name, 18);

Конструктор, как и ф-ция, может иметь обязательные и необязательные пар-ры:
 Person({ required this.name, this.age = 18 }); 

Если конструктор, помимо инициализации полей, имеет еще какую-то логику, то поля 
можно вынести отдельно, в инициализаторы:

 Person(String name, int age): this.name = name, this.age = age {
   print("Персона $name создана!");
 }

Чтобы сделать приватными поля или методы класса, нужно объявить их с нижнем подчеркиванием.
Но приватность будет работать только в том случае, если сам класс находится в отдельном 
файле или библиотеке. Точно также можно сделать приватными и конструкторы.

 Файл person.dart

  class Person {
    String _name = "";

    Person(String name) {
   	  _name = name;
    }
  
    void display() => _print(); 
    void _print() => print("Имя: $_name");
  }

 Файл main.dart 

  import "person.dart";
  
  void main() {
    Person p = Person("Tom");
    p.display();
  } 

Геттеры и сеттеры определяются так:

 String get name { return _name; }
 String get name => _name;  // сокращенный вариант

 set name(String value) {
   _name = value;
 }

Если поля требуется инициализировать не сразу, а в процессе работы с объектом, то можно
использовать отложенную инициализацию (вместо nullable-типов).

 late String name;  // теперь начальное значение можно не указывать
 late int age;

Late-поля инициализируются только при первом обращении к ним. Поэтому их также можно
использовать, когда нужна оптимизация кода.

Как и в JS, в Dart есть специальный оператор ?. (null-aware access operator) 
для обращения к членам nullable-объекта:

 Person? p;
 p?.age = 23;

Но после инициализации объекта, оператор ?. можно не использовать:

 p = Person();
 p.display();

Точно также можно использовать и каскадную нотацию с этим оператором:

 void myFn(Person? person) {
   person
     ?..name = "Tom"
      ..age = 38
 }

Если есть уверенность в том, что nullable-переменная точно не будет иметь null, то к ней
можно применять оператор ! (null assertion operator), как в TS.

 String? name;
 String getName() => name!;

Оператор !. используется для обращения к полям nullable-объекта, который не равен null

 String? name;
 bool isValid() => name!.length > 6;  // без знака ! была бы ошибка

Чтобы сделать поля класса константными, нужно использовать ключевое слово final. Но константы
можно установить только до вызова тела конструктора, поэтому чтобы передать им значения из
вне, можно использовать либо инициализаторы, либо сокращенный вариант конструктора.

Конструкторы также могут быть константными, для этого они должны предваряться ключевым 
словом const. Такие конструкторы не имеют тела. Класс, с константным конструктором должен
содержать только константные поля. 

 class Person {
   final String name;
   final int age;
   const Person(this.name, this.age);
 }

 const Person p = Person("Tom", 38);

Использование подобных классов увеличивает производительность программы. Например Flutter
часто использует константные виджеты, что позволяет ему не тратить время на лишние
пересчеты и отрисовку макета.

Чтобы сделать поля или методы класса статичискими, используется ключевое слово static.
Статическими могут быть также геттеры, сеттеры и константы.

 static const int commonPrice = 65; 
 static int get count => _count;

В Dart можно сделать фабричный конструктор. Такой конструктор полезен при создании
сложносоставных объектов, а также тогда, когда вместо нового экзепляра требуется возвращать
уже имеющийся (т.е. синглтон). Фабричный конструктор может быть именованным. 
Но this в таком конструкторе недоступен.

 class Person {                               class Person {
   String _name;                                Person._();
                                                static Person _instance = Person._();
   factory Person.create(String name) {         factory Person() => _instance;
     if (name.length < 3) {                   }
       name = "Serg";                            
     }                                        Person p = Person();  // синглтон
     return Person._create(name);
   }

   Person._create(this._name);
 }

 Person p = Person.create("Jo");

Наследование реализуется с пом. ключевого слова extends. При этом конструкторы не
наследуются. Если в базовом классе есть конструктор (кроме конструктора по умолчанию), 
то его необходимо всегда вызывать в конструкторе дочернего класса.

 class Employee extends Person {
   // С пом. super() вызываем базовый конструктор
   Employee(String name, int age, this.company): super(name, age)

   // Таже запись, что и выше, только в сокращенном виде
   Employee(super.name, super.age, this.company);

   // Переопределение именованного конструктора
   Employee.withName(String name): super.withName(name);
 }

Чтобы переопределить метод базового класса, используется аннотация @override

 @override
 void display() {
   super.display();
   print("Компания: $company");
 }
 
Dart может неявно преобразовать производный тип в базовый тип. Но если требуется
преобразовать базовый тип в производный, то это нужно делать явно с пом. оператора as.
А если требуется просто проверить тип, то используется оператор is либо is!.

 Person p = Employee("Tom", "Sun");  // неявное преобразование
 Employee e = p as Employee;         // явное преобразование
 
 if (p is Employee) { }   // true - если p типа Employee
 if (p is! Employee) { }  // true - если p не типа Employee
 
Абстрактные классы определяются с пом. ключевого слова abstract. Объекты абстрактных классов
создавать нельзя, но в них можно задавать какую-то базовую логику. 

Абстрактный метод - это метод без тела. Абстрактные методы могут определятся только в
абстрактный классах и они должны быть обязательно реализованы у наследников.

 abstract class Shape {
   int calcArea();
 } 

 class Rectangle extends Shape {
   Rectangle(this.width, this.height);

   @override
   int calcArea() {
     return width * height;
   }
 }

В Dart интерфейсы реализовываются через классы. Для реализации интерфейса класса 
используется ключевое слово implements.

 class Student implements Person { }  // Person - это класс

Если класс реализует интерфейс другого класса, то в отличие от наследования, он обязан
определить все его поля и методы (через @override), но не конструкторы.

Начиная с версии Dart 3.0, класс может определяться с ключевым словом interface. В этом
случае такой класс может быть унаследован только рамках своей библиотеки, а за ее
пределами использоваться только как интерфейс.

 interface class Worker { }

Интерфейсный класс может также быть абстрактным (т.е. быть интерфейсом в самом 
классическом понимании, без реализации какой-либо логики).

 abstract interface class Worker { }

Интерфейсов можно реализовать сколь угодно, но наследоваться можно только от одного класса.
К членам класса, который реализован как интерфейс, нельзя обратиться через super.

В Dart можно создавать миксины. Они используются для реализации множественного наследования.
Создавать можно как чистые миксины, так и классы-миксины. Миксины не могут содержать
конструкторов, не могут применять к себе другие миксины и не могут наследовать классы.
Применить миксин к классу можно с пом. ключевого слова with.

 mixin A { }             // чистый миксин (можно только подмешивать его логику) 
 mixin class B { }       // класс-миксин (можно доп. создать его объект)
 class C with A, B { }   // применение миксинов

Члены миксином можно также переопределять (через @override).

Дженерики определяются следующим образом:

 class Person<T> {
   T id;  // тип T - это универсальный параметр
 }

 Person<String> p = Person<String>("345");
 p.id.runtimeType  // runtimeType возвращает конкретный тип

 void log<T>(T arg) { }  // обобщенная ф-ция

Дженерикам можно задать ограничение. В этом случае тип T станет ограничивающим типом или
наследником ограничивающего типа. Но при этом у T появятся все его члены.

 class Transaction<T extends Account> { 
   T account;  // T будет либо Account либо наследником Account
 }

В Dart можно переопределять операторы. Выполняется это с пом. следующей записи:
 возвращаемый_тип operator переопределяемый_оператор(параметр) { }

Операторы, доступные для переопределения: < + | [] > / ^ []= <= ~/ & ~ >= * << == – % >>
Пример перегрузки оператора сложения для класса Counter:

 class Counter {
   int value;
   Counter(this.value);
   
   Counter operator +(Counter other) {
     return Counter(this.value + other.value);
   }
 }

 Counter c1 = Counter(5);
 Counter c2 = Counter(10);
 Counter c3 = c1 + c2;

Перечисления определяются следующим образом:

 enum Operation { add, sub, mul }

 Operation.mul        -->  "Operation.mul"
 Operation.mul.index  -->  2

 Operation op = Operation.add;
 op.index  -->  0

Dart поддерживает расширения типов. Реализуется это так: extension on Класс { }

 extension on int {
   int get square => this * this;

   double pow(int n) {
     double res = 1;
     for (int i = 0; i < n; i++) {
       res *= this;
     }
     return res;
   }
 }
 
 int num = 2;
 num.pow(3);  -->  8.0
 num.square;  -->  4.0

------------------

КОЛЛЕКЦИИ


