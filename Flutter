СОЗДАНИЕ ПРОЕКТА

Flutter - это кроссплатформенный UI-фреймворк, написанный на языке Dart.
Процесс установки приведен в официальной документации: https://docs.flutter.dev/install

Проекты на flutter бывают 2х типов: приложения и библиотеки. Но у них схожая структура папок.
Корневыми папками в основном являются платформенные папки. Они содержат код и настройки
специфичные для каждой платформы:

 .dart_tool/
 android/
 assets/
 ios/
 lib/
 linux/
 macos/
 test/
 web/
 windows/
 .metadata
 pubspec.yaml
 pubspec.lock
 analysis_options.yaml

Папка .dart_tool создается автоматически при выполнение операций, связанных с интсрументами 
и пакетами. В ней содержатся временные файлы, кеши, артефакты и др.

Папка assets хранит ресурсы проекта (изображения, шрифты, иконки и пр.)
Папка lib - основная папка проекта, в которой находятся Dart-файлы (UI, бизнес-логика).
Папка test содержит юнит-тесты и виджет-тесты.

Файл .metadata используется средой разработки для отслеживания параметров проекта. В нем
может находиться информация о версии фреймворка, файлы для миграции на другую версию и пр.

Файл pubspec.yaml определяет конфигурацию проекта, зависимости, настройки сборки и др.

Файл pubspec.lock содержит информацию о версиях каждой установленной зависимости. Этот файл
не рекомендуется хранить в репозитории при разработке библиотек, т.к. зависимости библиотек
всегда должны быть самыми актуальными, во избежание проблем с безопасносью. Но это
накладывает на разработчика доп. обязанность - постоянно поддерживать совместимость 
своих библиотек с новыми версиями зависимостей.

Файл analysis_options.yaml определяет конфигурацию линтера.

Подробнее https://education.yandex.ru/handbook/flutter/article/flutter-struktura-proekta

Библиотеки также делятся на 2 типа: пакеты и плагины. Пакеты содержат только код, написанный
на Dart, а плагины, помимо Dart-кода, имеют еще платформо-специфичный код (нативный). Это
может быть ф-ционал для работы с ОС, доступ к аппаратной части (камера, блютуз) и др.

Официальный репозиторий пакетов для Dart и Flutter - страница pub.dev

Для управления пакетами и зависимостями используется инструмент командной строки pub, 
который входит в состав Dart SDK.

Чтобы вручную добавить зависимость, нужно в поле dependencies, файла pubspec.yaml, 
указать название нужной библиотеки. Зависимости бывают 4х типов:

 1) Зависимость из pub.dev                 2) Локальная зависимость
 
  dependencies:                             dependencies:
    dependency_name: <version>                <dependency_name>:
                                                path: <local_or_absolute_path>
 
 3) Hosted-зависимость (т.е. не из pub.dev, а с другого сайта)

  dependencies:
    <dependency_name>:
      hosted: https://some-package-server.com
      version: <version>

 4) Зависимость из github                    

  dependencies:
    <dependency_name>:                           
      git: https://github.com/<repo_url>           
                                                     
    или так                                                 
                      
    <dependency_name>
      git:
        url: https://github.com/<repo_url>
        ref: some-branch  ## номер коммита или название ветки, чтобы не тянуть из master
        path: sub-folder  ## путь к библиотеке, если она не в корне проекта

Для указаний ограничений на версии зависимостей использ. следующие операторы:

 any - любая версия зависимости;
 x.y.z - конкретная версия (x - мажор, y - минор, z - патч);
 >x.y.z - максимально возможная версия, что выше x.y.z;
 >=x.y.z - максимально возможная версия, что выше или равная x.y.z;;
 <x.y.z - максимально возможная версия, что ниже x.y.z;
 <=x.y.z - максимально возможная версия, что ниже или равная x.y.z;

 ^x.y.z - максимально возможная версия, что выше или равная x.y.z 
   но только в предалах минорных версий;

Можно также указывать диапазон версий, например >=1.12.8<=3.0.0 означает, что нужно
установить версию от 1.12.8 до 3.0.0 включительно.
 
Зависимости из поля dev_dependencies не попадают в сборку. Они нужнты только на этапе
разработки. Там указывается в основном различный инструментарий (зависимости для
тестов, линтеры и пр.) 

Установить все зависимости: flutter pub get (как npm install) 

Создать новый проект: flutter create project_name
Проект под определенные платформы: flutter create --platforms=ios,android project_name
Создать пакет:  flutter create --template=package package_name
Создать плагин: flutter create --template=plugin plugin_name 

Если проект не собирается, может помочь команда: flutter clean (очищает папку .dart_tools)
После нее нужно снова переустановить все зависимости через: flutter pub get 

После установки зависимостей они кешируются в папке .pub_cache. Но иногда кеш может слетать. 
В этом случае помогает его очистка и переустановка:

 flutter pub cache clean
 flutter pub cache repair

Иногда бывают ошибки связанные с платформо-специфичными библиотеками. Например когда
некоторые из них не установлены. В этом случае помогает их очистка и переустановка.

 pod deintegrate && pod install  // для iOS
 gradlew clean                   // для Android 

Сгенерировать документацию на основе коммпентариев из кода: dart doc

--------------

РЕСУРСЫ

Для работы с ресурсами нужно сначала зарегистрировать их в файле pubspec.yaml

 flutter:
    assets:
      - assets/folder_name/asset_name.svg  ## Добавится изображение svg

      - assets/folder_name/   ## Добавятся все ресурсы из папки assets/folder_name
      - my_folder/            ## Добавятся все ресурсы из папки my_folder

      - packages/package_name/assets/folder_name/asset_name.png 

После регистрации изображений, получить доступ к ним можно через класс AssetImage 
или метод (фабричный конструктор?) Image.asset()

 // Доступ к конкретной иконке (без учета pixel ratio)
 Image.asset('assets/icon/heart.png');  

 // Доступ к наиболее подходящей по размеру иконке (с учетом pixel ratio)
 AssetImage('icons/heart.png');  

 // Если иконка берется из импортируемого пакета, то указываем его в пар-ре package
 AssetImage('icons/heart.png', package: 'my_icons');

Flutter может загружать наиболее подходящее изображение для текущего соотношения пикселей
(pixel ratio). Соотношение пикселей - это отношение между физическим кол-во пикселей
устройства и логическим кол-вом пикселей приложения. Чем больше разрешение экрана устройства
тем больше физических пикселей помещается в одном логическом пикселе. Логический пиксель -
это абстрактная единица измерения, используемая для создания интерфейса приложения.

Если pixel ratio больше 1.0, то для каждого логического пикселя будет использоваться
несколько физических пикселей (например, при pixel ratio 2.0 - на один логический пиксель
будет использоваться 4 физических пикселя)

Чтобы ресурсы могли автоматически сопостовляться со значением pixel ratio, они должны быть
организованы следующим образом (при этом регистрировать нужно только основной ресурс 
или его родительский каталог):

 my_icon/
   my_icon.png     (mdpi)

   1.5x/
     my_icon.png   (hdpi)

   2.0x/
     my_icon.png   (xhdpi)

   3.0x/
     my_icon.png   (xxhdpi)

Если pixel ration 1.8, то будет выбран ресурс 2.0x/my_icon.png
А если pixel ration 2.7, то 3.0x/my_icon.png

Шрифты регистрируются следующим образом:

 flutter:
   fonts:
    - family: Raleway
      fonts:
        - asset: assets/fonts/Raleway-Regular.ttf
        - asset: assets/fonts/Raleway-Italic.ttf
          style: italic
    - family: RobotoMono
      fonts:
        - asset: assets/fonts/RobotoMono-Regular.ttf
        - asset: assets/fonts/RobotoMono-Bold.ttf
          weight: 700

Параметр family определяет семейство шрифтов. Один шрифт может ссылаться на несколько файлов
с разными weight и style. (как в примере выше, где для RobotoMono с weight 700 задается
файл RobotoMono-Bold.ttf, а для обычного RobotoMono - RobotoMono-Regular.ttf)

После регистрации, шрифты и их стили можно задавать через класс TextStyle.

Для работы с текстовыми ассетами (файлы .txt или .json) - используется класс AssetBundle.
С AssetBundle можно работать либо через объект rootBundle, либо через объект
DefaultAssetBundle.

 import 'package:flutter/services.dart' show rootBundle;
 await rootBundle.loadString('assets/config.json'); 

Иконка приложения задается нативным способом для каждой из платформ.
Для Android размещается в папке android/app/src/main/res/
Для iOS размещается в папке ios/Runner/Assets.xcassets/AppIcon.appiconset/

Launch Screen (стартовый экран, который видит пользователь до тех пор, пока Flutter 
не отрисует первый кадр приложения) также устанавливается нативным способом.
Для Androind задается через файл android/app/src/main/res/drawable/launch_background.xml
Для iOS нужно разместить картинки (с названиями LaunchImage.png, LaunchImage@2x.png и т.д.)
в папке ios/Runner/Assets.xcassets/LaunchImage.imageset

--------------

ВИДЖЕТЫ

Каждый графический элемент в приложении на Flutter является виджетом (иконка, текст, 
колонка и пр.) Виджет - это константный объект класса Widget. Он описывает какую-то часть UI.

При работе с виджетами используется композиция (когда один виджет вкладывается в другой).
Это означается что все виджеты можно представить в виде дерева.

Чтобы дерево виджетов могло отобразиться на экране, нужно передать его в ф-цию runApp(),
которая, в свою очередь, вызывается из ф-ции main().

Ф-ция main() не вызывается сразу после запуска приложения, а только после того, как
инициализируется движок. До этого момента, на экране будет отображаться Launch Screen.
Вызов runApp() автоматически закрывает Launch Screen. При этом runApp() необязательно
вызывать сразу. Можно сначала дождаться каких-то асинхронных операции (например получения
данных из БД или инициализации библиотеки аналитики).

Если runApp() вызвать несколько раз раз, то старое дерево будет отсоединено 
от экрана, а новое присоединено.

Существует 3 основных типа виджетов:
 * StatelessWidget - статический виджет (не имеет состояния);
 * StatefulWidget - динамический виджет (имеет состояние);
 * InheritedWidget - виджет, для передачи данных;

StatelessWidget используется для декомпозиции UI (т.е. инкапсулирет другие виджеты)

 class MyWidget extends SatelessWidget {
   const MyWidget({ Key? key }): super(key: key);

   @override
   Widget build(BuildContext ctx) {
     return Text('hello', textDirection: TextDirection.ltr);
   }
 }

Параметр конструктора key - это идентификатор виджета. Метод build() собственно и возвращает
декомпозированный UI, т.е. дерево виджетов или один виджет.

Виджеты стоит декомпозировать так, чтобы build() был сразу понятен. Длинные деревья
следует разбивать на деревья поменьше, вынося их реализацию в привытные виджеты или методы.

InheritedWidget хранит данные и делится ими с потомками, автоматически обновляя их 
(потомков) при изменении данных. Такой виджет должен также реализовывать методы of() 
и updateShouldNotify(). Первый метод позволяет потомкам удобно получать данные, 
а второй - говорит Flutter, нужно ли обновлять потомков.

 class CounterProvider extends InheritedWidget {
   final int counter;

   const CounterProvider({ 
     super.key, required super.child, 
     required this.counter 
   });

   static CounterProvider of(BuildContext ctx) {
     return ctx.dependOnInheritedWidgetOfExactType<CounterProvider>(); 
   }

   @override
   bool updateShouldNotify(CounterProvider oldWgt) {
     return oldWgt.counter != counter;
   }
 }

 class App extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     // Передаем данные потомку HomePage
     return CounterProvider(counter: 10, child: HomePage());
   }
 }

 class HomePage extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     final counter = CounterProvider.of(ctx).counter;
     return Text('Counter: $counter');
   }
 }

Метод of() не обязан сразу возвращать объект виджета. Он может иметь доп. логику 
(строить сложносоставные объекты, как это делают фабричные конструкторы).

Если метод of() используется сразу, на этапе инициализации, то его нужно обернуть 
в Builder. Иначе он получит неправильный контекст.

 class App extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     return CounterProvider(
       counter: 10, 
 
       // Так нельзя делать
       child: Text(CounterProvider.of(ctx).counter.toString())

       // Нужно использовать Builder
       child: Builder(
         builder: (_ctx) => Text(CounterProvider.of(_ctx).counter.toString())
       )
     );
   }
 }

StatefulWidget имеет состояние, которое представлено классом State. Оно создается 
с пом. метода createState(). В состояние выносятся метод build() и мутабельные данные, 
а в виджете могут оставаться иммутабельные данные. Для доступа к данным виджета, 
в State есть специальный геттер - widget.

 class MyWidget extends StatefulWidget {
   final String text;
   const MyWidget({ required this.text, super.key });

   @override
   State<MyWidget> createState() => _MyWidgetState();
 }

 class _MyWidgetState extends State<MyWidget> {
   @override
   Widget build(BuildContext ctx) {
     return Text(widget.text);
   }
 }

Мутабельные данные следует изменять в методе setState(). Он уведомляет фреймворк 
о том, что State изменился и его виджет нужно перерисовать.

 class _MyWidgetState extends State<MyWidget> {
   bool _isLightOn = false;

   @override
   Widget build(BuildContext ctx) {
     return ElevatedButton(
       child: Text(_isLightOn ? 'Выключить свет' : 'Включить свет'),
       onPress: () {
         setState(() => _isLightOn = !_isLightOn);
       }    
     ),
   }
 }

У State есть также геттер - mounted, который позволяет проверить, прикреплен ли виджет к
дереву (поскольку его может и не быть там, если произойдет, к примеру, переход на предыдущий
экран). Используется в основном в асинхронном коде перед вызовом setState().

Дерево виджетов - это абстракция, на основе которой Flutter строит дерево элементов
и работает уже с ним. Элементы отвечают за жизненный цикл UI и его обновление.

При создании виджета, Flutter вызывает у него метод createElement(). Полученный элемент
помещается в дерево эл-тов, а также в метод build() виджета. В самом методе он экранируется
интерфейсом BuildContext, который предоставляет лишь часть членов Element.

На основе дерева эл-тов создается также дерево RenderObject, которое отвечает 
непосредсвенно за позиционирование и отрисовку эл-тов UI.

Когда обновляется состояние, виджеты пересоздаются заново и Flutter сопоставляет их с уже
имеющимся деревом эл-тов и далее добавляет/удаляет/обновляет элементы при надобности.
При этом пересоздаются только легковесные объекты Widget, а тяжелые Element и RenderObject
переиспользуются, если это возможно.

Жизненный цикл виджетов:

 У StatelessWidget есть только конструктор и метод build().

 У StatefulWidget есть конструктор и метод createState(), который вызывается когда виджет
 встраивается в дерево, чтобы создать State. Может вызываться несколько раз, если 
 используется один и тот же экземпляр виджета в разных места или когда виджет 
 отсоединяется и присоединяется повторно.

 State имеет такие методы:

  initState() - вызывается один раз, после того, как State привязывается к Element;
    используется для инициализации контроллеров либо полей, которые зависят 
    от данных из widget или context (несмотря на то, что context уже доступен, 
    использовать метод inheritedWidget.of() здесь нельзя);

  didChangeDependencies() - вызывается после initState(), а также при изменении 
    зависимого InheritedWidget; здесь можно использовать inheritedWidget.of();

  build() - вызывается после setState() и didChangeDependencies(), а также при hot reload;
    здесь нельзя вызывать setState(), но если это все же нужно сделать, то следует
    использовать обертку addPostFrameCallback;

  didUpdateWidget() - вызывается всякий раз, когда изменяется экземляр виджета, 
    что привязан к State, независимо от того, меняются ли в нем какие-то параметры;
    здесь можно выполнять аниманию и другую работу, зависящую от конфигурации виджета;
 
  dispose() - вызывается, когда виджет убирается из дерева, после всех других методов
    жизненнго цикла; используется для освобождения ресурсов, отмены подписок и т.п.

React Native использует платформенные реализации для отображения UI (например текст будет
отображаться либо через нативный виджет TextView, при разуске приложения на Android, 
либо через UITextView, при запуске на iOS). 

Flutter работает по другому. Для отрисовки UI он использует графический движок. (Skia или 
уже другой). Благодаря этому, Flutter можно адаптировать под любую ОС. Это также дает
уверенность, что UI будет выглядеть одинаково на всеъ платформах.

Во Flutter есть три библиотеки, предоставляющие готовые виджеты:
 1) Widgets library - общие виджеты, не привязанные к конкретной платформе.
 2) Material library - виджеты стилизованые Material Design.
 3) Cupertino library - виджеты, стилизованные под Apple.

У большинства Material-виджетов есть аналоги из Cupertino.
Виджеты можно разделить на 4 группы:

 1) Фундамент - задают структуру приложения.

   WidgetsApp - базовый виджет, который задает основу приложения: управление навигацией, 
     темизация, локализация и др. От него наследуются MaterialApp и CupertinoApp.

   MaterialApp - адаптирует внешний вид приложения в зависимости от того, на какой ОС 
     оно запущено (например поведение скролла и анимация переключения страниц будут
     отличаться на Android и iOS). В параметре home указывается виджет 
     главной страницы (обычно это Scaffold).

   CupertinoApp - повторяет поведение нативных iOS приложений, независимо от того, 
     на какой платформе запускается приложение.

   Scaffold - определяет страницу (экран) приложения. В параметре body указывается виджет
     содержимого страницы. Он также позволяет задать экрану различные панели, 
     (например AppBar, BottomAppBar), позволяет взаимодействовать со снекбаром и др.

 2) Содержимое - определяют, как выглядят изображения, текст и др.

   Text - отображает текст с определенным стилем. Некоторые параметры виджета:
     textAlign - задает выравнивание текста;
     overflow - задает поведение, если размер текст больше размеров виджета;
     maxLines - максимальное кол-во строк, которое может вместить виджет;
     style - объект, задающий стиль текста;

   RichText - отображает форматированный текст (с его помощью можно 
     имитировать ссылки и др.)

   Icon - отображает векторые иконки, которым можно задать цвет, размер и др.
     В классах Icons (от Material) и CupertinoIcons содержится большой набор иконок, 
     но чтобы использовать эти классы, нужно их подключить через pubspec.yaml
     https://education.yandex.ru/handbook/flutter/article/vidzheti-standartnie-biblioteki

     Чтобы добавить свои иконки, нужно преобразовать набор картинок в шрифт и подключить
     шрифт в качестве ассета (для преобразования иконок в шрифт поможет сайт FlutterIcon)

   Image - отображает картинки в форматах JPEG, PNG, GIF и др. Параметр image задает
     изображение. Для удобства есть несколько конструкторов: Image.asset() и Image.network()
     первый задает изображение из ассетов, а второй - из интернета.

     Параметр fit задает положение изображения внутри виджета (будет ли оно растянуто 
     или сохранит пропорции и т.д.)

   GestureDetector - обрабатывает жесты, свайпы и другие события. Делает дочерний виджет
     кликабельными. Чтобы увеличить зону кликабельности можно обернуть дочерний виджет 
     в Padding. Но GestureDetector по умолчанию игнорирует прозрачные области эл-тов, 
     поэтому придется доп. использ. параметр behavior со значен. HitTestBehavior.opaque

   InkWell - аналог GestureDetector с анимацией в стиле Material Design (наз. Ripple).
     Но чтобы работала анимация, InkWell должен быть обернут в виджет Material.
     Используется для обработки простых жестов. (тапы, двойные тапы и др.)

   SnackBar - виджет сообщение, которое отображается поверх остального UI. 
     Для отображения сообщения используется метод showSnackBar(), внутри которого 
     и определяется объект снекбара.

 3) Расположение - отвечают за позиционирование.

   Column и Row - располагают дочерние виджеты друг за другом векртикально 
     и горизонтально соответственно. Основные параметры виджета:

     mainAxisAlignment - выравнивает дочерние эл-ты вдоль основной оси. 
       Например значение MainAxisAlignment.start располагает эл-ты в начале колонки. 
       а MainAxisAlignment.spaceBetween распределяет свободное пространство между эл-тами.

     mainAxisSize - расстояние, которое виджет займет по основной оси. Например значение
       MainAxisSize.min означает, что колонка займет минимально возможно расстояние, 
       а MainAxisSize.max заставит колонку занять все доступное место.

     crossAxisAlignment - задает то, сколько места займут дочерние виджеты по второстепенной
       оси (для Column это горизонтальная ось). Значение CrossAxisAlignment.end позволит
       прижать виджеты к правой части колонки, а CrossAxisAlignment.stretch заставит их
       растянуться по всей ширине колонки.

   SingleChildScrollView - простой скроллящийся контейнер, в который можно положить 
     дочерний виджет с размерами, превышающими допустимую область отрисоки, 
     и появится скролл. Основные параметры виджета:
   
     scrollDirection - направление прокрутки (Axis.vertical / Axis.horizontal);
     reverse - прямое или обратное направление прокрутки;
     padding - оступы внутри списка (т.е. внутри прокручиваемой области);
     physics - задает физику скролла (например как на iOS), либо выключает ее вообще;
     clipBehavior - задает то, как будет обрезаться содержимое, за границами виджета.

   ListView - виджет для отображения прокручиваемых списков. Он лучше оптимизирован для
     работы с большим кол-вом эл-тов, чем SingleChildScrollView, поскольку отрисовывает
     только видимые элементы. У этого виджета есть удобный конструктор ListView.separated 
     при помощи которого можно автоматически проставлять отступы между эл-тами. 

     Параметр shrkinkWrap со значением false заставит ListView занимать все доступное
     пространство по основной оси, а со значением true - занимать столько место, 
     сколько занимает внутреннее содержимое.

   SizedBox - виджет, задающий размеры для дочернего виджета;

   Padding - виджет, задающий отступы вокруг дочернего виджета. 
     Оступы задаются с пом. объекта EdgeInsets. 

   SafeArea - задает отступы по краям экрана (чтобы UI не налазил на системные элементы). 
     По умолчанию добавляет со всех сторон, но это можно переопределить пар-рами: 
     top, bottom, left, right.

 4) Декорация - добавляют визуальные эффекты.

   Container - позволяет добавить дочернему виджету: фон, тень, высоту, выравнивание,
     трансформацию, padding, margin, border и пр. Под капотом он составляет композицию из
     различных виджетов (например для оступов использует виджет Padding).

   Card - это разновидность контейнера, со стилем в виде карточки из Material Design.
     Карточки хорошо подходят если UI приложения вписывается в Material или если создается
     приложение без конкретного дизайна и нужны максимально готовые компоненты.
     Подробнее: https://m3.material.io/components/cards/overview

Чтобы задать любому виджету потомка, используется параметр child. Если нужно задать 
список потомков, то нужно использовать параметр children.

Flutter позволяет делать очень многое из коробки. Поэтому прежде чем делать свой виджет,
нужно поискать сначала наиболее подходящий среди готовых https://docs.flutter.dev/ui/widgets

Ключи виджетов используется при построении дерева виджетов, чтобы фреймворк мог 
отличать друг от друга виджеты с одинаковым типом.

Когда у родительского виджета есть несколько дочерних Stateful-виджетов с одинаковым типом,
то этим виджетам нужно задавать ключ (иначе при перемещении этих виджетов или удалении 
одного из них, Flutter не сможет определить какие именно виджеты были затронуты).

 class ColorBlock extends StatefulWidget {
   final Color color;
   const ColorBlock({ required this.color, Key? key }): super(key: key);

   @override
   State<ColorBlock> createState() => _ColorBlockState();
 }

 class _ColorBlockState extends State<ColorBlock> {
   @override
   Widget build(BuildContext ctx) {
     return Container(color: widget.color, width: 100.0, height: 100.0);
   }
 }

 class MyWidget extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     return Column(

       // Здесь фактически используется ValueKey 
       // Вместо ColorBlock может быть список из Padding и др.
       
       children: [
         ColorBlock(
           key: Key(Random().nextInt().toString())
           color: Colors.primaries(1)
         ),
         ColorBlock(
           key: Key(Random().nextInt().toString())
           color: Colors.primaries(2)
         ),
         ColorBlock(
           key: Key(Random().nextInt().toString())
           color: Colors.primaries(3)
         ),
       ]
     ) 
   }
 }

Ключи имеют две иерархии: LocalKey и GlobalKey. Базовым классом является Key.

Особенность локальных ключей в том, что они должны быть уникальны для всех виджетов 
с одним родителем. Типы локальных ключей:

 ValueKey<T> - уникальность ключа определяется по значению объекта T. Это значит, 
   что для работы ключа нужно переопределять метод hashCode и оператор ==

 ObjectKey - уникальность ключа определяется по ссылке на объект;
 UniqueKey - уникальный ключ, который равен только самому себе;

Особеннось глобальных ключей в том, что они должны быть уникальны 
для всего приложения. Типы глобальных ключей:

 LabeledGlobalKey - глобальный аналог UniqueKey;
 GlobalObjectKey - глобальный аналог ObjectKey;

Глобальные ключи использоваться для доступа к Stateful-виджету (а точнее к его State) 
из любой точки приложения (т.е. он выступает в роли ссылки) или когда виджету 
нужно поменять родителя.

 class MyWidgetState extends State<MyWidget> {
   final _columnKey = GlobalKey();
 
   @override
   Widget build(BuildContext ctx) {
     return OrientationBuilder(builder: (_ctx, orientation) {
       return Scaffold(
         
         // Без использования _columnKey, при повороте экрана 
         // заново пересоздавалось бы все поддерево body

         body: orientation == Orientation.portrait 
           ? Column(
         	   key: _columnKey,
               children: _colorBlocks,
             ),
           : Padding(
               padding: const EdgeInsets.all(8.0),
               child: Column(
         	     key: _columnKey,
                 children: _colorBlocks,
               )
             ),
       );
     });
   }
 }

 // Получить доступ к API Stateful-виджета можно так: 
 _myGlobalKey.currentState?.someMethod();
 
Расчет лейаута (верстки) во Flutter выполняется не так, как в HTML/CSS или нативной моб.
разработке. Он совершается в два прохода. При первом проходе, от родителей к детям (вниз 
по дереву) передаются констрейнты (ограничения размеров). А при втором проходе, от детей 
к родителям (вверх по дереву) возвращаются размеры и родители позиционируют детей.

Отсюда исходит главное правило лейаута - если какой-то из виджетов имеет неправильный размер,
то первым делом стоит смотреть не на параметры виджета, а на параметры его родителя и на
констрейты, которые он передает.

Размер виджета представлен классом Size, который содержит два поля: width и height.

Констрейнты представлены классом BoxConstraints, который содержит поля: minWidth, maxWidth,
minHeight, maxHeight. Констрейнты бывают loose (задают виджету гибкие размеры, от 0 до 
какого-то значения) и tight (задают фиксированные размеры). Констрейнты могут быть разными 
по высоте и ширине (например по высоте быть loose, а по ширине - tight).

Также констрейнты могут быть unbounded (максимальная и/или минимальная высота/ширина равны
бесконечности) и bounded (максимальная и/или минимальная высота/ширина не равны бесконечности)
Большинство ошибок в верстке возникают именно при работе с unbound-констрейнтами.

Для реализации адаптивного лейаута следует использовать виджет LayoutBuilder, который
вызывает пользовательский колбек при каждом изменении констрейнтов. Это дает возможность 
по разному компоновать виджеты, зависимости от полученных значений.

Для работы с portrain и landscape ориентациями следует использовать виджет
OrientationBuilder, который построен на базе LayoutBuilder. 

Основные лейаут-виджеты (третья группа):

 Align - позиционирует дочерний виджет относительно себя. Основные параметры:
   width/heightFactor - задает размер Align пропорционально размеру дочернего виджета;
   alignment - задает позиционирование;

   Если имеет bounded-констрейнты, то он занимает максимально доступное место.

 Center - обертка над Align. Позиционирует дочерний виджет всегда по центру.

 ConstrainedBox - переопределяет констрейнты от родительского виджета. Констрейнты можно
   только сузить (т.е. нельзя выходить за пределы того, что уже задано)

 UnconstainedBox - убирает текущие констрейнты для виджета и позволяет ему быть любого
   размера (т.е. принимать нужные размеры без учета констрейнтов от родителя). Параметр -
   constrainedAxis задает конкретную ось, по которой будут игнорироваться констрейнты.

 OverflowBox - работает также, как и UnconstainedBox, но не вызывает ошибку если 
   дочерний виджет не умещается в пределы экрана.

 FittedBox - ограничивает большие размеры размерами экрана. Часто используется с негибкими
   виджетами, размер которых неизвестен заранее (например с картинками). А также, когда
   дочерний виджет больше или меньше границ, в которых требуется расположить его.
 
 Flex - виджет, который может работать и как Column, и как Row 
   (Column и Row являются обертками над Flex)

 LimitedBox - ограничивает размер дочернего виджета, если текущие констрейнты являются
   unbounded (как Expanded, но в unbdounded-констрейнтах; см. далее).

 Stack - позволяет своим потомкам накладываться друг на друга в пределах своих границ 
   (как при абсолютном позиционировании). Констрейнты задаются пар-ром fit. Его значения:

   StackFit.loose - всем виджетам задаются loose-констрейнты с максимальной шириной 
     и высотой равной размерам самого Stack.

   StackFit.expand - неспозиционированные виджеты (те, что не обернуты в Positioned)
     получают tight-констрейнты, равные максимально возможным, а спозиционированные - loose.

   StackFit.passthrough - неспозиционнированные дети получают констрейнты, которые Stack
     получил от родителя, спозиционнированые получают loose-констрейнты (часто используется,
     когда Stack находится в Row/Column)

   Внутри Stack использ. спец. виджет - Positioned, который и задает позиционирование
   потомкам. Он имеет такие параметры: left, top, right, bottom, width и height. При этом
   нельзя одновременно задать top, right и width (как в html) тоже самое касается и высоты.

Виджет Row получает unbounded-констрейнты по ширине, поэтому его потомки могут вылазить за
пределы экрана. Чтобы разделить доступную ширину среди потомков, можно использовать
виджеты: Flexible, Expanded и Spacer.

Обернув потомка во Flexible, ему можно будет задать вес с пом. пар-ра flex. Expanded
наследуется от Flexible и всегда имеет FlexFit.tight (обернув виджет в Expanded он займет
оставшееся пространство экрана). Spacer - это Expanded у которого нет child. Он служит как
заполитель для пустого места.

Виджеты IntrinsicWidth и IntrinsicHeight предотвращают растягивание эл-тов и задают им
фиксированую высоту или ширину. Например с пом. IntrinsicWidth можно сделать так, чтобы все
элементы колонки имели одинаковую ширину, равную ширине самого длинного элемента. Но их не
стоит использовать часто, поскольку они ухудшают производительность.

Виджеты со скроллом и списки (SingleChildScrollView, ListView) нельзя размещать 
в родителях с unbounded-констрейнтами.

Основные виджеты ввода (вторая группа):

 TextField - текстовое поле. Параметр decoration позволяет задать label, icon, hint и др.
   Для отслеживания введенного текста можно использовать колбек onChanged() или
   TextEditingController (задается через параметр controller).

 TextFormField - обертка для TextField, которая используется только с виджетом Form. 
   Дает удобную возможность для валидации ввода с пом. колбека validator.

 Form - контейнер с TextFormField. Для удобного обращения нужно использ. c GlobalKey.
   Чтобы выполнить валидацию полей, нужно вызвать метод формы - validate().
   Пользовательские формы часто создаются как Stateful-виджеты.

Для валидации ввода можно также использовать форматтеры. Например, если требуется чтобы 
текст был определенной длины, можно использовать форматер LengthLimitingTextInputFormatter.
Форматтер FilteringTextInputFormatter позволяет валидировать текст на основе рег. выр-я.
Задать форматтер текстовому полю можно через параметр inputFormatters.

Чтобы текстовое поле при отображении получало фокус, нужно задать ему параметр autofocus.
Чтобы вручную управлять фокусом поля, нужно использовать объект FocusNode.

Виджеты ввода часто помещают в ListView или SingleChildScrollView, чтобы с пом. прокрутки
иметь доступ ко всем элементам, когда клавиатура перекроет собой часть экрана.

Виджеты кнопок (вторая группа):

 ElevatedButton - объемная кнопка (стилизована так, как будто парит в воздухе);
 IconButton - кнопка с иконкой (по типу бургера или стрелки);
 OutlineButton - кнопка без фона, но с рамкой;
 TextButton - самая обычная кнопка;

 FloatingActionButton - кнопка главного действия на экране 
   (обычно ее кладут в Scaffold);

 Radio - радиокнопка. Для создания нужно передать след. пар-ры:
   value - значение радиокнопки;
   groupValue - активное значение (по нему определяется выбранная кнопка); 
   onChange - колбек, в котором получают актуальное value;

 Checkbox - чекбокс, который по умолчанию может находится в 2х состояниях. Но можно также
   добавить промежуточное состояние с пом. пар-ра tristate со значением true.
 
--------------

РАБОТА С СЕТЬЮ

Протокол HTTP был изначально задуман для передачи HTML-документов (поэтому он имеет схожую 
с HTML структуру формирования данных - headers, body и пр.) Но позже получил широкое
применение для обмена произвольными данными (текста, картинок, видео и др.)

Класс HttpClient не подходит для разработки веб-приложений, поскольку библиотека dart:io
работает только на мобильных и десктопных платформах. При разработке под веб нужно
использовать класс HttpRequest из библиотеки dart:html

Библиотека http упрощает работу c HttpClient и HttpRequest, предоставляя более
высокоуровневый API. Она также является кроссплатформенной (можно использовать для веб)

 Файл pubspec.yaml

  dependencies:                ## после добавление зависимости нужно выполнить 
    http: <latest_version>     ## установку командой flutter pub get

 Произвольный dart-файл

  import 'package:http/http.dart' as http;
  
  Future<String?> getUserData(String userID) async {
    final userDataUrl = Uri.parse('https://mysite.ru/user/data/$userID');
    final userDataRes = await http.get(userDataUrl);
    if (userDataRes.statusCode != 200) {
      print('Failed to retrieve user data');
      return null;
    }
    return userDataRes.body;
  }

Для ручного преобразования данных в JSON используется библиотека dart:convert
Ручное преобразование данных хорошо подходит для маленьких проектов, где используется
небольшое кол-во сущностей.

Для автоматического преобразования - библиотека json_serializable и вспомогательная
build_runner. Процесс преобразования выполняется командой flutter pub run build_runner build
Преобразование происходит за счет добавления в классы сущностей, специальных аннотаций
(@JsonSerializable и др.) после чего будет сгенерированы файлы моделей *.g.dart
См. https://education.yandex.ru/handbook/flutter/article/osnovi-raboti-s-setiu-i-dannimi

Для работы с веб-сокетами также используется dart:io/dart:html либо web_socket_channel.
Вторая является кроссплатформенной оберткой.

--------------

ХРАНЕНИЕ ДАННЫХ

Пакет path_provider предоставляет кроссплатформенный доступ к местам, где хранятся данные
приложения. Одним из таких мест является документы приложения. В этих документах находятся
файлы, доступ к которым есть только у самого приложения. При удалении приложения этот каталог
очищается файловой системой. В iOS - это NSDocumentDirector, а в Android - AppData.

 // Доступ можно получить с пом. метода getApplicationDocumentsDirectory()

 Future<String> getPath() async {
   final dir = await getApplicationDocumentsDirectory();
   return dir.path;
 }

 // Запись данных пользователя

 final path = await getPath();
 final file = File('$path/user_data.txt');
 file.writeAsString(jsonEncode(myUser));

Альтернативным вариантом является хранение данных в нативном хранилище. Оно позволяет хранить
пары "ключ-значение". Для доступа к хранилищу используется пакет shared_preferences, который
оборачивает нативное хранилище (NSUserDefaults в iOS/macOS, и SharedPreferences в Android).

Хранилище является простым и удобным, но имеет ряд ограничений. Оно позволяет хранить только
типы данных: int, double, bool, String и List<String>. Оно не предназначено для хранения
большого кол-ва данных. Оно больше подходит для данных, которые часто читаются, но редко
обновляются. В нем также небезопасно хранить конфиденциальные данные. Для них стоит
использовать плагин flutter_secure_storage или шифровать перед сохранением с пом. 
encrypt/flutter_string_encrypt

 final prefs = await SharedPreferences.getInstance();
 
 // Для записи используется set-методы. Они синхронно обновляют 
 // данные в памяти и сохраняют их на диск.  

 await prefs.setInt('userId', userId);
 await prefs.setBool('userValud', userValid);
 await prefs.setStringList('userRoles', userRoles);

 // Для чтения данных используются get-методы

 final String? userName = prefs.getString('userName');
 final List<String>? userRoles = prefs.getStringList('userRoles');

 // Удаление данных

 await prefs.remove('counter');

--------------

ОТЛАДКА

Логи, выводимые с пом. print(), также происходят и в релизных сборках. Это может быть
небезопасно, поскольку в них может оказаться чувствительная информация.

Во Flutter есть специальная ф-ция - log() из библиотеки dart:developer
Она позволяет логировать сообщения по уровням. Уровни логирования бывают такими:

 verbose (200) - малозначительная техническая информация, требующая глубокого 
   погружения, чтобы понимать то, что происходит;

 debug (300) - уровень технических логов, часто используется по умолчанию;

 info (400) - информационные сообщения о наступлении каких-то событий, 
   в рамках ожидаемого поведения;

 warning (500) - уровень предупреждений, когда что-то пошло не так; 
   однако все еще не портит UX (пользовательский опыт);

 error (1000) - сигнализирует об ошибке, которая сломала сценарий взаимодействия 
   пользователя с программой;

 critical/fatal (2000) - критическая ошибка, портящая UX (например крэш);

 // Параметр name нужен для фильтрации нужных логов, 
 // среди большого кол-ва информации в потоке сообщений
 log('hello world', name: 'MyApp', level: 400);

Ф-ция debugPrint() - это обертка над print(), которая позволяет обойти специфичную 
для Android проблему, обрезания системой слишком длинных логов.

Для логирования есть также несколько библиотек: logger (самая популярная) и logging.
Logger позволяет более удобно выводить информацию, чем стандартный log (в отформатированном
виде со стек-трейсом и прочим; возможно можно настроить, чтобы логи сохранялись в файл).

Для ошибок, которые возникают на уровне Flutter, можно использ. глобальный обработчик:

 void main() {
   FlutterError.onError = (details) {
     FlutterError.presentError(details);  
     // Здесь доп. действия
   };
  
   runApp(const MyApp());
 }

Ошибки построения виджетов в debug-режиме вызывают показ красного экрана с логом, 
но в release-режиме они просто закрашивают сломавшийся виджет в серый цвет. Показ более
осмысленных экранов, сообщающих об ошибках, можно реализовать через параметр builder, 
виджета MaterialApp.

 @override
 Widget build(BuildContet ctx) {
   Widget error = const Text('Произошла ошибка');
   if (widget is Scaffold || widget is Navigator) {
     error = Scaffold(body: error);
   }
   ErrorWidget.builder = (details) => error;
   return widget!;
 }

Чтобы глобально перехватывать все ошибки (что возникают и на уровне Flutter, и на уровне
Dart, т.е. через throw) можно использовать PlatformDispatcher. 

 Future<void> main() async {
   WidgetsFlutterBinding.ensureInitialized();
   WidgetsBinding.instance.platformDispatcher.onError = ((e), st) {
     // Такие ошибки можно отправлять в аналитику 
     // или на собственный бекенд при необходимости
     print('FE: ${e.toString()}');
     return true;  // true возвращают при успешной обработке, иначе false
   }
 }

--------------

ТЕМИЗАЦИЯ

Чтобы задать тему нужно установить параметр theme, в виджете MaterialApp. Этот параметр
принимает объект ThemeData, который уже содержит какие-то стили.

 MaterialApp(theme: ThemeData())

Для установки собственных стилей можно применять разные подходы:

Если пользовательский виджет имеет всего немного стилей, то их можно передавать напрямую,
через конструктор. Если виджет имеет много стилей, то их можно выносить в отдельный класс.
Например для виджета Clock, стили могут определяться в классе ClockStyle. 

Если один и тот же класс стилей применяется несколько раз, в разных виджетах, то его можно
передавать через пользовательский Theme-виджет (в этом случае класс может заканчиваться 
не на *Style, а на ThemeData, чтобы в именовании соответствовать стандартному ThemeData).

 class ClockTheme extends InheritedWidget {
   final ClockThemeData data;
   
   // maybeof() отличается от of() тем, что возвращает nullable-тип

   static ClockThemeData? maybeOf(BuildContext ctx) {
     final theme = ctx.dependOnInheritedWidgetOfExactType<ClockTheme>();
     return theme?.data;
   }
   ...
 }

 class ClockThemeData {
   final Color shadowColor;
   final Color borderColor;
   final double hourHandWidth;
   ...
 }

 class Clock extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     final theme = ClockTheme.maymeof(ctx) ?? ClockThemeData.myDefaultData;
     final borderColor = theme.borderColor;
     ...
   }
 }

Вместо того, чтобы передавать стили через пользовательский Theme-виджет, стилевой класс 
можно сделать наследником от ThemeExtension и задавать в параметре extensions, 
стандартного ThemeData.

 MaterialApp(
   theme: ThemeData(
     extensions: [ClockThemeData()]
   )
 )

 class ClockThemeData extends ThemeExtension<ClockThemeData> {
   final Color shadowColor;
   final Color borderColor;
   final double hourHandWidth;
   ...

   // Метод lerp() используется для плавного переключения стилей

   @override
   ThemeExtension<ClockThemeData> lerp(ThemeExtension<ClockThemeData>? other, double t) {
     return ClockThemeData(
       borderColor: Color.lerp(borderColor, other?.borderColor),
       ...
     );
   }
 }

--------------

НАВИГАЦИЯ
 
Во Flutter есть несколько механизмов для навигации. Самый простой и распространенный
называется Navigation 1.0. Он реализуется с пом. класса Navigator.

Переход на новый экран выполняется с пом. метода push().

 Navigator.push(
   context, 
   MaterialPageRoute(builder: (BuilderContext ctx) => MyPage())
 )

Возврат к предыдущему экрану происходит с пом. метода pop().

 // Если вызвать на главном экране, то экран станет черным, т.к. в приложении 
 // больше не будет открытых экранов (стек навигации станет пустым)

 Navigator.pop(context);

Другие методы Navigator:
 pushNamed() - переходит на указанный экран из таблица маршрутизации;
 pushReplacement() - заменяет текущий экран указанным (в стеке навигации);
 pupUntil() - возвращается на указанный экран;

Чтобы создать маршрутные экраны, нужно в MaterialApp установить параметр routes. 
Ему задается так называемая таблица маршрутизации.

 MaterialApp(
   initialRoute: '/A',  // определяет начальный экран
   routes: {
     '/A': (ctx) => PageA(), 
     '/B': (ctx) => PageB(), 
     '/C': (ctx) => PageC(), 
   },
 )

 // Теперь навигация можно выполнять так.
 // Большинство разработчиков используют именно такую 
 // навигацию (через таблицу маршрутизации)

 Navigator.pushNamed(context, '/B');

При навигации через push(), данные можно передавать прямо в виджет экрана.
При навигации через pushNamed(), данные передаются через параметр arguments.

 Navigator.pushNamed(context, '/B', arguments: 'hello');
 
Получить данные можно только на открывшемся экране:

 final data = ModalRoute.of(context)?.settings.arguments;

Передать данные можно и при возврате:

 Navigator.pop(context, 'world');

Но чтобы получить эти данные, экран, откуда возвращаются данные, должен быть открыт
асинхронно, а его возвращаемое значение - записываться в переменную. И как только 
он закроется, данные станут доступны:

 // При обычном вызове pop(), без данных, он возвращает null. 
 // Поэтому нужно возвращаемое значение должно быть nullable-типа

 final returnedData = await Navigator.pushNamed<String?>(context, '/B');

--------------

ИНТЕРНАЦИОНАЛИЗАЦИЯ

Это адаптация приложения под различные языки и культурные особенности. Интернационализация
(сокращенно i18n, т.е. i и следующие 18 букв) включает в себя локализацию, корретное
отображение дат, времени и др.

Чтобы реализовать локализацию, используется пакет flutter_localizations. 

Настройка flutter_localizations и генерации переводов...

https://education.yandex.ru/handbook/flutter/article/project-internatsionalizatsiia-i-lokalizatsiia

