СОЗДАНИЕ ПРОЕКТА

Flutter - это кроссплатформенный UI-фреймворк, написанный на языке Dart.
Процесс установки приведен в официальной документации: https://docs.flutter.dev/install

Проекты на flutter бывают 2х типов: приложения и библиотеки. Но у них схожая структура папок.
Корневыми папками в основном являются платформенные папки. Они содержат код и настройки
специфичные для каждой платформы:

 .dart_tool/
 android/
 assets/
 ios/
 lib/
 linux/
 macos/
 test/
 web/
 windows/
 .metadata
 pubspec.yaml
 pubspec.lock
 analysis_options.yaml

Папка .dart_tool создается автоматически при выполнение операций, связанных с интсрументами 
и пакетами. В ней содержатся временные файлы, кеши, артефакты и др.

Папка assets хранит ресурсы проекта (изображения, шрифты, иконки и пр.)
Папка lib - основная папка проекта, в которой находятся Dart-файлы (UI, бизнес-логика).
Папка test содержит юнит-тесты и виджет-тесты.

Файл .metadata используется средой разработки для отслеживания параметров проекта. В нем
может находиться информация о версии фреймворка, файлы для миграции на другую версию и пр.

Файл pubspec.yaml определяет конфигурацию проекта, зависимости, настройки сборки и др.

Файл pubspec.lock содержит информацию о версиях каждой установленной зависимости. Этот файл
не рекомендуется хранить в репозитории при разработке библиотек, т.к. зависимости библиотек
всегда должны быть самыми актуальными, во избежание проблем с безопасносью. Но это
накладывает на разработчика доп. обязанность - постоянно поддерживать совместимость 
своих библиотек с новыми версиями зависимостей.

Файл analysis_options.yaml определяет конфигурацию линтера.

Подробнее https://education.yandex.ru/handbook/flutter/article/flutter-struktura-proekta

Библиотеки также делятся на 2 типа: пакеты и плагины. Пакеты содержат только код, написанный
на Dart, а плагины, помимо Dart-кода, имеют еще платформо-специфичный код (нативный). Это
может быть ф-ционал для работы с ОС, доступ к аппаратной части (камера, блютуз) и др.

Официальный репозиторий пакетов для Dart и Flutter - страница pub.dev

Для управления пакетами и зависимостями используется инструмент командной строки pub, 
который входит в состав Dart SDK.

Чтобы вручную добавить зависимость, нужно в поле dependencies, файла pubspec.yaml, 
указать название нужной библиотеки. Зависимости бывают 4х типов:

 1) Зависимость из pub.dev                 2) Локальная зависимость
 
  dependencies:                             dependencies:
    dependency_name: <version>                <dependency_name>:
                                                path: <local_or_absolute_path>
 
 3) Hosted-зависимость (т.е. не из pub.dev, а с другого сайта)

  dependencies:
    <dependency_name>:
      hosted: https://some-package-server.com
      version: <version>

 4) Зависимость из github                    

  dependencies:
    <dependency_name>:                           
      git: https://github.com/<repo_url>           
                                                     
    или так                                                 
                      
    <dependency_name>
      git:
        url: https://github.com/<repo_url>
        ref: some-branch  ## номер коммита или название ветки, чтобы не тянуть из master
        path: sub-folder  ## путь к библиотеке, если она не в корне проекта

Для указаний ограничений на версии зависимостей использ. следующие операторы:

 any - любая версия зависимости;
 x.y.z - конкретная версия (x - мажор, y - минор, z - патч);
 >x.y.z - максимально возможная версия, что выше x.y.z;
 >=x.y.z - максимально возможная версия, что выше или равная x.y.z;;
 <x.y.z - максимально возможная версия, что ниже x.y.z;
 <=x.y.z - максимально возможная версия, что ниже или равная x.y.z;

 ^x.y.z - максимально возможная версия, что выше или равная x.y.z 
   но только в предалах минорных версий;

Можно также указывать диапазон версий, например >=1.12.8<=3.0.0 означает, что нужно
установить версию от 1.12.8 до 3.0.0 включительно.
 
Зависимости из поля dev_dependencies не попадают в сборку. Они нужнты только на этапе
разработки. Там указывается в основном различный инструментарий (зависимости для
тестов, линтеры и пр.) 

Установить все зависимости: flutter pub get (как npm install) 

Создать новый проект: flutter create project_name
Проект под определенные платформы: flutter create --platforms=ios,android project_name
Создать пакет:  flutter create --template=package package_name
Создать плагин: flutter create --template=plugin plugin_name 

Если проект не собирается, может помочь команда: flutter clean (очищает папку .dart_tools)
После нее нужно снова переустановить все зависимости через: flutter pub get 

После установки зависимостей они кешируются в папке .pub_cache. Но иногда кеш может слетать. 
В этом случае помогает его очистка и переустановка:

 flutter pub cache clean
 flutter pub cache repair

Иногда бывают ошибки связанные с платформо-специфичными библиотеками. Например когда
некоторые из них не установлены. В этом случае помогает их очистка и переустановка.

 pod deintegrate && pod install  // для iOS
 gradlew clean                   // для Android 

Сгенерировать документацию на основе коммпентариев из кода: dart doc

--------------

РЕСУРСЫ

Для работы с ресурсами нужно сначала зарегистрировать их в файле pubspec.yaml

 flutter:
    assets:
      - assets/folder_name/asset_name.svg  ## Добавится изображение svg

      - assets/folder_name/   ## Добавятся все ресурсы из папки assets/folder_name
      - my_folder/            ## Добавятся все ресурсы из папки my_folder

      - packages/package_name/assets/folder_name/asset_name.png 

После регистрации изображений, получить доступ к ним можно через класс AssetImage 
или метод (фабричный конструктор?) Image.asset()

 // Доступ к конкретной иконке (без учета pixel ratio)
 Image.asset('assets/icon/heart.png');  

 // Доступ к наиболее подходящей по размеру иконке (с учетом pixel ratio)
 AssetImage('icons/heart.png');  

 // Если иконка берется из импортируемого пакета, то указываем его в пар-ре package
 AssetImage('icons/heart.png', package: 'my_icons');

Flutter может загружать наиболее подходящее изображение для текущего соотношения пикселей
(pixel ratio). Соотношение пикселей - это отношение между физическим кол-во пикселей
устройства и логическим кол-вом пикселей приложения. Чем больше разрешение экрана устройства
тем больше физических пикселей помещается в одном логическом пикселе. Логический пиксель -
это абстрактная единица измерения, используемая для создания интерфейса приложения.

Если pixel ratio больше 1.0, то для каждого логического пикселя будет использоваться
несколько физических пикселей (например, при pixel ratio 2.0 - на один логический пиксель
будет использоваться 4 физических пикселя)

Чтобы ресурсы могли автоматически сопостовляться со значением pixel ratio, они должны быть
организованы следующим образом (при этом регистрировать нужно только основной ресурс 
или его родительский каталог):

 my_icon/
   my_icon.png     (mdpi)

   1.5x/
     my_icon.png   (hdpi)

   2.0x/
     my_icon.png   (xhdpi)

   3.0x/
     my_icon.png   (xxhdpi)

Если pixel ration 1.8, то будет выбран ресурс 2.0x/my_icon.png
А если pixel ration 2.7, то 3.0x/my_icon.png

Шрифты регистрируются следующим образом:

 flutter:
   fonts:
    - family: Raleway
      fonts:
        - asset: assets/fonts/Raleway-Regular.ttf
        - asset: assets/fonts/Raleway-Italic.ttf
          style: italic
    - family: RobotoMono
      fonts:
        - asset: assets/fonts/RobotoMono-Regular.ttf
        - asset: assets/fonts/RobotoMono-Bold.ttf
          weight: 700

Параметр family определяет семейство шрифтов. Один шрифт может ссылаться на несколько файлов
с разными weight и style. (как в примере выше, где для RobotoMono с weight 700 задается
файл RobotoMono-Bold.ttf, а для обычного RobotoMono - RobotoMono-Regular.ttf)

После регистрации, шрифты и их стили можно задавать через класс TextStyle.

Для работы с текстовыми ассетами (файлы .txt или .json) - используется класс AssetBundle.
С AssetBundle можно работать либо через объект rootBundle, либо через объект
DefaultAssetBundle.

 import 'package:flutter/services.dart' show rootBundle;
 await rootBundle.loadString('assets/config.json'); 

Иконка приложения задается нативным способом для каждой из платформ.
Для Android размещается в папке android/app/src/main/res/
Для iOS размещается в папке ios/Runner/Assets.xcassets/AppIcon.appiconset/

Launch Screen (стартовый экран, который видит пользователь до тех пор, пока Flutter 
не отрисует первый кадр приложения) также устанавливается нативным способом.
Для Androind задается через файл android/app/src/main/res/drawable/launch_background.xml
Для iOS нужно разместить картинки (с названиями LaunchImage.png, LaunchImage@2x.png и т.д.)
в папке ios/Runner/Assets.xcassets/LaunchImage.imageset

--------------

ВИДЖЕТЫ

Каждый графический элемент в приложении на Flutter является виджетом (иконка, текст, 
колонка и пр.) Виджет - это константный объект класса Widget. Он описывает какую-то часть UI.

При работе с виджетами используется композиция (когда один виджет вкладывается в другой).
Это означается что все виджеты можно представить в виде дерева.

Чтобы дерево виджетов могло отобразиться на экране, нужно передать его в ф-цию runApp(),
которая, в свою очередь, вызывается из ф-ции main().

Ф-ция main() не вызывается сразу после запуска приложения, а только после того, как
инициализируется движок. До этого момента, на экране будет отображаться Launch Screen.
Вызов runApp() автоматически закрывает Launch Screen. При этом runApp() необязательно
вызывать сразу. Можно сначала дождаться каких-то асинхронных операции (например получения
данных из БД или инициализации библиотеки аналитики).

Если runApp() вызвать несколько раз раз, то старое дерево будет отсоединено 
от экрана, а новое присоединено.

Существует 3 основных типа виджетов:
 * StatelessWidget - статический виджет (не имеет состояния);
 * StatefulWidget - динамический виджет (имеет состояние);
 * InheritedWidget - виджет, для передачи данных;

StatelessWidget используется для декомпозиции UI (т.е. инкапсулирет другие виджеты)

 class MyWidget extends SatelessWidget {
   const MyWidget({ Key? key }): super(key: key);

   @override
   Widget build(BuildContext ctx) {
     return Text('hello', textDirection: TextDirection.ltr);
   }
 }

Параметр конструктора key - это идентификатор виджета. Метод build() собственно и возвращает
декомпозированный UI, т.е. дерево виджетов или один виджет.

Виджеты стоит декомпозировать так, чтобы build() был сразу понятен. Длинные деревья
следует разбивать на деревья поменьше, вынося их реализацию в привытные виджеты или методы.

InheritedWidget хранит данные и делится ими с потомками, автоматически обновляя их 
(потомков) при изменении данных. Такой виджет должен также реализовывать методы of() 
и updateShouldNotify(). Первый метод позволяет потомкам удобно получать данные, 
а второй - говорит Flutter, нужно ли обновлять потомков.

 class CounterProvider extends InheritedWidget {
   final int counter;

   const CounterProvider({ 
     super.key, required super.child, 
     required this.counter 
   });

   static CounterProvider of(BuildContext ctx) {
     return ctx.dependOnInheritedWidgetOfExactType<CounterProvider>(); 
   }

   @override
   bool updateShouldNotify(CounterProvider oldWgt) {
     return oldWgt.counter != counter;
   }
 }

 class App extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     // Передаем данные потомку HomePage
     return CounterProvider(counter: 10, child: HomePage());
   }
 }

 class HomePage extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     final counter = CounterProvider.of(ctx).counter;
     return Text('Counter: $counter');
   }
 }

Метод of() не обязан сразу возвращать объект виджета. Он может иметь доп. логику 
(строить сложносоставные объекты, как это делают фабричные конструкторы).

Если метод of() используется сразу, на этапе инициализации, то его нужно обернуть 
в Builder. Иначе он получит неправильный контекст.

 class App extends StatelessWidget {
   @override
   Widget build(BuildContext ctx) {
     return CounterProvider(
       counter: 10, 
 
       // Так нельзя делать
       child: Text(CounterProvider.of(ctx).counter.toString())

       // Нужно использовать Builder
       child: Builder(
         builder: (_ctx) => Text(CounterProvider.of(_ctx).counter.toString())
       )
     );
   }
 }

StatefulWidget имеет состояние, которое представлено классом State. Оно создается 
с пом. метода createState(). В состояние выносятся метод build() и мутабельные данные, 
а в виджете могут оставаться иммутабельные данные. Для доступа к данным виджета, 
в State есть специальный геттер - widget.

 class MyWidget extends StatefulWidget {
   final String text;
   const MyWidget({ required this.text, super.key });

   @override
   State<MyWidget> createState() => _MyWidgetState();
 }

 class _MyWidgetState extends State<MyWidget> {
   @override
   Widget build(BuildContext ctx) {
     return Text(widget.text);
   }
 }

Мутабельные данные следует изменять в методе setState(). Он уведомляет фреймворк 
о том, что State изменился и его виджет нужно перерисовать.

 class _MyWidgetState extends State<MyWidget> {
   bool _isLightOn = false;

   @override
   Widget build(BuildContext ctx) {
     return ElevatedButton(
       child: Text(_isLightOn ? 'Выключить свет' : 'Включить свет'),
       onPress: () {
         setState(() => _isLightOn = !_isLightOn);
       }    
     ),
   }
 }

У State есть также геттер - mounted, который позволяет проверить, прикреплен ли виджет к
дереву (поскольку его может и не быть там, если произойдет, к примеру, переход на предыдущий
экран). Используется в основном в асинхронном коде перед вызовом setState().

Дерево виджетов - это абстракция, на основе которой Flutter строит дерево элементов
и работает уже с ним. Элементы отвечают за жизненный цикл UI и его обновление.

При создании виджета, Flutter вызывает у него метод createElement(). Полученный элемент
помещается в дерево эл-тов, а также в метод build() виджета. В самом методе он экранируется
интерфейсом BuildContext, который предоставляет лишь часть членов Element.

На основе дерева эл-тов создается также дерево RenderObject, которое отвечает 
непосредсвенно за позиционирование и отрисовку эл-тов UI.

Когда обновляется состояние, виджеты пересоздаются заново и Flutter сопоставляет их с уже
имеющимся деревом эл-тов и далее добавляет/удаляет/обновляет элементы при надобности.
При этом пересоздаются только легковесные объекты Widget, а тяжелые Element и RenderObject
переиспользуются, если это возможно.

Жизненный цикл виджетов:

 У StatelessWidget есть только конструктор и метод build().

 У StatefulWidget есть конструктор и метод createState(), который вызывается когда виджет
 встраивается в дерево, чтобы создать State. Может вызываться несколько раз, если 
 используется один и тот же экземпляр виджета в разных места или когда виджет 
 отсоединяется и присоединяется повторно.

 State имеет такие методы:

  initState() - вызывается один раз, после того, как State привязывается к Element;
    используется для инициализации контроллеров либо полей, которые зависят 
    от данных из widget или context (несмотря на то, что context уже доступен, 
    использовать метод inheritedWidget.of() здесь нельзя);

  didChangeDependencies() - вызывается после initState(), а также при изменении 
    зависимого InheritedWidget; здесь можно использовать inheritedWidget.of();

  build() - вызывается после setState() и didChangeDependencies(), а также при hot reload;
    здесь нельзя вызывать setState(), но если это все же нужно сделать, то следует
    использовать обертку addPostFrameCallback;

  didUpdateWidget() - вызывается всякий раз, когда изменяется экземляр виджета, 
    что привязан к State, независимо от того, меняются ли в нем какие-то параметры;
    здесь можно выполнять аниманию и другую работу, зависящую от конфигурации виджета;
 
  dispose() - вызывается, когда виджет убирается из дерева, после всех других методов
    жизненнго цикла; используется для освобождения ресурсов, отмены подписок и т.п.

React Native использует платформенные реализации для отображения UI (например текст будет
отображаться либо через нативный виджет TextView, при разуске приложения на Android, 
либо через UITextView, при запуске на iOS). 

Flutter работает по другому. Для отрисовки UI он использует графический движок. (Skia или 
уже другой). Благодаря этому, Flutter можно адаптировать под любую ОС. Это также дает
уверенность, что UI будет выглядеть одинаково на всеъ платформах.

Во Flutter есть три библиотеки, предоставляющие готовые виджеты:
 1) Widgets library - общие виджеты, не привязанные к конкретной платформе.
 2) Material library - виджеты стилизованые Material Design.
 3) Cupertino library - виджеты, стилизованные под Apple.

У большинства Material-виджетов есть аналоги из Cupertino.
Виджеты можно разделить на 4 группы:

 1) Фундамент - задают структуру приложения.

   WidgetsApp - базовый виджет, который задает основу приложения: управление навигацией, 
     темизация, локализация и др. От него наследуются MaterialApp и CupertinoApp;

   MaterialApp - адаптирует внешний вид приложения в зависимости от того, на какой ОС 
     оно запущено (например поведение скролла и анимация переключения страниц 
     будут отличаться на Android и iOS);

   CupertinoApp - повторяет поведение нативных iOS приложений, независимо от того, 
     на какой платформе запускается приложение;

   Scaffold - определяет страницу (экран) приложения. В параметре body 
     указывается виджет содержимого страницы;

 2) Содержимое - определяют, как выглядят изображения, текст и др.

   Text - отображает текст с определенным стилем. Некоторые параметры виджета:
     textAlign - задает выравнивание текста;
     overflow - задает поведение, если размер текст больше размеров виджета;
     maxLines - максимальное кол-во строк, которое может вместить виджет;
     style - объект, задающий стиль текста;

   RichText - отображает форматированный текст (с его помощью можно 
     имитировать ссылки и др.)

   Icon - отображает векторые иконки, которым можно задать цвет, размер и др.
     В классах Icons (от Material) и CupertinoIcons содержится большой набор иконок, 
     но чтобы использовать эти классы, нужно их подключить через pubspec.yaml
     https://education.yandex.ru/handbook/flutter/article/vidzheti-standartnie-biblioteki

     Чтобы добавить свои иконки, нужно преобразовать набор картинок в шрифт и подключить
     шрифт в качестве ассета (для преобразования иконок в шрифт поможет сайт FlutterIcon)

   Image - отображает картинки в форматах JPEG, PNG, GIF и др. Параметр image задает
     изображение. Для удобства есть несколько конструкторов: Image.asset() и Image.network()
     первый задает изображение из ассетов, а второй - из интернета.

     Параметр fit задает положение изображения внутри виджета (будет ли оно растянуто 
     или сохранит пропорции и т.д.)

   GestureDetector - обрабатывает жесты, свайпы и другие события. Делает дочерний виджет
     кликабельными. Чтобы увеличить зону кликабельности можно обернуть дочерний виджет 
     в Padding. Но GestureDetector по умолчанию игнорирует прозрачные области эл-тов, 
     поэтому придется использовать еще параметр behavior со значен. HitTestBehavior.opaque

   InkWell - аналог GestureDetector но с анимацией в стиле Material Design (наз. Ripple).
     Но чтобы анимация была видна InkWell должен быть обернут в виджет Material.

   TextField, Button - текстовое поле и кнопка со встроенной кликабельностью...

   SnackBar - виджет сообщение, которое отображается поверх остального UI. 
     Для отображения сообщения используется метод showSnackBar() внутри которого и задается
     данный виджет. Взаимодействие со снекбаром, это еще одна из обязанностей Scaffold.

 3) Расположение - отвечают за позиционирование.

   Column и Row - располагают дочерние виджеты друг за другом векртикально 
     и горизонтально соответственно. Основные параметры виджета:

     mainAxisAlignment - выравнивает дочерние эл-ты вдоль основной оси. 
       Например значение MainAxisAlignment.start располагает эл-ты в начале колонки. 
       а MainAxisAlignment.spaceBetween распределяет свободное пространство между эл-тами.

     mainAxisSize - расстояние, которое виджет займет по основной оси. Например значение
       MainAxisSize.min означает, что колонка займет минимально возможно расстояние, 
       а MainAxisSize.max заставит колонку занять все доступное место.

     crossAxisAlignment - задает то, сколько места займут дочерние виджеты по второстепенной
       оси (для Column это горизонтальная ось). Значение CrossAxisAlignment.end позволит
       прижать виджеты к правой части колонки, а CrossAxisAlignment.stretch заставит их
       растянуться по всей ширине колонки.

   Stack - располагает виджеты относительно стека (а не относительно друг друга), 
     позволяя реализовать наложение виджетов... 

   SingleChildScrollView - простой скроллящийся контейнер, в который можно положить 
     дочерний виджет с размерами, превышающими допустимую область отрисоки, 
     и появится скролл. Основные параметры виджета:
   
     scrollDirection - направление прокрутки (Axis.vertical / Axis.horizontal);
     reverse - прямое или обратное направление прокрутки;
     padding - оступы внутри списка (т.е. внутри прокручиваемой области);
     physics - задает физику скролла (например как на iOS), либо выключает ее вообще;
     clipBehavior - задает то, как будет обрезаться содержимое, за границами виджета.

   ListView - виджет для отображения прокручиваемых списков. Он лучше оптимизирован для
     работы с большим кол-вом эл-тов, чем SingleChildScrollView, поскольку отрисовывает
     только видимые элементы. У этого виджета есть удобный конструктор ListView.separated 
     при помощи которого можно автоматически проставлять отступы между эл-тами. 

     Параметр shrkinkWrap со значением false заставит ListView занимать все доступное
     пространство по основной оси, а со значением true - занимать столько место, 
     сколько занимает внутреннее содержимое.

   SizedBox - виджет, задающий размеры для дочернего виджета;

   Padding - виджет, задающий отступы вокруг дочернего виджета. 
     Оступы задаются с пом. объекта EdgeInsets. 

   SafeArea - задает отступы, равные размерам системных эл-тов интерфейса (таких как 
     статус бар или нижняя навигационная панель). По умолчанию добавляет оступы со всех
     сторон, но это можно переопределить параметрами: top, bottom, left, right.

 4) Декорация - добавляют визуальные эффекты.

   Container - позволяет добавить дочернему виджету: фон, тень, высоту, выравнивание,
     трансформацию, padding, margin, border и пр. Под капотом он составляет композицию из
     различных виджетов (например для оступов использует виджет Padding).

   Card - это разновидность контейнера с заданным стилем в виде карточки (плашки).
     Карточки хорошо подходят если UI приложения вписывается в Material или если создается
     приложение без конкретного дизайна и нужны максимально готовые компоненты

Подробнее про карточки: https://m3.material.io/components/cards/overview

Flutter позволяет делать очень многое из коробки. Поэтому прежде чем делать свой виджет,
нужно поискать сначала наиболее подходящий среди готовых https://docs.flutter.dev/ui/widgets

2.12. Виджеты: идентификатор key...

