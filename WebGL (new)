ОСНОВЫ WEBGL

Отрисовка графики на странице происходит с помощью тега <canvas></canvas>
Канвас поддерживает 2 контекста отрисовки: 2d и webgl.

Пример отрисовки пустого окна:
...
const canvas = document.getElelemetById('my-canvas');
const gl = canvas.getContext('webgl');
gl.clearColor(0.0, 1.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

Метод clearColor() устанавливает цвет для константы COLOR_BUFFER_BIT.
Метод clear() закрашивает фон цветом COLOR_BUFFER_BIT (очищает цветовой буфер).

Чтобы нарисовать объект, нужно выполнить следующие шаги:
1) создать шейдерную программу; 
2) создать буфер вершин;
3) установить указатель на чтение из буфера;
4) отрисовать примитивы объекта;

Шейдерная программа состоит из 2х шейдеров: вершинного и фрагментного.
...
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 a_vertexPos;
  void main() {
    gl_Position = vec4(a_vertexPos, 1.0);
  }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.6, 0.6);
  }
</script>

Код шейдеров можно размещать внутри тега <script></script>, с произвольным типом.
В этом случае браузер не будет загружать его содержимое, а просто проигнирирует его.
Также, шейдеры могут определяться в отдельных файлах. Загружать их можно через fetch().

Создание шейдерной программы:
...
const program = gl.createProgram();
gl.attachShader(program, getShader(gl.VERTEX_SHADER, 'shader-vs'));
gl.attachShader(program, getShader(gl.FRAGMENT_SHADER, 'shader-fs'));
gl.linkProgram(program);

function getShader(type, elemId) {
  const shaderElem = document.getElementById(elemId);

  const shader = gl.createShader(type);
  gl.shaderSource(shader, shaderElem.text);
  gl.compileShader(shader);

  return shader;
}

Метод createProgram() создает объект программы, attachShader() прикрепляет к программе
шейдеры, а linkProgram() - связывает программу с контекстом WebGL.

После создания программы, нужно передать её на выполнение: gl.useProgram(program);

Создание буфера вершин:
...
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.5, -0.5, 0.0,
   0.0,  0.5, 0.0,
   0.5, -0.5, 0.0,
]), gl.STATIC_DRAW);

Метод createBuffer() создает некий буфер данных. Затем, с пом. метода bindBuffer()
производится привязка этого буфера к контексту WebGL.

Первый параметр bindBuffer() может принимать:
* ARRAY_BUFFER - данные вершин;
* ELEMENT_ARRAY_BUFFER - данные индексов;

Поскольку мы имеем дело с данными вершин, то выбирать нужно именно ARRAY_BUFFER.
Привязка означает, что все операции над ARRAY_BUFFER будут происходить с vertexBuffer.

Привязка нужна чтобы некоторые ф-ции WebGL имели (неявный) доступ к буферу.
Отвязать буфер можно так: gl.bindBuffer(gl.ARRAY_BUFFER, null);

Метод bufferData() наполняет буфер данными из массива. Массив должен быть типизирован.
STATIC_DRAW необходим для оптимизации. Это означает что данные не будут меняться.

В дополнении к буферу вершин можно создать буфер индексов:
...
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 2, 1]), gl.STATIC_DRAW);

Этот буфер задает порядок вершин, по которому будут рисоваться примитивы. 
Каждый индекс обозначает какую-то вершину, например 0 - это (-0.5, -0.5, 0.0).

Если буфер индексов отсутствует, то примитивы будут рисоваться по вершинам 
(в порядке размещения в vetrexBuffer), а не по индексам.

Установка указателя на чтение из буфера (этот указатель называется атрибутом):
...
const vertexPosAttrib = gl.getAttribLocation(program, 'a_vertexPos');
gl.enableVertexAttribArray(vertexPosAttrib);
gl.vertexAttribPointer(vertexPosAttrib, 3, gl.FLOAT, false, 0, 0);

Метод getAttribLocation() как бы связывает атрибут между шейдером и WebGL.
С помощью него мы получаем ссылку на a_vertexPos и присваиваем её в vertexPosAttrib.

Метод enableVertexAttribArray() включает атрибут. Обычно, вызывается перед установкой.

Метод vertexAttribPointer() устанавливает атрибут. После этого WebGL будет знать, 
как передавать данные буфера в шейдер. Метод принимает следующие параметры:

* index - индекс атрибута;
* size - кол-во элементов буфера на одну вершину;
* type - тип данных элементов буфера;
* norm - нормализация; управляет числовыми преоразованиями;
* stride - шаг сдвига к новой вершине; 0 означает size * sizeof(type);
* offset - позиция с кот. начинается обработка; 0 это начальная позиция;

Поскольку параметр size имеет значение 3, то при каждом вызове вершинного шейдера
атрибут a_vertexPos будет получать по 3 элемента из буфера. Сначала это будут эл-ты
(-0.5, -0.5, 0.0), затем (0.0, 0.5, 0.0) (указатель сдвинется на size * sizeof(type)).

Если a_vertexPos имеет тип, отличный от vec3, например vec4, то из буфера установятся
только первые 3 компоненты: x, y, z, а компонента w примет значение по умолчанию.

Перед отрисовкой примитивов нужно установить viewport (область отрисовки):
gl.viewport(offsetX, offsetY, width, height);

Если параметры offsetX и offsetY имеют нулевое значение, то отрисовка 
будет начинаться с левого нижнего угла.

Отрисовка примитивов: gl.drawArrays(gl.TRIANGLES, 0, 3);

Примитивы можно отрисовывать с пом. 2х методов: drawArrays() и drawElements().
Первый метод отрисовывает примитивы последовательно, по вершинам из буфера вершин.
Второй метод отрисовывает примитивы по индексам, когда имеется буфер индексов.

Метод drawArrays() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять объект;
* index - указывает индекс первой вершины;
* count - кол-во вершин для отрисовки;

Метод drawElements() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять объект;
* count - кол-во элементов (буфера индексов) для отрисовки;
* type - тип данных элементов (буфера индексов);
* offset - с какого индекса будет проводиться отрисовка;

Типы примитивов в WebGL:
* LINES - отдельные линии (даже если есть общие вершины);
* LINE_LOOP - соединенные линии (в замкнутый контур);
* LINE_STRIP - соединенные линии, но последняя вершина не соединяется с первой;
* TRIANGLES - отдельные треугольники;
* TRIANGLE_STRIP - соединенные треугольники;
* TRIANGLE_FAN - треугольники, у которых одна вершина общая (веер);
* PONTS - отдельные точки;

----------------------

КОНВЕЙЕР WEBGL:

1. Создается буфер вершин. По вершинам впоследствии будут составлены примитивы, 
   а из примитивов - объекты. Проводится некоторая предобработка.

2. Содержимое буфера поступает на обработку в вершинный шейдер. Шейдер производит 
   над ними некоторые трансформации, задаваемые разработчиком.

3. Происходит Primtive Assembly. Конвейер получает результат вершинного шейдера и
   сопоставляет трансформированные вершины в отдельные примитивы (треугольники, линии). 
   Далее определяется, входит ли примитив в видимое пространство. Если нет, то он
   обрезается. Видимые примитивы передаются на следующий этап конвейера.

4. Происходит растеризация. Полученные примитивы преобразов. во фрагменты (пиксели),
   которые затем будут отрисованы на экране.

5. Вызывается фрагментный шейдер (в Direct3D он называется пиксельным шейдером)
   Он наполняет примитивы цветом, т.е. окрашивает фрагменты примитивов 
   и передает их на следующие подэтапы.

5.1. Scissor Test. Здесь проверяется, находится ли фрагмент в пределах отсекающего
     прямоугольника. Если да, то он передается дальше, иначе отбрасывается 
     и больше не принимает участия в обработке.

5.2. Multisample Fragment Operations (возможно это Multisampling). 
     Здесь производится сглаживание.

5.3. Stencil Test. Фрагмент передается в буфер трафаретов (stencil buffer). В этом
     буфере дополнительно отбрасываются фрагменты, кот. не должны отображаться.
     Как правило, он используется для создания эффектов, например теней.

5.4. Depth Buffer Test. Происходит тест буфера глубины (z-buffer). Здесь сравнивается 
     z-компонента фрагмента. Если один фрагмент ближе к сцене, чем другой, 
     то он проходит тест, а иначе отбрасывается.

5.5. Blending. Здесь происходит смешивание цветов, для создания прозрачности.
5.6. Dithering. Здесь происходит смешивание цветов, для создания тонов и полутонов.

6. Фрагмент передается во Frame Buffer (превращается в пиксель на экране).

----------------------

ШЕЙДЕРЫ

Шейдеры - это программы, которые выполняются на видеокарте. Они пишутся на языке GLSL.
Чаще всего встречается 2 типа шейдеров: вершинные, фрагментные.

В самом начале, при вызове метода draw*(), данные из буфера вершин поступают в
вершинный шейдер. Количество вызовов вершинного шейдера зависит от параметра count.

Задача вершинного шейдера - обработать (трансформировать) вершины примитивов. 
Задача фрагментного шейдера - закрасить пиксели примитивов.

Вершинный шейдер вызывается один раз для каждой вершины. Фрагментный шейдер вызывается
один раз для каждого пикселя. Например, для треугольника с площадью 300 пикселей
фрагментный шейдер вызовется 300 раз, тогда как вершинный всего 3 раза.

Все действия шейдеров выполняются внутри ф-ции main().

В GLSL определены след. примитивные типы:
* void, bool, int, float - аналогичны тем, что в C++; 
* vec2, vec3, vec4 - 2х, 3х, 4х мерные векторы, с типом float для компонентов;
* ivec2, ivec3, ivec4 - теже векторы, но с типом int для компонентов;
* bvec2, bvec3, bvec4 - векторы с типом bool для компонентов;
* mat2, mat3, mat4 - матрицы с эл-тами типа float;
* sampler2d, samplerCube - семплеры для работы с текстурами; с их помощью можно
  получать различные цветовые значения текстур и передавать их в примитив.

С пом. структур можно также создавать и составные типы.

В GLSL переменные обычно объявляются с квалификаторами. Их список:
* attribute - атрибут вершины; через него в шейдер передаются данные буфера;
* const - константа, как и в других языках;
* uniform - константа со значением для всего примитива;
* varying - переменная, которая задается в вершинном шейдере и затем передается 
  во фрагментный шейдер, где может быть использованая;

Для переменных типа float можно задавать точность:
* highp - число с плавающей точкой будет иметь максимальную точность;
* mediump - число со средней степенью точности;
* lowp - диапазон плавающей запятой от -2 до 2;

Точность можно задать и глобально, для всего шейдера:
...
precision mediump float;
void main() { }

Встроенные переменные вершинного шейдера:
* gl_Position - указывает на позицию вершины (выходной параметр, vec4);
* gl_PointSize - содержит размер точки (выходной параметр, float);

Встроенные переменные фрагментного шейдера:
* gl_PointCoord - позиция фрагмента внутри точки (входной параметр vec2);
* gl_FontFacing - пренадлежит ли фрагмент лицевому примитиву (входной, bool);
* gl_FragCoord - указывает на позицию фрагмента в буфере фреймов (выходной, vec4);
* gl_FragColor - указывает на цвет фрагмента (выходной, vec4);
* gl_FragData[n] - указ. на цвет фрагмента для прикреплен. цвета n (выходной, vec4);

Встроенные функции:
* dot(x, y) - возвращает скалярное произведение векторов x и y;
* cross(x, y) - возвращает векторное произведение векторов x и y;
* matrixCompMult(matX, matY) - возвращает произведение матриц x и y 
  (матрицы должны быть одной размерности); 
* normalize(x) - возвращает нормализированный вектор x;
* reflect(t, n) - возвращает проекцию вектора t вдоль вектора n;
* sin(angle) - возвращает синус угла angle;
* cos(angle) - возвращает косинус угла angle;
* pow(x, y) - возвращает x в степени y;
* max(x, y) - возвращает максимальное значение;
* min(x, y) - возвращает минимальное значение;

----------------------

РАБОТА С МАТРИЦАМИ

...

