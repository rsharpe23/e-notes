ОСНОВЫ WEBGL

Отрисовка графики на странице происходит с помощью тега <canvas></canvas>
Канвас поддерживает 2 контекста отрисовки: 2d и webgl.

Пример отрисовки пустого окна:
...
const canvas = document.getElelemetById('my-canvas');
const gl = canvas.getContext('webgl');
gl.clearColor(0.0, 1.0, 0.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

Метод clearColor() устанавливает цвет для константы COLOR_BUFFER_BIT.
Метод clear() закрашивает фон цветом COLOR_BUFFER_BIT (очищает цветовой буфер).

Чтобы отобразить объект, нужно выполнить следующие шаги:
1) создать шейдерную программу; 
2) создать буфер вершин;
3) установить указатель на чтение из буфера;
4) отрисовать фигуру;

Шейдерная программа состоит из 2х шейдеров: вершинного и фрагментного.
...
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 a_vertexPos;
  void main() {
    gl_Position = vec4(a_vertexPos, 1.0);
  }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.6, 0.6);
  }
</script>

Код шейдеров можно размещать внутри тега <script></script>, с произвольным типом.
В этом случае браузер не будет загружать его содержимое, а просто проигнирирует его.
Также, шейдеры могут определяться в отдельных файлах. Загружать их можно через fetch().

Создание шейдерной программы:
...
const program = gl.createProgram();
gl.attachShader(program, getShader(gl.VERTEX_SHADER, 'shader-vs'));
gl.attachShader(program, getShader(gl.FRAGMENT_SHADER, 'shader-fs'));
gl.linkProgram(program);

function getShader(type, elemId) {
  const shaderElem = document.getElementById(elemId);

  const shader = gl.createShader(type);
  gl.shaderSource(shader, shaderElem.text);
  gl.compileShader(shader);

  return shader;
}

Метод createProgram() создает объект программы, attachShader() прикрепляет к программе
шейдеры, а linkProgram() - связывает программу с контекстом WebGL.

После создания программы, нужно передать её на выполнение: gl.useProgram(program);

Создание буфера вершин:
...
const vertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.5, -0.5, 0.0,
   0.0,  0.5, 0.0,
   0.5, -0.5, 0.0,
]), gl.STATIC_DRAW);

Метод createBuffer() создает некий буфер данных. Затем, с пом. метода bindBuffer()
производится привязка этого буфера к контексту WebGL.

Первый параметр bindBuffer() может принимать:
* ARRAY_BUFFER - данные вершин;
* ELEMENT_ARRAY_BUFFER - данные индексов;

Поскольку создается именно буфер вершин, то и выбирать нужно ARRAY_BUFFER.
Привязка означает, что все операции над ARRAY_BUFFER будут происходить с vertexBuffer.
Отвязать буфер можно так: gl.bindBuffer(gl.ARRAY_BUFFER, null);

Метод bufferData() наполняет буфер данными из массива. Массив должен быть типизирован.
STATIC_DRAW необходим для оптимизации. Это означает что данные не будут меняться.

В дополнении к буферу вершин можно создать буфер индексов:
...
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 2, 1]), gl.STATIC_DRAW);

Этот буфер задает порядок вершин, по которому будут рисоваться примитивы. 
Каждый индекс обозначает какую-то вершину, например 0 - это (-0.5, -0.5, 0.0).

Если буфер индексов отсутствует, то примитивы будут рисоваться по вершинам 
(в порядке размещения в vetrexBuffer), а не по индексам.

Установка указателя на чтение из буфера (этот указатель называется атрибутом):
...
const vertexPosAttrib = gl.getAttribLocation(program, 'a_vertexPos');
gl.vertexAttribPointer(vertexPosAttrib, 3, gl.FLOAT, false, 0, 0);

Метод getAttribLocation() как бы связывает атрибут между шейдером и WebGL.
С помощью него мы получаем ссылку на a_vertexPos и присваиваем её в vertexPosAttrib.

Метод vertexAttribPointer() устанавливает атрибут. После этого WebGL будет знать, 
как передавать данные в шейдер. Метод принимает следующие параметры:

* index - индекс атрибута;
* size - кол-во элементов буфера на одну вершину;
* type - тип данных элементов буфера;
* norm - нормализация; управляет числовыми преоразованиями;
* stride - шаг сдвига к новой вершине; 0 означает size * sizeof(type);
* offset - позиция с кот. начинается обработка; 0 это начальная позиция;

Поскольку параметр size имеет значение 3, то при каждом вызове вершинного шейдера
атрибут a_vertexPos будет получать по 3 элемента из буфера. Сначала это будут эл-ты
(-0.5, -0.5, 0.0), затем (0.0, 0.5, 0.0) (указатель сдвинется на size * sizeof(type)).

После установки атрибута, его нужно дополнительно включить:
gl.enableVertexAttribArray(vertexPosAttrib);

Отрисовка фигуры: gl.drawArrays(gl.TRIANGLES, 0, 3);

Фигруры можно отрисовывать с пом. 2х методов: drawArrays() и drawElements():
Первый метод отрисовывает фигуру последовательно, по вершинам из буфера вершин.
Второй метод отрисовывает фигуру по индексам, когда имеется буфер индексов.

Метод drawArrays() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять фигура;
* index - указывает номер первой вершины для примитива;
* count - сколько вершин будет использоваться для отрисовки;

Метод drawElements() принимает след. параметры:
* mode - тип примитивов, из которых будет состоять фигура;
* count - кол-во элементов (буфера индексов) для отрисовки;
* type - тип данных элементов (буфера индексов);
* offset - с какого индекса будет проводиться отрисовка;

В WebGL определены след. типы примитивов:
* LINES - отдельные линии (даже если есть общие точки);
* LINE_STRIP - соединенные линии;
* LINE_LOOP - соединенные линии, но последняя точка соединяется с первой;
* TRIANGLES - треугольники;
* TRIANGLE_STRIP - треугольники, у которых вершины последовательно соединены;
* TRIANGLE_FAN - треугольники, у которых одна вершина общая;
* PONTS - набор точек;

----------------------

КОНВЕЙЕР WEBGL:

1. Создается буфер вершин. По вершинам впоследствии будут составлены примитивы, 
   а из примитивов - объекты. Проводится некоторая предобработка.

2. Содержимое буфера поступает на обработку в вершинный шейдер. Шейдер производит 
   над ними некоторые трансформации, задаваемые разработчиком.

3. Происходит Primtive Assembly. Конвейер получает результат вершинного шейдера и
   сопоставляет трансформированные вершины в отдельные примитивы (треугольники, линии). 
   Далее определяется, входит ли примитив в видимое пространство. Если нет, то он
   обрезается. Видимые примитивы передаются на следующий этап конвейера.

4. Происходит растеризация. Полученные примитивы преобразов. во фрагменты (пиксели),
   которые затем будут отрисованы на экране.

5. Вызывается фрагментный шейдер (в Direct3D он называется пиксельным шейдером)
   Он наполняет примитивы цветом, т.е. окрашивает фрагменты примитивов 
   и передает их на следующие подэтапы.

5.1. Scissor Test. Здесь проверяется, находится ли фрагмент в пределах отсекающего
     прямоугольника. Если да, то он передается дальше, иначе отбрасывается 
     и больше не принимает участия в обработке.

5.2. Multisample Fragment Operations (возможно это Multisampling). 
     Здесь производится сглаживание.

5.3. Stencil Test. Фрагмент передается в буфер трафаретов (stencil buffer). В этом
     буфере дополнительно отбрасываются фрагменты, кот. не должны отображаться.
     Как правило, он используется для создания эффектов, например теней.

5.4. Depth Buffer Test. Происходит тест буфера глубины (z-buffer). Здесь сравнивается 
     z-компонента фрагмента. Если один фрагмент ближе к сцене, чем другой, 
     то он проходит тест, а иначе отбрасывается.

5.5. Blending. Здесь происходит смешивание цветов, для создания прозрачности.
5.6. Dithering. Здесь происходит смешивание цветов, для создания тонов и полутонов.

6. Фрагмент передается во Frame Buffer (превращается в пиксель на экране).

----------------------

ШЕЙДЕРЫ

Код шейдеров выполняется на видеокарте.

