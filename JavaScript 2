Документ.

DOM (Document Object Model) - структура документа, где каждый тег представлен в виде
объекта. Объект document - основная точка входа. С его помощью можно что-то созавать
или менять на странице.

BOM (Browser Object Model) - дополнительные объекты, для работы с браузером: 
window, location, navigator и т.д.

Объекты DOM - это узлы. Есть 12 типов узлов, 4 из которых являются основными:
1) document - входная точка в DOM;
2) узлы-элементы - html-теги;
3) текстовые узлы - текст, содержащийся как внутри, так и снаружи html-тегов,
4) комментарии - информация, которая не отображается в документе, но доступна для
чтения через JS.

Получив DOM-узел, множно перейти к его соседям используя навигационные свойства. 

Сиблинги - узлы у которых один общих родительский узел.
Дочерние узлы - узлы, которые лежат внутри другого узла на первом уровне.
Потомки - все узлы, которые лежат внутри другого узла (узлы узлов и т.д.).

<html> = document.documentElement
<head> = document.head
<body> = document.body

Навигационные свойства для всех узлов:
- parentNode - родительский узел;
- childNodes - коллекция, содержащая всех детей, включая текстовые узлы;
- firstChild - первый дочерний узел (childNodes[0]);  
- lastChild - последний дочерний узел (childNodes[childNodes.length - 1]);
- previousSibling - предыдущий узел того же родителя;
- nextSibling - следующий узел того же родителя.

Навигационные свойства для узлов-элементов: 
- parentElement - родительский элемент;
- children - коллекция детей, которые являются элементами;
- firstElementChild - первый дочерний элемент;
- lastElementChild - последний дочерний элемент;
- previousElementSibling; - предыдущий сиблинг элемент;
- nextElementSibling - следующий сиблинг элемент.

Навигационные методы:
- hasChildNodes() - проверяет наличие дочерних узлов; 
- querySelector() - возвращает одиночный элемент по css-селектору;
- querySelectorAll() - возвращают статическую коллекцию элементов по css-селектору;
- getElementById() - возвращает элемент по id;
- getElementsByName() - возвращает динамическую коллекцию по атрибуту name;
- getElementsByTagName() - возвращает динамическую коллекцию по названию тега;
- getElementsByClassName() - возвращает динамическую коллекцию по атрибуту class.

Специальные методы:
- elem.matches(css) - проверяет, удовлетворяет ли элемент css-селектору;
- elem.closest(css) - ищет ближайшего по иерархии предка, соответств. css-селектору.
- elem1.contains(elem2) - вернет true, если elem2 находится внутри elem1.

Динамическая коллекция элементов - это список элементов, который динамически меняется,
в зависимости от манипуляции с DOM. Статическая коллекция не меняется. Ее значения
определяются одни раз, при выборке.

Каждый DOM-узел принадлежит определенному классу (на прототипах). Классы формируют
иерахию. Каждый класс в иерархии содержит какие-то свои общие свойства.

Список общих свойств:
- nodeType - позволяет узнать тип DOM-узла (целочисленное значение);
- nodeName/tagName - возвращает название тега (для элементов) или узла;
- innerHTML - получает/изменяет внутренне html-содержимое элемента;
- outerHTML - получает/перезаписывает внутреннее html-содержимое вместе с тегом
(обновляет DOM но, в отличии от innerHTML, не перезаписыват переменную; чтобы получить
доступ к изменениям нужно заново найти их);
- nodeValue/data - получает содержимое текстового узла;
- textContent - при чтении получает текстовое содержимое внутри html-элемента, при этом
отбрасывает все теги; при записи записывает все как текст, 
html-элементы при этом экранируются;
- hidden - тоже что и style="display:none".

Большинство стандартных html-атрибутов имеют соответствующее DOM-свойство:
id, name, type, href, value и т.п.

Методы (и свойство) для работы с атрибутами:
- hasAttribute() - проверяет на наличие;
- getAttribute() - получает значение;
- setAttribute() - устанавливает значение;
- removeAttribute() - удаляет атрибут;
- elem.attributes - коллекция всех атрибутов.

Значение атрибута, полученное через getAttribute(), это всегда строка, тогда как
соответствующее свойство может быть не только строкой но и объектом или 
булевым значинем.

Пользовательские атрибуты записываются (в html) с префиксом data-*. 
Чтобы получить соответствующее свойство нужно обратится через dataset:
<div data-message="Hello!"></div> -> divElem.dataset.message == "Hello!".

Методы для создания узлов:
- document.createElement() - создает элемент с заданным тегом;
- document.createTextNode() - создает текстовый узел;
- elem.cloneNode() - клонирует элемент.

Методы вставки и удаления:
- node.append() - вставляет внутрь node в конец;
- node.prepend() - вставляет внутрь node в начало;
- node.before() - вставляет прямо перед node;
- node.after() - вставляет сразу после node;
- node.replaceWith() - заменяет node;
- node.remove() - удаляет node.

Устаревшие методы:
- parent.appendChild();
- parent.insertBefore();
- parent.removeChild();
- parent.replaceChild().

Чтобы переместить элемент необязательно его удалять, можно воспользоваться одним из
методов вставки. Такие методы автоматически удаляют узлы со старых мест:
secondElem.after(firstElem).

Методы вставки не подойдут, если нужно вставить html строкой. 
Чтобы реализовать такую возможность нужно использовать elem.insertAdjacentHTML().

Метод document.write() старый но быстрый, потому что работает отдельно от DOM.
Его нужно использовать только во время загрузки страницы. После загрузки его вызов
затрет документ. Он вставляет html в необходимое место на странице. Браузеры
воспринимают такой html как будто он изначально был частью загруженного документа.

Для управления css-классами существует два DOM-свойства:
1) className - строковое значение для управления всем набором классов;
2) classList - объект с методами add/remove/toggle/constains для управления 
отдельными классами.

Чтобы изменить стили существует:
- свойство style (объект), чтение и запись его свойст работает так же, как изменение
соответсвующих стилей в html-атрибуте "style";
- свойство style.cssText соответстует всему атрибуту "style" для элемента, 
в виде строки стилей (подобно className).

Для чтения окончательных стилей (с учетом всех классов, после применения css и
вычисления всех значений) используется метод getComputedStyle(). Он возвращает объект,
похожий по формату на style.

У элементов есть следующие геометрические свойства (метрики):
- offsetParent - ближайший родитель с позиционированием (имеет css-свойство "position")
или ближайший td, th, table, body;
- offsetLeft/Top - позиция верхнего левого угла, относительно offsetParent;
- offsetWidth/Height - полная ширина/высота элемента, включая рамки;
- clientLeft/clientTop - больше используется как ширина/высота рамки;
- clientWidth/Height - ширина/высота элемента с внутренними отступами,
но без полосы прокрутки и рамок;
- scrollWidth/Height - ширина/высота аналогична clientWidth/Height, но учитывает
прокрученную, невидимую область элемента;
- scrollLeft/Top - ширина/высота прокрученной сверху части элемента, 
от верхнего левого угла.

Вычисление ширины/высоты не учитывает margin, т.к. он не относится к элементу.

Ширина/высота окна: document.documentElement.clientWidth/Height.
Если в html нет doctype, то геометрические свойства верхнего уровня могут работать
некорректно.

Ширина/высота документа:
- для ширины: document.documentElement.scrollWidth;
- для высоты, наибольшее значение из: 
    body.scrollHeight, documentElement.scrollHeight, 
    body.offsetHeight, documentElement.offsetHeight,
    body.clientHeight, documentElement.clientHeight.

Прокрутка документа:
- получить: window.pageYOffset/XOffset;
- установить: 
    window.scrollTo() - по абсолютным координатам,
    window.scrollBy() - относительно текущего места.

Прокрутить страницу так, чтобы elem выровнился отосительно верхней/нижней части окна:
elem.scrollIntoView(true/false).

Когда страница прокручивается, то ее элементы всегда меняют свои координаты
относительно окна. При этом координаты относительно документа остаются прежними.

Чтобы получить координаты элемента на странице, относительно окна, нужно использовать
метод getBoundingClientRect(). Чтобы получить элемент на странице по координатам, 
нужно использовать метод elementFromPoint(). Он возвращает наиболее глубоко 
вложенный элемент (если выбранный элемент имеет потомков).

Обычно pageX/Y - это координаты относительно документа, а clientX/Y - координаты
относительно окна браузера.

Правильные координаты относительно документа вычисляются так:
- pageX = clientX + window.pageXOffset;
- pageY = clientY + window.pageYOffset;

Координаты относительно окна бразуера соответсвуют css-свойству "position: fixed",
а координаты относительно документа - "position: absolute" на самом верхнем уровне.
Absolute смещает элемент по странице, относительно другого элемента. 
Fixed смещает элемент по окну, относительно его начальных позиций.

----------------------------------------------

Браузерные события.

Есть три способа назначения обработчиков событий:
1) через атрибут html on<event>="...";
2) через свойство DOM-объекта: elem.on<event> = function () { ... };
3) через методы elem.add/removeEventListener();

При назначении обработчика через атрибут, весь код внутри атрибута on<event> будет
обернут в функциональное выражение, а сама ф-ция присвоится свойству DOM-объекта.
<a onclick="alert(23)"> -> a.onclick = function () { alert(23) };

Свойство DOM-объекта ограничено только одним обработчиком. Метод addEventListener()
позволяет записать несколько обработчиков сразу, а также подписаться на события,
которые недоступны через свойство (DOMContentLoaded и другие).

Обработчиком события может быть не только ф-ция но и объект с методом handleEvent().

Все обработчики принимают параметр - объект "event". Вот некотороые его свойства:
- type: тип события (click, focus, mousedown и т.п.);
- target: целевой элемент, на котором произошло событие;
- currentTarget: элемент, на котором сработал обработчик (тоже самое что и this);
- clientX/Y: координаты курсора в момент клика относительно окна (для событий мыши);
- eventPhase: номер фазы, на которой событие было поймано;
- defaultPrevented: событие было отменено;
- isTrusted: указывает на "настоящее" событие.

Список самых часто используемых DOM-событий:

События мыши:
- click: при клике по элементу ЛКМ;
- contextmenu: при клике по элементу ПКМ;
- mouseover/mouseout: кода мышь новится или покидает элемент;
- mousedown/mouseup: когда нажали/отжали кнопку мыши на элементе;
- mousemove: при движении мыши.

События на элементах управления:
- submit: после отправки формы <form>;
- focus: при установке фокуса (пользователь нажал на <input> и т.п.);

Клавиатурные события:
- keydown и keyup: при нажати/отпускании клавиши.

События документа и CSS события:
- DOMContentLoaded - когда html загружен и обработан, DOM документа 
полностью построен и доступен.
- transitionend: после завершения css-анимации.

События роботают следующим образом. Выполняется 3 прохода:
1) фаза погружения: событие идет сверху вниз, до целевого элемента;
2) фаза цели: событие достигло целевого элемента;
3) фаза всплытия: событие начинает всплывать.

Обработчики события вызываются на 3й фазе. Для того, чтобы они вызывались на всех
фазах, нужно передать 3й аргумет capture в метод addEventListener().

При всплытии события вызываються все его обработчики, начиная от целевого элемента 
и заканчивая тем родительским, на котором весит последний обработчик. Чтобы перекрыть
дальнейшее всплытие на одном из промежуточных элементов, нужно использовать метод
stopPropagation(). Метод stopImmediatePropagation() не только перекрывает всплытие, 
но и останавливает обработку на текущем элементе.

Предположим что документ состоит только из 3х элементов - FORM > DIV > P, тогда если
обработчик клика определен на FORM, а мы кликаем по P, то P - это event.target, 
а FORM - event.currentTarget.

Событие вызвается на том элементе, где определен обработчик, при этом инициировать его
может любой внутренний элемент. Поэтому хорошей практикой считается задавать обработчик
один раз на родительском элементе, а не на каждом внутреннем по отдельности. 
Это называется делегированием событий.

Преимущества делегирования событий:
- не нужно вешать много обработчиков, это экономит память;
- при добавлении/удалении элементов не нужно ставить или снимать обработчики.

Многие события автоматически влекут за собой действия бразуера, например на клик по
ссылке будет переход по url и т.д. Чтобы отменить действия браузера по умолчанию, нужно
вызвать в обработчике метод event.preventDefault() или return false. Последний вариант
не работает, если обработчик задан через addEventListener().

Опция passive для addEventListener() сообщает браузеру что действие по умолчанию не
будет отменено (т.е. мы обещаем что не будет вызывать preventDeafault). Это полезно 
при оптимизации. Например, перед вызовом события touchmove, браузер будет проверять
каждый обработчик есть ли где preventDefault() и только после этого вызовет это
событие, что чревато притормаживанием. Опция passive сообщит браузеру, что обработчик
не собирается отменять touchmove. Тогда браузер начинает его немедленно, обеспечивая
максимальную плавность.

Свойство event.defaultPrevented говорит о том, что событие было отменено. Это очень
полезное свойство, помогающее заменить stopPropagation(). Допустим есть два обработчика
события: один на document, а другой на каком-то элементе. При клике по элементу даже
если событие отменено, оно все равно будет вспылвать дальше до последнего заданного
обработчика, т.е. до document. И мы получим два вызова вместо одного. Чтобы это
исправить, можно вызвать stopPropagation() в обработчике элемента, либо 
воспользоваться проверкой свойства defaultPrevented в обработчике document.

Чтобы вызвать событие из кода, нужно создать объект класса Event и передать его 
в метод elem.dispatchEvent(). Для пользовательских событий нужно использовать
конструктор CustomEvent. Он содержит специальное свойство detail. С его помощью можно
передавать доп. информацию в обработчик. Генерировать встроенные события из кода
считается плохой практикой. Чтобы отличить событие, порождаемое реальными действиями
пользователя от тех, которые генерируются из кода, нужно воспользоваться свойством
event.isTrusted.

----------------------------------------------

Интерфейсные события.

1) События мыши:

Простые:
- mousedown/mouseup: кнопка мыши нажата/отпущена над элементом;
- mouseover/mouseout: курсор мыши появляется над элементом и уходт с него;
- mousemove: каждое движение над элементом генерирует это событие;
- contextmenu: вызывается при попытке открытия контекстного меню (обычно ПКМ).

Комплексные (состоят из комбинации простых):
- click: вызывается при mousedown и mouseup над элементом, если использовалась ЛКМ;
- dbclick: вызывается двойным кликом на элементе.

События связанные с кликом всегда имеют свойство which, которое определяет нажатую
кнопку мыши: 
- event.which == 1 -> ЛКМ; 
- event.which == 2 -> СКМ; 
- event.which == 3 -> ПКМ.

Все события мыши содержат информацию о нажатых клавишах-модификаторах:
- event.shiftKey -> Shift;
- event.altKey -> Alt или Opt для Mac;
- event.ctrlKey -> Ctrl;
- event.metaKey -> Cmd для Mac.

Некоторые особенности событий движения мыши:
- при быстром движении события не будут возникать на промежуточных элементах;
- события mouseover/mouseout и mouseenter/mouseleave имеют дополнительное свойство
relatedTarget. Оно дополняет свойство target и содержит ссылку на элемент, с/на который
мы переходим.

События mouseover/mouseout возникают, даже когда происходит переход с родительского
элемента на потомка. События mouseenter/mouseleave отличаются тем, что генерируются
когда курсор переходит на элемент в целом или уходит с него.

Алгортим Drag'n'Drop: https://learn.javascript.ru/mouse-drag-and-drop/.

2) События клавиатуры:

- keydown: при нажатии на клавишу (если клавиша остается зажатой, 
происходит автопортор);
- keyup: при отпускании клавиши.

Главные свойства клавиатурного события:
- code: код клавиши (KeyA/Z, Digit0/9, ArrowLeft и т.д.) привязанный к физическому
расположению клавиши на клавиатуре (игнорирует языки);
- key: символ ("A", "a" и т.д.) для не буквенно-цифровых клавиш (Esc, Enter и т.д.)
имеет то же значение, что и code.

Существует старое событие - "keypress", которое не рекомендуется использовать из-за
большого кол-ва несовместимостей. А также его свойства: keyCode, charCode, which.

При удержании клавиши возникает автоповтор. Свойство event.repeat помогает 
отследить его. События клавиатуры не должны обрабатывать ввод, для этого есть
специальные события типа "input", "change". События клавиатуры должны использоваться,
например чтобы реагировать на горячии или специальные клавиши.

3) События указателя:

Это современный способ обработки ввода с раздичных устройст: мышь, стилус, сенсорный
экран и т.д. Вот их список (многие из них аналогичны событиям мыши):

- pointerdown -> mousedown;
- pointerup -> mouseup;
- pointermove -> mousemove;
- pointerover -> mouseover;
- pointerout -> mouseout;
- pointerenter -> mouseenter;
- pointercancel: происходит, когда действие с указателем прирывается (перекрыто
браузерным событием, либо изменилась ориентация устройства и т.д.);
- getpointercapture -> происходит, когда элемент использует setPointerCapture() 
для включения захвата;
- lostpointercapture -> происходит, при освобождении от захвата.

Основные свойства событий указателя:
- event.pointerId: уникальный идентификатор указателя, вызвавшего событие (для каждого
касания свой pointerId);
- event.pointerType: тип указателя (строка: "mouse", "pen", "touch");
- event.isPrimary: true для основного указателя (первый палец в мульти-тач).

Есть и другие свойства, описывающие степень давления указателя, положение пера
относительно сенсорной поверхности и т.д.

При обработке drag'n'drop и сложных касаний, браузер может попытаться обработать их
сам. Чтобы дополнить отмену drap'n'drop по умолчанию (например для картинок), можно
установить css-свойство "touch-action: none" для перетаскиваемого элемента 
(а также не забыть выключить обработку события ondragstart).

Захват указателя, это удобный ф-ционал для обработки событий типа drag'n'drop. Смысл
заключается в том, чтобы привязать событие указателя к конкретному элементу. Допустим
пользователь кликает по ползунку и начинает его перемещать, если указатель соскочет с
ползунка то перетаскивание прекратится. Чтобы этого избежать и перемещать указатель где
угодно по экрану (после зажатия) и нужен как раз этот захват. 
Делается он так: elem.setPointerCapture(pointerId).

4) Событие прокрутки:

- scroll: реагирует на прокрутку страницы или элемента (т.е. работает как на window 
так и на других элементах).

Прокрутку нельзя предотвратить, используя event.preventDefault() в обработчике
onscroll, потому что обработчик срабатывает после того, как прокрутка уже произошла. 
Но можно предотвратить прокрутку, используя preventDefault() на событии, которое ее
вызывает, например при keydown и т.п.

----------------------------------------------

Формы, элементы управления.

Форма доступна чарез: document.forms[name/index], где индекс - это порядковый номер 
в документе (т.е. 0 - первая форма в документе и т.д.).

Элементы формы доступны через: form.elements[name/index], или можно просто
использовать: form[name/index]. Свойство elements также работает для <fieldset> 
(т.е. form.elements.userFields -> <form><fieldset name="userFields">...).

Элементы хранят ссылку на свою форму в свойстве: elem.form.

Значения элементов формы доступны через: input.value, textarea.value, select.value 
и т.д. либо input.checked для чекбоксов и переключателей.

Для select можно получить/задать индекс выбранного пункта через: select.selectedIndex,
либо используя коллекцию пунктов select.options.

Можно удобно создавать <option> с помощью конструктора Option():
let option = new Option("Text", "value");

Для фокусировки элементов существуют специальные события: focus/blur, которые
вызываются в момент фокусировки и потери фокуса соответственно.

Эти события вызываются только на тех элементах, с которым может взаимодействовать
пользователь: button, input, select, a и т.д. Их также можно вызвать самостоятельно, 
из кода, с помощью методов elem.focus(), elem.blur(). 

Чтобы сделать фокусируемым любой элемент, нужно использовать атрибут tabindex или
аналогичное ему свойство elem.tabIndex. Для tabindex есть два специальных значения:
- tabindex="0": ставит элемент в один ряд с другими без tabindex, т.е. при переключении
через tab такие элементы будут после других, где tabindex >= 1;
- tabindex="-1": позволяет фокусироваться на элементе только программно (клавиша tab
проигнорирут такой элемент, но метод elem.focus() будет действовать).

Эти события не всплывают, но есть альтернативные события - focusin/focusout, 
которые поддерживают эту возможность. Focusin/focusout могут использоваться только 
с addEventListener().

Отменить потерю фокуса с помощью preventDefault() нельзя потому, что обработчик 
onblur срабатывает после потери фокуса элеметом. Текущий элемент с фокусом можно
получить из document.activeElement.

События обновления данных:
- change: срабатывает когда значение было изменено (для текстовых полей срабатывает 
при потере фокуса);
- input: срабатывает каждый раз при изменении значения (срабатывает немедленно, 
в отличии от change);
- cut/copy/paste: срабатывают при вырезании/копировании/вставке.

Событие input происходит после изменения значения, поэтому его нельзя отменить 
через preventDefault(). События cut/copy/paste отменить можно. Они относятся к классу
ClipboardEvent и обеспечивают доступ к комируемым/вставляемым данным (через свойство
event.clipboardData).

Событие submit срабатывает при отправке формы на сервер. Метод form.submit() позволяет
инициировать отправку формы из JavaScript. При отправке формы по нажатию Enter в
текстовом поле, генерируется событие click на к кнопке <input type="submit">.

----------------------------------------------

Загрузка документа и ресурсов.

События загрузки:
- DOMContentLoaded: браузер загрузил html, было построено DOM-дерево, но внешние
ресурсы (картинки, стили и т.п.) могут быть еще не загружены;
- load: браузер полностью загрузил html и внешние ресурсы;
- beforeunload: вызывается когда пользователь собирается покинуть страницу (можно
отменить событие, в этом случае браузер спросит действительно ли пользователь 
хочет уйти -> window.onbeforeunload = function () { return false; });
- unload: вызывается когда пользователь покидает страницу.

Событие DOMContentLoaded вызывается на объекте document, а остальные - на window.
Скрипт, вроде <script>...</script> или <script src="..."></script> блокируют
DOMContentLoaded, браузер ждет, пока они выполнятся.

Из обработчика unload можно послать сетевой запрос на сервер для сохранения какой либо
информации о пользователе. Это делается с помощью метода navigator.sendBeacon(). 
Он посылает данные в фоне. Переход к другой странице не задерживается: 
браузер покидает страницу, но все равно выполняет sendBeacon().

Свойство document.readyState показывает текущее состояние загрузки:
- loading: документ загружается;
- interactive: документ был полностью прочитан (тоже что и DOMContentLoaded);
- complete: документ был полностью прочитан и все ресурсы также загрузились 
(тоже что и load).

Обработчик window.onload всегда срабатывает после всех load других обработчиков
(например после img.onload и т.п.).

Когда браузер загружает html и доходит до тега <script></script>, он не может
продолжать строить DOM. Он должен сначала загрузить и выполнить скрипт. 
Большие скрипты могут подолгу блокировать страницу. 

Атрибут defer сообщает браузеру что он должен продолжать обрабатывать страницу и
загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM-дерево
будет полностью построено (но до события DOMContentLoaded). 

Отложенные скрипты можно использовать, когда нужно подгружать старые модули CJS.
Они, как и обычные скипты, сохраняют порядок относительно друг друга. 

 <script type="module" src="bundle.js"></script> // Если браузер не поддерживает 
 <script nomodule scr="bundle-es5.js"></script>  // модульные скрипты, то будет загруж.
                                                 // тот, который помечен как nomodule.

Атрибут async означает, что скрипт абсолютно независим:
- страница не ждет асинхронных скриптов, содержимое обрабатыается 
  и отображается по мере готовности;
- событие DOMContentLoaded и асинхронные скрипты не ждут друг друга;
- остальные скрипты также не ждут async, и скрипты с async не ждут другие скрипты.

Асинхронные скрипты как и отложенные не блокируют отображение страницы.
Асинхронные скрипты полезны для подключение на страницу сторонних, независимых 
от DOM скриптов: счетчики, рекламы и т.д.

Динамчески загружаемые скрипты это те, что создаются из JS. По умолчанию они ведут себя
как async. Но это поведение можно убрать, присвоив явно значение false свойсвтву async:

let script = document.createElement('script');
script.src = '...';
script.async = false; -> только, если надо переопределить поведение по умолчанию.
document.body.append(script); -> с этого места начнется загрузка.

Изображения <img>, внешние ссылки, скрипты и другие ресурсы предоставляют свои события
load и error для отслеживания загрузки. Они срабатывают при успешной загрузке или при
ошибке соответственно. <iframe> - исключение. В нем всегда срабатывает load вне
зависимости от того как завершилась загрказка (по историческим причинам).

Чтобы получить доступ о какой-то внутренней информации скрипта, загружаемого с другого
домена (это может быть информация о том, почему не загрузился скрипт и т.п.), нужно
добавить тегу <script> атрибут crossorigin. Кроме того, удаленный сервер должен 
вернуть заголовки CORS. 

Три уровня кроссс-доменного доступа:
1) crossorigin отсутствует - доступ запрещен.
2) crossorigin="anonymous" - доступ разрешен, если сервер отвечат с заголовком 
Access-Control-Allow-Origin со значением * или наш домен.
3) crossorigin="use-credentials" - доступ разрешен, если сервер отвечает с таким же
заголовком что и для anonymous + дополнительный заголовок 
Access-Control-Allow-Credentials: true; в этом случае браузер отправляет
авторизированную информацию и куки на удаленный сервер.

----------------------------------------------

Разное.

Чтобы наблюдать за изменениями в DOM-элементах можно использовать специальный класс
MutatiomObserver. Он реагирует на: атрибуты, добавленные/удаленные дочерних элементов,
текстовое содержимое. Его можно использовать, чтобы отслеживать изменения производимые
другими частями собственного кода, а также стороннего (из других библиотек и т.п.).

JS позволяет манипулировать выделением как в документе, так и в полях формы.
Манипулировать выделением как целиком, так и по частям, убирать выделенную часть 
из документа, оборачивать ее в тег и т.д. Для этого используются встроенные классы
Range и Selection.

Алгоритм событийного цикла:
1) выбрать и выполнить самую старую задачу из очереди макрозадач;
2) выполнить все микрозадачи;
3) отрисовать изменения страницы, если они есть;
4) если очередь макросозадач пуста - подождать пока не появится новая;
5) вернуться на шагу 1.

Макрозадачи - это загрузка скрипта, выполнение события (например перемещение мыши),
выполнение setTimeout() и т.п. Микрозадачи - это то, что приходит из кода, например
выполнение обработчика промиса: then/catch/finaly. 

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, 
или перехода к другой макрозадачи. Если необходимо запустить ф-цию асинхронно 
(после текущего кода), но до отображения изменений и до новых событий, то можно
воспользоваться ф-цией queueMicrotask(func). Она помещает func в очередь микрозадач.

При выполнении следующего порядок обработки будет таким:

setTimeout(() => alert('timeout'));
Promise.resolve().then(() => alert('promise'));
alert('code');

1) "code" - потому что это обычный синхронный вызов. 
2) "promise" - т.к. then() проходит через очередь микрозадач и выполняется асинхронно. 
3) "timeout" - потому что это макрозадача.

